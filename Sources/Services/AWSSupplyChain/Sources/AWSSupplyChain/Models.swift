//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You do not have the required privileges to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension SupplyChainClientTypes {

    /// The status of the job.
    public enum ConfigurationJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case new
        case queued
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationJobStatus] {
            return [
                .failed,
                .inProgress,
                .new,
                .queued,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .new: return "NEW"
            case .queued: return "QUEUED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SupplyChainClientTypes {

    /// The BillOfMaterialsImportJob details.
    public struct BillOfMaterialsImportJob: Swift.Sendable {
        /// The BillOfMaterialsImportJob instanceId.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The BillOfMaterialsImportJob jobId.
        /// This member is required.
        public var jobId: Swift.String?
        /// When the BillOfMaterialsImportJob has reached a terminal state, there will be a message.
        public var message: Swift.String?
        /// The S3 URI from which the CSV is read.
        /// This member is required.
        public var s3uri: Swift.String?
        /// The BillOfMaterialsImportJob ConfigurationJobStatus.
        /// This member is required.
        public var status: SupplyChainClientTypes.ConfigurationJobStatus?

        public init(
            instanceId: Swift.String? = nil,
            jobId: Swift.String? = nil,
            message: Swift.String? = nil,
            s3uri: Swift.String? = nil,
            status: SupplyChainClientTypes.ConfigurationJobStatus? = nil
        ) {
            self.instanceId = instanceId
            self.jobId = jobId
            self.message = message
            self.s3uri = s3uri
            self.status = status
        }
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Unexpected error during processing of request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// Request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The input does not satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request parameters for CreateBillOfMaterialsImportJob.
public struct CreateBillOfMaterialsImportJobInput: Swift.Sendable {
    /// An idempotency token ensures the API request is only completed no more than once. This way, retrying the request will not trigger the operation multiple times. A client token is a unique, case-sensitive string of 33 to 128 ASCII characters. To make an idempotent API request, specify a client token in the request. You should not reuse the same client token for other requests. If you retry a successful request with the same client token, the request will succeed with no further actions being taken, and you will receive the same API response as the original successful request.
    public var clientToken: Swift.String?
    /// The AWS Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The S3 URI of the CSV file to be imported. The bucket must grant permissions for AWS Supply Chain to read the file.
    /// This member is required.
    public var s3uri: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        s3uri: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.instanceId = instanceId
        self.s3uri = s3uri
    }
}

/// The response parameters of CreateBillOfMaterialsImportJob.
public struct CreateBillOfMaterialsImportJobOutput: Swift.Sendable {
    /// The new BillOfMaterialsImportJob identifier.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    ) {
        self.jobId = jobId
    }
}

/// Request references a resource which does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request parameters for GetBillOfMaterialsImportJob.
public struct GetBillOfMaterialsImportJobInput: Swift.Sendable {
    /// The AWS Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The BillOfMaterialsImportJob identifier.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        jobId: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.jobId = jobId
    }
}

/// The response parameters for GetBillOfMaterialsImportJob.
public struct GetBillOfMaterialsImportJobOutput: Swift.Sendable {
    /// The BillOfMaterialsImportJob.
    /// This member is required.
    public var job: SupplyChainClientTypes.BillOfMaterialsImportJob?

    public init(
        job: SupplyChainClientTypes.BillOfMaterialsImportJob? = nil
    ) {
        self.job = job
    }
}

extension SupplyChainClientTypes {

    public enum DataIntegrationFlowFieldPriorityDedupeSortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [DataIntegrationFlowFieldPriorityDedupeSortOrder] {
            return [
                .asc,
                .desc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SupplyChainClientTypes {

    /// The field used in the field priority deduplication strategy.
    public struct DataIntegrationFlowFieldPriorityDedupeField: Swift.Sendable {
        /// The name of the deduplication field. Must exist in the dataset and not be a primary key.
        /// This member is required.
        public var name: Swift.String?
        /// The sort order for the deduplication field.
        /// This member is required.
        public var sortOrder: SupplyChainClientTypes.DataIntegrationFlowFieldPriorityDedupeSortOrder?

        public init(
            name: Swift.String? = nil,
            sortOrder: SupplyChainClientTypes.DataIntegrationFlowFieldPriorityDedupeSortOrder? = nil
        ) {
            self.name = name
            self.sortOrder = sortOrder
        }
    }
}

extension SupplyChainClientTypes {

    /// The field priority deduplication strategy details.
    public struct DataIntegrationFlowFieldPriorityDedupeStrategyConfiguration: Swift.Sendable {
        /// The list of field names and their sort order for deduplication, arranged in descending priority from highest to lowest.
        /// This member is required.
        public var fields: [SupplyChainClientTypes.DataIntegrationFlowFieldPriorityDedupeField]?

        public init(
            fields: [SupplyChainClientTypes.DataIntegrationFlowFieldPriorityDedupeField]? = nil
        ) {
            self.fields = fields
        }
    }
}

extension SupplyChainClientTypes {

    public enum DataIntegrationFlowDedupeStrategyType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fieldPriority
        case sdkUnknown(Swift.String)

        public static var allCases: [DataIntegrationFlowDedupeStrategyType] {
            return [
                .fieldPriority
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fieldPriority: return "FIELD_PRIORITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SupplyChainClientTypes {

    /// The deduplication strategy details.
    public struct DataIntegrationFlowDedupeStrategy: Swift.Sendable {
        /// The field priority deduplication strategy.
        public var fieldPriority: SupplyChainClientTypes.DataIntegrationFlowFieldPriorityDedupeStrategyConfiguration?
        /// The type of the deduplication strategy.
        ///
        /// * FIELD_PRIORITY - Field priority configuration for the deduplication strategy specifies an ordered list of fields used to tie-break the data records sharing the same primary key values. Fields earlier in the list have higher priority for evaluation. For each field, the sort order determines whether to retain data record with larger or smaller field value.
        /// This member is required.
        public var type: SupplyChainClientTypes.DataIntegrationFlowDedupeStrategyType?

        public init(
            fieldPriority: SupplyChainClientTypes.DataIntegrationFlowFieldPriorityDedupeStrategyConfiguration? = nil,
            type: SupplyChainClientTypes.DataIntegrationFlowDedupeStrategyType? = nil
        ) {
            self.fieldPriority = fieldPriority
            self.type = type
        }
    }
}

extension SupplyChainClientTypes {

    public enum DataIntegrationFlowLoadType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case incremental
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [DataIntegrationFlowLoadType] {
            return [
                .incremental,
                .replace
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .incremental: return "INCREMENTAL"
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SupplyChainClientTypes {

    /// The dataset options used in dataset source and target configurations.
    public struct DataIntegrationFlowDatasetOptions: Swift.Sendable {
        /// The option to perform deduplication on data records sharing same primary key values. If disabled, transformed data with duplicate primary key values will ingest into dataset, for datasets within asc namespace, such duplicates will cause ingestion fail. If enabled without dedupeStrategy, deduplication is done by retaining a random data record among those sharing the same primary key values. If enabled with dedupeStragtegy, the deduplication is done following the strategy. Note that target dataset may have partition configured, when dedupe is enabled, it only dedupe against primary keys and retain only one record out of those duplicates regardless of its partition status.
        public var dedupeRecords: Swift.Bool?
        /// The deduplication strategy to dedupe the data records sharing same primary key values of the target dataset. This strategy only applies to target dataset with primary keys and with dedupeRecords option enabled. If transformed data still got duplicates after the dedupeStrategy evaluation, a random data record is chosen to be retained.
        public var dedupeStrategy: SupplyChainClientTypes.DataIntegrationFlowDedupeStrategy?
        /// The target dataset's data load type. This only affects how source S3 files are selected in the S3-to-dataset flow.
        ///
        /// * REPLACE - Target dataset will get replaced with the new file added under the source s3 prefix.
        ///
        /// * INCREMENTAL - Target dataset will get updated with the up-to-date content under S3 prefix incorporating any file additions or removals there.
        public var loadType: SupplyChainClientTypes.DataIntegrationFlowLoadType?

        public init(
            dedupeRecords: Swift.Bool? = nil,
            dedupeStrategy: SupplyChainClientTypes.DataIntegrationFlowDedupeStrategy? = nil,
            loadType: SupplyChainClientTypes.DataIntegrationFlowLoadType? = nil
        ) {
            self.dedupeRecords = dedupeRecords
            self.dedupeStrategy = dedupeStrategy
            self.loadType = loadType
        }
    }
}

extension SupplyChainClientTypes {

    /// The dataset DataIntegrationFlow source configuration parameters.
    public struct DataIntegrationFlowDatasetSourceConfiguration: Swift.Sendable {
        /// The ARN of the dataset.
        /// This member is required.
        public var datasetIdentifier: Swift.String?
        /// The dataset DataIntegrationFlow source options.
        public var options: SupplyChainClientTypes.DataIntegrationFlowDatasetOptions?

        public init(
            datasetIdentifier: Swift.String? = nil,
            options: SupplyChainClientTypes.DataIntegrationFlowDatasetOptions? = nil
        ) {
            self.datasetIdentifier = datasetIdentifier
            self.options = options
        }
    }
}

extension SupplyChainClientTypes {

    public enum DataIntegrationFlowFileType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case json
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [DataIntegrationFlowFileType] {
            return [
                .csv,
                .json,
                .parquet
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .json: return "JSON"
            case .parquet: return "PARQUET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SupplyChainClientTypes {

    /// The Amazon S3 options used in S3 source and target configurations.
    public struct DataIntegrationFlowS3Options: Swift.Sendable {
        /// The Amazon S3 file type in S3 options.
        public var fileType: SupplyChainClientTypes.DataIntegrationFlowFileType?

        public init(
            fileType: SupplyChainClientTypes.DataIntegrationFlowFileType? = nil
        ) {
            self.fileType = fileType
        }
    }
}

extension SupplyChainClientTypes {

    /// The S3 DataIntegrationFlow source configuration parameters.
    public struct DataIntegrationFlowS3SourceConfiguration: Swift.Sendable {
        /// The bucketName of the S3 source objects.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The other options of the S3 DataIntegrationFlow source.
        public var options: SupplyChainClientTypes.DataIntegrationFlowS3Options?
        /// The prefix of the S3 source objects. To trigger data ingestion, S3 files need to be put under s3://bucketName/prefix/.
        /// This member is required.
        public var `prefix`: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            options: SupplyChainClientTypes.DataIntegrationFlowS3Options? = nil,
            `prefix`: Swift.String? = nil
        ) {
            self.bucketName = bucketName
            self.options = options
            self.`prefix` = `prefix`
        }
    }
}

extension SupplyChainClientTypes {

    public enum DataIntegrationFlowSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dataset
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [DataIntegrationFlowSourceType] {
            return [
                .dataset,
                .s3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dataset: return "DATASET"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SupplyChainClientTypes {

    /// The DataIntegrationFlow source parameters.
    public struct DataIntegrationFlowSource: Swift.Sendable {
        /// The dataset DataIntegrationFlow source.
        public var datasetSource: SupplyChainClientTypes.DataIntegrationFlowDatasetSourceConfiguration?
        /// The S3 DataIntegrationFlow source.
        public var s3Source: SupplyChainClientTypes.DataIntegrationFlowS3SourceConfiguration?
        /// The DataIntegrationFlow source name that can be used as table alias in SQL transformation query.
        /// This member is required.
        public var sourceName: Swift.String?
        /// The DataIntegrationFlow source type.
        /// This member is required.
        public var sourceType: SupplyChainClientTypes.DataIntegrationFlowSourceType?

        public init(
            datasetSource: SupplyChainClientTypes.DataIntegrationFlowDatasetSourceConfiguration? = nil,
            s3Source: SupplyChainClientTypes.DataIntegrationFlowS3SourceConfiguration? = nil,
            sourceName: Swift.String? = nil,
            sourceType: SupplyChainClientTypes.DataIntegrationFlowSourceType? = nil
        ) {
            self.datasetSource = datasetSource
            self.s3Source = s3Source
            self.sourceName = sourceName
            self.sourceType = sourceType
        }
    }
}

extension SupplyChainClientTypes {

    /// The dataset DataIntegrationFlow target configuration parameters.
    public struct DataIntegrationFlowDatasetTargetConfiguration: Swift.Sendable {
        /// The dataset ARN.
        /// This member is required.
        public var datasetIdentifier: Swift.String?
        /// The dataset DataIntegrationFlow target options.
        public var options: SupplyChainClientTypes.DataIntegrationFlowDatasetOptions?

        public init(
            datasetIdentifier: Swift.String? = nil,
            options: SupplyChainClientTypes.DataIntegrationFlowDatasetOptions? = nil
        ) {
            self.datasetIdentifier = datasetIdentifier
            self.options = options
        }
    }
}

extension SupplyChainClientTypes {

    /// The S3 DataIntegrationFlow target configuration parameters.
    public struct DataIntegrationFlowS3TargetConfiguration: Swift.Sendable {
        /// The bucketName of the S3 target objects.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The S3 DataIntegrationFlow target options.
        public var options: SupplyChainClientTypes.DataIntegrationFlowS3Options?
        /// The prefix of the S3 target objects.
        /// This member is required.
        public var `prefix`: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            options: SupplyChainClientTypes.DataIntegrationFlowS3Options? = nil,
            `prefix`: Swift.String? = nil
        ) {
            self.bucketName = bucketName
            self.options = options
            self.`prefix` = `prefix`
        }
    }
}

extension SupplyChainClientTypes {

    public enum DataIntegrationFlowTargetType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dataset
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [DataIntegrationFlowTargetType] {
            return [
                .dataset,
                .s3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dataset: return "DATASET"
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SupplyChainClientTypes {

    /// The DataIntegrationFlow target parameters.
    public struct DataIntegrationFlowTarget: Swift.Sendable {
        /// The dataset DataIntegrationFlow target. Note that for AWS Supply Chain dataset under asc namespace, it has a connection_id internal field that is not allowed to be provided by client directly, they will be auto populated.
        public var datasetTarget: SupplyChainClientTypes.DataIntegrationFlowDatasetTargetConfiguration?
        /// The S3 DataIntegrationFlow target.
        public var s3Target: SupplyChainClientTypes.DataIntegrationFlowS3TargetConfiguration?
        /// The DataIntegrationFlow target type.
        /// This member is required.
        public var targetType: SupplyChainClientTypes.DataIntegrationFlowTargetType?

        public init(
            datasetTarget: SupplyChainClientTypes.DataIntegrationFlowDatasetTargetConfiguration? = nil,
            s3Target: SupplyChainClientTypes.DataIntegrationFlowS3TargetConfiguration? = nil,
            targetType: SupplyChainClientTypes.DataIntegrationFlowTargetType? = nil
        ) {
            self.datasetTarget = datasetTarget
            self.s3Target = s3Target
            self.targetType = targetType
        }
    }
}

extension SupplyChainClientTypes {

    /// The SQL DataIntegrationFlow transformation configuration parameters.
    public struct DataIntegrationFlowSQLTransformationConfiguration: Swift.Sendable {
        /// The transformation SQL query body based on SparkSQL.
        /// This member is required.
        public var query: Swift.String?

        public init(
            query: Swift.String? = nil
        ) {
            self.query = query
        }
    }
}

extension SupplyChainClientTypes.DataIntegrationFlowSQLTransformationConfiguration: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DataIntegrationFlowSQLTransformationConfiguration(query: \"CONTENT_REDACTED\")"}
}

extension SupplyChainClientTypes {

    public enum DataIntegrationFlowTransformationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `none`
        case sql
        case sdkUnknown(Swift.String)

        public static var allCases: [DataIntegrationFlowTransformationType] {
            return [
                .none,
                .sql
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .none: return "NONE"
            case .sql: return "SQL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SupplyChainClientTypes {

    /// The DataIntegrationFlow transformation parameters.
    public struct DataIntegrationFlowTransformation: Swift.Sendable {
        /// The SQL DataIntegrationFlow transformation configuration.
        public var sqlTransformation: SupplyChainClientTypes.DataIntegrationFlowSQLTransformationConfiguration?
        /// The DataIntegrationFlow transformation type.
        /// This member is required.
        public var transformationType: SupplyChainClientTypes.DataIntegrationFlowTransformationType?

        public init(
            sqlTransformation: SupplyChainClientTypes.DataIntegrationFlowSQLTransformationConfiguration? = nil,
            transformationType: SupplyChainClientTypes.DataIntegrationFlowTransformationType? = nil
        ) {
            self.sqlTransformation = sqlTransformation
            self.transformationType = transformationType
        }
    }
}

/// The request parameters for CreateDataIntegrationFlow.
public struct CreateDataIntegrationFlowInput: Swift.Sendable {
    /// The Amazon Web Services Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Name of the DataIntegrationFlow.
    /// This member is required.
    public var name: Swift.String?
    /// The source configurations for DataIntegrationFlow.
    /// This member is required.
    public var sources: [SupplyChainClientTypes.DataIntegrationFlowSource]?
    /// The tags of the DataIntegrationFlow to be created
    public var tags: [Swift.String: Swift.String]?
    /// The target configurations for DataIntegrationFlow.
    /// This member is required.
    public var target: SupplyChainClientTypes.DataIntegrationFlowTarget?
    /// The transformation configurations for DataIntegrationFlow.
    /// This member is required.
    public var transformation: SupplyChainClientTypes.DataIntegrationFlowTransformation?

    public init(
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        sources: [SupplyChainClientTypes.DataIntegrationFlowSource]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        target: SupplyChainClientTypes.DataIntegrationFlowTarget? = nil,
        transformation: SupplyChainClientTypes.DataIntegrationFlowTransformation? = nil
    ) {
        self.instanceId = instanceId
        self.name = name
        self.sources = sources
        self.tags = tags
        self.target = target
        self.transformation = transformation
    }
}

/// The response parameters for CreateDataIntegrationFlow.
public struct CreateDataIntegrationFlowOutput: Swift.Sendable {
    /// The Amazon Web Services Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the DataIntegrationFlow created.
    /// This member is required.
    public var name: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.name = name
    }
}

extension SupplyChainClientTypes {

    public enum DataLakeDatasetPartitionTransformType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case day
        case hour
        case identity
        case month
        case year
        case sdkUnknown(Swift.String)

        public static var allCases: [DataLakeDatasetPartitionTransformType] {
            return [
                .day,
                .hour,
                .identity,
                .month,
                .year
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .hour: return "HOUR"
            case .identity: return "IDENTITY"
            case .month: return "MONTH"
            case .year: return "YEAR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SupplyChainClientTypes {

    /// The detail of the partition field transformation.
    public struct DataLakeDatasetPartitionFieldTransform: Swift.Sendable {
        /// The type of partitioning transformation for this field. The available options are:
        ///
        /// * IDENTITY - Partitions data on a given field by its exact values.
        ///
        /// * YEAR - Partitions data on a timestamp field using year granularity.
        ///
        /// * MONTH - Partitions data on a timestamp field using month granularity.
        ///
        /// * DAY - Partitions data on a timestamp field using day granularity.
        ///
        /// * HOUR - Partitions data on a timestamp field using hour granularity.
        /// This member is required.
        public var type: SupplyChainClientTypes.DataLakeDatasetPartitionTransformType?

        public init(
            type: SupplyChainClientTypes.DataLakeDatasetPartitionTransformType? = nil
        ) {
            self.type = type
        }
    }
}

extension SupplyChainClientTypes {

    /// The detail of the partition field.
    public struct DataLakeDatasetPartitionField: Swift.Sendable {
        /// The name of the partition field.
        /// This member is required.
        public var name: Swift.String?
        /// The transformation of the partition field. A transformation specifies how to partition on a given field. For example, with timestamp you can specify that you'd like to partition fields by day, e.g. data record with value 2025-01-03T00:00:00Z in partition field is in 2025-01-03 partition. Also noted that data record without any value in optional partition field is in NULL partition.
        /// This member is required.
        public var transform: SupplyChainClientTypes.DataLakeDatasetPartitionFieldTransform?

        public init(
            name: Swift.String? = nil,
            transform: SupplyChainClientTypes.DataLakeDatasetPartitionFieldTransform? = nil
        ) {
            self.name = name
            self.transform = transform
        }
    }
}

extension SupplyChainClientTypes {

    /// The partition specification for a dataset.
    public struct DataLakeDatasetPartitionSpec: Swift.Sendable {
        /// The fields on which to partition a dataset. The partitions will be applied hierarchically based on the order of this list.
        /// This member is required.
        public var fields: [SupplyChainClientTypes.DataLakeDatasetPartitionField]?

        public init(
            fields: [SupplyChainClientTypes.DataLakeDatasetPartitionField]? = nil
        ) {
            self.fields = fields
        }
    }
}

extension SupplyChainClientTypes {

    public enum DataLakeDatasetSchemaFieldType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case double
        case int
        case long
        case string
        case timestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [DataLakeDatasetSchemaFieldType] {
            return [
                .double,
                .int,
                .long,
                .string,
                .timestamp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .double: return "DOUBLE"
            case .int: return "INT"
            case .long: return "LONG"
            case .string: return "STRING"
            case .timestamp: return "TIMESTAMP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SupplyChainClientTypes {

    /// The dataset field details.
    public struct DataLakeDatasetSchemaField: Swift.Sendable {
        /// Indicate if the field is required or not.
        /// This member is required.
        public var isRequired: Swift.Bool?
        /// The dataset field name.
        /// This member is required.
        public var name: Swift.String?
        /// The dataset field type.
        /// This member is required.
        public var type: SupplyChainClientTypes.DataLakeDatasetSchemaFieldType?

        public init(
            isRequired: Swift.Bool? = nil,
            name: Swift.String? = nil,
            type: SupplyChainClientTypes.DataLakeDatasetSchemaFieldType? = nil
        ) {
            self.isRequired = isRequired
            self.name = name
            self.type = type
        }
    }
}

extension SupplyChainClientTypes {

    /// The detail of the primary key field.
    public struct DataLakeDatasetPrimaryKeyField: Swift.Sendable {
        /// The name of the primary key field.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        ) {
            self.name = name
        }
    }
}

extension SupplyChainClientTypes {

    /// The schema details of the dataset. Note that for AWS Supply Chain dataset under asc namespace, it may have internal fields like connection_id that will be auto populated by data ingestion methods.
    public struct DataLakeDatasetSchema: Swift.Sendable {
        /// The list of field details of the dataset schema.
        /// This member is required.
        public var fields: [SupplyChainClientTypes.DataLakeDatasetSchemaField]?
        /// The name of the dataset schema.
        /// This member is required.
        public var name: Swift.String?
        /// The list of primary key fields for the dataset. Primary keys defined can help data ingestion methods to ensure data uniqueness: CreateDataIntegrationFlow's dedupe strategy will leverage primary keys to perform records deduplication before write to dataset; SendDataIntegrationEvent's UPSERT and DELETE can only work with dataset with primary keys. For more details, refer to those data ingestion documentations. Note that defining primary keys does not necessarily mean the dataset cannot have duplicate records, duplicate records can still be ingested if CreateDataIntegrationFlow's dedupe disabled or through SendDataIntegrationEvent's APPEND operation.
        public var primaryKeys: [SupplyChainClientTypes.DataLakeDatasetPrimaryKeyField]?

        public init(
            fields: [SupplyChainClientTypes.DataLakeDatasetSchemaField]? = nil,
            name: Swift.String? = nil,
            primaryKeys: [SupplyChainClientTypes.DataLakeDatasetPrimaryKeyField]? = nil
        ) {
            self.fields = fields
            self.name = name
            self.primaryKeys = primaryKeys
        }
    }
}

/// The request parameters for CreateDataLakeDataset.
public struct CreateDataLakeDatasetInput: Swift.Sendable {
    /// The description of the dataset.
    public var description: Swift.String?
    /// The Amazon Web Services Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the dataset. For asc name space, the name must be one of the supported data entities under [https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html).
    /// This member is required.
    public var name: Swift.String?
    /// The namespace of the dataset, besides the custom defined namespace, every instance comes with below pre-defined namespaces:
    ///
    /// * asc - For information on the Amazon Web Services Supply Chain supported datasets see [https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html).
    ///
    /// * default - For datasets with custom user-defined schemas.
    /// This member is required.
    public var namespace: Swift.String?
    /// The partition specification of the dataset. Partitioning can effectively improve the dataset query performance by reducing the amount of data scanned during query execution. But partitioning or not will affect how data get ingested by data ingestion methods, such as SendDataIntegrationEvent's dataset UPSERT will upsert records within partition (instead of within whole dataset). For more details, refer to those data ingestion documentations.
    public var partitionSpec: SupplyChainClientTypes.DataLakeDatasetPartitionSpec?
    /// The custom schema of the data lake dataset and required for dataset in default and custom namespaces.
    public var schema: SupplyChainClientTypes.DataLakeDatasetSchema?
    /// The tags of the dataset.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        partitionSpec: SupplyChainClientTypes.DataLakeDatasetPartitionSpec? = nil,
        schema: SupplyChainClientTypes.DataLakeDatasetSchema? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.namespace = namespace
        self.partitionSpec = partitionSpec
        self.schema = schema
        self.tags = tags
    }
}

extension SupplyChainClientTypes {

    /// The data lake dataset details.
    public struct DataLakeDataset: Swift.Sendable {
        /// The arn of the dataset.
        /// This member is required.
        public var arn: Swift.String?
        /// The creation time of the dataset.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The description of the dataset.
        public var description: Swift.String?
        /// The Amazon Web Services Supply Chain instance identifier.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The last modified time of the dataset.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the dataset. For asc namespace, the name must be one of the supported data entities under [https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html).
        /// This member is required.
        public var name: Swift.String?
        /// The namespace of the dataset, besides the custom defined namespace, every instance comes with below pre-defined namespaces:
        ///
        /// * asc - For information on the Amazon Web Services Supply Chain supported datasets see [https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html).
        ///
        /// * default - For datasets with custom user-defined schemas.
        /// This member is required.
        public var namespace: Swift.String?
        /// The partition specification for a dataset.
        public var partitionSpec: SupplyChainClientTypes.DataLakeDatasetPartitionSpec?
        /// The schema of the dataset.
        /// This member is required.
        public var schema: SupplyChainClientTypes.DataLakeDatasetSchema?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            namespace: Swift.String? = nil,
            partitionSpec: SupplyChainClientTypes.DataLakeDatasetPartitionSpec? = nil,
            schema: SupplyChainClientTypes.DataLakeDatasetSchema? = nil
        ) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.instanceId = instanceId
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.namespace = namespace
            self.partitionSpec = partitionSpec
            self.schema = schema
        }
    }
}

/// The response parameters of CreateDataLakeDataset.
public struct CreateDataLakeDatasetOutput: Swift.Sendable {
    /// The detail of created dataset.
    /// This member is required.
    public var dataset: SupplyChainClientTypes.DataLakeDataset?

    public init(
        dataset: SupplyChainClientTypes.DataLakeDataset? = nil
    ) {
        self.dataset = dataset
    }
}

/// The request parameters for CreateDataLakeNamespace.
public struct CreateDataLakeNamespaceInput: Swift.Sendable {
    /// The description of the namespace.
    public var description: Swift.String?
    /// The Amazon Web Services Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the namespace. Noted you cannot create namespace with name starting with asc, default, scn, aws, amazon, amzn
    /// This member is required.
    public var name: Swift.String?
    /// The tags of the namespace.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.tags = tags
    }
}

extension SupplyChainClientTypes {

    /// The data lake namespace details.
    public struct DataLakeNamespace: Swift.Sendable {
        /// The arn of the namespace.
        /// This member is required.
        public var arn: Swift.String?
        /// The creation time of the namespace.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The description of the namespace.
        public var description: Swift.String?
        /// The Amazon Web Services Supply Chain instance identifier.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The last modified time of the namespace.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The name of the namespace.
        /// This member is required.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil
        ) {
            self.arn = arn
            self.createdTime = createdTime
            self.description = description
            self.instanceId = instanceId
            self.lastModifiedTime = lastModifiedTime
            self.name = name
        }
    }
}

/// The response parameters of CreateDataLakeNamespace.
public struct CreateDataLakeNamespaceOutput: Swift.Sendable {
    /// The detail of created namespace.
    /// This member is required.
    public var namespace: SupplyChainClientTypes.DataLakeNamespace?

    public init(
        namespace: SupplyChainClientTypes.DataLakeNamespace? = nil
    ) {
        self.namespace = namespace
    }
}

/// The request parameters for CreateInstance.
public struct CreateInstanceInput: Swift.Sendable {
    /// The client token for idempotency.
    public var clientToken: Swift.String?
    /// The AWS Supply Chain instance description.
    public var instanceDescription: Swift.String?
    /// The AWS Supply Chain instance name.
    public var instanceName: Swift.String?
    /// The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you provide for encryption. This is required if you do not want to use the Amazon Web Services owned KMS key. If you don't provide anything here, AWS Supply Chain uses the Amazon Web Services owned KMS key.
    public var kmsKeyArn: Swift.String?
    /// The Amazon Web Services tags of an instance to be created.
    public var tags: [Swift.String: Swift.String]?
    /// The DNS subdomain of the web app. This would be "example" in the URL "example.scn.global.on.aws". You can set this to a custom value, as long as the domain isn't already being used by someone else. The name may only include alphanumeric characters and hyphens.
    public var webAppDnsDomain: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        instanceDescription: Swift.String? = nil,
        instanceName: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        webAppDnsDomain: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.instanceDescription = instanceDescription
        self.instanceName = instanceName
        self.kmsKeyArn = kmsKeyArn
        self.tags = tags
        self.webAppDnsDomain = webAppDnsDomain
    }
}

extension SupplyChainClientTypes {

    public enum InstanceState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createFailed
        case deleted
        case deleteFailed
        case deleting
        case initializing
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceState] {
            return [
                .active,
                .createFailed,
                .deleted,
                .deleteFailed,
                .deleting,
                .initializing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .createFailed: return "CreateFailed"
            case .deleted: return "Deleted"
            case .deleteFailed: return "DeleteFailed"
            case .deleting: return "Deleting"
            case .initializing: return "Initializing"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SupplyChainClientTypes {

    /// The details of the instance.
    public struct Instance: Swift.Sendable {
        /// The Amazon Web Services account ID that owns the instance.
        /// This member is required.
        public var awsAccountId: Swift.String?
        /// The instance creation timestamp.
        public var createdTime: Foundation.Date?
        /// The Amazon Web Services Supply Chain instance error message. If the instance results in an unhealthy state, customers need to check the error message, delete the current instance, and recreate a new one based on the mitigation from the error message.
        public var errorMessage: Swift.String?
        /// The Amazon Web Services Supply Chain instance description.
        public var instanceDescription: Swift.String?
        /// The Amazon Web Services Supply Chain instance identifier.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The Amazon Web Services Supply Chain instance name.
        public var instanceName: Swift.String?
        /// The ARN (Amazon Resource Name) of the Key Management Service (KMS) key you optionally provided for encryption. If you did not provide anything here, AWS Supply Chain uses the Amazon Web Services owned KMS key and nothing is returned.
        public var kmsKeyArn: Swift.String?
        /// The instance last modified timestamp.
        public var lastModifiedTime: Foundation.Date?
        /// The state of the instance.
        /// This member is required.
        public var state: SupplyChainClientTypes.InstanceState?
        /// The version number of the instance.
        public var versionNumber: Swift.Double?
        /// The WebApp DNS domain name of the instance.
        public var webAppDnsDomain: Swift.String?

        public init(
            awsAccountId: Swift.String? = nil,
            createdTime: Foundation.Date? = nil,
            errorMessage: Swift.String? = nil,
            instanceDescription: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            instanceName: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            state: SupplyChainClientTypes.InstanceState? = nil,
            versionNumber: Swift.Double? = nil,
            webAppDnsDomain: Swift.String? = nil
        ) {
            self.awsAccountId = awsAccountId
            self.createdTime = createdTime
            self.errorMessage = errorMessage
            self.instanceDescription = instanceDescription
            self.instanceId = instanceId
            self.instanceName = instanceName
            self.kmsKeyArn = kmsKeyArn
            self.lastModifiedTime = lastModifiedTime
            self.state = state
            self.versionNumber = versionNumber
            self.webAppDnsDomain = webAppDnsDomain
        }
    }
}

/// The response parameters for CreateInstance.
public struct CreateInstanceOutput: Swift.Sendable {
    /// The AWS Supply Chain instance resource data details.
    /// This member is required.
    public var instance: SupplyChainClientTypes.Instance?

    public init(
        instance: SupplyChainClientTypes.Instance? = nil
    ) {
        self.instance = instance
    }
}

extension SupplyChainClientTypes {

    public enum DataIntegrationEventDatasetLoadStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DataIntegrationEventDatasetLoadStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SupplyChainClientTypes {

    /// The target dataset load execution details.
    public struct DataIntegrationEventDatasetLoadExecutionDetails: Swift.Sendable {
        /// The failure message (if any) of failed event load execution to dataset.
        public var message: Swift.String?
        /// The event load execution status to target dataset.
        /// This member is required.
        public var status: SupplyChainClientTypes.DataIntegrationEventDatasetLoadStatus?

        public init(
            message: Swift.String? = nil,
            status: SupplyChainClientTypes.DataIntegrationEventDatasetLoadStatus? = nil
        ) {
            self.message = message
            self.status = status
        }
    }
}

extension SupplyChainClientTypes {

    public enum DataIntegrationEventDatasetOperationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case append
        case delete
        case upsert
        case sdkUnknown(Swift.String)

        public static var allCases: [DataIntegrationEventDatasetOperationType] {
            return [
                .append,
                .delete,
                .upsert
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .append: return "APPEND"
            case .delete: return "DELETE"
            case .upsert: return "UPSERT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SupplyChainClientTypes {

    /// The target dataset details for a DATASET event type.
    public struct DataIntegrationEventDatasetTargetDetails: Swift.Sendable {
        /// The datalake dataset ARN identifier.
        /// This member is required.
        public var datasetIdentifier: Swift.String?
        /// The target dataset load execution.
        /// This member is required.
        public var datasetLoadExecution: SupplyChainClientTypes.DataIntegrationEventDatasetLoadExecutionDetails?
        /// The target dataset load operation type. The available options are:
        ///
        /// * APPEND - Add new records to the dataset. Noted that this operation type will just try to append records as-is without any primary key or partition constraints.
        ///
        /// * UPSERT - Modify existing records in the dataset with primary key configured, events for datasets without primary keys are not allowed. If event data contains primary keys that match records in the dataset within same partition, then those existing records (in that partition) will be updated. If primary keys do not match, new records will be added. Note that if dataset contain records with duplicate primary key values in the same partition, those duplicate records will be deduped into one updated record.
        ///
        /// * DELETE - Remove existing records in the dataset with primary key configured, events for datasets without primary keys are not allowed. If event data contains primary keys that match records in the dataset within same partition, then those existing records (in that partition) will be deleted. If primary keys do not match, no actions will be done. Note that if dataset contain records with duplicate primary key values in the same partition, all those duplicates will be removed.
        /// This member is required.
        public var operationType: SupplyChainClientTypes.DataIntegrationEventDatasetOperationType?

        public init(
            datasetIdentifier: Swift.String? = nil,
            datasetLoadExecution: SupplyChainClientTypes.DataIntegrationEventDatasetLoadExecutionDetails? = nil,
            operationType: SupplyChainClientTypes.DataIntegrationEventDatasetOperationType? = nil
        ) {
            self.datasetIdentifier = datasetIdentifier
            self.datasetLoadExecution = datasetLoadExecution
            self.operationType = operationType
        }
    }
}

extension SupplyChainClientTypes {

    public enum DataIntegrationEventType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dataset
        case forecast
        case inboundOrder
        case inboundOrderLine
        case inboundOrderLineSchedule
        case inventoryLevel
        case outboundOrderLine
        case outboundShipment
        case processHeader
        case processOperation
        case processProduct
        case reservation
        case shipment
        case shipmentStop
        case shipmentStopOrder
        case supplyPlan
        case sdkUnknown(Swift.String)

        public static var allCases: [DataIntegrationEventType] {
            return [
                .dataset,
                .forecast,
                .inboundOrder,
                .inboundOrderLine,
                .inboundOrderLineSchedule,
                .inventoryLevel,
                .outboundOrderLine,
                .outboundShipment,
                .processHeader,
                .processOperation,
                .processProduct,
                .reservation,
                .shipment,
                .shipmentStop,
                .shipmentStopOrder,
                .supplyPlan
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dataset: return "scn.data.dataset"
            case .forecast: return "scn.data.forecast"
            case .inboundOrder: return "scn.data.inboundorder"
            case .inboundOrderLine: return "scn.data.inboundorderline"
            case .inboundOrderLineSchedule: return "scn.data.inboundorderlineschedule"
            case .inventoryLevel: return "scn.data.inventorylevel"
            case .outboundOrderLine: return "scn.data.outboundorderline"
            case .outboundShipment: return "scn.data.outboundshipment"
            case .processHeader: return "scn.data.processheader"
            case .processOperation: return "scn.data.processoperation"
            case .processProduct: return "scn.data.processproduct"
            case .reservation: return "scn.data.reservation"
            case .shipment: return "scn.data.shipment"
            case .shipmentStop: return "scn.data.shipmentstop"
            case .shipmentStopOrder: return "scn.data.shipmentstoporder"
            case .supplyPlan: return "scn.data.supplyplan"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SupplyChainClientTypes {

    /// The data integration event details.
    public struct DataIntegrationEvent: Swift.Sendable {
        /// The target dataset details for a DATASET event type.
        public var datasetTargetDetails: SupplyChainClientTypes.DataIntegrationEventDatasetTargetDetails?
        /// Event identifier (for example, orderId for InboundOrder) used for data sharding or partitioning.
        /// This member is required.
        public var eventGroupId: Swift.String?
        /// The unique event identifier.
        /// This member is required.
        public var eventId: Swift.String?
        /// The event timestamp (in epoch seconds).
        /// This member is required.
        public var eventTimestamp: Foundation.Date?
        /// The data event type.
        /// This member is required.
        public var eventType: SupplyChainClientTypes.DataIntegrationEventType?
        /// The AWS Supply Chain instance identifier.
        /// This member is required.
        public var instanceId: Swift.String?

        public init(
            datasetTargetDetails: SupplyChainClientTypes.DataIntegrationEventDatasetTargetDetails? = nil,
            eventGroupId: Swift.String? = nil,
            eventId: Swift.String? = nil,
            eventTimestamp: Foundation.Date? = nil,
            eventType: SupplyChainClientTypes.DataIntegrationEventType? = nil,
            instanceId: Swift.String? = nil
        ) {
            self.datasetTargetDetails = datasetTargetDetails
            self.eventGroupId = eventGroupId
            self.eventId = eventId
            self.eventTimestamp = eventTimestamp
            self.eventType = eventType
            self.instanceId = instanceId
        }
    }
}

extension SupplyChainClientTypes {

    /// The target dataset configuration for a DATASET event type.
    public struct DataIntegrationEventDatasetTargetConfiguration: Swift.Sendable {
        /// The datalake dataset ARN identifier.
        /// This member is required.
        public var datasetIdentifier: Swift.String?
        /// The target dataset load operation type.
        /// This member is required.
        public var operationType: SupplyChainClientTypes.DataIntegrationEventDatasetOperationType?

        public init(
            datasetIdentifier: Swift.String? = nil,
            operationType: SupplyChainClientTypes.DataIntegrationEventDatasetOperationType? = nil
        ) {
            self.datasetIdentifier = datasetIdentifier
            self.operationType = operationType
        }
    }
}

extension SupplyChainClientTypes {

    /// The DataIntegrationFlow details.
    public struct DataIntegrationFlow: Swift.Sendable {
        /// The DataIntegrationFlow creation timestamp.
        /// This member is required.
        public var createdTime: Foundation.Date?
        /// The DataIntegrationFlow instance ID.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The DataIntegrationFlow last modified timestamp.
        /// This member is required.
        public var lastModifiedTime: Foundation.Date?
        /// The DataIntegrationFlow name.
        /// This member is required.
        public var name: Swift.String?
        /// The DataIntegrationFlow source configurations.
        /// This member is required.
        public var sources: [SupplyChainClientTypes.DataIntegrationFlowSource]?
        /// The DataIntegrationFlow target configuration.
        /// This member is required.
        public var target: SupplyChainClientTypes.DataIntegrationFlowTarget?
        /// The DataIntegrationFlow transformation configurations.
        /// This member is required.
        public var transformation: SupplyChainClientTypes.DataIntegrationFlowTransformation?

        public init(
            createdTime: Foundation.Date? = nil,
            instanceId: Swift.String? = nil,
            lastModifiedTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            sources: [SupplyChainClientTypes.DataIntegrationFlowSource]? = nil,
            target: SupplyChainClientTypes.DataIntegrationFlowTarget? = nil,
            transformation: SupplyChainClientTypes.DataIntegrationFlowTransformation? = nil
        ) {
            self.createdTime = createdTime
            self.instanceId = instanceId
            self.lastModifiedTime = lastModifiedTime
            self.name = name
            self.sources = sources
            self.target = target
            self.transformation = transformation
        }
    }
}

extension SupplyChainClientTypes {

    /// The details of a flow execution with dataset source.
    public struct DataIntegrationFlowDatasetSource: Swift.Sendable {
        /// The ARN of the dataset source.
        /// This member is required.
        public var datasetIdentifier: Swift.String?

        public init(
            datasetIdentifier: Swift.String? = nil
        ) {
            self.datasetIdentifier = datasetIdentifier
        }
    }
}

extension SupplyChainClientTypes {

    /// The output metadata of the flow execution.
    public struct DataIntegrationFlowExecutionOutputMetadata: Swift.Sendable {
        /// The S3 URI under which all diagnostic files (such as deduped records if any) are stored.
        public var diagnosticReportsRootS3URI: Swift.String?

        public init(
            diagnosticReportsRootS3URI: Swift.String? = nil
        ) {
            self.diagnosticReportsRootS3URI = diagnosticReportsRootS3URI
        }
    }
}

extension SupplyChainClientTypes {

    /// The details of a flow execution with S3 source.
    public struct DataIntegrationFlowS3Source: Swift.Sendable {
        /// The S3 bucket name of the S3 source.
        /// This member is required.
        public var bucketName: Swift.String?
        /// The S3 object key of the S3 source.
        /// This member is required.
        public var key: Swift.String?

        public init(
            bucketName: Swift.String? = nil,
            key: Swift.String? = nil
        ) {
            self.bucketName = bucketName
            self.key = key
        }
    }
}

extension SupplyChainClientTypes {

    /// The source information of a flow execution.
    public struct DataIntegrationFlowExecutionSourceInfo: Swift.Sendable {
        /// The source details of a flow execution with dataset source.
        public var datasetSource: SupplyChainClientTypes.DataIntegrationFlowDatasetSource?
        /// The source details of a flow execution with S3 source.
        public var s3Source: SupplyChainClientTypes.DataIntegrationFlowS3Source?
        /// The data integration flow execution source type.
        /// This member is required.
        public var sourceType: SupplyChainClientTypes.DataIntegrationFlowSourceType?

        public init(
            datasetSource: SupplyChainClientTypes.DataIntegrationFlowDatasetSource? = nil,
            s3Source: SupplyChainClientTypes.DataIntegrationFlowS3Source? = nil,
            sourceType: SupplyChainClientTypes.DataIntegrationFlowSourceType? = nil
        ) {
            self.datasetSource = datasetSource
            self.s3Source = s3Source
            self.sourceType = sourceType
        }
    }
}

extension SupplyChainClientTypes {

    public enum DataIntegrationFlowExecutionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DataIntegrationFlowExecutionStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SupplyChainClientTypes {

    /// The flow execution details.
    public struct DataIntegrationFlowExecution: Swift.Sendable {
        /// The flow execution end timestamp.
        public var endTime: Foundation.Date?
        /// The flow executionId.
        /// This member is required.
        public var executionId: Swift.String?
        /// The flow execution's flowName.
        /// This member is required.
        public var flowName: Swift.String?
        /// The flow execution's instanceId.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The failure message (if any) of failed flow execution.
        public var message: Swift.String?
        /// The flow execution output metadata.
        public var outputMetadata: SupplyChainClientTypes.DataIntegrationFlowExecutionOutputMetadata?
        /// The source information for a flow execution.
        public var sourceInfo: SupplyChainClientTypes.DataIntegrationFlowExecutionSourceInfo?
        /// The flow execution start timestamp.
        public var startTime: Foundation.Date?
        /// The status of flow execution.
        public var status: SupplyChainClientTypes.DataIntegrationFlowExecutionStatus?

        public init(
            endTime: Foundation.Date? = nil,
            executionId: Swift.String? = nil,
            flowName: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            message: Swift.String? = nil,
            outputMetadata: SupplyChainClientTypes.DataIntegrationFlowExecutionOutputMetadata? = nil,
            sourceInfo: SupplyChainClientTypes.DataIntegrationFlowExecutionSourceInfo? = nil,
            startTime: Foundation.Date? = nil,
            status: SupplyChainClientTypes.DataIntegrationFlowExecutionStatus? = nil
        ) {
            self.endTime = endTime
            self.executionId = executionId
            self.flowName = flowName
            self.instanceId = instanceId
            self.message = message
            self.outputMetadata = outputMetadata
            self.sourceInfo = sourceInfo
            self.startTime = startTime
            self.status = status
        }
    }
}

/// The request parameters for DeleteDataIntegrationFlow.
public struct DeleteDataIntegrationFlowInput: Swift.Sendable {
    /// The Amazon Web Services Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the DataIntegrationFlow to be deleted.
    /// This member is required.
    public var name: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.name = name
    }
}

/// The response parameters for DeleteDataIntegrationFlow.
public struct DeleteDataIntegrationFlowOutput: Swift.Sendable {
    /// The Amazon Web Services Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the DataIntegrationFlow deleted.
    /// This member is required.
    public var name: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.name = name
    }
}

/// The request parameters for GetDataIntegrationFlow.
public struct GetDataIntegrationFlowInput: Swift.Sendable {
    /// The Amazon Web Services Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the DataIntegrationFlow created.
    /// This member is required.
    public var name: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.name = name
    }
}

/// The response parameters for GetDataIntegrationFlow.
public struct GetDataIntegrationFlowOutput: Swift.Sendable {
    /// The details of the DataIntegrationFlow returned.
    /// This member is required.
    public var flow: SupplyChainClientTypes.DataIntegrationFlow?

    public init(
        flow: SupplyChainClientTypes.DataIntegrationFlow? = nil
    ) {
        self.flow = flow
    }
}

/// The request parameters for ListDataIntegrationFlows.
public struct ListDataIntegrationFlowsInput: Swift.Sendable {
    /// The Amazon Web Services Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Specify the maximum number of DataIntegrationFlows to fetch in one paginated request.
    public var maxResults: Swift.Int?
    /// The pagination token to fetch the next page of the DataIntegrationFlows.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = 10,
        nextToken: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// The response parameters for ListDataIntegrationFlows.
public struct ListDataIntegrationFlowsOutput: Swift.Sendable {
    /// The response parameters for ListDataIntegrationFlows.
    /// This member is required.
    public var flows: [SupplyChainClientTypes.DataIntegrationFlow]?
    /// The pagination token to fetch the next page of the DataIntegrationFlows.
    public var nextToken: Swift.String?

    public init(
        flows: [SupplyChainClientTypes.DataIntegrationFlow]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.flows = flows
        self.nextToken = nextToken
    }
}

/// The request parameters for UpdateDataIntegrationFlow.
public struct UpdateDataIntegrationFlowInput: Swift.Sendable {
    /// The Amazon Web Services Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the DataIntegrationFlow to be updated.
    /// This member is required.
    public var name: Swift.String?
    /// The new source configurations for the DataIntegrationFlow.
    public var sources: [SupplyChainClientTypes.DataIntegrationFlowSource]?
    /// The new target configurations for the DataIntegrationFlow.
    public var target: SupplyChainClientTypes.DataIntegrationFlowTarget?
    /// The new transformation configurations for the DataIntegrationFlow.
    public var transformation: SupplyChainClientTypes.DataIntegrationFlowTransformation?

    public init(
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        sources: [SupplyChainClientTypes.DataIntegrationFlowSource]? = nil,
        target: SupplyChainClientTypes.DataIntegrationFlowTarget? = nil,
        transformation: SupplyChainClientTypes.DataIntegrationFlowTransformation? = nil
    ) {
        self.instanceId = instanceId
        self.name = name
        self.sources = sources
        self.target = target
        self.transformation = transformation
    }
}

/// The response parameters for UpdateDataIntegrationFlow.
public struct UpdateDataIntegrationFlowOutput: Swift.Sendable {
    /// The details of the updated DataIntegrationFlow.
    /// This member is required.
    public var flow: SupplyChainClientTypes.DataIntegrationFlow?

    public init(
        flow: SupplyChainClientTypes.DataIntegrationFlow? = nil
    ) {
        self.flow = flow
    }
}

/// The request parameters of DeleteDataLakeDataset.
public struct DeleteDataLakeDatasetInput: Swift.Sendable {
    /// The AWS Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the dataset. For asc namespace, the name must be one of the supported data entities under [https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html).
    /// This member is required.
    public var name: Swift.String?
    /// The namespace of the dataset, besides the custom defined namespace, every instance comes with below pre-defined namespaces:
    ///
    /// * asc - For information on the Amazon Web Services Supply Chain supported datasets see [https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html).
    ///
    /// * default - For datasets with custom user-defined schemas.
    /// This member is required.
    public var namespace: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        namespace: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.name = name
        self.namespace = namespace
    }
}

/// The response parameters of DeleteDataLakeDataset.
public struct DeleteDataLakeDatasetOutput: Swift.Sendable {
    /// The AWS Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of deleted dataset.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace of deleted dataset.
    /// This member is required.
    public var namespace: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        namespace: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.name = name
        self.namespace = namespace
    }
}

/// The request parameters for GetDataLakeDataset.
public struct GetDataLakeDatasetInput: Swift.Sendable {
    /// The Amazon Web Services Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the dataset. For asc namespace, the name must be one of the supported data entities under [https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html).
    /// This member is required.
    public var name: Swift.String?
    /// The namespace of the dataset, besides the custom defined namespace, every instance comes with below pre-defined namespaces:
    ///
    /// * asc - For information on the Amazon Web Services Supply Chain supported datasets see [https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html).
    ///
    /// * default - For datasets with custom user-defined schemas.
    /// This member is required.
    public var namespace: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        namespace: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.name = name
        self.namespace = namespace
    }
}

/// The response parameters for GetDataLakeDataset.
public struct GetDataLakeDatasetOutput: Swift.Sendable {
    /// The fetched dataset details.
    /// This member is required.
    public var dataset: SupplyChainClientTypes.DataLakeDataset?

    public init(
        dataset: SupplyChainClientTypes.DataLakeDataset? = nil
    ) {
        self.dataset = dataset
    }
}

/// The request parameters of ListDataLakeDatasets.
public struct ListDataLakeDatasetsInput: Swift.Sendable {
    /// The Amazon Web Services Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The max number of datasets to fetch in this paginated request.
    public var maxResults: Swift.Int?
    /// The namespace of the dataset, besides the custom defined namespace, every instance comes with below pre-defined namespaces:
    ///
    /// * asc - For information on the Amazon Web Services Supply Chain supported datasets see [https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html).
    ///
    /// * default - For datasets with custom user-defined schemas.
    /// This member is required.
    public var namespace: Swift.String?
    /// The pagination token to fetch next page of datasets.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = 10,
        namespace: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.namespace = namespace
        self.nextToken = nextToken
    }
}

/// The response parameters of ListDataLakeDatasets.
public struct ListDataLakeDatasetsOutput: Swift.Sendable {
    /// The list of fetched dataset details.
    /// This member is required.
    public var datasets: [SupplyChainClientTypes.DataLakeDataset]?
    /// The pagination token to fetch next page of datasets.
    public var nextToken: Swift.String?

    public init(
        datasets: [SupplyChainClientTypes.DataLakeDataset]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.datasets = datasets
        self.nextToken = nextToken
    }
}

/// The request parameters of UpdateDataLakeDataset.
public struct UpdateDataLakeDatasetInput: Swift.Sendable {
    /// The updated description of the data lake dataset.
    public var description: Swift.String?
    /// The Amazon Web Services Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the dataset. For asc namespace, the name must be one of the supported data entities under [https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html).
    /// This member is required.
    public var name: Swift.String?
    /// The namespace of the dataset, besides the custom defined namespace, every instance comes with below pre-defined namespaces:
    ///
    /// * asc - For information on the Amazon Web Services Supply Chain supported datasets see [https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html).
    ///
    /// * default - For datasets with custom user-defined schemas.
    /// This member is required.
    public var namespace: Swift.String?

    public init(
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil,
        namespace: Swift.String? = nil
    ) {
        self.description = description
        self.instanceId = instanceId
        self.name = name
        self.namespace = namespace
    }
}

/// The response parameters of UpdateDataLakeDataset.
public struct UpdateDataLakeDatasetOutput: Swift.Sendable {
    /// The updated dataset details.
    /// This member is required.
    public var dataset: SupplyChainClientTypes.DataLakeDataset?

    public init(
        dataset: SupplyChainClientTypes.DataLakeDataset? = nil
    ) {
        self.dataset = dataset
    }
}

/// The request parameters of DeleteDataLakeNamespace.
public struct DeleteDataLakeNamespaceInput: Swift.Sendable {
    /// The AWS Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the namespace. Noted you cannot delete pre-defined namespace like asc, default which are only deleted through instance deletion.
    /// This member is required.
    public var name: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.name = name
    }
}

/// The response parameters of DeleteDataLakeNamespace.
public struct DeleteDataLakeNamespaceOutput: Swift.Sendable {
    /// The AWS Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of deleted namespace.
    /// This member is required.
    public var name: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.name = name
    }
}

/// The request parameters for GetDataLakeNamespace.
public struct GetDataLakeNamespaceInput: Swift.Sendable {
    /// The Amazon Web Services Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the namespace. Besides the namespaces user created, you can also specify the pre-defined namespaces:
    ///
    /// * asc - Pre-defined namespace containing Amazon Web Services Supply Chain supported datasets, see [https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html).
    ///
    /// * default - Pre-defined namespace containing datasets with custom user-defined schemas.
    /// This member is required.
    public var name: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.name = name
    }
}

/// The response parameters for GetDataLakeNamespace.
public struct GetDataLakeNamespaceOutput: Swift.Sendable {
    /// The fetched namespace details.
    /// This member is required.
    public var namespace: SupplyChainClientTypes.DataLakeNamespace?

    public init(
        namespace: SupplyChainClientTypes.DataLakeNamespace? = nil
    ) {
        self.namespace = namespace
    }
}

/// The request parameters of ListDataLakeNamespaces.
public struct ListDataLakeNamespacesInput: Swift.Sendable {
    /// The Amazon Web Services Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The max number of namespaces to fetch in this paginated request.
    public var maxResults: Swift.Int?
    /// The pagination token to fetch next page of namespaces.
    public var nextToken: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = 10,
        nextToken: Swift.String? = nil
    ) {
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// The response parameters of ListDataLakeNamespaces.
public struct ListDataLakeNamespacesOutput: Swift.Sendable {
    /// The list of fetched namespace details. Noted it only contains custom namespaces, pre-defined namespaces are not included.
    /// This member is required.
    public var namespaces: [SupplyChainClientTypes.DataLakeNamespace]?
    /// The pagination token to fetch next page of namespaces.
    public var nextToken: Swift.String?

    public init(
        namespaces: [SupplyChainClientTypes.DataLakeNamespace]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.namespaces = namespaces
        self.nextToken = nextToken
    }
}

/// The request parameters of UpdateDataLakeNamespace.
public struct UpdateDataLakeNamespaceInput: Swift.Sendable {
    /// The updated description of the data lake namespace.
    public var description: Swift.String?
    /// The Amazon Web Services Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The name of the namespace. Noted you cannot update namespace with name starting with asc, default, scn, aws, amazon, amzn
    /// This member is required.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        name: Swift.String? = nil
    ) {
        self.description = description
        self.instanceId = instanceId
        self.name = name
    }
}

/// The response parameters of UpdateDataLakeNamespace.
public struct UpdateDataLakeNamespaceOutput: Swift.Sendable {
    /// The updated namespace details.
    /// This member is required.
    public var namespace: SupplyChainClientTypes.DataLakeNamespace?

    public init(
        namespace: SupplyChainClientTypes.DataLakeNamespace? = nil
    ) {
        self.namespace = namespace
    }
}

/// The request parameters for DeleteInstance.
public struct DeleteInstanceInput: Swift.Sendable {
    /// The AWS Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    ) {
        self.instanceId = instanceId
    }
}

/// The response parameters for DeleteInstance.
public struct DeleteInstanceOutput: Swift.Sendable {
    /// The AWS Supply Chain instance resource data details.
    /// This member is required.
    public var instance: SupplyChainClientTypes.Instance?

    public init(
        instance: SupplyChainClientTypes.Instance? = nil
    ) {
        self.instance = instance
    }
}

/// The request parameters for GetDataIntegrationEvent.
public struct GetDataIntegrationEventInput: Swift.Sendable {
    /// The unique event identifier.
    /// This member is required.
    public var eventId: Swift.String?
    /// The Amazon Web Services Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        eventId: Swift.String? = nil,
        instanceId: Swift.String? = nil
    ) {
        self.eventId = eventId
        self.instanceId = instanceId
    }
}

/// The response parameters for GetDataIntegrationEvent.
public struct GetDataIntegrationEventOutput: Swift.Sendable {
    /// The details of the DataIntegrationEvent returned.
    /// This member is required.
    public var event: SupplyChainClientTypes.DataIntegrationEvent?

    public init(
        event: SupplyChainClientTypes.DataIntegrationEvent? = nil
    ) {
        self.event = event
    }
}

/// The request parameters of GetFlowExecution.
public struct GetDataIntegrationFlowExecutionInput: Swift.Sendable {
    /// The flow execution identifier.
    /// This member is required.
    public var executionId: Swift.String?
    /// The flow name.
    /// This member is required.
    public var flowName: Swift.String?
    /// The AWS Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        executionId: Swift.String? = nil,
        flowName: Swift.String? = nil,
        instanceId: Swift.String? = nil
    ) {
        self.executionId = executionId
        self.flowName = flowName
        self.instanceId = instanceId
    }
}

/// The response parameters of GetFlowExecution.
public struct GetDataIntegrationFlowExecutionOutput: Swift.Sendable {
    /// The flow execution details.
    /// This member is required.
    public var flowExecution: SupplyChainClientTypes.DataIntegrationFlowExecution?

    public init(
        flowExecution: SupplyChainClientTypes.DataIntegrationFlowExecution? = nil
    ) {
        self.flowExecution = flowExecution
    }
}

/// The request parameters for GetInstance.
public struct GetInstanceInput: Swift.Sendable {
    /// The AWS Supply Chain instance identifier
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        instanceId: Swift.String? = nil
    ) {
        self.instanceId = instanceId
    }
}

/// The response parameters for GetInstance.
public struct GetInstanceOutput: Swift.Sendable {
    /// The instance resource data details.
    /// This member is required.
    public var instance: SupplyChainClientTypes.Instance?

    public init(
        instance: SupplyChainClientTypes.Instance? = nil
    ) {
        self.instance = instance
    }
}

/// The request parameters for ListInstances.
public struct ListInstancesInput: Swift.Sendable {
    /// The filter to ListInstances based on their names.
    public var instanceNameFilter: [Swift.String]?
    /// The filter to ListInstances based on their state.
    public var instanceStateFilter: [SupplyChainClientTypes.InstanceState]?
    /// Specify the maximum number of instances to fetch in this paginated request.
    public var maxResults: Swift.Int?
    /// The pagination token to fetch the next page of instances.
    public var nextToken: Swift.String?

    public init(
        instanceNameFilter: [Swift.String]? = nil,
        instanceStateFilter: [SupplyChainClientTypes.InstanceState]? = nil,
        maxResults: Swift.Int? = 10,
        nextToken: Swift.String? = nil
    ) {
        self.instanceNameFilter = instanceNameFilter
        self.instanceStateFilter = instanceStateFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// The response parameters for ListInstances.
public struct ListInstancesOutput: Swift.Sendable {
    /// The list of instances resource data details.
    /// This member is required.
    public var instances: [SupplyChainClientTypes.Instance]?
    /// The pagination token to fetch the next page of instances.
    public var nextToken: Swift.String?

    public init(
        instances: [SupplyChainClientTypes.Instance]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.instances = instances
        self.nextToken = nextToken
    }
}

/// The request parameters for UpdateInstance.
public struct UpdateInstanceInput: Swift.Sendable {
    /// The AWS Supply Chain instance description.
    public var instanceDescription: Swift.String?
    /// The AWS Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The AWS Supply Chain instance name.
    public var instanceName: Swift.String?

    public init(
        instanceDescription: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        instanceName: Swift.String? = nil
    ) {
        self.instanceDescription = instanceDescription
        self.instanceId = instanceId
        self.instanceName = instanceName
    }
}

/// The response parameters for UpdateInstance.
public struct UpdateInstanceOutput: Swift.Sendable {
    /// The instance resource data details.
    /// This member is required.
    public var instance: SupplyChainClientTypes.Instance?

    public init(
        instance: SupplyChainClientTypes.Instance? = nil
    ) {
        self.instance = instance
    }
}

/// The request parameters for ListDataIntegrationEvents.
public struct ListDataIntegrationEventsInput: Swift.Sendable {
    /// List data integration events for the specified eventType.
    public var eventType: SupplyChainClientTypes.DataIntegrationEventType?
    /// The Amazon Web Services Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// Specify the maximum number of data integration events to fetch in one paginated request.
    public var maxResults: Swift.Int?
    /// The pagination token to fetch the next page of the data integration events.
    public var nextToken: Swift.String?

    public init(
        eventType: SupplyChainClientTypes.DataIntegrationEventType? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = 10,
        nextToken: Swift.String? = nil
    ) {
        self.eventType = eventType
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// The response parameters for ListDataIntegrationEvents.
public struct ListDataIntegrationEventsOutput: Swift.Sendable {
    /// The list of data integration events.
    /// This member is required.
    public var events: [SupplyChainClientTypes.DataIntegrationEvent]?
    /// The pagination token to fetch the next page of the ListDataIntegrationEvents.
    public var nextToken: Swift.String?

    public init(
        events: [SupplyChainClientTypes.DataIntegrationEvent]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.events = events
        self.nextToken = nextToken
    }
}

/// The request parameters of ListFlowExecutions.
public struct ListDataIntegrationFlowExecutionsInput: Swift.Sendable {
    /// The flow name.
    /// This member is required.
    public var flowName: Swift.String?
    /// The AWS Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The number to specify the max number of flow executions to fetch in this paginated request.
    public var maxResults: Swift.Int?
    /// The pagination token to fetch next page of flow executions.
    public var nextToken: Swift.String?

    public init(
        flowName: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        maxResults: Swift.Int? = 10,
        nextToken: Swift.String? = nil
    ) {
        self.flowName = flowName
        self.instanceId = instanceId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// The response parameters of ListFlowExecutions.
public struct ListDataIntegrationFlowExecutionsOutput: Swift.Sendable {
    /// The list of flow executions.
    /// This member is required.
    public var flowExecutions: [SupplyChainClientTypes.DataIntegrationFlowExecution]?
    /// The pagination token to fetch next page of flow executions.
    public var nextToken: Swift.String?

    public init(
        flowExecutions: [SupplyChainClientTypes.DataIntegrationFlowExecution]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.flowExecutions = flowExecutions
        self.nextToken = nextToken
    }
}

/// The request parameters of ListTagsForResource.
public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Web Services Supply chain resource ARN that needs tags to be listed.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

/// The response parameters of ListTagsForResource.
public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags added to an Amazon Web Services Supply Chain resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

/// The request parameters for SendDataIntegrationEvent.
public struct SendDataIntegrationEventInput: Swift.Sendable {
    /// The idempotent client token. The token is active for 8 hours, and within its lifetime, it ensures the request completes only once upon retry with same client token. If omitted, the AWS SDK generates a unique value so that AWS SDK can safely retry the request upon network errors.
    public var clientToken: Swift.String?
    /// The data payload of the event, should follow the data schema of the target dataset, or see [Data entities supported in AWS Supply Chain](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/data-model-asc.html). To send single data record, use JsonObject format; to send multiple data records, use JsonArray format. Note that for AWS Supply Chain dataset under asc namespace, it has a connection_id internal field that is not allowed to be provided by client directly, they will be auto populated.
    /// This member is required.
    public var data: Swift.String?
    /// The target dataset configuration for scn.data.dataset event type.
    public var datasetTarget: SupplyChainClientTypes.DataIntegrationEventDatasetTargetConfiguration?
    /// Event identifier (for example, orderId for InboundOrder) used for data sharding or partitioning. Noted under one eventGroupId of same eventType and instanceId, events are processed sequentially in the order they are received by the server.
    /// This member is required.
    public var eventGroupId: Swift.String?
    /// The timestamp (in epoch seconds) associated with the event. If not provided, it will be assigned with current timestamp.
    public var eventTimestamp: Foundation.Date?
    /// The data event type.
    ///
    /// * scn.data.dataset - Send data directly to any specified dataset.
    ///
    /// * scn.data.supplyplan - Send data to [supply_plan](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/supply-plan-entity.html) dataset.
    ///
    /// * scn.data.shipmentstoporder - Send data to [shipment_stop_order](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/replenishment-shipment-stop-order-entity.html) dataset.
    ///
    /// * scn.data.shipmentstop - Send data to [shipment_stop](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/replenishment-shipment-stop-entity.html) dataset.
    ///
    /// * scn.data.shipment - Send data to [shipment](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/replenishment-shipment-entity.html) dataset.
    ///
    /// * scn.data.reservation - Send data to [reservation](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/planning-reservation-entity.html) dataset.
    ///
    /// * scn.data.processproduct - Send data to [process_product](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/operation-process-product-entity.html) dataset.
    ///
    /// * scn.data.processoperation - Send data to [process_operation](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/operation-process-operation-entity.html) dataset.
    ///
    /// * scn.data.processheader - Send data to [process_header](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/operation-process-header-entity.html) dataset.
    ///
    /// * scn.data.forecast - Send data to [forecast](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/forecast-forecast-entity.html) dataset.
    ///
    /// * scn.data.inventorylevel - Send data to [inv_level](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/inventory_mgmnt-inv-level-entity.html) dataset.
    ///
    /// * scn.data.inboundorder - Send data to [inbound_order](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/replenishment-inbound-order-entity.html) dataset.
    ///
    /// * scn.data.inboundorderline - Send data to [inbound_order_line](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/replenishment-inbound-order-line-entity.html) dataset.
    ///
    /// * scn.data.inboundorderlineschedule - Send data to [inbound_order_line_schedule](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/replenishment-inbound-order-line-schedule-entity.html) dataset.
    ///
    /// * scn.data.outboundorderline - Send data to [outbound_order_line](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/outbound-fulfillment-order-line-entity.html) dataset.
    ///
    /// * scn.data.outboundshipment - Send data to [outbound_shipment](https://docs.aws.amazon.com/aws-supply-chain/latest/userguide/outbound-fulfillment-shipment-entity.html) dataset.
    /// This member is required.
    public var eventType: SupplyChainClientTypes.DataIntegrationEventType?
    /// The AWS Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        data: Swift.String? = nil,
        datasetTarget: SupplyChainClientTypes.DataIntegrationEventDatasetTargetConfiguration? = nil,
        eventGroupId: Swift.String? = nil,
        eventTimestamp: Foundation.Date? = nil,
        eventType: SupplyChainClientTypes.DataIntegrationEventType? = nil,
        instanceId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.data = data
        self.datasetTarget = datasetTarget
        self.eventGroupId = eventGroupId
        self.eventTimestamp = eventTimestamp
        self.eventType = eventType
        self.instanceId = instanceId
    }
}

extension SendDataIntegrationEventInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendDataIntegrationEventInput(clientToken: \(Swift.String(describing: clientToken)), datasetTarget: \(Swift.String(describing: datasetTarget)), eventGroupId: \(Swift.String(describing: eventGroupId)), eventTimestamp: \(Swift.String(describing: eventTimestamp)), eventType: \(Swift.String(describing: eventType)), instanceId: \(Swift.String(describing: instanceId)), data: \"CONTENT_REDACTED\")"}
}

/// The response parameters for SendDataIntegrationEvent.
public struct SendDataIntegrationEventOutput: Swift.Sendable {
    /// The unique event identifier.
    /// This member is required.
    public var eventId: Swift.String?

    public init(
        eventId: Swift.String? = nil
    ) {
        self.eventId = eventId
    }
}

/// The request parameters of TagResource.
public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Web Services Supply chain resource ARN that needs to be tagged.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags of the Amazon Web Services Supply chain resource to be created.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

/// The response parameters for TagResource.
public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

/// The request parameters of UntagResource.
public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Web Services Supply chain resource ARN that needs to be untagged.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to be deleted for an Amazon Web Services Supply Chain resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

/// The response parameters of UntagResource.
public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension CreateBillOfMaterialsImportJobInput {

    static func urlPathProvider(_ value: CreateBillOfMaterialsImportJobInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/api/configuration/instances/\(instanceId.urlPercentEncoding())/bill-of-materials-import-jobs"
    }
}

extension CreateDataIntegrationFlowInput {

    static func urlPathProvider(_ value: CreateDataIntegrationFlowInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/api/data-integration/instance/\(instanceId.urlPercentEncoding())/data-integration-flows/\(name.urlPercentEncoding())"
    }
}

extension CreateDataLakeDatasetInput {

    static func urlPathProvider(_ value: CreateDataLakeDatasetInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/api/datalake/instance/\(instanceId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/datasets/\(name.urlPercentEncoding())"
    }
}

extension CreateDataLakeNamespaceInput {

    static func urlPathProvider(_ value: CreateDataLakeNamespaceInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/api/datalake/instance/\(instanceId.urlPercentEncoding())/namespaces/\(name.urlPercentEncoding())"
    }
}

extension CreateInstanceInput {

    static func urlPathProvider(_ value: CreateInstanceInput) -> Swift.String? {
        return "/api/instance"
    }
}

extension DeleteDataIntegrationFlowInput {

    static func urlPathProvider(_ value: DeleteDataIntegrationFlowInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/api/data-integration/instance/\(instanceId.urlPercentEncoding())/data-integration-flows/\(name.urlPercentEncoding())"
    }
}

extension DeleteDataLakeDatasetInput {

    static func urlPathProvider(_ value: DeleteDataLakeDatasetInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/api/datalake/instance/\(instanceId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/datasets/\(name.urlPercentEncoding())"
    }
}

extension DeleteDataLakeNamespaceInput {

    static func urlPathProvider(_ value: DeleteDataLakeNamespaceInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/api/datalake/instance/\(instanceId.urlPercentEncoding())/namespaces/\(name.urlPercentEncoding())"
    }
}

extension DeleteInstanceInput {

    static func urlPathProvider(_ value: DeleteInstanceInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/api/instance/\(instanceId.urlPercentEncoding())"
    }
}

extension GetBillOfMaterialsImportJobInput {

    static func urlPathProvider(_ value: GetBillOfMaterialsImportJobInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/api/configuration/instances/\(instanceId.urlPercentEncoding())/bill-of-materials-import-jobs/\(jobId.urlPercentEncoding())"
    }
}

extension GetDataIntegrationEventInput {

    static func urlPathProvider(_ value: GetDataIntegrationEventInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let eventId = value.eventId else {
            return nil
        }
        return "/api-data/data-integration/instance/\(instanceId.urlPercentEncoding())/data-integration-events/\(eventId.urlPercentEncoding())"
    }
}

extension GetDataIntegrationFlowInput {

    static func urlPathProvider(_ value: GetDataIntegrationFlowInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/api/data-integration/instance/\(instanceId.urlPercentEncoding())/data-integration-flows/\(name.urlPercentEncoding())"
    }
}

extension GetDataIntegrationFlowExecutionInput {

    static func urlPathProvider(_ value: GetDataIntegrationFlowExecutionInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let flowName = value.flowName else {
            return nil
        }
        guard let executionId = value.executionId else {
            return nil
        }
        return "/api-data/data-integration/instance/\(instanceId.urlPercentEncoding())/data-integration-flows/\(flowName.urlPercentEncoding())/executions/\(executionId.urlPercentEncoding())"
    }
}

extension GetDataLakeDatasetInput {

    static func urlPathProvider(_ value: GetDataLakeDatasetInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/api/datalake/instance/\(instanceId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/datasets/\(name.urlPercentEncoding())"
    }
}

extension GetDataLakeNamespaceInput {

    static func urlPathProvider(_ value: GetDataLakeNamespaceInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/api/datalake/instance/\(instanceId.urlPercentEncoding())/namespaces/\(name.urlPercentEncoding())"
    }
}

extension GetInstanceInput {

    static func urlPathProvider(_ value: GetInstanceInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/api/instance/\(instanceId.urlPercentEncoding())"
    }
}

extension ListDataIntegrationEventsInput {

    static func urlPathProvider(_ value: ListDataIntegrationEventsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/api-data/data-integration/instance/\(instanceId.urlPercentEncoding())/data-integration-events"
    }
}

extension ListDataIntegrationEventsInput {

    static func queryItemProvider(_ value: ListDataIntegrationEventsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let eventType = value.eventType {
            let eventTypeQueryItem = Smithy.URIQueryItem(name: "eventType".urlPercentEncoding(), value: Swift.String(eventType.rawValue).urlPercentEncoding())
            items.append(eventTypeQueryItem)
        }
        return items
    }
}

extension ListDataIntegrationFlowExecutionsInput {

    static func urlPathProvider(_ value: ListDataIntegrationFlowExecutionsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let flowName = value.flowName else {
            return nil
        }
        return "/api-data/data-integration/instance/\(instanceId.urlPercentEncoding())/data-integration-flows/\(flowName.urlPercentEncoding())/executions"
    }
}

extension ListDataIntegrationFlowExecutionsInput {

    static func queryItemProvider(_ value: ListDataIntegrationFlowExecutionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDataIntegrationFlowsInput {

    static func urlPathProvider(_ value: ListDataIntegrationFlowsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/api/data-integration/instance/\(instanceId.urlPercentEncoding())/data-integration-flows"
    }
}

extension ListDataIntegrationFlowsInput {

    static func queryItemProvider(_ value: ListDataIntegrationFlowsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDataLakeDatasetsInput {

    static func urlPathProvider(_ value: ListDataLakeDatasetsInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        return "/api/datalake/instance/\(instanceId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/datasets"
    }
}

extension ListDataLakeDatasetsInput {

    static func queryItemProvider(_ value: ListDataLakeDatasetsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDataLakeNamespacesInput {

    static func urlPathProvider(_ value: ListDataLakeNamespacesInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/api/datalake/instance/\(instanceId.urlPercentEncoding())/namespaces"
    }
}

extension ListDataLakeNamespacesInput {

    static func queryItemProvider(_ value: ListDataLakeNamespacesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListInstancesInput {

    static func urlPathProvider(_ value: ListInstancesInput) -> Swift.String? {
        return "/api/instance"
    }
}

extension ListInstancesInput {

    static func queryItemProvider(_ value: ListInstancesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let instanceNameFilter = value.instanceNameFilter {
            instanceNameFilter.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "instanceNameFilter".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let instanceStateFilter = value.instanceStateFilter {
            instanceStateFilter.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "instanceStateFilter".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/api/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension SendDataIntegrationEventInput {

    static func urlPathProvider(_ value: SendDataIntegrationEventInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/api-data/data-integration/instance/\(instanceId.urlPercentEncoding())/data-integration-events"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/api/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/api/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateDataIntegrationFlowInput {

    static func urlPathProvider(_ value: UpdateDataIntegrationFlowInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/api/data-integration/instance/\(instanceId.urlPercentEncoding())/data-integration-flows/\(name.urlPercentEncoding())"
    }
}

extension UpdateDataLakeDatasetInput {

    static func urlPathProvider(_ value: UpdateDataLakeDatasetInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/api/datalake/instance/\(instanceId.urlPercentEncoding())/namespaces/\(namespace.urlPercentEncoding())/datasets/\(name.urlPercentEncoding())"
    }
}

extension UpdateDataLakeNamespaceInput {

    static func urlPathProvider(_ value: UpdateDataLakeNamespaceInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/api/datalake/instance/\(instanceId.urlPercentEncoding())/namespaces/\(name.urlPercentEncoding())"
    }
}

extension UpdateInstanceInput {

    static func urlPathProvider(_ value: UpdateInstanceInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/api/instance/\(instanceId.urlPercentEncoding())"
    }
}

extension CreateBillOfMaterialsImportJobInput {

    static func write(value: CreateBillOfMaterialsImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["s3uri"].write(value.s3uri)
    }
}

extension CreateDataIntegrationFlowInput {

    static func write(value: CreateDataIntegrationFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sources"].writeList(value.sources, memberWritingClosure: SupplyChainClientTypes.DataIntegrationFlowSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["target"].write(value.target, with: SupplyChainClientTypes.DataIntegrationFlowTarget.write(value:to:))
        try writer["transformation"].write(value.transformation, with: SupplyChainClientTypes.DataIntegrationFlowTransformation.write(value:to:))
    }
}

extension CreateDataLakeDatasetInput {

    static func write(value: CreateDataLakeDatasetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["partitionSpec"].write(value.partitionSpec, with: SupplyChainClientTypes.DataLakeDatasetPartitionSpec.write(value:to:))
        try writer["schema"].write(value.schema, with: SupplyChainClientTypes.DataLakeDatasetSchema.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateDataLakeNamespaceInput {

    static func write(value: CreateDataLakeNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateInstanceInput {

    static func write(value: CreateInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["instanceDescription"].write(value.instanceDescription)
        try writer["instanceName"].write(value.instanceName)
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["webAppDnsDomain"].write(value.webAppDnsDomain)
    }
}

extension SendDataIntegrationEventInput {

    static func write(value: SendDataIntegrationEventInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["data"].write(value.data)
        try writer["datasetTarget"].write(value.datasetTarget, with: SupplyChainClientTypes.DataIntegrationEventDatasetTargetConfiguration.write(value:to:))
        try writer["eventGroupId"].write(value.eventGroupId)
        try writer["eventTimestamp"].writeTimestamp(value.eventTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["eventType"].write(value.eventType)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateDataIntegrationFlowInput {

    static func write(value: UpdateDataIntegrationFlowInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sources"].writeList(value.sources, memberWritingClosure: SupplyChainClientTypes.DataIntegrationFlowSource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["target"].write(value.target, with: SupplyChainClientTypes.DataIntegrationFlowTarget.write(value:to:))
        try writer["transformation"].write(value.transformation, with: SupplyChainClientTypes.DataIntegrationFlowTransformation.write(value:to:))
    }
}

extension UpdateDataLakeDatasetInput {

    static func write(value: UpdateDataLakeDatasetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
    }
}

extension UpdateDataLakeNamespaceInput {

    static func write(value: UpdateDataLakeNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
    }
}

extension UpdateInstanceInput {

    static func write(value: UpdateInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["instanceDescription"].write(value.instanceDescription)
        try writer["instanceName"].write(value.instanceName)
    }
}

extension CreateBillOfMaterialsImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBillOfMaterialsImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBillOfMaterialsImportJobOutput()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateDataIntegrationFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataIntegrationFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataIntegrationFlowOutput()
        value.instanceId = try reader["instanceId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension CreateDataLakeDatasetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataLakeDatasetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataLakeDatasetOutput()
        value.dataset = try reader["dataset"].readIfPresent(with: SupplyChainClientTypes.DataLakeDataset.read(from:))
        return value
    }
}

extension CreateDataLakeNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDataLakeNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDataLakeNamespaceOutput()
        value.namespace = try reader["namespace"].readIfPresent(with: SupplyChainClientTypes.DataLakeNamespace.read(from:))
        return value
    }
}

extension CreateInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateInstanceOutput()
        value.instance = try reader["instance"].readIfPresent(with: SupplyChainClientTypes.Instance.read(from:))
        return value
    }
}

extension DeleteDataIntegrationFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDataIntegrationFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDataIntegrationFlowOutput()
        value.instanceId = try reader["instanceId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteDataLakeDatasetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDataLakeDatasetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDataLakeDatasetOutput()
        value.instanceId = try reader["instanceId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.namespace = try reader["namespace"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteDataLakeNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDataLakeNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDataLakeNamespaceOutput()
        value.instanceId = try reader["instanceId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteInstanceOutput()
        value.instance = try reader["instance"].readIfPresent(with: SupplyChainClientTypes.Instance.read(from:))
        return value
    }
}

extension GetBillOfMaterialsImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBillOfMaterialsImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBillOfMaterialsImportJobOutput()
        value.job = try reader["job"].readIfPresent(with: SupplyChainClientTypes.BillOfMaterialsImportJob.read(from:))
        return value
    }
}

extension GetDataIntegrationEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataIntegrationEventOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataIntegrationEventOutput()
        value.event = try reader["event"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationEvent.read(from:))
        return value
    }
}

extension GetDataIntegrationFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataIntegrationFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataIntegrationFlowOutput()
        value.flow = try reader["flow"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationFlow.read(from:))
        return value
    }
}

extension GetDataIntegrationFlowExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataIntegrationFlowExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataIntegrationFlowExecutionOutput()
        value.flowExecution = try reader["flowExecution"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationFlowExecution.read(from:))
        return value
    }
}

extension GetDataLakeDatasetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataLakeDatasetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataLakeDatasetOutput()
        value.dataset = try reader["dataset"].readIfPresent(with: SupplyChainClientTypes.DataLakeDataset.read(from:))
        return value
    }
}

extension GetDataLakeNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataLakeNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataLakeNamespaceOutput()
        value.namespace = try reader["namespace"].readIfPresent(with: SupplyChainClientTypes.DataLakeNamespace.read(from:))
        return value
    }
}

extension GetInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInstanceOutput()
        value.instance = try reader["instance"].readIfPresent(with: SupplyChainClientTypes.Instance.read(from:))
        return value
    }
}

extension ListDataIntegrationEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataIntegrationEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataIntegrationEventsOutput()
        value.events = try reader["events"].readListIfPresent(memberReadingClosure: SupplyChainClientTypes.DataIntegrationEvent.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDataIntegrationFlowExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataIntegrationFlowExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataIntegrationFlowExecutionsOutput()
        value.flowExecutions = try reader["flowExecutions"].readListIfPresent(memberReadingClosure: SupplyChainClientTypes.DataIntegrationFlowExecution.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDataIntegrationFlowsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataIntegrationFlowsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataIntegrationFlowsOutput()
        value.flows = try reader["flows"].readListIfPresent(memberReadingClosure: SupplyChainClientTypes.DataIntegrationFlow.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDataLakeDatasetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataLakeDatasetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataLakeDatasetsOutput()
        value.datasets = try reader["datasets"].readListIfPresent(memberReadingClosure: SupplyChainClientTypes.DataLakeDataset.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDataLakeNamespacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDataLakeNamespacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDataLakeNamespacesOutput()
        value.namespaces = try reader["namespaces"].readListIfPresent(memberReadingClosure: SupplyChainClientTypes.DataLakeNamespace.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInstancesOutput()
        value.instances = try reader["instances"].readListIfPresent(memberReadingClosure: SupplyChainClientTypes.Instance.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension SendDataIntegrationEventOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendDataIntegrationEventOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = SendDataIntegrationEventOutput()
        value.eventId = try reader["eventId"].readIfPresent() ?? ""
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateDataIntegrationFlowOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDataIntegrationFlowOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDataIntegrationFlowOutput()
        value.flow = try reader["flow"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationFlow.read(from:))
        return value
    }
}

extension UpdateDataLakeDatasetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDataLakeDatasetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDataLakeDatasetOutput()
        value.dataset = try reader["dataset"].readIfPresent(with: SupplyChainClientTypes.DataLakeDataset.read(from:))
        return value
    }
}

extension UpdateDataLakeNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDataLakeNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDataLakeNamespaceOutput()
        value.namespace = try reader["namespace"].readIfPresent(with: SupplyChainClientTypes.DataLakeNamespace.read(from:))
        return value
    }
}

extension UpdateInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateInstanceOutput()
        value.instance = try reader["instance"].readIfPresent(with: SupplyChainClientTypes.Instance.read(from:))
        return value
    }
}

func httpServiceError(baseError: AWSClientRuntime.RestJSONError) throws -> Swift.Error? {
    switch baseError.code {
        case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
        case "ConflictException": return try ConflictException.makeError(baseError: baseError)
        case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
        case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
        case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
        case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
        case "ValidationException": return try ValidationException.makeError(baseError: baseError)
        default: return nil
    }
}

enum CreateBillOfMaterialsImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataIntegrationFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataLakeDatasetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDataLakeNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDataIntegrationFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDataLakeDatasetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDataLakeNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBillOfMaterialsImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataIntegrationEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataIntegrationFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataIntegrationFlowExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataLakeDatasetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataLakeNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataIntegrationEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataIntegrationFlowExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataIntegrationFlowsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataLakeDatasetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDataLakeNamespacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendDataIntegrationEventOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDataIntegrationFlowOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDataLakeDatasetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDataLakeNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SupplyChainClientTypes.DataLakeDataset {

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataLakeDataset {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataLakeDataset()
        value.instanceId = try reader["instanceId"].readIfPresent() ?? ""
        value.namespace = try reader["namespace"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.schema = try reader["schema"].readIfPresent(with: SupplyChainClientTypes.DataLakeDatasetSchema.read(from:))
        value.description = try reader["description"].readIfPresent()
        value.partitionSpec = try reader["partitionSpec"].readIfPresent(with: SupplyChainClientTypes.DataLakeDatasetPartitionSpec.read(from:))
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension SupplyChainClientTypes.DataLakeDatasetPartitionSpec {

    static func write(value: SupplyChainClientTypes.DataLakeDatasetPartitionSpec?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fields"].writeList(value.fields, memberWritingClosure: SupplyChainClientTypes.DataLakeDatasetPartitionField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataLakeDatasetPartitionSpec {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataLakeDatasetPartitionSpec()
        value.fields = try reader["fields"].readListIfPresent(memberReadingClosure: SupplyChainClientTypes.DataLakeDatasetPartitionField.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SupplyChainClientTypes.DataLakeDatasetPartitionField {

    static func write(value: SupplyChainClientTypes.DataLakeDatasetPartitionField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["transform"].write(value.transform, with: SupplyChainClientTypes.DataLakeDatasetPartitionFieldTransform.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataLakeDatasetPartitionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataLakeDatasetPartitionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.transform = try reader["transform"].readIfPresent(with: SupplyChainClientTypes.DataLakeDatasetPartitionFieldTransform.read(from:))
        return value
    }
}

extension SupplyChainClientTypes.DataLakeDatasetPartitionFieldTransform {

    static func write(value: SupplyChainClientTypes.DataLakeDatasetPartitionFieldTransform?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataLakeDatasetPartitionFieldTransform {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataLakeDatasetPartitionFieldTransform()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension SupplyChainClientTypes.DataLakeDatasetSchema {

    static func write(value: SupplyChainClientTypes.DataLakeDatasetSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fields"].writeList(value.fields, memberWritingClosure: SupplyChainClientTypes.DataLakeDatasetSchemaField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["primaryKeys"].writeList(value.primaryKeys, memberWritingClosure: SupplyChainClientTypes.DataLakeDatasetPrimaryKeyField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataLakeDatasetSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataLakeDatasetSchema()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.fields = try reader["fields"].readListIfPresent(memberReadingClosure: SupplyChainClientTypes.DataLakeDatasetSchemaField.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.primaryKeys = try reader["primaryKeys"].readListIfPresent(memberReadingClosure: SupplyChainClientTypes.DataLakeDatasetPrimaryKeyField.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SupplyChainClientTypes.DataLakeDatasetPrimaryKeyField {

    static func write(value: SupplyChainClientTypes.DataLakeDatasetPrimaryKeyField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataLakeDatasetPrimaryKeyField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataLakeDatasetPrimaryKeyField()
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension SupplyChainClientTypes.DataLakeDatasetSchemaField {

    static func write(value: SupplyChainClientTypes.DataLakeDatasetSchemaField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["isRequired"].write(value.isRequired)
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataLakeDatasetSchemaField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataLakeDatasetSchemaField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.isRequired = try reader["isRequired"].readIfPresent() ?? false
        return value
    }
}

extension SupplyChainClientTypes.DataLakeNamespace {

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataLakeNamespace {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataLakeNamespace()
        value.instanceId = try reader["instanceId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension SupplyChainClientTypes.Instance {

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.Instance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.Instance()
        value.instanceId = try reader["instanceId"].readIfPresent() ?? ""
        value.awsAccountId = try reader["awsAccountId"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.webAppDnsDomain = try reader["webAppDnsDomain"].readIfPresent()
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.instanceName = try reader["instanceName"].readIfPresent()
        value.instanceDescription = try reader["instanceDescription"].readIfPresent()
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        value.versionNumber = try reader["versionNumber"].readIfPresent()
        return value
    }
}

extension SupplyChainClientTypes.BillOfMaterialsImportJob {

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.BillOfMaterialsImportJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.BillOfMaterialsImportJob()
        value.instanceId = try reader["instanceId"].readIfPresent() ?? ""
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.s3uri = try reader["s3uri"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationEvent()
        value.instanceId = try reader["instanceId"].readIfPresent() ?? ""
        value.eventId = try reader["eventId"].readIfPresent() ?? ""
        value.eventType = try reader["eventType"].readIfPresent() ?? .sdkUnknown("")
        value.eventGroupId = try reader["eventGroupId"].readIfPresent() ?? ""
        value.eventTimestamp = try reader["eventTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.datasetTargetDetails = try reader["datasetTargetDetails"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationEventDatasetTargetDetails.read(from:))
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationEventDatasetTargetDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationEventDatasetTargetDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationEventDatasetTargetDetails()
        value.datasetIdentifier = try reader["datasetIdentifier"].readIfPresent() ?? ""
        value.operationType = try reader["operationType"].readIfPresent() ?? .sdkUnknown("")
        value.datasetLoadExecution = try reader["datasetLoadExecution"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationEventDatasetLoadExecutionDetails.read(from:))
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationEventDatasetLoadExecutionDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationEventDatasetLoadExecutionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationEventDatasetLoadExecutionDetails()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationFlow {

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationFlow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationFlow()
        value.instanceId = try reader["instanceId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.sources = try reader["sources"].readListIfPresent(memberReadingClosure: SupplyChainClientTypes.DataIntegrationFlowSource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.transformation = try reader["transformation"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationFlowTransformation.read(from:))
        value.target = try reader["target"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationFlowTarget.read(from:))
        value.createdTime = try reader["createdTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastModifiedTime = try reader["lastModifiedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationFlowTarget {

    static func write(value: SupplyChainClientTypes.DataIntegrationFlowTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetTarget"].write(value.datasetTarget, with: SupplyChainClientTypes.DataIntegrationFlowDatasetTargetConfiguration.write(value:to:))
        try writer["s3Target"].write(value.s3Target, with: SupplyChainClientTypes.DataIntegrationFlowS3TargetConfiguration.write(value:to:))
        try writer["targetType"].write(value.targetType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationFlowTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationFlowTarget()
        value.targetType = try reader["targetType"].readIfPresent() ?? .sdkUnknown("")
        value.s3Target = try reader["s3Target"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationFlowS3TargetConfiguration.read(from:))
        value.datasetTarget = try reader["datasetTarget"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationFlowDatasetTargetConfiguration.read(from:))
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationFlowDatasetTargetConfiguration {

    static func write(value: SupplyChainClientTypes.DataIntegrationFlowDatasetTargetConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetIdentifier"].write(value.datasetIdentifier)
        try writer["options"].write(value.options, with: SupplyChainClientTypes.DataIntegrationFlowDatasetOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationFlowDatasetTargetConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationFlowDatasetTargetConfiguration()
        value.datasetIdentifier = try reader["datasetIdentifier"].readIfPresent() ?? ""
        value.options = try reader["options"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationFlowDatasetOptions.read(from:))
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationFlowDatasetOptions {

    static func write(value: SupplyChainClientTypes.DataIntegrationFlowDatasetOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dedupeRecords"].write(value.dedupeRecords)
        try writer["dedupeStrategy"].write(value.dedupeStrategy, with: SupplyChainClientTypes.DataIntegrationFlowDedupeStrategy.write(value:to:))
        try writer["loadType"].write(value.loadType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationFlowDatasetOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationFlowDatasetOptions()
        value.loadType = try reader["loadType"].readIfPresent()
        value.dedupeRecords = try reader["dedupeRecords"].readIfPresent()
        value.dedupeStrategy = try reader["dedupeStrategy"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationFlowDedupeStrategy.read(from:))
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationFlowDedupeStrategy {

    static func write(value: SupplyChainClientTypes.DataIntegrationFlowDedupeStrategy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fieldPriority"].write(value.fieldPriority, with: SupplyChainClientTypes.DataIntegrationFlowFieldPriorityDedupeStrategyConfiguration.write(value:to:))
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationFlowDedupeStrategy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationFlowDedupeStrategy()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.fieldPriority = try reader["fieldPriority"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationFlowFieldPriorityDedupeStrategyConfiguration.read(from:))
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationFlowFieldPriorityDedupeStrategyConfiguration {

    static func write(value: SupplyChainClientTypes.DataIntegrationFlowFieldPriorityDedupeStrategyConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fields"].writeList(value.fields, memberWritingClosure: SupplyChainClientTypes.DataIntegrationFlowFieldPriorityDedupeField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationFlowFieldPriorityDedupeStrategyConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationFlowFieldPriorityDedupeStrategyConfiguration()
        value.fields = try reader["fields"].readListIfPresent(memberReadingClosure: SupplyChainClientTypes.DataIntegrationFlowFieldPriorityDedupeField.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationFlowFieldPriorityDedupeField {

    static func write(value: SupplyChainClientTypes.DataIntegrationFlowFieldPriorityDedupeField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["sortOrder"].write(value.sortOrder)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationFlowFieldPriorityDedupeField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationFlowFieldPriorityDedupeField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.sortOrder = try reader["sortOrder"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationFlowS3TargetConfiguration {

    static func write(value: SupplyChainClientTypes.DataIntegrationFlowS3TargetConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["options"].write(value.options, with: SupplyChainClientTypes.DataIntegrationFlowS3Options.write(value:to:))
        try writer["prefix"].write(value.`prefix`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationFlowS3TargetConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationFlowS3TargetConfiguration()
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        value.`prefix` = try reader["prefix"].readIfPresent() ?? ""
        value.options = try reader["options"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationFlowS3Options.read(from:))
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationFlowS3Options {

    static func write(value: SupplyChainClientTypes.DataIntegrationFlowS3Options?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fileType"].write(value.fileType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationFlowS3Options {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationFlowS3Options()
        value.fileType = try reader["fileType"].readIfPresent()
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationFlowTransformation {

    static func write(value: SupplyChainClientTypes.DataIntegrationFlowTransformation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sqlTransformation"].write(value.sqlTransformation, with: SupplyChainClientTypes.DataIntegrationFlowSQLTransformationConfiguration.write(value:to:))
        try writer["transformationType"].write(value.transformationType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationFlowTransformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationFlowTransformation()
        value.transformationType = try reader["transformationType"].readIfPresent() ?? .sdkUnknown("")
        value.sqlTransformation = try reader["sqlTransformation"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationFlowSQLTransformationConfiguration.read(from:))
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationFlowSQLTransformationConfiguration {

    static func write(value: SupplyChainClientTypes.DataIntegrationFlowSQLTransformationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["query"].write(value.query)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationFlowSQLTransformationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationFlowSQLTransformationConfiguration()
        value.query = try reader["query"].readIfPresent() ?? ""
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationFlowSource {

    static func write(value: SupplyChainClientTypes.DataIntegrationFlowSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetSource"].write(value.datasetSource, with: SupplyChainClientTypes.DataIntegrationFlowDatasetSourceConfiguration.write(value:to:))
        try writer["s3Source"].write(value.s3Source, with: SupplyChainClientTypes.DataIntegrationFlowS3SourceConfiguration.write(value:to:))
        try writer["sourceName"].write(value.sourceName)
        try writer["sourceType"].write(value.sourceType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationFlowSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationFlowSource()
        value.sourceType = try reader["sourceType"].readIfPresent() ?? .sdkUnknown("")
        value.sourceName = try reader["sourceName"].readIfPresent() ?? ""
        value.s3Source = try reader["s3Source"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationFlowS3SourceConfiguration.read(from:))
        value.datasetSource = try reader["datasetSource"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationFlowDatasetSourceConfiguration.read(from:))
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationFlowDatasetSourceConfiguration {

    static func write(value: SupplyChainClientTypes.DataIntegrationFlowDatasetSourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetIdentifier"].write(value.datasetIdentifier)
        try writer["options"].write(value.options, with: SupplyChainClientTypes.DataIntegrationFlowDatasetOptions.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationFlowDatasetSourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationFlowDatasetSourceConfiguration()
        value.datasetIdentifier = try reader["datasetIdentifier"].readIfPresent() ?? ""
        value.options = try reader["options"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationFlowDatasetOptions.read(from:))
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationFlowS3SourceConfiguration {

    static func write(value: SupplyChainClientTypes.DataIntegrationFlowS3SourceConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucketName"].write(value.bucketName)
        try writer["options"].write(value.options, with: SupplyChainClientTypes.DataIntegrationFlowS3Options.write(value:to:))
        try writer["prefix"].write(value.`prefix`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationFlowS3SourceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationFlowS3SourceConfiguration()
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        value.`prefix` = try reader["prefix"].readIfPresent() ?? ""
        value.options = try reader["options"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationFlowS3Options.read(from:))
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationFlowExecution {

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationFlowExecution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationFlowExecution()
        value.instanceId = try reader["instanceId"].readIfPresent() ?? ""
        value.flowName = try reader["flowName"].readIfPresent() ?? ""
        value.executionId = try reader["executionId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent()
        value.sourceInfo = try reader["sourceInfo"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationFlowExecutionSourceInfo.read(from:))
        value.message = try reader["message"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.outputMetadata = try reader["outputMetadata"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationFlowExecutionOutputMetadata.read(from:))
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationFlowExecutionOutputMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationFlowExecutionOutputMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationFlowExecutionOutputMetadata()
        value.diagnosticReportsRootS3URI = try reader["diagnosticReportsRootS3URI"].readIfPresent()
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationFlowExecutionSourceInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationFlowExecutionSourceInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationFlowExecutionSourceInfo()
        value.sourceType = try reader["sourceType"].readIfPresent() ?? .sdkUnknown("")
        value.s3Source = try reader["s3Source"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationFlowS3Source.read(from:))
        value.datasetSource = try reader["datasetSource"].readIfPresent(with: SupplyChainClientTypes.DataIntegrationFlowDatasetSource.read(from:))
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationFlowDatasetSource {

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationFlowDatasetSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationFlowDatasetSource()
        value.datasetIdentifier = try reader["datasetIdentifier"].readIfPresent() ?? ""
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationFlowS3Source {

    static func read(from reader: SmithyJSON.Reader) throws -> SupplyChainClientTypes.DataIntegrationFlowS3Source {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SupplyChainClientTypes.DataIntegrationFlowS3Source()
        value.bucketName = try reader["bucketName"].readIfPresent() ?? ""
        value.key = try reader["key"].readIfPresent() ?? ""
        return value
    }
}

extension SupplyChainClientTypes.DataIntegrationEventDatasetTargetConfiguration {

    static func write(value: SupplyChainClientTypes.DataIntegrationEventDatasetTargetConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["datasetIdentifier"].write(value.datasetIdentifier)
        try writer["operationType"].write(value.operationType)
    }
}

public enum SupplyChainClientTypes {}
