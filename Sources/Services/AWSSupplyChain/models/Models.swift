// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have the required privileges to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SupplyChainClientTypes.BillOfMaterialsImportJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceId
        case jobId
        case message
        case s3uri
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let jobId = self.jobId {
            try encodeContainer.encode(jobId, forKey: .jobId)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let s3uri = self.s3uri {
            try encodeContainer.encode(s3uri, forKey: .s3uri)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SupplyChainClientTypes.ConfigurationJobStatus.self, forKey: .status)
        status = statusDecoded
        let s3uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3uri)
        s3uri = s3uriDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SupplyChainClientTypes {
    /// The BillOfMaterialsImportJob details.
    public struct BillOfMaterialsImportJob: Swift.Equatable {
        /// The BillOfMaterialsImportJob instanceId.
        /// This member is required.
        public var instanceId: Swift.String?
        /// The BillOfMaterialsImportJob jobId.
        /// This member is required.
        public var jobId: Swift.String?
        /// When the BillOfMaterialsImportJob has reached a terminal state, there will be a message.
        public var message: Swift.String?
        /// The S3 URI from which the CSV is read.
        /// This member is required.
        public var s3uri: Swift.String?
        /// The BillOfMaterialsImportJob ConfigurationJobStatus.
        /// This member is required.
        public var status: SupplyChainClientTypes.ConfigurationJobStatus?

        public init(
            instanceId: Swift.String? = nil,
            jobId: Swift.String? = nil,
            message: Swift.String? = nil,
            s3uri: Swift.String? = nil,
            status: SupplyChainClientTypes.ConfigurationJobStatus? = nil
        )
        {
            self.instanceId = instanceId
            self.jobId = jobId
            self.message = message
            self.s3uri = s3uri
            self.status = status
        }
    }

}

extension SupplyChainClientTypes {
    /// The status of the job.
    public enum ConfigurationJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case new
        case queued
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationJobStatus] {
            return [
                .failed,
                .inProgress,
                .new,
                .queued,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .new: return "NEW"
            case .queued: return "QUEUED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationJobStatus(rawValue: rawValue) ?? ConfigurationJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateBillOfMaterialsImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case s3uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let s3uri = self.s3uri {
            try encodeContainer.encode(s3uri, forKey: .s3uri)
        }
    }
}

extension CreateBillOfMaterialsImportJobInput {

    static func urlPathProvider(_ value: CreateBillOfMaterialsImportJobInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/api/configuration/instances/\(instanceId.urlPercentEncoding())/bill-of-materials-import-jobs"
    }
}

/// The request parameters for CreateBillOfMaterialsImportJob.
public struct CreateBillOfMaterialsImportJobInput: Swift.Equatable {
    /// An idempotency token.
    public var clientToken: Swift.String?
    /// The AWS Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The S3 URI of the CSV file to be imported. The bucket must grant permissions for AWS Supply Chain to read the file.
    /// This member is required.
    public var s3uri: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        instanceId: Swift.String? = nil,
        s3uri: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.instanceId = instanceId
        self.s3uri = s3uri
    }
}

struct CreateBillOfMaterialsImportJobInputBody: Swift.Equatable {
    let s3uri: Swift.String?
    let clientToken: Swift.String?
}

extension CreateBillOfMaterialsImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case s3uri
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3uri)
        s3uri = s3uriDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateBillOfMaterialsImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBillOfMaterialsImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
        } else {
            self.jobId = nil
        }
    }
}

/// The response parameters of CreateBillOfMaterialsImportJob.
public struct CreateBillOfMaterialsImportJobOutput: Swift.Equatable {
    /// The new BillOfMaterialsImportJob identifier.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct CreateBillOfMaterialsImportJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
}

extension CreateBillOfMaterialsImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
    }
}

enum CreateBillOfMaterialsImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await SupplyChainClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SupplyChainClientTypes {
    public enum DataIntegrationEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case forecast
        case inboundOrder
        case inboundOrderLine
        case inboundOrderLineSchedule
        case inventoryLevel
        case outboundOrderLine
        case outboundShipment
        case processHeader
        case processOperation
        case processProduct
        case reservation
        case shipment
        case shipmentStop
        case shipmentStopOrder
        case supplyPlan
        case sdkUnknown(Swift.String)

        public static var allCases: [DataIntegrationEventType] {
            return [
                .forecast,
                .inboundOrder,
                .inboundOrderLine,
                .inboundOrderLineSchedule,
                .inventoryLevel,
                .outboundOrderLine,
                .outboundShipment,
                .processHeader,
                .processOperation,
                .processProduct,
                .reservation,
                .shipment,
                .shipmentStop,
                .shipmentStopOrder,
                .supplyPlan,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .forecast: return "scn.data.forecast"
            case .inboundOrder: return "scn.data.inboundorder"
            case .inboundOrderLine: return "scn.data.inboundorderline"
            case .inboundOrderLineSchedule: return "scn.data.inboundorderlineschedule"
            case .inventoryLevel: return "scn.data.inventorylevel"
            case .outboundOrderLine: return "scn.data.outboundorderline"
            case .outboundShipment: return "scn.data.outboundshipment"
            case .processHeader: return "scn.data.processheader"
            case .processOperation: return "scn.data.processoperation"
            case .processProduct: return "scn.data.processproduct"
            case .reservation: return "scn.data.reservation"
            case .shipment: return "scn.data.shipment"
            case .shipmentStop: return "scn.data.shipmentstop"
            case .shipmentStopOrder: return "scn.data.shipmentstoporder"
            case .supplyPlan: return "scn.data.supplyplan"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataIntegrationEventType(rawValue: rawValue) ?? DataIntegrationEventType.sdkUnknown(rawValue)
        }
    }
}

extension SupplyChainClientTypes {
    static func makeServiceError(_ httpResponse: ClientRuntime.HttpResponse, _ decoder: ClientRuntime.ResponseDecoder? = nil, _ error: AWSClientRuntime.RestJSONError, _ id: String?) async throws -> Swift.Error? {
        switch error.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: error.errorMessage, requestID: id)
            default: return nil
        }
    }
}

extension GetBillOfMaterialsImportJobInput {

    static func urlPathProvider(_ value: GetBillOfMaterialsImportJobInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        guard let jobId = value.jobId else {
            return nil
        }
        return "/api/configuration/instances/\(instanceId.urlPercentEncoding())/bill-of-materials-import-jobs/\(jobId.urlPercentEncoding())"
    }
}

/// The request parameters for GetBillOfMaterialsImportJob.
public struct GetBillOfMaterialsImportJobInput: Swift.Equatable {
    /// The AWS Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?
    /// The BillOfMaterialsImportJob identifier.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        instanceId: Swift.String? = nil,
        jobId: Swift.String? = nil
    )
    {
        self.instanceId = instanceId
        self.jobId = jobId
    }
}

struct GetBillOfMaterialsImportJobInputBody: Swift.Equatable {
}

extension GetBillOfMaterialsImportJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBillOfMaterialsImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBillOfMaterialsImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

/// The response parameters for GetBillOfMaterialsImportJob.
public struct GetBillOfMaterialsImportJobOutput: Swift.Equatable {
    /// The BillOfMaterialsImportJob.
    /// This member is required.
    public var job: SupplyChainClientTypes.BillOfMaterialsImportJob?

    public init(
        job: SupplyChainClientTypes.BillOfMaterialsImportJob? = nil
    )
    {
        self.job = job
    }
}

struct GetBillOfMaterialsImportJobOutputBody: Swift.Equatable {
    let job: SupplyChainClientTypes.BillOfMaterialsImportJob?
}

extension GetBillOfMaterialsImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(SupplyChainClientTypes.BillOfMaterialsImportJob.self, forKey: .job)
        job = jobDecoded
    }
}

enum GetBillOfMaterialsImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await SupplyChainClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Unexpected error during processing of request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request references a resource which does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SendDataIntegrationEventInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SendDataIntegrationEventInput(clientToken: \(Swift.String(describing: clientToken)), eventGroupId: \(Swift.String(describing: eventGroupId)), eventTimestamp: \(Swift.String(describing: eventTimestamp)), eventType: \(Swift.String(describing: eventType)), instanceId: \(Swift.String(describing: instanceId)), data: \"CONTENT_REDACTED\")"}
}

extension SendDataIntegrationEventInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case data
        case eventGroupId
        case eventTimestamp
        case eventType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let data = self.data {
            try encodeContainer.encode(data, forKey: .data)
        }
        if let eventGroupId = self.eventGroupId {
            try encodeContainer.encode(eventGroupId, forKey: .eventGroupId)
        }
        if let eventTimestamp = self.eventTimestamp {
            try encodeContainer.encodeTimestamp(eventTimestamp, format: .epochSeconds, forKey: .eventTimestamp)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
    }
}

extension SendDataIntegrationEventInput {

    static func urlPathProvider(_ value: SendDataIntegrationEventInput) -> Swift.String? {
        guard let instanceId = value.instanceId else {
            return nil
        }
        return "/api-data/data-integration/instance/\(instanceId.urlPercentEncoding())/data-integration-events"
    }
}

/// The request parameters for SendDataIntegrationEvent.
public struct SendDataIntegrationEventInput: Swift.Equatable {
    /// The idempotent client token.
    public var clientToken: Swift.String?
    /// The data payload of the event.
    /// This member is required.
    public var data: Swift.String?
    /// Event identifier (for example, orderId for InboundOrder) used for data sharing or partitioning.
    /// This member is required.
    public var eventGroupId: Swift.String?
    /// The event timestamp (in epoch seconds).
    public var eventTimestamp: ClientRuntime.Date?
    /// The data event type.
    /// This member is required.
    public var eventType: SupplyChainClientTypes.DataIntegrationEventType?
    /// The AWS Supply Chain instance identifier.
    /// This member is required.
    public var instanceId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        data: Swift.String? = nil,
        eventGroupId: Swift.String? = nil,
        eventTimestamp: ClientRuntime.Date? = nil,
        eventType: SupplyChainClientTypes.DataIntegrationEventType? = nil,
        instanceId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.data = data
        self.eventGroupId = eventGroupId
        self.eventTimestamp = eventTimestamp
        self.eventType = eventType
        self.instanceId = instanceId
    }
}

struct SendDataIntegrationEventInputBody: Swift.Equatable {
    let eventType: SupplyChainClientTypes.DataIntegrationEventType?
    let data: Swift.String?
    let eventGroupId: Swift.String?
    let eventTimestamp: ClientRuntime.Date?
    let clientToken: Swift.String?
}

extension SendDataIntegrationEventInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case data
        case eventGroupId
        case eventTimestamp
        case eventType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeDecoded = try containerValues.decodeIfPresent(SupplyChainClientTypes.DataIntegrationEventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let dataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .data)
        data = dataDecoded
        let eventGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventGroupId)
        eventGroupId = eventGroupIdDecoded
        let eventTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .eventTimestamp)
        eventTimestamp = eventTimestampDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension SendDataIntegrationEventOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SendDataIntegrationEventOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventId = output.eventId
        } else {
            self.eventId = nil
        }
    }
}

/// The response parameters for SendDataIntegrationEvent.
public struct SendDataIntegrationEventOutput: Swift.Equatable {
    /// The unique event identifier.
    /// This member is required.
    public var eventId: Swift.String?

    public init(
        eventId: Swift.String? = nil
    )
    {
        self.eventId = eventId
    }
}

struct SendDataIntegrationEventOutputBody: Swift.Equatable {
    let eventId: Swift.String?
}

extension SendDataIntegrationEventOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventId)
        eventId = eventIdDecoded
    }
}

enum SendDataIntegrationEventOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        let serviceError = try await SupplyChainClientTypes.makeServiceError(httpResponse, decoder, restJSONError, requestID)
        if let error = serviceError { return error }
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public enum SupplyChainClientTypes {}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input does not satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
