//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

extension SSMContactsClientTypes {

    public enum AcceptCodeValidation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enforce
        case ignore
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceptCodeValidation] {
            return [
                .enforce,
                .ignore
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enforce: return "ENFORCE"
            case .ignore: return "IGNORE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// You don't have sufficient access to perform this operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Unexpected error occurred while processing the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// Request references a resource that doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Hypothetical resource identifier that was not found
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Hypothetical resource type that was not found
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Service Quotas requirement to identify originating service
        public internal(set) var quotaCode: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried
        public internal(set) var retryAfterSeconds: Swift.Int = 0
        /// Service Quotas requirement to identify originating quota
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension SSMContactsClientTypes {
    /// Provides information about which field caused the exception.
    public struct ValidationExceptionField {
        /// Information about what caused the field to cause an exception.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that caused the exception.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension SSMContactsClientTypes {

    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The fields that caused the error
        public internal(set) var fields: [SSMContactsClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Reason the request failed validation
        public internal(set) var reason: SSMContactsClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [SSMContactsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: SSMContactsClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension SSMContactsClientTypes {

    public enum AcceptType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case delivered
        case read
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceptType] {
            return [
                .delivered,
                .read
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .delivered: return "DELIVERED"
            case .read: return "READ"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AcceptPageInput {
    /// A 6-digit code used to acknowledge the page.
    /// This member is required.
    public var acceptCode: Swift.String?
    /// An optional field that Incident Manager uses to ENFORCEAcceptCode validation when acknowledging an page. Acknowledgement can occur by replying to a page, or when entering the AcceptCode in the console. Enforcing AcceptCode validation causes Incident Manager to verify that the code entered by the user matches the code sent by Incident Manager with the page. Incident Manager can also IGNOREAcceptCode validation. Ignoring AcceptCode validation causes Incident Manager to accept any value entered for the AcceptCode.
    public var acceptCodeValidation: SSMContactsClientTypes.AcceptCodeValidation?
    /// The type indicates if the page was DELIVERED or READ.
    /// This member is required.
    public var acceptType: SSMContactsClientTypes.AcceptType?
    /// The ARN of the contact channel.
    public var contactChannelId: Swift.String?
    /// Information provided by the user when the user acknowledges the page.
    public var note: Swift.String?
    /// The Amazon Resource Name (ARN) of the engagement to a contact channel.
    /// This member is required.
    public var pageId: Swift.String?

    public init(
        acceptCode: Swift.String? = nil,
        acceptCodeValidation: SSMContactsClientTypes.AcceptCodeValidation? = nil,
        acceptType: SSMContactsClientTypes.AcceptType? = nil,
        contactChannelId: Swift.String? = nil,
        note: Swift.String? = nil,
        pageId: Swift.String? = nil
    )
    {
        self.acceptCode = acceptCode
        self.acceptCodeValidation = acceptCodeValidation
        self.acceptType = acceptType
        self.contactChannelId = contactChannelId
        self.note = note
        self.pageId = pageId
    }
}

public struct AcceptPageOutput {

    public init() { }
}

public struct ActivateContactChannelInput {
    /// The code sent to the contact channel when it was created in the contact.
    /// This member is required.
    public var activationCode: Swift.String?
    /// The Amazon Resource Name (ARN) of the contact channel.
    /// This member is required.
    public var contactChannelId: Swift.String?

    public init(
        activationCode: Swift.String? = nil,
        contactChannelId: Swift.String? = nil
    )
    {
        self.activationCode = activationCode
        self.contactChannelId = contactChannelId
    }
}

public struct ActivateContactChannelOutput {

    public init() { }
}

extension SSMContactsClientTypes {

    public enum ActivationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activated
        case notActivated
        case sdkUnknown(Swift.String)

        public static var allCases: [ActivationStatus] {
            return [
                .activated,
                .notActivated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .notActivated: return "NOT_ACTIVATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMContactsClientTypes {
    /// Information about the contact channel that Incident Manager uses to engage the contact.
    public struct ChannelTargetInfo {
        /// The Amazon Resource Name (ARN) of the contact channel.
        /// This member is required.
        public var contactChannelId: Swift.String?
        /// The number of minutes to wait to retry sending engagement in the case the engagement initially fails.
        public var retryIntervalInMinutes: Swift.Int?

        public init(
            contactChannelId: Swift.String? = nil,
            retryIntervalInMinutes: Swift.Int? = nil
        )
        {
            self.contactChannelId = contactChannelId
            self.retryIntervalInMinutes = retryIntervalInMinutes
        }
    }

}

extension SSMContactsClientTypes {

    public enum ChannelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case email
        case sms
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelType] {
            return [
                .email,
                .sms,
                .voice
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case .sms: return "SMS"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMContactsClientTypes {
    /// Information about a resource that another resource is related to or depends on. For example, if a contact is a member of a rotation, the rotation is a dependent entity of the contact.
    public struct DependentEntity {
        /// The Amazon Resource Names (ARNs) of the dependent resources.
        /// This member is required.
        public var dependentResourceIds: [Swift.String]?
        /// The type of relationship between one resource and the other resource that it is related to or depends on.
        /// This member is required.
        public var relationType: Swift.String?

        public init(
            dependentResourceIds: [Swift.String]? = nil,
            relationType: Swift.String? = nil
        )
        {
            self.dependentResourceIds = dependentResourceIds
            self.relationType = relationType
        }
    }

}

/// Updating or deleting a resource causes an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// List of dependent entities containing information on relation type and resourceArns linked to the resource in use
        public internal(set) var dependentEntities: [SSMContactsClientTypes.DependentEntity]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource in use
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource in use
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        dependentEntities: [SSMContactsClientTypes.DependentEntity]? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.dependentEntities = dependentEntities
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

extension SSMContactsClientTypes {

    public enum ContactType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case escalation
        case oncallSchedule
        case personal
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactType] {
            return [
                .escalation,
                .oncallSchedule,
                .personal
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .escalation: return "ESCALATION"
            case .oncallSchedule: return "ONCALL_SCHEDULE"
            case .personal: return "PERSONAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMContactsClientTypes {
    /// A personal contact or escalation plan that Incident Manager engages during an incident.
    public struct Contact {
        /// The unique and identifiable alias of the contact or escalation plan.
        /// This member is required.
        public var alias: Swift.String?
        /// The Amazon Resource Name (ARN) of the contact or escalation plan.
        /// This member is required.
        public var contactArn: Swift.String?
        /// The full name of the contact or escalation plan.
        public var displayName: Swift.String?
        /// Refers to the type of contact. A single contact is type PERSONAL and an escalation plan is type ESCALATION.
        /// This member is required.
        public var type: SSMContactsClientTypes.ContactType?

        public init(
            alias: Swift.String? = nil,
            contactArn: Swift.String? = nil,
            displayName: Swift.String? = nil,
            type: SSMContactsClientTypes.ContactType? = nil
        )
        {
            self.alias = alias
            self.contactArn = contactArn
            self.displayName = displayName
            self.type = type
        }
    }

}

extension SSMContactsClientTypes {
    /// The details that Incident Manager uses when trying to engage the contact channel.
    public struct ContactChannelAddress {
        /// The format is dependent on the type of the contact channel. The following are the expected formats:
        ///
        /// * SMS - '+' followed by the country code and phone number
        ///
        /// * VOICE - '+' followed by the country code and phone number
        ///
        /// * EMAIL - any standard email format
        public var simpleAddress: Swift.String?

        public init(
            simpleAddress: Swift.String? = nil
        )
        {
            self.simpleAddress = simpleAddress
        }
    }

}

extension SSMContactsClientTypes {
    /// The method that Incident Manager uses to engage a contact.
    public struct ContactChannel {
        /// A Boolean value describing if the contact channel has been activated or not. If the contact channel isn't activated, Incident Manager can't engage the contact through it.
        /// This member is required.
        public var activationStatus: SSMContactsClientTypes.ActivationStatus?
        /// The ARN of the contact that contains the contact channel.
        /// This member is required.
        public var contactArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the contact channel.
        /// This member is required.
        public var contactChannelArn: Swift.String?
        /// The details that Incident Manager uses when trying to engage the contact channel.
        /// This member is required.
        public var deliveryAddress: SSMContactsClientTypes.ContactChannelAddress?
        /// The name of the contact channel.
        /// This member is required.
        public var name: Swift.String?
        /// The type of the contact channel. Incident Manager supports three contact methods:
        ///
        /// * SMS
        ///
        /// * VOICE
        ///
        /// * EMAIL
        public var type: SSMContactsClientTypes.ChannelType?

        public init(
            activationStatus: SSMContactsClientTypes.ActivationStatus? = nil,
            contactArn: Swift.String? = nil,
            contactChannelArn: Swift.String? = nil,
            deliveryAddress: SSMContactsClientTypes.ContactChannelAddress? = nil,
            name: Swift.String? = nil,
            type: SSMContactsClientTypes.ChannelType? = nil
        )
        {
            self.activationStatus = activationStatus
            self.contactArn = contactArn
            self.contactChannelArn = contactChannelArn
            self.deliveryAddress = deliveryAddress
            self.name = name
            self.type = type
        }
    }

}

extension SSMContactsClientTypes {
    /// The contact that Incident Manager is engaging during an incident.
    public struct ContactTargetInfo {
        /// The Amazon Resource Name (ARN) of the contact.
        public var contactId: Swift.String?
        /// A Boolean value determining if the contact's acknowledgement stops the progress of stages in the plan.
        /// This member is required.
        public var isEssential: Swift.Bool?

        public init(
            contactId: Swift.String? = nil,
            isEssential: Swift.Bool? = nil
        )
        {
            self.contactId = contactId
            self.isEssential = isEssential
        }
    }

}

extension SSMContactsClientTypes {
    /// Details about when an on-call rotation shift begins or ends.
    public struct HandOffTime {
        /// The hour when an on-call rotation shift begins or ends.
        /// This member is required.
        public var hourOfDay: Swift.Int
        /// The minute when an on-call rotation shift begins or ends.
        /// This member is required.
        public var minuteOfHour: Swift.Int

        public init(
            hourOfDay: Swift.Int = 0,
            minuteOfHour: Swift.Int = 0
        )
        {
            self.hourOfDay = hourOfDay
            self.minuteOfHour = minuteOfHour
        }
    }

}

extension SSMContactsClientTypes {
    /// Information about when an on-call shift begins and ends.
    public struct CoverageTime {
        /// Information about when the on-call rotation shift ends.
        public var end: SSMContactsClientTypes.HandOffTime?
        /// Information about when the on-call rotation shift begins.
        public var start: SSMContactsClientTypes.HandOffTime?

        public init(
            end: SSMContactsClientTypes.HandOffTime? = nil,
            start: SSMContactsClientTypes.HandOffTime? = nil
        )
        {
            self.end = end
            self.start = start
        }
    }

}

/// The operation failed to due an encryption key error.
public struct DataEncryptionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DataEncryptionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Service Quotas requirement to identify originating service
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Identifier of the resource affected
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected
        public internal(set) var resourceType: Swift.String? = nil
        /// Service Quotas requirement to identify originating quota
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

extension SSMContactsClientTypes {
    /// The contact or contact channel that's being engaged.
    public struct Target {
        /// Information about the contact channel Incident Manager is engaging.
        public var channelTargetInfo: SSMContactsClientTypes.ChannelTargetInfo?
        /// Information about the contact that Incident Manager is engaging.
        public var contactTargetInfo: SSMContactsClientTypes.ContactTargetInfo?

        public init(
            channelTargetInfo: SSMContactsClientTypes.ChannelTargetInfo? = nil,
            contactTargetInfo: SSMContactsClientTypes.ContactTargetInfo? = nil
        )
        {
            self.channelTargetInfo = channelTargetInfo
            self.contactTargetInfo = contactTargetInfo
        }
    }

}

extension SSMContactsClientTypes {
    /// A set amount of time that an escalation plan or engagement plan engages the specified contacts or contact methods.
    public struct Stage {
        /// The time to wait until beginning the next stage. The duration can only be set to 0 if a target is specified.
        /// This member is required.
        public var durationInMinutes: Swift.Int?
        /// The contacts or contact methods that the escalation plan or engagement plan is engaging.
        /// This member is required.
        public var targets: [SSMContactsClientTypes.Target]?

        public init(
            durationInMinutes: Swift.Int? = nil,
            targets: [SSMContactsClientTypes.Target]? = nil
        )
        {
            self.durationInMinutes = durationInMinutes
            self.targets = targets
        }
    }

}

extension SSMContactsClientTypes {
    /// Information about the stages and on-call rotation teams associated with an escalation plan or engagement plan.
    public struct Plan {
        /// The Amazon Resource Names (ARNs) of the on-call rotations associated with the plan.
        public var rotationIds: [Swift.String]?
        /// A list of stages that the escalation plan or engagement plan uses to engage contacts and contact methods.
        public var stages: [SSMContactsClientTypes.Stage]?

        public init(
            rotationIds: [Swift.String]? = nil,
            stages: [SSMContactsClientTypes.Stage]? = nil
        )
        {
            self.rotationIds = rotationIds
            self.stages = stages
        }
    }

}

extension SSMContactsClientTypes {
    /// A container of a key-value name pair.
    public struct Tag {
        /// Name of the object key.
        public var key: Swift.String?
        /// Value of the tag.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct CreateContactInput {
    /// The short name to quickly identify a contact or escalation plan. The contact alias must be unique and identifiable.
    /// This member is required.
    public var alias: Swift.String?
    /// The full name of the contact or escalation plan.
    public var displayName: Swift.String?
    /// A token ensuring that the operation is called only once with the specified details.
    public var idempotencyToken: Swift.String?
    /// A list of stages. A contact has an engagement plan with stages that contact specified contact channels. An escalation plan uses stages that contact specified contacts.
    /// This member is required.
    public var plan: SSMContactsClientTypes.Plan?
    /// Adds a tag to the target. You can only tag resources created in the first Region of your replication set.
    public var tags: [SSMContactsClientTypes.Tag]?
    /// To create an escalation plan use ESCALATION. To create a contact use PERSONAL.
    /// This member is required.
    public var type: SSMContactsClientTypes.ContactType?

    public init(
        alias: Swift.String? = nil,
        displayName: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        plan: SSMContactsClientTypes.Plan? = nil,
        tags: [SSMContactsClientTypes.Tag]? = nil,
        type: SSMContactsClientTypes.ContactType? = nil
    )
    {
        self.alias = alias
        self.displayName = displayName
        self.idempotencyToken = idempotencyToken
        self.plan = plan
        self.tags = tags
        self.type = type
    }
}

public struct CreateContactOutput {
    /// The Amazon Resource Name (ARN) of the created contact or escalation plan.
    /// This member is required.
    public var contactArn: Swift.String?

    public init(
        contactArn: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

public struct CreateContactChannelInput {
    /// The Amazon Resource Name (ARN) of the contact you are adding the contact channel to.
    /// This member is required.
    public var contactId: Swift.String?
    /// If you want to activate the channel at a later time, you can choose to defer activation. Incident Manager can't engage your contact channel until it has been activated.
    public var deferActivation: Swift.Bool?
    /// The details that Incident Manager uses when trying to engage the contact channel. The format is dependent on the type of the contact channel. The following are the expected formats:
    ///
    /// * SMS - '+' followed by the country code and phone number
    ///
    /// * VOICE - '+' followed by the country code and phone number
    ///
    /// * EMAIL - any standard email format
    /// This member is required.
    public var deliveryAddress: SSMContactsClientTypes.ContactChannelAddress?
    /// A token ensuring that the operation is called only once with the specified details.
    public var idempotencyToken: Swift.String?
    /// The name of the contact channel.
    /// This member is required.
    public var name: Swift.String?
    /// Incident Manager supports three types of contact channels:
    ///
    /// * SMS
    ///
    /// * VOICE
    ///
    /// * EMAIL
    /// This member is required.
    public var type: SSMContactsClientTypes.ChannelType?

    public init(
        contactId: Swift.String? = nil,
        deferActivation: Swift.Bool? = nil,
        deliveryAddress: SSMContactsClientTypes.ContactChannelAddress? = nil,
        idempotencyToken: Swift.String? = nil,
        name: Swift.String? = nil,
        type: SSMContactsClientTypes.ChannelType? = nil
    )
    {
        self.contactId = contactId
        self.deferActivation = deferActivation
        self.deliveryAddress = deliveryAddress
        self.idempotencyToken = idempotencyToken
        self.name = name
        self.type = type
    }
}

public struct CreateContactChannelOutput {
    /// The Amazon Resource Name (ARN) of the contact channel.
    /// This member is required.
    public var contactChannelArn: Swift.String?

    public init(
        contactChannelArn: Swift.String? = nil
    )
    {
        self.contactChannelArn = contactChannelArn
    }
}

extension SSMContactsClientTypes {
    /// Information about on-call rotations that recur monthly.
    public struct MonthlySetting {
        /// The day of the month when monthly recurring on-call rotations begin.
        /// This member is required.
        public var dayOfMonth: Swift.Int?
        /// The time of day when a monthly recurring on-call shift rotation begins.
        /// This member is required.
        public var handOffTime: SSMContactsClientTypes.HandOffTime?

        public init(
            dayOfMonth: Swift.Int? = nil,
            handOffTime: SSMContactsClientTypes.HandOffTime? = nil
        )
        {
            self.dayOfMonth = dayOfMonth
            self.handOffTime = handOffTime
        }
    }

}

extension SSMContactsClientTypes {

    public enum DayOfWeek: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fri
        case mon
        case sat
        case sun
        case thu
        case tue
        case wed
        case sdkUnknown(Swift.String)

        public static var allCases: [DayOfWeek] {
            return [
                .fri,
                .mon,
                .sat,
                .sun,
                .thu,
                .tue,
                .wed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fri: return "FRI"
            case .mon: return "MON"
            case .sat: return "SAT"
            case .sun: return "SUN"
            case .thu: return "THU"
            case .tue: return "TUE"
            case .wed: return "WED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMContactsClientTypes {
    /// Information about rotations that recur weekly.
    public struct WeeklySetting {
        /// The day of the week when weekly recurring on-call shift rotations begins.
        /// This member is required.
        public var dayOfWeek: SSMContactsClientTypes.DayOfWeek?
        /// The time of day when a weekly recurring on-call shift rotation begins.
        /// This member is required.
        public var handOffTime: SSMContactsClientTypes.HandOffTime?

        public init(
            dayOfWeek: SSMContactsClientTypes.DayOfWeek? = nil,
            handOffTime: SSMContactsClientTypes.HandOffTime? = nil
        )
        {
            self.dayOfWeek = dayOfWeek
            self.handOffTime = handOffTime
        }
    }

}

extension SSMContactsClientTypes {
    /// Information about when an on-call rotation is in effect and how long the rotation period lasts.
    public struct RecurrenceSettings {
        /// Information about on-call rotations that recur daily.
        public var dailySettings: [SSMContactsClientTypes.HandOffTime]?
        /// Information about on-call rotations that recur monthly.
        public var monthlySettings: [SSMContactsClientTypes.MonthlySetting]?
        /// The number of contacts, or shift team members designated to be on call concurrently during a shift. For example, in an on-call schedule containing ten contacts, a value of 2 designates that two of them are on call at any given time.
        /// This member is required.
        public var numberOfOnCalls: Swift.Int?
        /// The number of days, weeks, or months a single rotation lasts.
        /// This member is required.
        public var recurrenceMultiplier: Swift.Int?
        /// Information about the days of the week included in on-call rotation coverage.
        public var shiftCoverages: [Swift.String: [SSMContactsClientTypes.CoverageTime]]?
        /// Information about on-call rotations that recur weekly.
        public var weeklySettings: [SSMContactsClientTypes.WeeklySetting]?

        public init(
            dailySettings: [SSMContactsClientTypes.HandOffTime]? = nil,
            monthlySettings: [SSMContactsClientTypes.MonthlySetting]? = nil,
            numberOfOnCalls: Swift.Int? = nil,
            recurrenceMultiplier: Swift.Int? = nil,
            shiftCoverages: [Swift.String: [SSMContactsClientTypes.CoverageTime]]? = nil,
            weeklySettings: [SSMContactsClientTypes.WeeklySetting]? = nil
        )
        {
            self.dailySettings = dailySettings
            self.monthlySettings = monthlySettings
            self.numberOfOnCalls = numberOfOnCalls
            self.recurrenceMultiplier = recurrenceMultiplier
            self.shiftCoverages = shiftCoverages
            self.weeklySettings = weeklySettings
        }
    }

}

public struct CreateRotationInput {
    /// The Amazon Resource Names (ARNs) of the contacts to add to the rotation. The order that you list the contacts in is their shift order in the rotation schedule. To change the order of the contact's shifts, use the [UpdateRotation] operation.
    /// This member is required.
    public var contactIds: [Swift.String]?
    /// A token that ensures that the operation is called only once with the specified details.
    public var idempotencyToken: Swift.String?
    /// The name of the rotation.
    /// This member is required.
    public var name: Swift.String?
    /// Information about the rule that specifies when a shift's team members rotate.
    /// This member is required.
    public var recurrence: SSMContactsClientTypes.RecurrenceSettings?
    /// The date and time that the rotation goes into effect.
    public var startTime: Foundation.Date?
    /// Optional metadata to assign to the rotation. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For more information, see [Tagging Incident Manager resources](https://docs.aws.amazon.com/incident-manager/latest/userguide/tagging.html) in the Incident Manager User Guide.
    public var tags: [SSMContactsClientTypes.Tag]?
    /// The time zone to base the rotation’s activity on in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul". For more information, see the [Time Zone Database](https://www.iana.org/time-zones) on the IANA website. Designators for time zones that don’t support Daylight Savings Time rules, such as Pacific Standard Time (PST) and Pacific Daylight Time (PDT), are not supported.
    /// This member is required.
    public var timeZoneId: Swift.String?

    public init(
        contactIds: [Swift.String]? = nil,
        idempotencyToken: Swift.String? = nil,
        name: Swift.String? = nil,
        recurrence: SSMContactsClientTypes.RecurrenceSettings? = nil,
        startTime: Foundation.Date? = nil,
        tags: [SSMContactsClientTypes.Tag]? = nil,
        timeZoneId: Swift.String? = nil
    )
    {
        self.contactIds = contactIds
        self.idempotencyToken = idempotencyToken
        self.name = name
        self.recurrence = recurrence
        self.startTime = startTime
        self.tags = tags
        self.timeZoneId = timeZoneId
    }
}

public struct CreateRotationOutput {
    /// The Amazon Resource Name (ARN) of the created rotation.
    /// This member is required.
    public var rotationArn: Swift.String?

    public init(
        rotationArn: Swift.String? = nil
    )
    {
        self.rotationArn = rotationArn
    }
}

public struct CreateRotationOverrideInput {
    /// The date and time when the override ends.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// A token that ensures that the operation is called only once with the specified details.
    public var idempotencyToken: Swift.String?
    /// The Amazon Resource Names (ARNs) of the contacts to replace those in the current on-call rotation with. If you want to include any current team members in the override shift, you must include their ARNs in the new contact ID list.
    /// This member is required.
    public var newContactIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the rotation to create an override for.
    /// This member is required.
    public var rotationId: Swift.String?
    /// The date and time when the override goes into effect.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        idempotencyToken: Swift.String? = nil,
        newContactIds: [Swift.String]? = nil,
        rotationId: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.idempotencyToken = idempotencyToken
        self.newContactIds = newContactIds
        self.rotationId = rotationId
        self.startTime = startTime
    }
}

public struct CreateRotationOverrideOutput {
    /// The Amazon Resource Name (ARN) of the created rotation override.
    /// This member is required.
    public var rotationOverrideId: Swift.String?

    public init(
        rotationOverrideId: Swift.String? = nil
    )
    {
        self.rotationOverrideId = rotationOverrideId
    }
}

public struct DeactivateContactChannelInput {
    /// The Amazon Resource Name (ARN) of the contact channel you're deactivating.
    /// This member is required.
    public var contactChannelId: Swift.String?

    public init(
        contactChannelId: Swift.String? = nil
    )
    {
        self.contactChannelId = contactChannelId
    }
}

public struct DeactivateContactChannelOutput {

    public init() { }
}

public struct DeleteContactInput {
    /// The Amazon Resource Name (ARN) of the contact that you're deleting.
    /// This member is required.
    public var contactId: Swift.String?

    public init(
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

public struct DeleteContactOutput {

    public init() { }
}

public struct DeleteContactChannelInput {
    /// The Amazon Resource Name (ARN) of the contact channel.
    /// This member is required.
    public var contactChannelId: Swift.String?

    public init(
        contactChannelId: Swift.String? = nil
    )
    {
        self.contactChannelId = contactChannelId
    }
}

public struct DeleteContactChannelOutput {

    public init() { }
}

public struct DeleteRotationInput {
    /// The Amazon Resource Name (ARN) of the on-call rotation to delete.
    /// This member is required.
    public var rotationId: Swift.String?

    public init(
        rotationId: Swift.String? = nil
    )
    {
        self.rotationId = rotationId
    }
}

public struct DeleteRotationOutput {

    public init() { }
}

public struct DeleteRotationOverrideInput {
    /// The Amazon Resource Name (ARN) of the rotation that was overridden.
    /// This member is required.
    public var rotationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the on-call rotation override to delete.
    /// This member is required.
    public var rotationOverrideId: Swift.String?

    public init(
        rotationId: Swift.String? = nil,
        rotationOverrideId: Swift.String? = nil
    )
    {
        self.rotationId = rotationId
        self.rotationOverrideId = rotationOverrideId
    }
}

public struct DeleteRotationOverrideOutput {

    public init() { }
}

public struct DescribeEngagementInput {
    /// The Amazon Resource Name (ARN) of the engagement you want the details of.
    /// This member is required.
    public var engagementId: Swift.String?

    public init(
        engagementId: Swift.String? = nil
    )
    {
        self.engagementId = engagementId
    }
}

public struct DescribeEngagementOutput {
    /// The ARN of the escalation plan or contacts involved in the engagement.
    /// This member is required.
    public var contactArn: Swift.String?
    /// The secure content of the message that was sent to the contact. Use this field for engagements to VOICE and EMAIL.
    /// This member is required.
    public var content: Swift.String?
    /// The ARN of the engagement.
    /// This member is required.
    public var engagementArn: Swift.String?
    /// The ARN of the incident in which the engagement occurred.
    public var incidentId: Swift.String?
    /// The insecure content of the message that was sent to the contact. Use this field for engagements to SMS.
    public var publicContent: Swift.String?
    /// The insecure subject of the message that was sent to the contact. Use this field for engagements to SMS.
    public var publicSubject: Swift.String?
    /// The user that started the engagement.
    /// This member is required.
    public var sender: Swift.String?
    /// The time that the engagement started.
    public var startTime: Foundation.Date?
    /// The time that the engagement ended.
    public var stopTime: Foundation.Date?
    /// The secure subject of the message that was sent to the contact. Use this field for engagements to VOICE and EMAIL.
    /// This member is required.
    public var subject: Swift.String?

    public init(
        contactArn: Swift.String? = nil,
        content: Swift.String? = nil,
        engagementArn: Swift.String? = nil,
        incidentId: Swift.String? = nil,
        publicContent: Swift.String? = nil,
        publicSubject: Swift.String? = nil,
        sender: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        stopTime: Foundation.Date? = nil,
        subject: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.content = content
        self.engagementArn = engagementArn
        self.incidentId = incidentId
        self.publicContent = publicContent
        self.publicSubject = publicSubject
        self.sender = sender
        self.startTime = startTime
        self.stopTime = stopTime
        self.subject = subject
    }
}

public struct DescribePageInput {
    /// The ID of the engagement to a contact channel.
    /// This member is required.
    public var pageId: Swift.String?

    public init(
        pageId: Swift.String? = nil
    )
    {
        self.pageId = pageId
    }
}

public struct DescribePageOutput {
    /// The ARN of the contact that was engaged.
    /// This member is required.
    public var contactArn: Swift.String?
    /// The secure content of the message that was sent to the contact. Use this field for engagements to VOICE and EMAIL.
    /// This member is required.
    public var content: Swift.String?
    /// The time that the contact channel received the engagement.
    public var deliveryTime: Foundation.Date?
    /// The ARN of the engagement that engaged the contact channel.
    /// This member is required.
    public var engagementArn: Swift.String?
    /// The ARN of the incident that engaged the contact channel.
    public var incidentId: Swift.String?
    /// The Amazon Resource Name (ARN) of the engagement to a contact channel.
    /// This member is required.
    public var pageArn: Swift.String?
    /// The insecure content of the message that was sent to the contact. Use this field for engagements to SMS.
    public var publicContent: Swift.String?
    /// The insecure subject of the message that was sent to the contact. Use this field for engagements to SMS.
    public var publicSubject: Swift.String?
    /// The time that the contact channel acknowledged the engagement.
    public var readTime: Foundation.Date?
    /// The user that started the engagement.
    /// This member is required.
    public var sender: Swift.String?
    /// The time the engagement was sent to the contact channel.
    public var sentTime: Foundation.Date?
    /// The secure subject of the message that was sent to the contact. Use this field for engagements to VOICE and EMAIL.
    /// This member is required.
    public var subject: Swift.String?

    public init(
        contactArn: Swift.String? = nil,
        content: Swift.String? = nil,
        deliveryTime: Foundation.Date? = nil,
        engagementArn: Swift.String? = nil,
        incidentId: Swift.String? = nil,
        pageArn: Swift.String? = nil,
        publicContent: Swift.String? = nil,
        publicSubject: Swift.String? = nil,
        readTime: Foundation.Date? = nil,
        sender: Swift.String? = nil,
        sentTime: Foundation.Date? = nil,
        subject: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.content = content
        self.deliveryTime = deliveryTime
        self.engagementArn = engagementArn
        self.incidentId = incidentId
        self.pageArn = pageArn
        self.publicContent = publicContent
        self.publicSubject = publicSubject
        self.readTime = readTime
        self.sender = sender
        self.sentTime = sentTime
        self.subject = subject
    }
}

extension SSMContactsClientTypes {
    /// Incident Manager reaching out to a contact or escalation plan to engage contact during an incident.
    public struct Engagement {
        /// The ARN of the escalation plan or contact that Incident Manager is engaging.
        /// This member is required.
        public var contactArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the engagement.
        /// This member is required.
        public var engagementArn: Swift.String?
        /// The ARN of the incident that's engaging the contact.
        public var incidentId: Swift.String?
        /// The user that started the engagement.
        /// This member is required.
        public var sender: Swift.String?
        /// The time that the engagement began.
        public var startTime: Foundation.Date?
        /// The time that the engagement ended.
        public var stopTime: Foundation.Date?

        public init(
            contactArn: Swift.String? = nil,
            engagementArn: Swift.String? = nil,
            incidentId: Swift.String? = nil,
            sender: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            stopTime: Foundation.Date? = nil
        )
        {
            self.contactArn = contactArn
            self.engagementArn = engagementArn
            self.incidentId = incidentId
            self.sender = sender
            self.startTime = startTime
            self.stopTime = stopTime
        }
    }

}

public struct GetContactInput {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public var contactId: Swift.String?

    public init(
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

public struct GetContactOutput {
    /// The alias of the contact or escalation plan. The alias is unique and identifiable.
    /// This member is required.
    public var alias: Swift.String?
    /// The ARN of the contact or escalation plan.
    /// This member is required.
    public var contactArn: Swift.String?
    /// The full name of the contact or escalation plan.
    public var displayName: Swift.String?
    /// Details about the specific timing or stages and targets of the escalation plan or engagement plan.
    /// This member is required.
    public var plan: SSMContactsClientTypes.Plan?
    /// The type of contact, either PERSONAL or ESCALATION.
    /// This member is required.
    public var type: SSMContactsClientTypes.ContactType?

    public init(
        alias: Swift.String? = nil,
        contactArn: Swift.String? = nil,
        displayName: Swift.String? = nil,
        plan: SSMContactsClientTypes.Plan? = nil,
        type: SSMContactsClientTypes.ContactType? = nil
    )
    {
        self.alias = alias
        self.contactArn = contactArn
        self.displayName = displayName
        self.plan = plan
        self.type = type
    }
}

public struct GetContactChannelInput {
    /// The Amazon Resource Name (ARN) of the contact channel you want information about.
    /// This member is required.
    public var contactChannelId: Swift.String?

    public init(
        contactChannelId: Swift.String? = nil
    )
    {
        self.contactChannelId = contactChannelId
    }
}

public struct GetContactChannelOutput {
    /// A Boolean value indicating if the contact channel has been activated or not.
    public var activationStatus: SSMContactsClientTypes.ActivationStatus?
    /// The ARN of the contact that the channel belongs to.
    /// This member is required.
    public var contactArn: Swift.String?
    /// The ARN of the contact channel.
    /// This member is required.
    public var contactChannelArn: Swift.String?
    /// The details that Incident Manager uses when trying to engage the contact channel.
    /// This member is required.
    public var deliveryAddress: SSMContactsClientTypes.ContactChannelAddress?
    /// The name of the contact channel
    /// This member is required.
    public var name: Swift.String?
    /// The type of contact channel. The type is SMS, VOICE, or EMAIL.
    /// This member is required.
    public var type: SSMContactsClientTypes.ChannelType?

    public init(
        activationStatus: SSMContactsClientTypes.ActivationStatus? = nil,
        contactArn: Swift.String? = nil,
        contactChannelArn: Swift.String? = nil,
        deliveryAddress: SSMContactsClientTypes.ContactChannelAddress? = nil,
        name: Swift.String? = nil,
        type: SSMContactsClientTypes.ChannelType? = nil
    )
    {
        self.activationStatus = activationStatus
        self.contactArn = contactArn
        self.contactChannelArn = contactChannelArn
        self.deliveryAddress = deliveryAddress
        self.name = name
        self.type = type
    }
}

public struct GetContactPolicyInput {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public var contactArn: Swift.String?

    public init(
        contactArn: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

public struct GetContactPolicyOutput {
    /// The ARN of the contact or escalation plan.
    public var contactArn: Swift.String?
    /// Details about the resource policy attached to the contact or escalation plan.
    public var policy: Swift.String?

    public init(
        contactArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.policy = policy
    }
}

public struct GetRotationInput {
    /// The Amazon Resource Name (ARN) of the on-call rotation to retrieve information about.
    /// This member is required.
    public var rotationId: Swift.String?

    public init(
        rotationId: Swift.String? = nil
    )
    {
        self.rotationId = rotationId
    }
}

public struct GetRotationOutput {
    /// The Amazon Resource Names (ARNs) of the contacts assigned to the on-call rotation team.
    /// This member is required.
    public var contactIds: [Swift.String]?
    /// The name of the on-call rotation.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies how long a rotation lasts before restarting at the beginning of the shift order.
    /// This member is required.
    public var recurrence: SSMContactsClientTypes.RecurrenceSettings?
    /// The Amazon Resource Name (ARN) of the on-call rotation.
    /// This member is required.
    public var rotationArn: Swift.String?
    /// The specified start time for the on-call rotation.
    /// This member is required.
    public var startTime: Foundation.Date?
    /// The time zone that the rotation’s activity is based on, in Internet Assigned Numbers Authority (IANA) format.
    /// This member is required.
    public var timeZoneId: Swift.String?

    public init(
        contactIds: [Swift.String]? = nil,
        name: Swift.String? = nil,
        recurrence: SSMContactsClientTypes.RecurrenceSettings? = nil,
        rotationArn: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        timeZoneId: Swift.String? = nil
    )
    {
        self.contactIds = contactIds
        self.name = name
        self.recurrence = recurrence
        self.rotationArn = rotationArn
        self.startTime = startTime
        self.timeZoneId = timeZoneId
    }
}

public struct GetRotationOverrideInput {
    /// The Amazon Resource Name (ARN) of the overridden rotation to retrieve information about.
    /// This member is required.
    public var rotationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the on-call rotation override to retrieve information about.
    /// This member is required.
    public var rotationOverrideId: Swift.String?

    public init(
        rotationId: Swift.String? = nil,
        rotationOverrideId: Swift.String? = nil
    )
    {
        self.rotationId = rotationId
        self.rotationOverrideId = rotationOverrideId
    }
}

public struct GetRotationOverrideOutput {
    /// The date and time when the override was created.
    public var createTime: Foundation.Date?
    /// The date and time when the override ends.
    public var endTime: Foundation.Date?
    /// The Amazon Resource Names (ARNs) of the contacts assigned to the override of the on-call rotation.
    public var newContactIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the on-call rotation that was overridden.
    public var rotationArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the override to an on-call rotation.
    public var rotationOverrideId: Swift.String?
    /// The date and time when the override goes into effect.
    public var startTime: Foundation.Date?

    public init(
        createTime: Foundation.Date? = nil,
        endTime: Foundation.Date? = nil,
        newContactIds: [Swift.String]? = nil,
        rotationArn: Swift.String? = nil,
        rotationOverrideId: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.createTime = createTime
        self.endTime = endTime
        self.newContactIds = newContactIds
        self.rotationArn = rotationArn
        self.rotationOverrideId = rotationOverrideId
        self.startTime = startTime
    }
}

public struct ListContactChannelsInput {
    /// The Amazon Resource Name (ARN) of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The maximum number of contact channels per page.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListContactChannelsOutput {
    /// A list of contact channels related to the specified contact.
    /// This member is required.
    public var contactChannels: [SSMContactsClientTypes.ContactChannel]?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init(
        contactChannels: [SSMContactsClientTypes.ContactChannel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactChannels = contactChannels
        self.nextToken = nextToken
    }
}

public struct ListContactsInput {
    /// Used to list only contacts who's aliases start with the specified prefix.
    public var aliasPrefix: Swift.String?
    /// The maximum number of contacts and escalation plans per page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// The type of contact. A contact is type PERSONAL and an escalation plan is type ESCALATION.
    public var type: SSMContactsClientTypes.ContactType?

    public init(
        aliasPrefix: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: SSMContactsClientTypes.ContactType? = nil
    )
    {
        self.aliasPrefix = aliasPrefix
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

public struct ListContactsOutput {
    /// A list of the contacts and escalation plans in your Incident Manager account.
    public var contacts: [SSMContactsClientTypes.Contact]?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init(
        contacts: [SSMContactsClientTypes.Contact]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contacts = contacts
        self.nextToken = nextToken
    }
}

extension SSMContactsClientTypes {
    /// A range of between two set times
    public struct TimeRange {
        /// The end of the time range.
        public var endTime: Foundation.Date?
        /// The start of the time range.
        public var startTime: Foundation.Date?

        public init(
            endTime: Foundation.Date? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

public struct ListEngagementsInput {
    /// The Amazon Resource Name (ARN) of the incident you're listing engagements for.
    public var incidentId: Swift.String?
    /// The maximum number of engagements per page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// The time range to lists engagements for an incident.
    public var timeRangeValue: SSMContactsClientTypes.TimeRange?

    public init(
        incidentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        timeRangeValue: SSMContactsClientTypes.TimeRange? = nil
    )
    {
        self.incidentId = incidentId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timeRangeValue = timeRangeValue
    }
}

public struct ListEngagementsOutput {
    /// A list of each engagement that occurred during the specified time range of an incident.
    /// This member is required.
    public var engagements: [SSMContactsClientTypes.Engagement]?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init(
        engagements: [SSMContactsClientTypes.Engagement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engagements = engagements
        self.nextToken = nextToken
    }
}

public struct ListPageReceiptsInput {
    /// The maximum number of acknowledgements per page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the engagement to a specific contact channel.
    /// This member is required.
    public var pageId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pageId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pageId = pageId
    }
}

extension SSMContactsClientTypes {

    public enum ReceiptType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case delivered
        case error
        case read
        case sent
        case stop
        case sdkUnknown(Swift.String)

        public static var allCases: [ReceiptType] {
            return [
                .delivered,
                .error,
                .read,
                .sent,
                .stop
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .delivered: return "DELIVERED"
            case .error: return "ERROR"
            case .read: return "READ"
            case .sent: return "SENT"
            case .stop: return "STOP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMContactsClientTypes {
    /// Records events during an engagement.
    public struct Receipt {
        /// The Amazon Resource Name (ARN) of the contact channel Incident Manager engaged.
        public var contactChannelArn: Swift.String?
        /// Information provided during the page acknowledgement.
        public var receiptInfo: Swift.String?
        /// The time receipt was SENT, DELIVERED, or READ.
        /// This member is required.
        public var receiptTime: Foundation.Date?
        /// The type follows the engagement cycle, SENT, DELIVERED, and READ.
        /// This member is required.
        public var receiptType: SSMContactsClientTypes.ReceiptType?

        public init(
            contactChannelArn: Swift.String? = nil,
            receiptInfo: Swift.String? = nil,
            receiptTime: Foundation.Date? = nil,
            receiptType: SSMContactsClientTypes.ReceiptType? = nil
        )
        {
            self.contactChannelArn = contactChannelArn
            self.receiptInfo = receiptInfo
            self.receiptTime = receiptTime
            self.receiptType = receiptType
        }
    }

}

public struct ListPageReceiptsOutput {
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// A list of each acknowledgement.
    public var receipts: [SSMContactsClientTypes.Receipt]?

    public init(
        nextToken: Swift.String? = nil,
        receipts: [SSMContactsClientTypes.Receipt]? = nil
    )
    {
        self.nextToken = nextToken
        self.receipts = receipts
    }
}

public struct ListPageResolutionsInput {
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the contact engaged for the incident.
    /// This member is required.
    public var pageId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        pageId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.pageId = pageId
    }
}

extension SSMContactsClientTypes {
    /// Information about the engagement resolution steps. The resolution starts from the first contact, which can be an escalation plan, then resolves to an on-call rotation, and finally to a personal contact. The ResolutionContact structure describes the information for each node or step in that process. It contains information about different contact types, such as the escalation, rotation, and personal contacts.
    public struct ResolutionContact {
        /// The Amazon Resource Name (ARN) of a contact in the engagement resolution process.
        /// This member is required.
        public var contactArn: Swift.String?
        /// The stage in the escalation plan that resolves to this contact.
        public var stageIndex: Swift.Int?
        /// The type of contact for a resolution step.
        /// This member is required.
        public var type: SSMContactsClientTypes.ContactType?

        public init(
            contactArn: Swift.String? = nil,
            stageIndex: Swift.Int? = 0,
            type: SSMContactsClientTypes.ContactType? = nil
        )
        {
            self.contactArn = contactArn
            self.stageIndex = stageIndex
            self.type = type
        }
    }

}

public struct ListPageResolutionsOutput {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// Information about the resolution for an engagement.
    /// This member is required.
    public var pageResolutions: [SSMContactsClientTypes.ResolutionContact]?

    public init(
        nextToken: Swift.String? = nil,
        pageResolutions: [SSMContactsClientTypes.ResolutionContact]? = nil
    )
    {
        self.nextToken = nextToken
        self.pageResolutions = pageResolutions
    }
}

public struct ListPagesByContactInput {
    /// The Amazon Resource Name (ARN) of the contact you are retrieving engagements for.
    /// This member is required.
    public var contactId: Swift.String?
    /// The maximum number of engagements to contact channels to list per page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSMContactsClientTypes {
    /// Incident Manager engaging a contact's contact channel.
    public struct Page {
        /// The ARN of the contact that Incident Manager is engaging.
        /// This member is required.
        public var contactArn: Swift.String?
        /// The time the message was delivered to the contact channel.
        public var deliveryTime: Foundation.Date?
        /// The ARN of the engagement that this page is part of.
        /// This member is required.
        public var engagementArn: Swift.String?
        /// The ARN of the incident that's engaging the contact channel.
        public var incidentId: Swift.String?
        /// The Amazon Resource Name (ARN) of the page to the contact channel.
        /// This member is required.
        public var pageArn: Swift.String?
        /// The time that the contact channel acknowledged engagement.
        public var readTime: Foundation.Date?
        /// The user that started the engagement.
        /// This member is required.
        public var sender: Swift.String?
        /// The time that Incident Manager engaged the contact channel.
        public var sentTime: Foundation.Date?

        public init(
            contactArn: Swift.String? = nil,
            deliveryTime: Foundation.Date? = nil,
            engagementArn: Swift.String? = nil,
            incidentId: Swift.String? = nil,
            pageArn: Swift.String? = nil,
            readTime: Foundation.Date? = nil,
            sender: Swift.String? = nil,
            sentTime: Foundation.Date? = nil
        )
        {
            self.contactArn = contactArn
            self.deliveryTime = deliveryTime
            self.engagementArn = engagementArn
            self.incidentId = incidentId
            self.pageArn = pageArn
            self.readTime = readTime
            self.sender = sender
            self.sentTime = sentTime
        }
    }

}

public struct ListPagesByContactOutput {
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// The list of engagements to a contact's contact channel.
    /// This member is required.
    public var pages: [SSMContactsClientTypes.Page]?

    public init(
        nextToken: Swift.String? = nil,
        pages: [SSMContactsClientTypes.Page]? = nil
    )
    {
        self.nextToken = nextToken
        self.pages = pages
    }
}

public struct ListPagesByEngagementInput {
    /// The Amazon Resource Name (ARN) of the engagement.
    /// This member is required.
    public var engagementId: Swift.String?
    /// The maximum number of engagements to contact channels to list per page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init(
        engagementId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engagementId = engagementId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListPagesByEngagementOutput {
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// The list of engagements to contact channels.
    /// This member is required.
    public var pages: [SSMContactsClientTypes.Page]?

    public init(
        nextToken: Swift.String? = nil,
        pages: [SSMContactsClientTypes.Page]? = nil
    )
    {
        self.nextToken = nextToken
        self.pages = pages
    }
}

extension SSMContactsClientTypes {
    /// Information about contacts and times that an on-call override replaces.
    public struct PreviewOverride {
        /// Information about the time a rotation override would end.
        public var endTime: Foundation.Date?
        /// Information about contacts to add to an on-call rotation override.
        public var newMembers: [Swift.String]?
        /// Information about the time a rotation override would begin.
        public var startTime: Foundation.Date?

        public init(
            endTime: Foundation.Date? = nil,
            newMembers: [Swift.String]? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.endTime = endTime
            self.newMembers = newMembers
            self.startTime = startTime
        }
    }

}

public struct ListPreviewRotationShiftsInput {
    /// The date and time a rotation shift would end.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// The maximum number of items to return for this call. The call also returns a token that can be specified in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The contacts that would be assigned to a rotation.
    /// This member is required.
    public var members: [Swift.String]?
    /// A token to start the list. This token is used to get the next set of results.
    public var nextToken: Swift.String?
    /// Information about changes that would be made in a rotation override.
    public var overrides: [SSMContactsClientTypes.PreviewOverride]?
    /// Information about how long a rotation would last before restarting at the beginning of the shift order.
    /// This member is required.
    public var recurrence: SSMContactsClientTypes.RecurrenceSettings?
    /// The date and time a rotation would begin. The first shift is calculated from this date and time.
    public var rotationStartTime: Foundation.Date?
    /// Used to filter the range of calculated shifts before sending the response back to the user.
    public var startTime: Foundation.Date?
    /// The time zone the rotation’s activity would be based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul".
    /// This member is required.
    public var timeZoneId: Swift.String?

    public init(
        endTime: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        members: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        overrides: [SSMContactsClientTypes.PreviewOverride]? = nil,
        recurrence: SSMContactsClientTypes.RecurrenceSettings? = nil,
        rotationStartTime: Foundation.Date? = nil,
        startTime: Foundation.Date? = nil,
        timeZoneId: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.members = members
        self.nextToken = nextToken
        self.overrides = overrides
        self.recurrence = recurrence
        self.rotationStartTime = rotationStartTime
        self.startTime = startTime
        self.timeZoneId = timeZoneId
    }
}

extension SSMContactsClientTypes {
    /// Information about overrides to an on-call rotation shift.
    public struct ShiftDetails {
        /// The Amazon Resources Names (ARNs) of the contacts who were replaced in a shift when an override was created. If the override is deleted, these contacts are restored to the shift.
        /// This member is required.
        public var overriddenContactIds: [Swift.String]?

        public init(
            overriddenContactIds: [Swift.String]? = nil
        )
        {
            self.overriddenContactIds = overriddenContactIds
        }
    }

}

extension SSMContactsClientTypes {

    public enum ShiftType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case overridden
        case regular
        case sdkUnknown(Swift.String)

        public static var allCases: [ShiftType] {
            return [
                .overridden,
                .regular
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .overridden: return "OVERRIDDEN"
            case .regular: return "REGULAR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSMContactsClientTypes {
    /// Information about a shift that belongs to an on-call rotation.
    public struct RotationShift {
        /// The Amazon Resource Names (ARNs) of the contacts who are part of the shift rotation.
        public var contactIds: [Swift.String]?
        /// The time a shift rotation ends.
        /// This member is required.
        public var endTime: Foundation.Date?
        /// Additional information about an on-call rotation shift.
        public var shiftDetails: SSMContactsClientTypes.ShiftDetails?
        /// The time a shift rotation begins.
        /// This member is required.
        public var startTime: Foundation.Date?
        /// The type of shift rotation.
        public var type: SSMContactsClientTypes.ShiftType?

        public init(
            contactIds: [Swift.String]? = nil,
            endTime: Foundation.Date? = nil,
            shiftDetails: SSMContactsClientTypes.ShiftDetails? = nil,
            startTime: Foundation.Date? = nil,
            type: SSMContactsClientTypes.ShiftType? = nil
        )
        {
            self.contactIds = contactIds
            self.endTime = endTime
            self.shiftDetails = shiftDetails
            self.startTime = startTime
            self.type = type
        }
    }

}

public struct ListPreviewRotationShiftsOutput {
    /// The token for the next set of items to return. This token is used to get the next set of results.
    public var nextToken: Swift.String?
    /// Details about a rotation shift, including times, types, and contacts.
    public var rotationShifts: [SSMContactsClientTypes.RotationShift]?

    public init(
        nextToken: Swift.String? = nil,
        rotationShifts: [SSMContactsClientTypes.RotationShift]? = nil
    )
    {
        self.nextToken = nextToken
        self.rotationShifts = rotationShifts
    }
}

public struct ListRotationOverridesInput {
    /// The date and time for the end of a time range for listing overrides.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the rotation to retrieve information about.
    /// This member is required.
    public var rotationId: Swift.String?
    /// The date and time for the beginning of a time range for listing overrides.
    /// This member is required.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        rotationId: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.rotationId = rotationId
        self.startTime = startTime
    }
}

extension SSMContactsClientTypes {
    /// Information about an override specified for an on-call rotation.
    public struct RotationOverride {
        /// The time a rotation override was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The time a rotation override ends.
        /// This member is required.
        public var endTime: Foundation.Date?
        /// The Amazon Resource Names (ARNs) of the contacts assigned to the override of the on-call rotation.
        /// This member is required.
        public var newContactIds: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the override to an on-call rotation.
        /// This member is required.
        public var rotationOverrideId: Swift.String?
        /// The time a rotation override begins.
        /// This member is required.
        public var startTime: Foundation.Date?

        public init(
            createTime: Foundation.Date? = nil,
            endTime: Foundation.Date? = nil,
            newContactIds: [Swift.String]? = nil,
            rotationOverrideId: Swift.String? = nil,
            startTime: Foundation.Date? = nil
        )
        {
            self.createTime = createTime
            self.endTime = endTime
            self.newContactIds = newContactIds
            self.rotationOverrideId = rotationOverrideId
            self.startTime = startTime
        }
    }

}

public struct ListRotationOverridesOutput {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of rotation overrides in the specified time range.
    public var rotationOverrides: [SSMContactsClientTypes.RotationOverride]?

    public init(
        nextToken: Swift.String? = nil,
        rotationOverrides: [SSMContactsClientTypes.RotationOverride]? = nil
    )
    {
        self.nextToken = nextToken
        self.rotationOverrides = rotationOverrides
    }
}

public struct ListRotationsInput {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A filter to include rotations in list results based on their common prefix. For example, entering prod returns a list of all rotation names that begin with prod, such as production and prod-1.
    public var rotationNamePrefix: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        rotationNamePrefix: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.rotationNamePrefix = rotationNamePrefix
    }
}

extension SSMContactsClientTypes {
    /// Information about a rotation in an on-call schedule.
    public struct Rotation {
        /// The Amazon Resource Names (ARNs) of the contacts assigned to the rotation team.
        public var contactIds: [Swift.String]?
        /// The name of the rotation.
        /// This member is required.
        public var name: Swift.String?
        /// Information about when an on-call rotation is in effect and how long the rotation period lasts.
        public var recurrence: SSMContactsClientTypes.RecurrenceSettings?
        /// The Amazon Resource Name (ARN) of the rotation.
        /// This member is required.
        public var rotationArn: Swift.String?
        /// The date and time the rotation becomes active.
        public var startTime: Foundation.Date?
        /// The time zone the rotation’s activity is based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul".
        public var timeZoneId: Swift.String?

        public init(
            contactIds: [Swift.String]? = nil,
            name: Swift.String? = nil,
            recurrence: SSMContactsClientTypes.RecurrenceSettings? = nil,
            rotationArn: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            timeZoneId: Swift.String? = nil
        )
        {
            self.contactIds = contactIds
            self.name = name
            self.recurrence = recurrence
            self.rotationArn = rotationArn
            self.startTime = startTime
            self.timeZoneId = timeZoneId
        }
    }

}

public struct ListRotationsOutput {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// Information about rotations that meet the filter criteria.
    /// This member is required.
    public var rotations: [SSMContactsClientTypes.Rotation]?

    public init(
        nextToken: Swift.String? = nil,
        rotations: [SSMContactsClientTypes.Rotation]? = nil
    )
    {
        self.nextToken = nextToken
        self.rotations = rotations
    }
}

public struct ListRotationShiftsInput {
    /// The date and time for the end of the time range to list shifts for.
    /// This member is required.
    public var endTime: Foundation.Date?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the rotation to retrieve shift information about.
    /// This member is required.
    public var rotationId: Swift.String?
    /// The date and time for the beginning of the time range to list shifts for.
    public var startTime: Foundation.Date?

    public init(
        endTime: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        rotationId: Swift.String? = nil,
        startTime: Foundation.Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.rotationId = rotationId
        self.startTime = startTime
    }
}

public struct ListRotationShiftsOutput {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// Information about shifts that meet the filter criteria.
    public var rotationShifts: [SSMContactsClientTypes.RotationShift]?

    public init(
        nextToken: Swift.String? = nil,
        rotationShifts: [SSMContactsClientTypes.RotationShift]? = nil
    )
    {
        self.nextToken = nextToken
        self.rotationShifts = rotationShifts
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput {
    /// The tags related to the contact or escalation plan.
    public var tags: [SSMContactsClientTypes.Tag]?

    public init(
        tags: [SSMContactsClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

public struct PutContactPolicyInput {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public var contactArn: Swift.String?
    /// Details of the resource policy.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        contactArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.policy = policy
    }
}

public struct PutContactPolicyOutput {

    public init() { }
}

public struct SendActivationCodeInput {
    /// The Amazon Resource Name (ARN) of the contact channel.
    /// This member is required.
    public var contactChannelId: Swift.String?

    public init(
        contactChannelId: Swift.String? = nil
    )
    {
        self.contactChannelId = contactChannelId
    }
}

public struct SendActivationCodeOutput {

    public init() { }
}

public struct StartEngagementInput {
    /// The Amazon Resource Name (ARN) of the contact being engaged.
    /// This member is required.
    public var contactId: Swift.String?
    /// The secure content of the message that was sent to the contact. Use this field for engagements to VOICE or EMAIL.
    /// This member is required.
    public var content: Swift.String?
    /// A token ensuring that the operation is called only once with the specified details.
    public var idempotencyToken: Swift.String?
    /// The ARN of the incident that the engagement is part of.
    public var incidentId: Swift.String?
    /// The insecure content of the message that was sent to the contact. Use this field for engagements to SMS.
    public var publicContent: Swift.String?
    /// The insecure subject of the message that was sent to the contact. Use this field for engagements to SMS.
    public var publicSubject: Swift.String?
    /// The user that started the engagement.
    /// This member is required.
    public var sender: Swift.String?
    /// The secure subject of the message that was sent to the contact. Use this field for engagements to VOICE or EMAIL.
    /// This member is required.
    public var subject: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        content: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        incidentId: Swift.String? = nil,
        publicContent: Swift.String? = nil,
        publicSubject: Swift.String? = nil,
        sender: Swift.String? = nil,
        subject: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.content = content
        self.idempotencyToken = idempotencyToken
        self.incidentId = incidentId
        self.publicContent = publicContent
        self.publicSubject = publicSubject
        self.sender = sender
        self.subject = subject
    }
}

public struct StartEngagementOutput {
    /// The ARN of the engagement.
    /// This member is required.
    public var engagementArn: Swift.String?

    public init(
        engagementArn: Swift.String? = nil
    )
    {
        self.engagementArn = engagementArn
    }
}

public struct StopEngagementInput {
    /// The Amazon Resource Name (ARN) of the engagement.
    /// This member is required.
    public var engagementId: Swift.String?
    /// The reason that you're stopping the engagement.
    public var reason: Swift.String?

    public init(
        engagementId: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.engagementId = engagementId
        self.reason = reason
    }
}

public struct StopEngagementOutput {

    public init() { }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tags that you are adding to the contact or escalation plan.
    /// This member is required.
    public var tags: [SSMContactsClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [SSMContactsClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The key of the tag that you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateContactInput {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan you're updating.
    /// This member is required.
    public var contactId: Swift.String?
    /// The full name of the contact or escalation plan.
    public var displayName: Swift.String?
    /// A list of stages. A contact has an engagement plan with stages for specified contact channels. An escalation plan uses these stages to contact specified contacts.
    public var plan: SSMContactsClientTypes.Plan?

    public init(
        contactId: Swift.String? = nil,
        displayName: Swift.String? = nil,
        plan: SSMContactsClientTypes.Plan? = nil
    )
    {
        self.contactId = contactId
        self.displayName = displayName
        self.plan = plan
    }
}

public struct UpdateContactOutput {

    public init() { }
}

public struct UpdateContactChannelInput {
    /// The Amazon Resource Name (ARN) of the contact channel you want to update.
    /// This member is required.
    public var contactChannelId: Swift.String?
    /// The details that Incident Manager uses when trying to engage the contact channel.
    public var deliveryAddress: SSMContactsClientTypes.ContactChannelAddress?
    /// The name of the contact channel.
    public var name: Swift.String?

    public init(
        contactChannelId: Swift.String? = nil,
        deliveryAddress: SSMContactsClientTypes.ContactChannelAddress? = nil,
        name: Swift.String? = nil
    )
    {
        self.contactChannelId = contactChannelId
        self.deliveryAddress = deliveryAddress
        self.name = name
    }
}

public struct UpdateContactChannelOutput {

    public init() { }
}

public struct UpdateRotationInput {
    /// The Amazon Resource Names (ARNs) of the contacts to include in the updated rotation. The order in which you list the contacts is their shift order in the rotation schedule.
    public var contactIds: [Swift.String]?
    /// Information about how long the updated rotation lasts before restarting at the beginning of the shift order.
    /// This member is required.
    public var recurrence: SSMContactsClientTypes.RecurrenceSettings?
    /// The Amazon Resource Name (ARN) of the rotation to update.
    /// This member is required.
    public var rotationId: Swift.String?
    /// The date and time the rotation goes into effect.
    public var startTime: Foundation.Date?
    /// The time zone to base the updated rotation’s activity on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul". For more information, see the [Time Zone Database](https://www.iana.org/time-zones) on the IANA website. Designators for time zones that don’t support Daylight Savings Time Rules, such as Pacific Standard Time (PST) and Pacific Daylight Time (PDT), aren't supported.
    public var timeZoneId: Swift.String?

    public init(
        contactIds: [Swift.String]? = nil,
        recurrence: SSMContactsClientTypes.RecurrenceSettings? = nil,
        rotationId: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        timeZoneId: Swift.String? = nil
    )
    {
        self.contactIds = contactIds
        self.recurrence = recurrence
        self.rotationId = rotationId
        self.startTime = startTime
        self.timeZoneId = timeZoneId
    }
}

public struct UpdateRotationOutput {

    public init() { }
}

extension AcceptPageInput {

    static func urlPathProvider(_ value: AcceptPageInput) -> Swift.String? {
        return "/"
    }
}

extension ActivateContactChannelInput {

    static func urlPathProvider(_ value: ActivateContactChannelInput) -> Swift.String? {
        return "/"
    }
}

extension CreateContactInput {

    static func urlPathProvider(_ value: CreateContactInput) -> Swift.String? {
        return "/"
    }
}

extension CreateContactChannelInput {

    static func urlPathProvider(_ value: CreateContactChannelInput) -> Swift.String? {
        return "/"
    }
}

extension CreateRotationInput {

    static func urlPathProvider(_ value: CreateRotationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateRotationOverrideInput {

    static func urlPathProvider(_ value: CreateRotationOverrideInput) -> Swift.String? {
        return "/"
    }
}

extension DeactivateContactChannelInput {

    static func urlPathProvider(_ value: DeactivateContactChannelInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteContactInput {

    static func urlPathProvider(_ value: DeleteContactInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteContactChannelInput {

    static func urlPathProvider(_ value: DeleteContactChannelInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRotationInput {

    static func urlPathProvider(_ value: DeleteRotationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteRotationOverrideInput {

    static func urlPathProvider(_ value: DeleteRotationOverrideInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeEngagementInput {

    static func urlPathProvider(_ value: DescribeEngagementInput) -> Swift.String? {
        return "/"
    }
}

extension DescribePageInput {

    static func urlPathProvider(_ value: DescribePageInput) -> Swift.String? {
        return "/"
    }
}

extension GetContactInput {

    static func urlPathProvider(_ value: GetContactInput) -> Swift.String? {
        return "/"
    }
}

extension GetContactChannelInput {

    static func urlPathProvider(_ value: GetContactChannelInput) -> Swift.String? {
        return "/"
    }
}

extension GetContactPolicyInput {

    static func urlPathProvider(_ value: GetContactPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension GetRotationInput {

    static func urlPathProvider(_ value: GetRotationInput) -> Swift.String? {
        return "/"
    }
}

extension GetRotationOverrideInput {

    static func urlPathProvider(_ value: GetRotationOverrideInput) -> Swift.String? {
        return "/"
    }
}

extension ListContactChannelsInput {

    static func urlPathProvider(_ value: ListContactChannelsInput) -> Swift.String? {
        return "/"
    }
}

extension ListContactsInput {

    static func urlPathProvider(_ value: ListContactsInput) -> Swift.String? {
        return "/"
    }
}

extension ListEngagementsInput {

    static func urlPathProvider(_ value: ListEngagementsInput) -> Swift.String? {
        return "/"
    }
}

extension ListPageReceiptsInput {

    static func urlPathProvider(_ value: ListPageReceiptsInput) -> Swift.String? {
        return "/"
    }
}

extension ListPageResolutionsInput {

    static func urlPathProvider(_ value: ListPageResolutionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListPagesByContactInput {

    static func urlPathProvider(_ value: ListPagesByContactInput) -> Swift.String? {
        return "/"
    }
}

extension ListPagesByEngagementInput {

    static func urlPathProvider(_ value: ListPagesByEngagementInput) -> Swift.String? {
        return "/"
    }
}

extension ListPreviewRotationShiftsInput {

    static func urlPathProvider(_ value: ListPreviewRotationShiftsInput) -> Swift.String? {
        return "/"
    }
}

extension ListRotationOverridesInput {

    static func urlPathProvider(_ value: ListRotationOverridesInput) -> Swift.String? {
        return "/"
    }
}

extension ListRotationsInput {

    static func urlPathProvider(_ value: ListRotationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListRotationShiftsInput {

    static func urlPathProvider(_ value: ListRotationShiftsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension PutContactPolicyInput {

    static func urlPathProvider(_ value: PutContactPolicyInput) -> Swift.String? {
        return "/"
    }
}

extension SendActivationCodeInput {

    static func urlPathProvider(_ value: SendActivationCodeInput) -> Swift.String? {
        return "/"
    }
}

extension StartEngagementInput {

    static func urlPathProvider(_ value: StartEngagementInput) -> Swift.String? {
        return "/"
    }
}

extension StopEngagementInput {

    static func urlPathProvider(_ value: StopEngagementInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateContactInput {

    static func urlPathProvider(_ value: UpdateContactInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateContactChannelInput {

    static func urlPathProvider(_ value: UpdateContactChannelInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateRotationInput {

    static func urlPathProvider(_ value: UpdateRotationInput) -> Swift.String? {
        return "/"
    }
}

extension AcceptPageInput {

    static func write(value: AcceptPageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AcceptCode"].write(value.acceptCode)
        try writer["AcceptCodeValidation"].write(value.acceptCodeValidation)
        try writer["AcceptType"].write(value.acceptType)
        try writer["ContactChannelId"].write(value.contactChannelId)
        try writer["Note"].write(value.note)
        try writer["PageId"].write(value.pageId)
    }
}

extension ActivateContactChannelInput {

    static func write(value: ActivateContactChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActivationCode"].write(value.activationCode)
        try writer["ContactChannelId"].write(value.contactChannelId)
    }
}

extension CreateContactInput {

    static func write(value: CreateContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Alias"].write(value.alias)
        try writer["DisplayName"].write(value.displayName)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["Plan"].write(value.plan, with: SSMContactsClientTypes.Plan.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SSMContactsClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Type"].write(value.type)
    }
}

extension CreateContactChannelInput {

    static func write(value: CreateContactChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactId"].write(value.contactId)
        try writer["DeferActivation"].write(value.deferActivation)
        try writer["DeliveryAddress"].write(value.deliveryAddress, with: SSMContactsClientTypes.ContactChannelAddress.write(value:to:))
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["Name"].write(value.name)
        try writer["Type"].write(value.type)
    }
}

extension CreateRotationInput {

    static func write(value: CreateRotationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactIds"].writeList(value.contactIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["Name"].write(value.name)
        try writer["Recurrence"].write(value.recurrence, with: SSMContactsClientTypes.RecurrenceSettings.write(value:to:))
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SSMContactsClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TimeZoneId"].write(value.timeZoneId)
    }
}

extension CreateRotationOverrideInput {

    static func write(value: CreateRotationOverrideInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["NewContactIds"].writeList(value.newContactIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["RotationId"].write(value.rotationId)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension DeactivateContactChannelInput {

    static func write(value: DeactivateContactChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactChannelId"].write(value.contactChannelId)
    }
}

extension DeleteContactInput {

    static func write(value: DeleteContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactId"].write(value.contactId)
    }
}

extension DeleteContactChannelInput {

    static func write(value: DeleteContactChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactChannelId"].write(value.contactChannelId)
    }
}

extension DeleteRotationInput {

    static func write(value: DeleteRotationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RotationId"].write(value.rotationId)
    }
}

extension DeleteRotationOverrideInput {

    static func write(value: DeleteRotationOverrideInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RotationId"].write(value.rotationId)
        try writer["RotationOverrideId"].write(value.rotationOverrideId)
    }
}

extension DescribeEngagementInput {

    static func write(value: DescribeEngagementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EngagementId"].write(value.engagementId)
    }
}

extension DescribePageInput {

    static func write(value: DescribePageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PageId"].write(value.pageId)
    }
}

extension GetContactInput {

    static func write(value: GetContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactId"].write(value.contactId)
    }
}

extension GetContactChannelInput {

    static func write(value: GetContactChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactChannelId"].write(value.contactChannelId)
    }
}

extension GetContactPolicyInput {

    static func write(value: GetContactPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactArn"].write(value.contactArn)
    }
}

extension GetRotationInput {

    static func write(value: GetRotationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RotationId"].write(value.rotationId)
    }
}

extension GetRotationOverrideInput {

    static func write(value: GetRotationOverrideInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RotationId"].write(value.rotationId)
        try writer["RotationOverrideId"].write(value.rotationOverrideId)
    }
}

extension ListContactChannelsInput {

    static func write(value: ListContactChannelsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactId"].write(value.contactId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListContactsInput {

    static func write(value: ListContactsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AliasPrefix"].write(value.aliasPrefix)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Type"].write(value.type)
    }
}

extension ListEngagementsInput {

    static func write(value: ListEngagementsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IncidentId"].write(value.incidentId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["TimeRangeValue"].write(value.timeRangeValue, with: SSMContactsClientTypes.TimeRange.write(value:to:))
    }
}

extension ListPageReceiptsInput {

    static func write(value: ListPageReceiptsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PageId"].write(value.pageId)
    }
}

extension ListPageResolutionsInput {

    static func write(value: ListPageResolutionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["PageId"].write(value.pageId)
    }
}

extension ListPagesByContactInput {

    static func write(value: ListPagesByContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactId"].write(value.contactId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListPagesByEngagementInput {

    static func write(value: ListPagesByEngagementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EngagementId"].write(value.engagementId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListPreviewRotationShiftsInput {

    static func write(value: ListPreviewRotationShiftsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["MaxResults"].write(value.maxResults)
        try writer["Members"].writeList(value.members, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NextToken"].write(value.nextToken)
        try writer["Overrides"].writeList(value.overrides, memberWritingClosure: SSMContactsClientTypes.PreviewOverride.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Recurrence"].write(value.recurrence, with: SSMContactsClientTypes.RecurrenceSettings.write(value:to:))
        try writer["RotationStartTime"].writeTimestamp(value.rotationStartTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["TimeZoneId"].write(value.timeZoneId)
    }
}

extension ListRotationOverridesInput {

    static func write(value: ListRotationOverridesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RotationId"].write(value.rotationId)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension ListRotationsInput {

    static func write(value: ListRotationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RotationNamePrefix"].write(value.rotationNamePrefix)
    }
}

extension ListRotationShiftsInput {

    static func write(value: ListRotationShiftsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["RotationId"].write(value.rotationId)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension PutContactPolicyInput {

    static func write(value: PutContactPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactArn"].write(value.contactArn)
        try writer["Policy"].write(value.policy)
    }
}

extension SendActivationCodeInput {

    static func write(value: SendActivationCodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactChannelId"].write(value.contactChannelId)
    }
}

extension StartEngagementInput {

    static func write(value: StartEngagementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactId"].write(value.contactId)
        try writer["Content"].write(value.content)
        try writer["IdempotencyToken"].write(value.idempotencyToken)
        try writer["IncidentId"].write(value.incidentId)
        try writer["PublicContent"].write(value.publicContent)
        try writer["PublicSubject"].write(value.publicSubject)
        try writer["Sender"].write(value.sender)
        try writer["Subject"].write(value.subject)
    }
}

extension StopEngagementInput {

    static func write(value: StopEngagementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EngagementId"].write(value.engagementId)
        try writer["Reason"].write(value.reason)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SSMContactsClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateContactInput {

    static func write(value: UpdateContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactId"].write(value.contactId)
        try writer["DisplayName"].write(value.displayName)
        try writer["Plan"].write(value.plan, with: SSMContactsClientTypes.Plan.write(value:to:))
    }
}

extension UpdateContactChannelInput {

    static func write(value: UpdateContactChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactChannelId"].write(value.contactChannelId)
        try writer["DeliveryAddress"].write(value.deliveryAddress, with: SSMContactsClientTypes.ContactChannelAddress.write(value:to:))
        try writer["Name"].write(value.name)
    }
}

extension UpdateRotationInput {

    static func write(value: UpdateRotationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactIds"].writeList(value.contactIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Recurrence"].write(value.recurrence, with: SSMContactsClientTypes.RecurrenceSettings.write(value:to:))
        try writer["RotationId"].write(value.rotationId)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["TimeZoneId"].write(value.timeZoneId)
    }
}

extension AcceptPageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AcceptPageOutput {
        return AcceptPageOutput()
    }
}

extension ActivateContactChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ActivateContactChannelOutput {
        return ActivateContactChannelOutput()
    }
}

extension CreateContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateContactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateContactOutput()
        value.contactArn = try reader["ContactArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateContactChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateContactChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateContactChannelOutput()
        value.contactChannelArn = try reader["ContactChannelArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateRotationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRotationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRotationOutput()
        value.rotationArn = try reader["RotationArn"].readIfPresent() ?? ""
        return value
    }
}

extension CreateRotationOverrideOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateRotationOverrideOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRotationOverrideOutput()
        value.rotationOverrideId = try reader["RotationOverrideId"].readIfPresent() ?? ""
        return value
    }
}

extension DeactivateContactChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeactivateContactChannelOutput {
        return DeactivateContactChannelOutput()
    }
}

extension DeleteContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteContactOutput {
        return DeleteContactOutput()
    }
}

extension DeleteContactChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteContactChannelOutput {
        return DeleteContactChannelOutput()
    }
}

extension DeleteRotationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRotationOutput {
        return DeleteRotationOutput()
    }
}

extension DeleteRotationOverrideOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteRotationOverrideOutput {
        return DeleteRotationOverrideOutput()
    }
}

extension DescribeEngagementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEngagementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEngagementOutput()
        value.contactArn = try reader["ContactArn"].readIfPresent() ?? ""
        value.content = try reader["Content"].readIfPresent() ?? ""
        value.engagementArn = try reader["EngagementArn"].readIfPresent() ?? ""
        value.incidentId = try reader["IncidentId"].readIfPresent()
        value.publicContent = try reader["PublicContent"].readIfPresent()
        value.publicSubject = try reader["PublicSubject"].readIfPresent()
        value.sender = try reader["Sender"].readIfPresent() ?? ""
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.stopTime = try reader["StopTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.subject = try reader["Subject"].readIfPresent() ?? ""
        return value
    }
}

extension DescribePageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePageOutput()
        value.contactArn = try reader["ContactArn"].readIfPresent() ?? ""
        value.content = try reader["Content"].readIfPresent() ?? ""
        value.deliveryTime = try reader["DeliveryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.engagementArn = try reader["EngagementArn"].readIfPresent() ?? ""
        value.incidentId = try reader["IncidentId"].readIfPresent()
        value.pageArn = try reader["PageArn"].readIfPresent() ?? ""
        value.publicContent = try reader["PublicContent"].readIfPresent()
        value.publicSubject = try reader["PublicSubject"].readIfPresent()
        value.readTime = try reader["ReadTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sender = try reader["Sender"].readIfPresent() ?? ""
        value.sentTime = try reader["SentTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.subject = try reader["Subject"].readIfPresent() ?? ""
        return value
    }
}

extension GetContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetContactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetContactOutput()
        value.alias = try reader["Alias"].readIfPresent() ?? ""
        value.contactArn = try reader["ContactArn"].readIfPresent() ?? ""
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.plan = try reader["Plan"].readIfPresent(with: SSMContactsClientTypes.Plan.read(from:))
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetContactChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetContactChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetContactChannelOutput()
        value.activationStatus = try reader["ActivationStatus"].readIfPresent()
        value.contactArn = try reader["ContactArn"].readIfPresent() ?? ""
        value.contactChannelArn = try reader["ContactChannelArn"].readIfPresent() ?? ""
        value.deliveryAddress = try reader["DeliveryAddress"].readIfPresent(with: SSMContactsClientTypes.ContactChannelAddress.read(from:))
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetContactPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetContactPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetContactPolicyOutput()
        value.contactArn = try reader["ContactArn"].readIfPresent()
        value.policy = try reader["Policy"].readIfPresent()
        return value
    }
}

extension GetRotationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRotationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRotationOutput()
        value.contactIds = try reader["ContactIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.recurrence = try reader["Recurrence"].readIfPresent(with: SSMContactsClientTypes.RecurrenceSettings.read(from:))
        value.rotationArn = try reader["RotationArn"].readIfPresent() ?? ""
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.timeZoneId = try reader["TimeZoneId"].readIfPresent() ?? ""
        return value
    }
}

extension GetRotationOverrideOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRotationOverrideOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRotationOverrideOutput()
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.newContactIds = try reader["NewContactIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.rotationArn = try reader["RotationArn"].readIfPresent()
        value.rotationOverrideId = try reader["RotationOverrideId"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ListContactChannelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListContactChannelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListContactChannelsOutput()
        value.contactChannels = try reader["ContactChannels"].readListIfPresent(memberReadingClosure: SSMContactsClientTypes.ContactChannel.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListContactsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListContactsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListContactsOutput()
        value.contacts = try reader["Contacts"].readListIfPresent(memberReadingClosure: SSMContactsClientTypes.Contact.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListEngagementsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEngagementsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEngagementsOutput()
        value.engagements = try reader["Engagements"].readListIfPresent(memberReadingClosure: SSMContactsClientTypes.Engagement.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListPageReceiptsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPageReceiptsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPageReceiptsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.receipts = try reader["Receipts"].readListIfPresent(memberReadingClosure: SSMContactsClientTypes.Receipt.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPageResolutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPageResolutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPageResolutionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.pageResolutions = try reader["PageResolutions"].readListIfPresent(memberReadingClosure: SSMContactsClientTypes.ResolutionContact.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListPagesByContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPagesByContactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPagesByContactOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.pages = try reader["Pages"].readListIfPresent(memberReadingClosure: SSMContactsClientTypes.Page.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListPagesByEngagementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPagesByEngagementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPagesByEngagementOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.pages = try reader["Pages"].readListIfPresent(memberReadingClosure: SSMContactsClientTypes.Page.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListPreviewRotationShiftsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPreviewRotationShiftsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPreviewRotationShiftsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.rotationShifts = try reader["RotationShifts"].readListIfPresent(memberReadingClosure: SSMContactsClientTypes.RotationShift.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRotationOverridesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRotationOverridesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRotationOverridesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.rotationOverrides = try reader["RotationOverrides"].readListIfPresent(memberReadingClosure: SSMContactsClientTypes.RotationOverride.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRotationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRotationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRotationsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.rotations = try reader["Rotations"].readListIfPresent(memberReadingClosure: SSMContactsClientTypes.Rotation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListRotationShiftsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRotationShiftsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRotationShiftsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.rotationShifts = try reader["RotationShifts"].readListIfPresent(memberReadingClosure: SSMContactsClientTypes.RotationShift.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: SSMContactsClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutContactPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutContactPolicyOutput {
        return PutContactPolicyOutput()
    }
}

extension SendActivationCodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendActivationCodeOutput {
        return SendActivationCodeOutput()
    }
}

extension StartEngagementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartEngagementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartEngagementOutput()
        value.engagementArn = try reader["EngagementArn"].readIfPresent() ?? ""
        return value
    }
}

extension StopEngagementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopEngagementOutput {
        return StopEngagementOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateContactOutput {
        return UpdateContactOutput()
    }
}

extension UpdateContactChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateContactChannelOutput {
        return UpdateContactChannelOutput()
    }
}

extension UpdateRotationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateRotationOutput {
        return UpdateRotationOutput()
    }
}

enum AcceptPageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ActivateContactChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DataEncryptionException": return try DataEncryptionException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateContactChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DataEncryptionException": return try DataEncryptionException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRotationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateRotationOverrideOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeactivateContactChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteContactChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRotationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteRotationOverrideOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEngagementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DataEncryptionException": return try DataEncryptionException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DataEncryptionException": return try DataEncryptionException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DataEncryptionException": return try DataEncryptionException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetContactChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DataEncryptionException": return try DataEncryptionException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetContactPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRotationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRotationOverrideOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListContactChannelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DataEncryptionException": return try DataEncryptionException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListContactsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEngagementsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPageReceiptsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPageResolutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPagesByContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPagesByEngagementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPreviewRotationShiftsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRotationOverridesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRotationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRotationShiftsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutContactPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendActivationCodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DataEncryptionException": return try DataEncryptionException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartEngagementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DataEncryptionException": return try DataEncryptionException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopEngagementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DataEncryptionException": return try DataEncryptionException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateContactChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DataEncryptionException": return try DataEncryptionException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateRotationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fields = try reader["Fields"].readListIfPresent(memberReadingClosure: SSMContactsClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["QuotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.dependentEntities = try reader["DependentEntities"].readListIfPresent(memberReadingClosure: SSMContactsClientTypes.DependentEntity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DataEncryptionException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DataEncryptionException {
        let reader = baseError.errorBodyReader
        var value = DataEncryptionException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["QuotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SSMContactsClientTypes.Plan {

    static func write(value: SSMContactsClientTypes.Plan?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RotationIds"].writeList(value.rotationIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Stages"].writeList(value.stages, memberWritingClosure: SSMContactsClientTypes.Stage.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.Plan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.Plan()
        value.stages = try reader["Stages"].readListIfPresent(memberReadingClosure: SSMContactsClientTypes.Stage.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.rotationIds = try reader["RotationIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSMContactsClientTypes.Stage {

    static func write(value: SSMContactsClientTypes.Stage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DurationInMinutes"].write(value.durationInMinutes)
        try writer["Targets"].writeList(value.targets, memberWritingClosure: SSMContactsClientTypes.Target.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.Stage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.Stage()
        value.durationInMinutes = try reader["DurationInMinutes"].readIfPresent() ?? 0
        value.targets = try reader["Targets"].readListIfPresent(memberReadingClosure: SSMContactsClientTypes.Target.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SSMContactsClientTypes.Target {

    static func write(value: SSMContactsClientTypes.Target?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelTargetInfo"].write(value.channelTargetInfo, with: SSMContactsClientTypes.ChannelTargetInfo.write(value:to:))
        try writer["ContactTargetInfo"].write(value.contactTargetInfo, with: SSMContactsClientTypes.ContactTargetInfo.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.Target {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.Target()
        value.channelTargetInfo = try reader["ChannelTargetInfo"].readIfPresent(with: SSMContactsClientTypes.ChannelTargetInfo.read(from:))
        value.contactTargetInfo = try reader["ContactTargetInfo"].readIfPresent(with: SSMContactsClientTypes.ContactTargetInfo.read(from:))
        return value
    }
}

extension SSMContactsClientTypes.ContactTargetInfo {

    static func write(value: SSMContactsClientTypes.ContactTargetInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactId"].write(value.contactId)
        try writer["IsEssential"].write(value.isEssential)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.ContactTargetInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.ContactTargetInfo()
        value.contactId = try reader["ContactId"].readIfPresent()
        value.isEssential = try reader["IsEssential"].readIfPresent() ?? false
        return value
    }
}

extension SSMContactsClientTypes.ChannelTargetInfo {

    static func write(value: SSMContactsClientTypes.ChannelTargetInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactChannelId"].write(value.contactChannelId)
        try writer["RetryIntervalInMinutes"].write(value.retryIntervalInMinutes)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.ChannelTargetInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.ChannelTargetInfo()
        value.contactChannelId = try reader["ContactChannelId"].readIfPresent() ?? ""
        value.retryIntervalInMinutes = try reader["RetryIntervalInMinutes"].readIfPresent()
        return value
    }
}

extension SSMContactsClientTypes.ContactChannelAddress {

    static func write(value: SSMContactsClientTypes.ContactChannelAddress?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SimpleAddress"].write(value.simpleAddress)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.ContactChannelAddress {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.ContactChannelAddress()
        value.simpleAddress = try reader["SimpleAddress"].readIfPresent()
        return value
    }
}

extension SSMContactsClientTypes.RecurrenceSettings {

    static func write(value: SSMContactsClientTypes.RecurrenceSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DailySettings"].writeList(value.dailySettings, memberWritingClosure: SSMContactsClientTypes.HandOffTime.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MonthlySettings"].writeList(value.monthlySettings, memberWritingClosure: SSMContactsClientTypes.MonthlySetting.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NumberOfOnCalls"].write(value.numberOfOnCalls)
        try writer["RecurrenceMultiplier"].write(value.recurrenceMultiplier)
        try writer["ShiftCoverages"].writeMap(value.shiftCoverages, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SSMContactsClientTypes.CoverageTime.write(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["WeeklySettings"].writeList(value.weeklySettings, memberWritingClosure: SSMContactsClientTypes.WeeklySetting.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.RecurrenceSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.RecurrenceSettings()
        value.monthlySettings = try reader["MonthlySettings"].readListIfPresent(memberReadingClosure: SSMContactsClientTypes.MonthlySetting.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.weeklySettings = try reader["WeeklySettings"].readListIfPresent(memberReadingClosure: SSMContactsClientTypes.WeeklySetting.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dailySettings = try reader["DailySettings"].readListIfPresent(memberReadingClosure: SSMContactsClientTypes.HandOffTime.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.numberOfOnCalls = try reader["NumberOfOnCalls"].readIfPresent() ?? 0
        value.shiftCoverages = try reader["ShiftCoverages"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SSMContactsClientTypes.CoverageTime.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.recurrenceMultiplier = try reader["RecurrenceMultiplier"].readIfPresent() ?? 0
        return value
    }
}

extension SSMContactsClientTypes.CoverageTime {

    static func write(value: SSMContactsClientTypes.CoverageTime?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["End"].write(value.end, with: SSMContactsClientTypes.HandOffTime.write(value:to:))
        try writer["Start"].write(value.start, with: SSMContactsClientTypes.HandOffTime.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.CoverageTime {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.CoverageTime()
        value.start = try reader["Start"].readIfPresent(with: SSMContactsClientTypes.HandOffTime.read(from:))
        value.end = try reader["End"].readIfPresent(with: SSMContactsClientTypes.HandOffTime.read(from:))
        return value
    }
}

extension SSMContactsClientTypes.HandOffTime {

    static func write(value: SSMContactsClientTypes.HandOffTime?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HourOfDay"].write(value.hourOfDay)
        try writer["MinuteOfHour"].write(value.minuteOfHour)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.HandOffTime {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.HandOffTime()
        value.hourOfDay = try reader["HourOfDay"].readIfPresent() ?? 0
        value.minuteOfHour = try reader["MinuteOfHour"].readIfPresent() ?? 0
        return value
    }
}

extension SSMContactsClientTypes.WeeklySetting {

    static func write(value: SSMContactsClientTypes.WeeklySetting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DayOfWeek"].write(value.dayOfWeek)
        try writer["HandOffTime"].write(value.handOffTime, with: SSMContactsClientTypes.HandOffTime.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.WeeklySetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.WeeklySetting()
        value.dayOfWeek = try reader["DayOfWeek"].readIfPresent() ?? .sdkUnknown("")
        value.handOffTime = try reader["HandOffTime"].readIfPresent(with: SSMContactsClientTypes.HandOffTime.read(from:))
        return value
    }
}

extension SSMContactsClientTypes.MonthlySetting {

    static func write(value: SSMContactsClientTypes.MonthlySetting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DayOfMonth"].write(value.dayOfMonth)
        try writer["HandOffTime"].write(value.handOffTime, with: SSMContactsClientTypes.HandOffTime.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.MonthlySetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.MonthlySetting()
        value.dayOfMonth = try reader["DayOfMonth"].readIfPresent() ?? 0
        value.handOffTime = try reader["HandOffTime"].readIfPresent(with: SSMContactsClientTypes.HandOffTime.read(from:))
        return value
    }
}

extension SSMContactsClientTypes.ContactChannel {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.ContactChannel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.ContactChannel()
        value.contactChannelArn = try reader["ContactChannelArn"].readIfPresent() ?? ""
        value.contactArn = try reader["ContactArn"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent()
        value.deliveryAddress = try reader["DeliveryAddress"].readIfPresent(with: SSMContactsClientTypes.ContactChannelAddress.read(from:))
        value.activationStatus = try reader["ActivationStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension SSMContactsClientTypes.Contact {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.Contact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.Contact()
        value.contactArn = try reader["ContactArn"].readIfPresent() ?? ""
        value.alias = try reader["Alias"].readIfPresent() ?? ""
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension SSMContactsClientTypes.Engagement {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.Engagement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.Engagement()
        value.engagementArn = try reader["EngagementArn"].readIfPresent() ?? ""
        value.contactArn = try reader["ContactArn"].readIfPresent() ?? ""
        value.sender = try reader["Sender"].readIfPresent() ?? ""
        value.incidentId = try reader["IncidentId"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.stopTime = try reader["StopTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension SSMContactsClientTypes.Receipt {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.Receipt {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.Receipt()
        value.contactChannelArn = try reader["ContactChannelArn"].readIfPresent()
        value.receiptType = try reader["ReceiptType"].readIfPresent() ?? .sdkUnknown("")
        value.receiptInfo = try reader["ReceiptInfo"].readIfPresent()
        value.receiptTime = try reader["ReceiptTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension SSMContactsClientTypes.ResolutionContact {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.ResolutionContact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.ResolutionContact()
        value.contactArn = try reader["ContactArn"].readIfPresent() ?? ""
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.stageIndex = try reader["StageIndex"].readIfPresent()
        return value
    }
}

extension SSMContactsClientTypes.Page {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.Page {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.Page()
        value.pageArn = try reader["PageArn"].readIfPresent() ?? ""
        value.engagementArn = try reader["EngagementArn"].readIfPresent() ?? ""
        value.contactArn = try reader["ContactArn"].readIfPresent() ?? ""
        value.sender = try reader["Sender"].readIfPresent() ?? ""
        value.incidentId = try reader["IncidentId"].readIfPresent()
        value.sentTime = try reader["SentTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deliveryTime = try reader["DeliveryTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.readTime = try reader["ReadTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension SSMContactsClientTypes.RotationShift {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.RotationShift {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.RotationShift()
        value.contactIds = try reader["ContactIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.type = try reader["Type"].readIfPresent()
        value.shiftDetails = try reader["ShiftDetails"].readIfPresent(with: SSMContactsClientTypes.ShiftDetails.read(from:))
        return value
    }
}

extension SSMContactsClientTypes.ShiftDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.ShiftDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.ShiftDetails()
        value.overriddenContactIds = try reader["OverriddenContactIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SSMContactsClientTypes.RotationOverride {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.RotationOverride {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.RotationOverride()
        value.rotationOverrideId = try reader["RotationOverrideId"].readIfPresent() ?? ""
        value.newContactIds = try reader["NewContactIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["EndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createTime = try reader["CreateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension SSMContactsClientTypes.Rotation {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.Rotation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.Rotation()
        value.rotationArn = try reader["RotationArn"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.contactIds = try reader["ContactIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.timeZoneId = try reader["TimeZoneId"].readIfPresent()
        value.recurrence = try reader["Recurrence"].readIfPresent(with: SSMContactsClientTypes.RecurrenceSettings.read(from:))
        return value
    }
}

extension SSMContactsClientTypes.Tag {

    static func write(value: SSMContactsClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension SSMContactsClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.ValidationExceptionField()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension SSMContactsClientTypes.DependentEntity {

    static func read(from reader: SmithyJSON.Reader) throws -> SSMContactsClientTypes.DependentEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSMContactsClientTypes.DependentEntity()
        value.relationType = try reader["RelationType"].readIfPresent() ?? ""
        value.dependentResourceIds = try reader["DependentResourceIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SSMContactsClientTypes.TimeRange {

    static func write(value: SSMContactsClientTypes.TimeRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension SSMContactsClientTypes.PreviewOverride {

    static func write(value: SSMContactsClientTypes.PreviewOverride?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EndTime"].writeTimestamp(value.endTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["NewMembers"].writeList(value.newMembers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StartTime"].writeTimestamp(value.startTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

public enum SSMContactsClientTypes {}
