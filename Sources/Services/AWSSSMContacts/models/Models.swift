// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension SSMContactsClientTypes {
    public enum AcceptCodeValidation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enforce
        case ignore
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceptCodeValidation] {
            return [
                .enforce,
                .ignore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enforce: return "ENFORCE"
            case .ignore: return "IGNORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AcceptCodeValidation(rawValue: rawValue) ?? AcceptCodeValidation.sdkUnknown(rawValue)
        }
    }
}

extension AcceptPageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptCode = "AcceptCode"
        case acceptCodeValidation = "AcceptCodeValidation"
        case acceptType = "AcceptType"
        case contactChannelId = "ContactChannelId"
        case note = "Note"
        case pageId = "PageId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptCode = self.acceptCode {
            try encodeContainer.encode(acceptCode, forKey: .acceptCode)
        }
        if let acceptCodeValidation = self.acceptCodeValidation {
            try encodeContainer.encode(acceptCodeValidation.rawValue, forKey: .acceptCodeValidation)
        }
        if let acceptType = self.acceptType {
            try encodeContainer.encode(acceptType.rawValue, forKey: .acceptType)
        }
        if let contactChannelId = self.contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
        if let note = self.note {
            try encodeContainer.encode(note, forKey: .note)
        }
        if let pageId = self.pageId {
            try encodeContainer.encode(pageId, forKey: .pageId)
        }
    }
}

extension AcceptPageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AcceptPageInput: Swift.Equatable {
    /// A 6-digit code used to acknowledge the page.
    /// This member is required.
    public var acceptCode: Swift.String?
    /// An optional field that Incident Manager uses to ENFORCEAcceptCode validation when acknowledging an page. Acknowledgement can occur by replying to a page, or when entering the AcceptCode in the console. Enforcing AcceptCode validation causes Incident Manager to verify that the code entered by the user matches the code sent by Incident Manager with the page. Incident Manager can also IGNOREAcceptCode validation. Ignoring AcceptCode validation causes Incident Manager to accept any value entered for the AcceptCode.
    public var acceptCodeValidation: SSMContactsClientTypes.AcceptCodeValidation?
    /// The type indicates if the page was DELIVERED or READ.
    /// This member is required.
    public var acceptType: SSMContactsClientTypes.AcceptType?
    /// The ARN of the contact channel.
    public var contactChannelId: Swift.String?
    /// Information provided by the user when the user acknowledges the page.
    public var note: Swift.String?
    /// The Amazon Resource Name (ARN) of the engagement to a contact channel.
    /// This member is required.
    public var pageId: Swift.String?

    public init(
        acceptCode: Swift.String? = nil,
        acceptCodeValidation: SSMContactsClientTypes.AcceptCodeValidation? = nil,
        acceptType: SSMContactsClientTypes.AcceptType? = nil,
        contactChannelId: Swift.String? = nil,
        note: Swift.String? = nil,
        pageId: Swift.String? = nil
    )
    {
        self.acceptCode = acceptCode
        self.acceptCodeValidation = acceptCodeValidation
        self.acceptType = acceptType
        self.contactChannelId = contactChannelId
        self.note = note
        self.pageId = pageId
    }
}

struct AcceptPageInputBody: Swift.Equatable {
    let pageId: Swift.String?
    let contactChannelId: Swift.String?
    let acceptType: SSMContactsClientTypes.AcceptType?
    let note: Swift.String?
    let acceptCode: Swift.String?
    let acceptCodeValidation: SSMContactsClientTypes.AcceptCodeValidation?
}

extension AcceptPageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptCode = "AcceptCode"
        case acceptCodeValidation = "AcceptCodeValidation"
        case acceptType = "AcceptType"
        case contactChannelId = "ContactChannelId"
        case note = "Note"
        case pageId = "PageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageId)
        pageId = pageIdDecoded
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
        let acceptTypeDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.AcceptType.self, forKey: .acceptType)
        acceptType = acceptTypeDecoded
        let noteDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .note)
        note = noteDecoded
        let acceptCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .acceptCode)
        acceptCode = acceptCodeDecoded
        let acceptCodeValidationDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.AcceptCodeValidation.self, forKey: .acceptCodeValidation)
        acceptCodeValidation = acceptCodeValidationDecoded
    }
}

extension AcceptPageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AcceptPageOutput: Swift.Equatable {

    public init() { }
}

enum AcceptPageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSMContactsClientTypes {
    public enum AcceptType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delivered
        case read
        case sdkUnknown(Swift.String)

        public static var allCases: [AcceptType] {
            return [
                .delivered,
                .read,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delivered: return "DELIVERED"
            case .read: return "READ"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AcceptType(rawValue: rawValue) ?? AcceptType.sdkUnknown(rawValue)
        }
    }
}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have sufficient access to perform this operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ActivateContactChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationCode = "ActivationCode"
        case contactChannelId = "ContactChannelId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationCode = self.activationCode {
            try encodeContainer.encode(activationCode, forKey: .activationCode)
        }
        if let contactChannelId = self.contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
    }
}

extension ActivateContactChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ActivateContactChannelInput: Swift.Equatable {
    /// The code sent to the contact channel when it was created in the contact.
    /// This member is required.
    public var activationCode: Swift.String?
    /// The Amazon Resource Name (ARN) of the contact channel.
    /// This member is required.
    public var contactChannelId: Swift.String?

    public init(
        activationCode: Swift.String? = nil,
        contactChannelId: Swift.String? = nil
    )
    {
        self.activationCode = activationCode
        self.contactChannelId = contactChannelId
    }
}

struct ActivateContactChannelInputBody: Swift.Equatable {
    let contactChannelId: Swift.String?
    let activationCode: Swift.String?
}

extension ActivateContactChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationCode = "ActivationCode"
        case contactChannelId = "ContactChannelId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
        let activationCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activationCode)
        activationCode = activationCodeDecoded
    }
}

extension ActivateContactChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ActivateContactChannelOutput: Swift.Equatable {

    public init() { }
}

enum ActivateContactChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSMContactsClientTypes {
    public enum ActivationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activated
        case notActivated
        case sdkUnknown(Swift.String)

        public static var allCases: [ActivationStatus] {
            return [
                .activated,
                .notActivated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activated: return "ACTIVATED"
            case .notActivated: return "NOT_ACTIVATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActivationStatus(rawValue: rawValue) ?? ActivationStatus.sdkUnknown(rawValue)
        }
    }
}

extension SSMContactsClientTypes.ChannelTargetInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
        case retryIntervalInMinutes = "RetryIntervalInMinutes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = self.contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
        if let retryIntervalInMinutes = self.retryIntervalInMinutes {
            try encodeContainer.encode(retryIntervalInMinutes, forKey: .retryIntervalInMinutes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
        let retryIntervalInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retryIntervalInMinutes)
        retryIntervalInMinutes = retryIntervalInMinutesDecoded
    }
}

extension SSMContactsClientTypes {
    /// Information about the contact channel that Incident Manager uses to engage the contact.
    public struct ChannelTargetInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the contact channel.
        /// This member is required.
        public var contactChannelId: Swift.String?
        /// The number of minutes to wait to retry sending engagement in the case the engagement initially fails.
        public var retryIntervalInMinutes: Swift.Int?

        public init(
            contactChannelId: Swift.String? = nil,
            retryIntervalInMinutes: Swift.Int? = nil
        )
        {
            self.contactChannelId = contactChannelId
            self.retryIntervalInMinutes = retryIntervalInMinutes
        }
    }

}

extension SSMContactsClientTypes {
    public enum ChannelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case email
        case sms
        case voice
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelType] {
            return [
                .email,
                .sms,
                .voice,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case .sms: return "SMS"
            case .voice: return "VOICE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelType(rawValue: rawValue) ?? ChannelType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.dependentEntities = output.dependentEntities
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.dependentEntities = nil
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Updating or deleting a resource causes an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// List of dependent entities containing information on relation type and resourceArns linked to the resource in use
        public internal(set) var dependentEntities: [SSMContactsClientTypes.DependentEntity]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource in use
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource in use
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        dependentEntities: [SSMContactsClientTypes.DependentEntity]? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.dependentEntities = dependentEntities
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let dependentEntities: [SSMContactsClientTypes.DependentEntity]?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependentEntities = "DependentEntities"
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let dependentEntitiesContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.DependentEntity?].self, forKey: .dependentEntities)
        var dependentEntitiesDecoded0:[SSMContactsClientTypes.DependentEntity]? = nil
        if let dependentEntitiesContainer = dependentEntitiesContainer {
            dependentEntitiesDecoded0 = [SSMContactsClientTypes.DependentEntity]()
            for structure0 in dependentEntitiesContainer {
                if let structure0 = structure0 {
                    dependentEntitiesDecoded0?.append(structure0)
                }
            }
        }
        dependentEntities = dependentEntitiesDecoded0
    }
}

extension SSMContactsClientTypes.Contact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case contactArn = "ContactArn"
        case displayName = "DisplayName"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.ContactType.self, forKey: .type)
        type = typeDecoded
    }
}

extension SSMContactsClientTypes {
    /// A personal contact or escalation plan that Incident Manager engages during an incident.
    public struct Contact: Swift.Equatable {
        /// The unique and identifiable alias of the contact or escalation plan.
        /// This member is required.
        public var alias: Swift.String?
        /// The Amazon Resource Name (ARN) of the contact or escalation plan.
        /// This member is required.
        public var contactArn: Swift.String?
        /// The full name of the contact or escalation plan.
        public var displayName: Swift.String?
        /// Refers to the type of contact. A single contact is type PERSONAL and an escalation plan is type ESCALATION.
        /// This member is required.
        public var type: SSMContactsClientTypes.ContactType?

        public init(
            alias: Swift.String? = nil,
            contactArn: Swift.String? = nil,
            displayName: Swift.String? = nil,
            type: SSMContactsClientTypes.ContactType? = nil
        )
        {
            self.alias = alias
            self.contactArn = contactArn
            self.displayName = displayName
            self.type = type
        }
    }

}

extension SSMContactsClientTypes.ContactChannel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationStatus = "ActivationStatus"
        case contactArn = "ContactArn"
        case contactChannelArn = "ContactChannelArn"
        case deliveryAddress = "DeliveryAddress"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationStatus = self.activationStatus {
            try encodeContainer.encode(activationStatus.rawValue, forKey: .activationStatus)
        }
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let contactChannelArn = self.contactChannelArn {
            try encodeContainer.encode(contactChannelArn, forKey: .contactChannelArn)
        }
        if let deliveryAddress = self.deliveryAddress {
            try encodeContainer.encode(deliveryAddress, forKey: .deliveryAddress)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelArn)
        contactChannelArn = contactChannelArnDecoded
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.ChannelType.self, forKey: .type)
        type = typeDecoded
        let deliveryAddressDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.ContactChannelAddress.self, forKey: .deliveryAddress)
        deliveryAddress = deliveryAddressDecoded
        let activationStatusDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.ActivationStatus.self, forKey: .activationStatus)
        activationStatus = activationStatusDecoded
    }
}

extension SSMContactsClientTypes {
    /// The method that Incident Manager uses to engage a contact.
    public struct ContactChannel: Swift.Equatable {
        /// A Boolean value describing if the contact channel has been activated or not. If the contact channel isn't activated, Incident Manager can't engage the contact through it.
        /// This member is required.
        public var activationStatus: SSMContactsClientTypes.ActivationStatus?
        /// The ARN of the contact that contains the contact channel.
        /// This member is required.
        public var contactArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the contact channel.
        /// This member is required.
        public var contactChannelArn: Swift.String?
        /// The details that Incident Manager uses when trying to engage the contact channel.
        /// This member is required.
        public var deliveryAddress: SSMContactsClientTypes.ContactChannelAddress?
        /// The name of the contact channel.
        /// This member is required.
        public var name: Swift.String?
        /// The type of the contact channel. Incident Manager supports three contact methods:
        ///
        /// * SMS
        ///
        /// * VOICE
        ///
        /// * EMAIL
        public var type: SSMContactsClientTypes.ChannelType?

        public init(
            activationStatus: SSMContactsClientTypes.ActivationStatus? = nil,
            contactArn: Swift.String? = nil,
            contactChannelArn: Swift.String? = nil,
            deliveryAddress: SSMContactsClientTypes.ContactChannelAddress? = nil,
            name: Swift.String? = nil,
            type: SSMContactsClientTypes.ChannelType? = nil
        )
        {
            self.activationStatus = activationStatus
            self.contactArn = contactArn
            self.contactChannelArn = contactChannelArn
            self.deliveryAddress = deliveryAddress
            self.name = name
            self.type = type
        }
    }

}

extension SSMContactsClientTypes.ContactChannelAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case simpleAddress = "SimpleAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let simpleAddress = self.simpleAddress {
            try encodeContainer.encode(simpleAddress, forKey: .simpleAddress)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let simpleAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .simpleAddress)
        simpleAddress = simpleAddressDecoded
    }
}

extension SSMContactsClientTypes {
    /// The details that Incident Manager uses when trying to engage the contact channel.
    public struct ContactChannelAddress: Swift.Equatable {
        /// The format is dependent on the type of the contact channel. The following are the expected formats:
        ///
        /// * SMS - '+' followed by the country code and phone number
        ///
        /// * VOICE - '+' followed by the country code and phone number
        ///
        /// * EMAIL - any standard email format
        public var simpleAddress: Swift.String?

        public init(
            simpleAddress: Swift.String? = nil
        )
        {
            self.simpleAddress = simpleAddress
        }
    }

}

extension SSMContactsClientTypes.ContactTargetInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case isEssential = "IsEssential"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let isEssential = self.isEssential {
            try encodeContainer.encode(isEssential, forKey: .isEssential)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let isEssentialDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isEssential)
        isEssential = isEssentialDecoded
    }
}

extension SSMContactsClientTypes {
    /// The contact that Incident Manager is engaging during an incident.
    public struct ContactTargetInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the contact.
        public var contactId: Swift.String?
        /// A Boolean value determining if the contact's acknowledgement stops the progress of stages in the plan.
        /// This member is required.
        public var isEssential: Swift.Bool?

        public init(
            contactId: Swift.String? = nil,
            isEssential: Swift.Bool? = nil
        )
        {
            self.contactId = contactId
            self.isEssential = isEssential
        }
    }

}

extension SSMContactsClientTypes {
    public enum ContactType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case escalation
        case oncallSchedule
        case personal
        case sdkUnknown(Swift.String)

        public static var allCases: [ContactType] {
            return [
                .escalation,
                .oncallSchedule,
                .personal,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .escalation: return "ESCALATION"
            case .oncallSchedule: return "ONCALL_SCHEDULE"
            case .personal: return "PERSONAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContactType(rawValue: rawValue) ?? ContactType.sdkUnknown(rawValue)
        }
    }
}

extension SSMContactsClientTypes.CoverageTime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case end = "End"
        case start = "Start"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = self.end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let start = self.start {
            try encodeContainer.encode(start, forKey: .start)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.HandOffTime.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.HandOffTime.self, forKey: .end)
        end = endDecoded
    }
}

extension SSMContactsClientTypes {
    /// Information about when an on-call shift begins and ends.
    public struct CoverageTime: Swift.Equatable {
        /// Information about when the on-call rotation shift ends.
        public var end: SSMContactsClientTypes.HandOffTime?
        /// Information about when the on-call rotation shift begins.
        public var start: SSMContactsClientTypes.HandOffTime?

        public init(
            end: SSMContactsClientTypes.HandOffTime? = nil,
            start: SSMContactsClientTypes.HandOffTime? = nil
        )
        {
            self.end = end
            self.start = start
        }
    }

}

extension CreateContactChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case deferActivation = "DeferActivation"
        case deliveryAddress = "DeliveryAddress"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let deferActivation = self.deferActivation {
            try encodeContainer.encode(deferActivation, forKey: .deferActivation)
        }
        if let deliveryAddress = self.deliveryAddress {
            try encodeContainer.encode(deliveryAddress, forKey: .deliveryAddress)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateContactChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateContactChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact you are adding the contact channel to.
    /// This member is required.
    public var contactId: Swift.String?
    /// If you want to activate the channel at a later time, you can choose to defer activation. Incident Manager can't engage your contact channel until it has been activated.
    public var deferActivation: Swift.Bool?
    /// The details that Incident Manager uses when trying to engage the contact channel. The format is dependent on the type of the contact channel. The following are the expected formats:
    ///
    /// * SMS - '+' followed by the country code and phone number
    ///
    /// * VOICE - '+' followed by the country code and phone number
    ///
    /// * EMAIL - any standard email format
    /// This member is required.
    public var deliveryAddress: SSMContactsClientTypes.ContactChannelAddress?
    /// A token ensuring that the operation is called only once with the specified details.
    public var idempotencyToken: Swift.String?
    /// The name of the contact channel.
    /// This member is required.
    public var name: Swift.String?
    /// Incident Manager supports three types of contact channels:
    ///
    /// * SMS
    ///
    /// * VOICE
    ///
    /// * EMAIL
    /// This member is required.
    public var type: SSMContactsClientTypes.ChannelType?

    public init(
        contactId: Swift.String? = nil,
        deferActivation: Swift.Bool? = nil,
        deliveryAddress: SSMContactsClientTypes.ContactChannelAddress? = nil,
        idempotencyToken: Swift.String? = nil,
        name: Swift.String? = nil,
        type: SSMContactsClientTypes.ChannelType? = nil
    )
    {
        self.contactId = contactId
        self.deferActivation = deferActivation
        self.deliveryAddress = deliveryAddress
        self.idempotencyToken = idempotencyToken
        self.name = name
        self.type = type
    }
}

struct CreateContactChannelInputBody: Swift.Equatable {
    let contactId: Swift.String?
    let name: Swift.String?
    let type: SSMContactsClientTypes.ChannelType?
    let deliveryAddress: SSMContactsClientTypes.ContactChannelAddress?
    let deferActivation: Swift.Bool?
    let idempotencyToken: Swift.String?
}

extension CreateContactChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case deferActivation = "DeferActivation"
        case deliveryAddress = "DeliveryAddress"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.ChannelType.self, forKey: .type)
        type = typeDecoded
        let deliveryAddressDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.ContactChannelAddress.self, forKey: .deliveryAddress)
        deliveryAddress = deliveryAddressDecoded
        let deferActivationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deferActivation)
        deferActivation = deferActivationDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateContactChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateContactChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactChannelArn = output.contactChannelArn
        } else {
            self.contactChannelArn = nil
        }
    }
}

public struct CreateContactChannelOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact channel.
    /// This member is required.
    public var contactChannelArn: Swift.String?

    public init(
        contactChannelArn: Swift.String? = nil
    )
    {
        self.contactChannelArn = contactChannelArn
    }
}

struct CreateContactChannelOutputBody: Swift.Equatable {
    let contactChannelArn: Swift.String?
}

extension CreateContactChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelArn = "ContactChannelArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelArn)
        contactChannelArn = contactChannelArnDecoded
    }
}

enum CreateContactChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DataEncryptionException": return try await DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case displayName = "DisplayName"
        case idempotencyToken = "IdempotencyToken"
        case plan = "Plan"
        case tags = "Tags"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let plan = self.plan {
            try encodeContainer.encode(plan, forKey: .plan)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateContactInput: Swift.Equatable {
    /// The short name to quickly identify a contact or escalation plan. The contact alias must be unique and identifiable.
    /// This member is required.
    public var alias: Swift.String?
    /// The full name of the contact or escalation plan.
    public var displayName: Swift.String?
    /// A token ensuring that the operation is called only once with the specified details.
    public var idempotencyToken: Swift.String?
    /// A list of stages. A contact has an engagement plan with stages that contact specified contact channels. An escalation plan uses stages that contact specified contacts.
    /// This member is required.
    public var plan: SSMContactsClientTypes.Plan?
    /// Adds a tag to the target. You can only tag resources created in the first Region of your replication set.
    public var tags: [SSMContactsClientTypes.Tag]?
    /// To create an escalation plan use ESCALATION. To create a contact use PERSONAL.
    /// This member is required.
    public var type: SSMContactsClientTypes.ContactType?

    public init(
        alias: Swift.String? = nil,
        displayName: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        plan: SSMContactsClientTypes.Plan? = nil,
        tags: [SSMContactsClientTypes.Tag]? = nil,
        type: SSMContactsClientTypes.ContactType? = nil
    )
    {
        self.alias = alias
        self.displayName = displayName
        self.idempotencyToken = idempotencyToken
        self.plan = plan
        self.tags = tags
        self.type = type
    }
}

struct CreateContactInputBody: Swift.Equatable {
    let alias: Swift.String?
    let displayName: Swift.String?
    let type: SSMContactsClientTypes.ContactType?
    let plan: SSMContactsClientTypes.Plan?
    let tags: [SSMContactsClientTypes.Tag]?
    let idempotencyToken: Swift.String?
}

extension CreateContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case displayName = "DisplayName"
        case idempotencyToken = "IdempotencyToken"
        case plan = "Plan"
        case tags = "Tags"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.ContactType.self, forKey: .type)
        type = typeDecoded
        let planDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.Plan.self, forKey: .plan)
        plan = planDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SSMContactsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SSMContactsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateContactOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactArn = output.contactArn
        } else {
            self.contactArn = nil
        }
    }
}

public struct CreateContactOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created contact or escalation plan.
    /// This member is required.
    public var contactArn: Swift.String?

    public init(
        contactArn: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

struct CreateContactOutputBody: Swift.Equatable {
    let contactArn: Swift.String?
}

extension CreateContactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

enum CreateContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DataEncryptionException": return try await DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRotationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactIds = "ContactIds"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
        case recurrence = "Recurrence"
        case startTime = "StartTime"
        case tags = "Tags"
        case timeZoneId = "TimeZoneId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactIds = contactIds {
            var contactIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contactIds)
            for ssmcontactsarn0 in contactIds {
                try contactIdsContainer.encode(ssmcontactsarn0)
            }
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recurrence = self.recurrence {
            try encodeContainer.encode(recurrence, forKey: .recurrence)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let timeZoneId = self.timeZoneId {
            try encodeContainer.encode(timeZoneId, forKey: .timeZoneId)
        }
    }
}

extension CreateRotationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateRotationInput: Swift.Equatable {
    /// The Amazon Resource Names (ARNs) of the contacts to add to the rotation. The order that you list the contacts in is their shift order in the rotation schedule. To change the order of the contact's shifts, use the [UpdateRotation] operation.
    /// This member is required.
    public var contactIds: [Swift.String]?
    /// A token that ensures that the operation is called only once with the specified details.
    public var idempotencyToken: Swift.String?
    /// The name of the rotation.
    /// This member is required.
    public var name: Swift.String?
    /// Information about the rule that specifies when a shift's team members rotate.
    /// This member is required.
    public var recurrence: SSMContactsClientTypes.RecurrenceSettings?
    /// The date and time that the rotation goes into effect.
    public var startTime: ClientRuntime.Date?
    /// Optional metadata to assign to the rotation. Tags enable you to categorize a resource in different ways, such as by purpose, owner, or environment. For more information, see [Tagging Incident Manager resources](https://docs.aws.amazon.com/incident-manager/latest/userguide/tagging.html) in the Incident Manager User Guide.
    public var tags: [SSMContactsClientTypes.Tag]?
    /// The time zone to base the rotation’s activity on in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul". For more information, see the [Time Zone Database](https://www.iana.org/time-zones) on the IANA website. Designators for time zones that don’t support Daylight Savings Time rules, such as Pacific Standard Time (PST) and Pacific Daylight Time (PDT), are not supported.
    /// This member is required.
    public var timeZoneId: Swift.String?

    public init(
        contactIds: [Swift.String]? = nil,
        idempotencyToken: Swift.String? = nil,
        name: Swift.String? = nil,
        recurrence: SSMContactsClientTypes.RecurrenceSettings? = nil,
        startTime: ClientRuntime.Date? = nil,
        tags: [SSMContactsClientTypes.Tag]? = nil,
        timeZoneId: Swift.String? = nil
    )
    {
        self.contactIds = contactIds
        self.idempotencyToken = idempotencyToken
        self.name = name
        self.recurrence = recurrence
        self.startTime = startTime
        self.tags = tags
        self.timeZoneId = timeZoneId
    }
}

struct CreateRotationInputBody: Swift.Equatable {
    let name: Swift.String?
    let contactIds: [Swift.String]?
    let startTime: ClientRuntime.Date?
    let timeZoneId: Swift.String?
    let recurrence: SSMContactsClientTypes.RecurrenceSettings?
    let tags: [SSMContactsClientTypes.Tag]?
    let idempotencyToken: Swift.String?
}

extension CreateRotationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactIds = "ContactIds"
        case idempotencyToken = "IdempotencyToken"
        case name = "Name"
        case recurrence = "Recurrence"
        case startTime = "StartTime"
        case tags = "Tags"
        case timeZoneId = "TimeZoneId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contactIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .contactIds)
        var contactIdsDecoded0:[Swift.String]? = nil
        if let contactIdsContainer = contactIdsContainer {
            contactIdsDecoded0 = [Swift.String]()
            for string0 in contactIdsContainer {
                if let string0 = string0 {
                    contactIdsDecoded0?.append(string0)
                }
            }
        }
        contactIds = contactIdsDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let timeZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZoneId)
        timeZoneId = timeZoneIdDecoded
        let recurrenceDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.RecurrenceSettings.self, forKey: .recurrence)
        recurrence = recurrenceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SSMContactsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SSMContactsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateRotationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRotationOutputBody = try responseDecoder.decode(responseBody: data)
            self.rotationArn = output.rotationArn
        } else {
            self.rotationArn = nil
        }
    }
}

public struct CreateRotationOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created rotation.
    /// This member is required.
    public var rotationArn: Swift.String?

    public init(
        rotationArn: Swift.String? = nil
    )
    {
        self.rotationArn = rotationArn
    }
}

struct CreateRotationOutputBody: Swift.Equatable {
    let rotationArn: Swift.String?
}

extension CreateRotationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rotationArn = "RotationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationArn)
        rotationArn = rotationArnDecoded
    }
}

enum CreateRotationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRotationOverrideInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case idempotencyToken = "IdempotencyToken"
        case newContactIds = "NewContactIds"
        case rotationId = "RotationId"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let newContactIds = newContactIds {
            var newContactIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .newContactIds)
            for ssmcontactsarn0 in newContactIds {
                try newContactIdsContainer.encode(ssmcontactsarn0)
            }
        }
        if let rotationId = self.rotationId {
            try encodeContainer.encode(rotationId, forKey: .rotationId)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension CreateRotationOverrideInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateRotationOverrideInput: Swift.Equatable {
    /// The date and time when the override ends.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// A token that ensures that the operation is called only once with the specified details.
    public var idempotencyToken: Swift.String?
    /// The Amazon Resource Names (ARNs) of the contacts to replace those in the current on-call rotation with. If you want to include any current team members in the override shift, you must include their ARNs in the new contact ID list.
    /// This member is required.
    public var newContactIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the rotation to create an override for.
    /// This member is required.
    public var rotationId: Swift.String?
    /// The date and time when the override goes into effect.
    /// This member is required.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        idempotencyToken: Swift.String? = nil,
        newContactIds: [Swift.String]? = nil,
        rotationId: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.idempotencyToken = idempotencyToken
        self.newContactIds = newContactIds
        self.rotationId = rotationId
        self.startTime = startTime
    }
}

struct CreateRotationOverrideInputBody: Swift.Equatable {
    let rotationId: Swift.String?
    let newContactIds: [Swift.String]?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let idempotencyToken: Swift.String?
}

extension CreateRotationOverrideInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case idempotencyToken = "IdempotencyToken"
        case newContactIds = "NewContactIds"
        case rotationId = "RotationId"
        case startTime = "StartTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationId)
        rotationId = rotationIdDecoded
        let newContactIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .newContactIds)
        var newContactIdsDecoded0:[Swift.String]? = nil
        if let newContactIdsContainer = newContactIdsContainer {
            newContactIdsDecoded0 = [Swift.String]()
            for string0 in newContactIdsContainer {
                if let string0 = string0 {
                    newContactIdsDecoded0?.append(string0)
                }
            }
        }
        newContactIds = newContactIdsDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension CreateRotationOverrideOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRotationOverrideOutputBody = try responseDecoder.decode(responseBody: data)
            self.rotationOverrideId = output.rotationOverrideId
        } else {
            self.rotationOverrideId = nil
        }
    }
}

public struct CreateRotationOverrideOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created rotation override.
    /// This member is required.
    public var rotationOverrideId: Swift.String?

    public init(
        rotationOverrideId: Swift.String? = nil
    )
    {
        self.rotationOverrideId = rotationOverrideId
    }
}

struct CreateRotationOverrideOutputBody: Swift.Equatable {
    let rotationOverrideId: Swift.String?
}

extension CreateRotationOverrideOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rotationOverrideId = "RotationOverrideId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationOverrideIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationOverrideId)
        rotationOverrideId = rotationOverrideIdDecoded
    }
}

enum CreateRotationOverrideOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DataEncryptionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DataEncryptionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed to due an encryption key error.
public struct DataEncryptionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DataEncryptionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DataEncryptionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DataEncryptionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SSMContactsClientTypes {
    public enum DayOfWeek: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fri
        case mon
        case sat
        case sun
        case thu
        case tue
        case wed
        case sdkUnknown(Swift.String)

        public static var allCases: [DayOfWeek] {
            return [
                .fri,
                .mon,
                .sat,
                .sun,
                .thu,
                .tue,
                .wed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fri: return "FRI"
            case .mon: return "MON"
            case .sat: return "SAT"
            case .sun: return "SUN"
            case .thu: return "THU"
            case .tue: return "TUE"
            case .wed: return "WED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DayOfWeek(rawValue: rawValue) ?? DayOfWeek.sdkUnknown(rawValue)
        }
    }
}

extension DeactivateContactChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = self.contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
    }
}

extension DeactivateContactChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeactivateContactChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact channel you're deactivating.
    /// This member is required.
    public var contactChannelId: Swift.String?

    public init(
        contactChannelId: Swift.String? = nil
    )
    {
        self.contactChannelId = contactChannelId
    }
}

struct DeactivateContactChannelInputBody: Swift.Equatable {
    let contactChannelId: Swift.String?
}

extension DeactivateContactChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
    }
}

extension DeactivateContactChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeactivateContactChannelOutput: Swift.Equatable {

    public init() { }
}

enum DeactivateContactChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteContactChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = self.contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
    }
}

extension DeleteContactChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteContactChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact channel.
    /// This member is required.
    public var contactChannelId: Swift.String?

    public init(
        contactChannelId: Swift.String? = nil
    )
    {
        self.contactChannelId = contactChannelId
    }
}

struct DeleteContactChannelInputBody: Swift.Equatable {
    let contactChannelId: Swift.String?
}

extension DeleteContactChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
    }
}

extension DeleteContactChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteContactChannelOutput: Swift.Equatable {

    public init() { }
}

enum DeleteContactChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
    }
}

extension DeleteContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteContactInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact that you're deleting.
    /// This member is required.
    public var contactId: Swift.String?

    public init(
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct DeleteContactInputBody: Swift.Equatable {
    let contactId: Swift.String?
}

extension DeleteContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

extension DeleteContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteContactOutput: Swift.Equatable {

    public init() { }
}

enum DeleteContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRotationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rotationId = "RotationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rotationId = self.rotationId {
            try encodeContainer.encode(rotationId, forKey: .rotationId)
        }
    }
}

extension DeleteRotationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRotationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the on-call rotation to delete.
    /// This member is required.
    public var rotationId: Swift.String?

    public init(
        rotationId: Swift.String? = nil
    )
    {
        self.rotationId = rotationId
    }
}

struct DeleteRotationInputBody: Swift.Equatable {
    let rotationId: Swift.String?
}

extension DeleteRotationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rotationId = "RotationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationId)
        rotationId = rotationIdDecoded
    }
}

extension DeleteRotationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRotationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRotationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRotationOverrideInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rotationId = "RotationId"
        case rotationOverrideId = "RotationOverrideId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rotationId = self.rotationId {
            try encodeContainer.encode(rotationId, forKey: .rotationId)
        }
        if let rotationOverrideId = self.rotationOverrideId {
            try encodeContainer.encode(rotationOverrideId, forKey: .rotationOverrideId)
        }
    }
}

extension DeleteRotationOverrideInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRotationOverrideInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the rotation that was overridden.
    /// This member is required.
    public var rotationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the on-call rotation override to delete.
    /// This member is required.
    public var rotationOverrideId: Swift.String?

    public init(
        rotationId: Swift.String? = nil,
        rotationOverrideId: Swift.String? = nil
    )
    {
        self.rotationId = rotationId
        self.rotationOverrideId = rotationOverrideId
    }
}

struct DeleteRotationOverrideInputBody: Swift.Equatable {
    let rotationId: Swift.String?
    let rotationOverrideId: Swift.String?
}

extension DeleteRotationOverrideInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rotationId = "RotationId"
        case rotationOverrideId = "RotationOverrideId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationId)
        rotationId = rotationIdDecoded
        let rotationOverrideIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationOverrideId)
        rotationOverrideId = rotationOverrideIdDecoded
    }
}

extension DeleteRotationOverrideOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRotationOverrideOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRotationOverrideOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSMContactsClientTypes.DependentEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dependentResourceIds = "DependentResourceIds"
        case relationType = "RelationType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dependentResourceIds = dependentResourceIds {
            var dependentResourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dependentResourceIds)
            for ssmcontactsarn0 in dependentResourceIds {
                try dependentResourceIdsContainer.encode(ssmcontactsarn0)
            }
        }
        if let relationType = self.relationType {
            try encodeContainer.encode(relationType, forKey: .relationType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let relationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relationType)
        relationType = relationTypeDecoded
        let dependentResourceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dependentResourceIds)
        var dependentResourceIdsDecoded0:[Swift.String]? = nil
        if let dependentResourceIdsContainer = dependentResourceIdsContainer {
            dependentResourceIdsDecoded0 = [Swift.String]()
            for string0 in dependentResourceIdsContainer {
                if let string0 = string0 {
                    dependentResourceIdsDecoded0?.append(string0)
                }
            }
        }
        dependentResourceIds = dependentResourceIdsDecoded0
    }
}

extension SSMContactsClientTypes {
    /// Information about a resource that another resource is related to or depends on. For example, if a contact is a member of a rotation, the rotation is a dependent entity of the contact.
    public struct DependentEntity: Swift.Equatable {
        /// The Amazon Resource Names (ARNs) of the dependent resources.
        /// This member is required.
        public var dependentResourceIds: [Swift.String]?
        /// The type of relationship between one resource and the other resource that it is related to or depends on.
        /// This member is required.
        public var relationType: Swift.String?

        public init(
            dependentResourceIds: [Swift.String]? = nil,
            relationType: Swift.String? = nil
        )
        {
            self.dependentResourceIds = dependentResourceIds
            self.relationType = relationType
        }
    }

}

extension DescribeEngagementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementId = "EngagementId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engagementId = self.engagementId {
            try encodeContainer.encode(engagementId, forKey: .engagementId)
        }
    }
}

extension DescribeEngagementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEngagementInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the engagement you want the details of.
    /// This member is required.
    public var engagementId: Swift.String?

    public init(
        engagementId: Swift.String? = nil
    )
    {
        self.engagementId = engagementId
    }
}

struct DescribeEngagementInputBody: Swift.Equatable {
    let engagementId: Swift.String?
}

extension DescribeEngagementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementId = "EngagementId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engagementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementId)
        engagementId = engagementIdDecoded
    }
}

extension DescribeEngagementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEngagementOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactArn = output.contactArn
            self.content = output.content
            self.engagementArn = output.engagementArn
            self.incidentId = output.incidentId
            self.publicContent = output.publicContent
            self.publicSubject = output.publicSubject
            self.sender = output.sender
            self.startTime = output.startTime
            self.stopTime = output.stopTime
            self.subject = output.subject
        } else {
            self.contactArn = nil
            self.content = nil
            self.engagementArn = nil
            self.incidentId = nil
            self.publicContent = nil
            self.publicSubject = nil
            self.sender = nil
            self.startTime = nil
            self.stopTime = nil
            self.subject = nil
        }
    }
}

public struct DescribeEngagementOutput: Swift.Equatable {
    /// The ARN of the escalation plan or contacts involved in the engagement.
    /// This member is required.
    public var contactArn: Swift.String?
    /// The secure content of the message that was sent to the contact. Use this field for engagements to VOICE and EMAIL.
    /// This member is required.
    public var content: Swift.String?
    /// The ARN of the engagement.
    /// This member is required.
    public var engagementArn: Swift.String?
    /// The ARN of the incident in which the engagement occurred.
    public var incidentId: Swift.String?
    /// The insecure content of the message that was sent to the contact. Use this field for engagements to SMS.
    public var publicContent: Swift.String?
    /// The insecure subject of the message that was sent to the contact. Use this field for engagements to SMS.
    public var publicSubject: Swift.String?
    /// The user that started the engagement.
    /// This member is required.
    public var sender: Swift.String?
    /// The time that the engagement started.
    public var startTime: ClientRuntime.Date?
    /// The time that the engagement ended.
    public var stopTime: ClientRuntime.Date?
    /// The secure subject of the message that was sent to the contact. Use this field for engagements to VOICE and EMAIL.
    /// This member is required.
    public var subject: Swift.String?

    public init(
        contactArn: Swift.String? = nil,
        content: Swift.String? = nil,
        engagementArn: Swift.String? = nil,
        incidentId: Swift.String? = nil,
        publicContent: Swift.String? = nil,
        publicSubject: Swift.String? = nil,
        sender: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        stopTime: ClientRuntime.Date? = nil,
        subject: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.content = content
        self.engagementArn = engagementArn
        self.incidentId = incidentId
        self.publicContent = publicContent
        self.publicSubject = publicSubject
        self.sender = sender
        self.startTime = startTime
        self.stopTime = stopTime
        self.subject = subject
    }
}

struct DescribeEngagementOutputBody: Swift.Equatable {
    let contactArn: Swift.String?
    let engagementArn: Swift.String?
    let sender: Swift.String?
    let subject: Swift.String?
    let content: Swift.String?
    let publicSubject: Swift.String?
    let publicContent: Swift.String?
    let incidentId: Swift.String?
    let startTime: ClientRuntime.Date?
    let stopTime: ClientRuntime.Date?
}

extension DescribeEngagementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case content = "Content"
        case engagementArn = "EngagementArn"
        case incidentId = "IncidentId"
        case publicContent = "PublicContent"
        case publicSubject = "PublicSubject"
        case sender = "Sender"
        case startTime = "StartTime"
        case stopTime = "StopTime"
        case subject = "Subject"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let engagementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementArn)
        engagementArn = engagementArnDecoded
        let senderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sender)
        sender = senderDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let publicSubjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicSubject)
        publicSubject = publicSubjectDecoded
        let publicContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicContent)
        publicContent = publicContentDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stopTime)
        stopTime = stopTimeDecoded
    }
}

enum DescribeEngagementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DataEncryptionException": return try await DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pageId = "PageId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pageId = self.pageId {
            try encodeContainer.encode(pageId, forKey: .pageId)
        }
    }
}

extension DescribePageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePageInput: Swift.Equatable {
    /// The ID of the engagement to a contact channel.
    /// This member is required.
    public var pageId: Swift.String?

    public init(
        pageId: Swift.String? = nil
    )
    {
        self.pageId = pageId
    }
}

struct DescribePageInputBody: Swift.Equatable {
    let pageId: Swift.String?
}

extension DescribePageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pageId = "PageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageId)
        pageId = pageIdDecoded
    }
}

extension DescribePageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePageOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactArn = output.contactArn
            self.content = output.content
            self.deliveryTime = output.deliveryTime
            self.engagementArn = output.engagementArn
            self.incidentId = output.incidentId
            self.pageArn = output.pageArn
            self.publicContent = output.publicContent
            self.publicSubject = output.publicSubject
            self.readTime = output.readTime
            self.sender = output.sender
            self.sentTime = output.sentTime
            self.subject = output.subject
        } else {
            self.contactArn = nil
            self.content = nil
            self.deliveryTime = nil
            self.engagementArn = nil
            self.incidentId = nil
            self.pageArn = nil
            self.publicContent = nil
            self.publicSubject = nil
            self.readTime = nil
            self.sender = nil
            self.sentTime = nil
            self.subject = nil
        }
    }
}

public struct DescribePageOutput: Swift.Equatable {
    /// The ARN of the contact that was engaged.
    /// This member is required.
    public var contactArn: Swift.String?
    /// The secure content of the message that was sent to the contact. Use this field for engagements to VOICE and EMAIL.
    /// This member is required.
    public var content: Swift.String?
    /// The time that the contact channel received the engagement.
    public var deliveryTime: ClientRuntime.Date?
    /// The ARN of the engagement that engaged the contact channel.
    /// This member is required.
    public var engagementArn: Swift.String?
    /// The ARN of the incident that engaged the contact channel.
    public var incidentId: Swift.String?
    /// The Amazon Resource Name (ARN) of the engagement to a contact channel.
    /// This member is required.
    public var pageArn: Swift.String?
    /// The insecure content of the message that was sent to the contact. Use this field for engagements to SMS.
    public var publicContent: Swift.String?
    /// The insecure subject of the message that was sent to the contact. Use this field for engagements to SMS.
    public var publicSubject: Swift.String?
    /// The time that the contact channel acknowledged the engagement.
    public var readTime: ClientRuntime.Date?
    /// The user that started the engagement.
    /// This member is required.
    public var sender: Swift.String?
    /// The time the engagement was sent to the contact channel.
    public var sentTime: ClientRuntime.Date?
    /// The secure subject of the message that was sent to the contact. Use this field for engagements to VOICE and EMAIL.
    /// This member is required.
    public var subject: Swift.String?

    public init(
        contactArn: Swift.String? = nil,
        content: Swift.String? = nil,
        deliveryTime: ClientRuntime.Date? = nil,
        engagementArn: Swift.String? = nil,
        incidentId: Swift.String? = nil,
        pageArn: Swift.String? = nil,
        publicContent: Swift.String? = nil,
        publicSubject: Swift.String? = nil,
        readTime: ClientRuntime.Date? = nil,
        sender: Swift.String? = nil,
        sentTime: ClientRuntime.Date? = nil,
        subject: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.content = content
        self.deliveryTime = deliveryTime
        self.engagementArn = engagementArn
        self.incidentId = incidentId
        self.pageArn = pageArn
        self.publicContent = publicContent
        self.publicSubject = publicSubject
        self.readTime = readTime
        self.sender = sender
        self.sentTime = sentTime
        self.subject = subject
    }
}

struct DescribePageOutputBody: Swift.Equatable {
    let pageArn: Swift.String?
    let engagementArn: Swift.String?
    let contactArn: Swift.String?
    let sender: Swift.String?
    let subject: Swift.String?
    let content: Swift.String?
    let publicSubject: Swift.String?
    let publicContent: Swift.String?
    let incidentId: Swift.String?
    let sentTime: ClientRuntime.Date?
    let readTime: ClientRuntime.Date?
    let deliveryTime: ClientRuntime.Date?
}

extension DescribePageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case content = "Content"
        case deliveryTime = "DeliveryTime"
        case engagementArn = "EngagementArn"
        case incidentId = "IncidentId"
        case pageArn = "PageArn"
        case publicContent = "PublicContent"
        case publicSubject = "PublicSubject"
        case readTime = "ReadTime"
        case sender = "Sender"
        case sentTime = "SentTime"
        case subject = "Subject"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageArn)
        pageArn = pageArnDecoded
        let engagementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementArn)
        engagementArn = engagementArnDecoded
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let senderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sender)
        sender = senderDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let publicSubjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicSubject)
        publicSubject = publicSubjectDecoded
        let publicContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicContent)
        publicContent = publicContentDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let sentTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .sentTime)
        sentTime = sentTimeDecoded
        let readTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .readTime)
        readTime = readTimeDecoded
        let deliveryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deliveryTime)
        deliveryTime = deliveryTimeDecoded
    }
}

enum DescribePageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DataEncryptionException": return try await DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSMContactsClientTypes.Engagement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case engagementArn = "EngagementArn"
        case incidentId = "IncidentId"
        case sender = "Sender"
        case startTime = "StartTime"
        case stopTime = "StopTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let engagementArn = self.engagementArn {
            try encodeContainer.encode(engagementArn, forKey: .engagementArn)
        }
        if let incidentId = self.incidentId {
            try encodeContainer.encode(incidentId, forKey: .incidentId)
        }
        if let sender = self.sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let stopTime = self.stopTime {
            try encodeContainer.encodeTimestamp(stopTime, format: .epochSeconds, forKey: .stopTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engagementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementArn)
        engagementArn = engagementArnDecoded
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let senderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sender)
        sender = senderDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let stopTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .stopTime)
        stopTime = stopTimeDecoded
    }
}

extension SSMContactsClientTypes {
    /// Incident Manager reaching out to a contact or escalation plan to engage contact during an incident.
    public struct Engagement: Swift.Equatable {
        /// The ARN of the escalation plan or contact that Incident Manager is engaging.
        /// This member is required.
        public var contactArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the engagement.
        /// This member is required.
        public var engagementArn: Swift.String?
        /// The ARN of the incident that's engaging the contact.
        public var incidentId: Swift.String?
        /// The user that started the engagement.
        /// This member is required.
        public var sender: Swift.String?
        /// The time that the engagement began.
        public var startTime: ClientRuntime.Date?
        /// The time that the engagement ended.
        public var stopTime: ClientRuntime.Date?

        public init(
            contactArn: Swift.String? = nil,
            engagementArn: Swift.String? = nil,
            incidentId: Swift.String? = nil,
            sender: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            stopTime: ClientRuntime.Date? = nil
        )
        {
            self.contactArn = contactArn
            self.engagementArn = engagementArn
            self.incidentId = incidentId
            self.sender = sender
            self.startTime = startTime
            self.stopTime = stopTime
        }
    }

}

extension GetContactChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = self.contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
    }
}

extension GetContactChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetContactChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact channel you want information about.
    /// This member is required.
    public var contactChannelId: Swift.String?

    public init(
        contactChannelId: Swift.String? = nil
    )
    {
        self.contactChannelId = contactChannelId
    }
}

struct GetContactChannelInputBody: Swift.Equatable {
    let contactChannelId: Swift.String?
}

extension GetContactChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
    }
}

extension GetContactChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetContactChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.activationStatus = output.activationStatus
            self.contactArn = output.contactArn
            self.contactChannelArn = output.contactChannelArn
            self.deliveryAddress = output.deliveryAddress
            self.name = output.name
            self.type = output.type
        } else {
            self.activationStatus = nil
            self.contactArn = nil
            self.contactChannelArn = nil
            self.deliveryAddress = nil
            self.name = nil
            self.type = nil
        }
    }
}

public struct GetContactChannelOutput: Swift.Equatable {
    /// A Boolean value indicating if the contact channel has been activated or not.
    public var activationStatus: SSMContactsClientTypes.ActivationStatus?
    /// The ARN of the contact that the channel belongs to.
    /// This member is required.
    public var contactArn: Swift.String?
    /// The ARN of the contact channel.
    /// This member is required.
    public var contactChannelArn: Swift.String?
    /// The details that Incident Manager uses when trying to engage the contact channel.
    /// This member is required.
    public var deliveryAddress: SSMContactsClientTypes.ContactChannelAddress?
    /// The name of the contact channel
    /// This member is required.
    public var name: Swift.String?
    /// The type of contact channel. The type is SMS, VOICE, or EMAIL.
    /// This member is required.
    public var type: SSMContactsClientTypes.ChannelType?

    public init(
        activationStatus: SSMContactsClientTypes.ActivationStatus? = nil,
        contactArn: Swift.String? = nil,
        contactChannelArn: Swift.String? = nil,
        deliveryAddress: SSMContactsClientTypes.ContactChannelAddress? = nil,
        name: Swift.String? = nil,
        type: SSMContactsClientTypes.ChannelType? = nil
    )
    {
        self.activationStatus = activationStatus
        self.contactArn = contactArn
        self.contactChannelArn = contactChannelArn
        self.deliveryAddress = deliveryAddress
        self.name = name
        self.type = type
    }
}

struct GetContactChannelOutputBody: Swift.Equatable {
    let contactArn: Swift.String?
    let contactChannelArn: Swift.String?
    let name: Swift.String?
    let type: SSMContactsClientTypes.ChannelType?
    let deliveryAddress: SSMContactsClientTypes.ContactChannelAddress?
    let activationStatus: SSMContactsClientTypes.ActivationStatus?
}

extension GetContactChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationStatus = "ActivationStatus"
        case contactArn = "ContactArn"
        case contactChannelArn = "ContactChannelArn"
        case deliveryAddress = "DeliveryAddress"
        case name = "Name"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let contactChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelArn)
        contactChannelArn = contactChannelArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.ChannelType.self, forKey: .type)
        type = typeDecoded
        let deliveryAddressDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.ContactChannelAddress.self, forKey: .deliveryAddress)
        deliveryAddress = deliveryAddressDecoded
        let activationStatusDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.ActivationStatus.self, forKey: .activationStatus)
        activationStatus = activationStatusDecoded
    }
}

enum GetContactChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DataEncryptionException": return try await DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
    }
}

extension GetContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetContactInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public var contactId: Swift.String?

    public init(
        contactId: Swift.String? = nil
    )
    {
        self.contactId = contactId
    }
}

struct GetContactInputBody: Swift.Equatable {
    let contactId: Swift.String?
}

extension GetContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

extension GetContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetContactOutputBody = try responseDecoder.decode(responseBody: data)
            self.alias = output.alias
            self.contactArn = output.contactArn
            self.displayName = output.displayName
            self.plan = output.plan
            self.type = output.type
        } else {
            self.alias = nil
            self.contactArn = nil
            self.displayName = nil
            self.plan = nil
            self.type = nil
        }
    }
}

public struct GetContactOutput: Swift.Equatable {
    /// The alias of the contact or escalation plan. The alias is unique and identifiable.
    /// This member is required.
    public var alias: Swift.String?
    /// The ARN of the contact or escalation plan.
    /// This member is required.
    public var contactArn: Swift.String?
    /// The full name of the contact or escalation plan.
    public var displayName: Swift.String?
    /// Details about the specific timing or stages and targets of the escalation plan or engagement plan.
    /// This member is required.
    public var plan: SSMContactsClientTypes.Plan?
    /// The type of contact, either PERSONAL or ESCALATION.
    /// This member is required.
    public var type: SSMContactsClientTypes.ContactType?

    public init(
        alias: Swift.String? = nil,
        contactArn: Swift.String? = nil,
        displayName: Swift.String? = nil,
        plan: SSMContactsClientTypes.Plan? = nil,
        type: SSMContactsClientTypes.ContactType? = nil
    )
    {
        self.alias = alias
        self.contactArn = contactArn
        self.displayName = displayName
        self.plan = plan
        self.type = type
    }
}

struct GetContactOutputBody: Swift.Equatable {
    let contactArn: Swift.String?
    let alias: Swift.String?
    let displayName: Swift.String?
    let type: SSMContactsClientTypes.ContactType?
    let plan: SSMContactsClientTypes.Plan?
}

extension GetContactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias = "Alias"
        case contactArn = "ContactArn"
        case displayName = "DisplayName"
        case plan = "Plan"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.ContactType.self, forKey: .type)
        type = typeDecoded
        let planDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.Plan.self, forKey: .plan)
        plan = planDecoded
    }
}

enum GetContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DataEncryptionException": return try await DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetContactPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
    }
}

extension GetContactPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetContactPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public var contactArn: Swift.String?

    public init(
        contactArn: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
    }
}

struct GetContactPolicyInputBody: Swift.Equatable {
    let contactArn: Swift.String?
}

extension GetContactPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
    }
}

extension GetContactPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetContactPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactArn = output.contactArn
            self.policy = output.policy
        } else {
            self.contactArn = nil
            self.policy = nil
        }
    }
}

public struct GetContactPolicyOutput: Swift.Equatable {
    /// The ARN of the contact or escalation plan.
    public var contactArn: Swift.String?
    /// Details about the resource policy attached to the contact or escalation plan.
    public var policy: Swift.String?

    public init(
        contactArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.policy = policy
    }
}

struct GetContactPolicyOutputBody: Swift.Equatable {
    let contactArn: Swift.String?
    let policy: Swift.String?
}

extension GetContactPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

enum GetContactPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRotationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rotationId = "RotationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rotationId = self.rotationId {
            try encodeContainer.encode(rotationId, forKey: .rotationId)
        }
    }
}

extension GetRotationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRotationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the on-call rotation to retrieve information about.
    /// This member is required.
    public var rotationId: Swift.String?

    public init(
        rotationId: Swift.String? = nil
    )
    {
        self.rotationId = rotationId
    }
}

struct GetRotationInputBody: Swift.Equatable {
    let rotationId: Swift.String?
}

extension GetRotationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rotationId = "RotationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationId)
        rotationId = rotationIdDecoded
    }
}

extension GetRotationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRotationOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactIds = output.contactIds
            self.name = output.name
            self.recurrence = output.recurrence
            self.rotationArn = output.rotationArn
            self.startTime = output.startTime
            self.timeZoneId = output.timeZoneId
        } else {
            self.contactIds = nil
            self.name = nil
            self.recurrence = nil
            self.rotationArn = nil
            self.startTime = nil
            self.timeZoneId = nil
        }
    }
}

public struct GetRotationOutput: Swift.Equatable {
    /// The Amazon Resource Names (ARNs) of the contacts assigned to the on-call rotation team.
    /// This member is required.
    public var contactIds: [Swift.String]?
    /// The name of the on-call rotation.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies how long a rotation lasts before restarting at the beginning of the shift order.
    /// This member is required.
    public var recurrence: SSMContactsClientTypes.RecurrenceSettings?
    /// The Amazon Resource Name (ARN) of the on-call rotation.
    /// This member is required.
    public var rotationArn: Swift.String?
    /// The specified start time for the on-call rotation.
    /// This member is required.
    public var startTime: ClientRuntime.Date?
    /// The time zone that the rotation’s activity is based on, in Internet Assigned Numbers Authority (IANA) format.
    /// This member is required.
    public var timeZoneId: Swift.String?

    public init(
        contactIds: [Swift.String]? = nil,
        name: Swift.String? = nil,
        recurrence: SSMContactsClientTypes.RecurrenceSettings? = nil,
        rotationArn: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        timeZoneId: Swift.String? = nil
    )
    {
        self.contactIds = contactIds
        self.name = name
        self.recurrence = recurrence
        self.rotationArn = rotationArn
        self.startTime = startTime
        self.timeZoneId = timeZoneId
    }
}

struct GetRotationOutputBody: Swift.Equatable {
    let rotationArn: Swift.String?
    let name: Swift.String?
    let contactIds: [Swift.String]?
    let startTime: ClientRuntime.Date?
    let timeZoneId: Swift.String?
    let recurrence: SSMContactsClientTypes.RecurrenceSettings?
}

extension GetRotationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactIds = "ContactIds"
        case name = "Name"
        case recurrence = "Recurrence"
        case rotationArn = "RotationArn"
        case startTime = "StartTime"
        case timeZoneId = "TimeZoneId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationArn)
        rotationArn = rotationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contactIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .contactIds)
        var contactIdsDecoded0:[Swift.String]? = nil
        if let contactIdsContainer = contactIdsContainer {
            contactIdsDecoded0 = [Swift.String]()
            for string0 in contactIdsContainer {
                if let string0 = string0 {
                    contactIdsDecoded0?.append(string0)
                }
            }
        }
        contactIds = contactIdsDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let timeZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZoneId)
        timeZoneId = timeZoneIdDecoded
        let recurrenceDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.RecurrenceSettings.self, forKey: .recurrence)
        recurrence = recurrenceDecoded
    }
}

enum GetRotationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRotationOverrideInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rotationId = "RotationId"
        case rotationOverrideId = "RotationOverrideId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rotationId = self.rotationId {
            try encodeContainer.encode(rotationId, forKey: .rotationId)
        }
        if let rotationOverrideId = self.rotationOverrideId {
            try encodeContainer.encode(rotationOverrideId, forKey: .rotationOverrideId)
        }
    }
}

extension GetRotationOverrideInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRotationOverrideInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the overridden rotation to retrieve information about.
    /// This member is required.
    public var rotationId: Swift.String?
    /// The Amazon Resource Name (ARN) of the on-call rotation override to retrieve information about.
    /// This member is required.
    public var rotationOverrideId: Swift.String?

    public init(
        rotationId: Swift.String? = nil,
        rotationOverrideId: Swift.String? = nil
    )
    {
        self.rotationId = rotationId
        self.rotationOverrideId = rotationOverrideId
    }
}

struct GetRotationOverrideInputBody: Swift.Equatable {
    let rotationId: Swift.String?
    let rotationOverrideId: Swift.String?
}

extension GetRotationOverrideInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rotationId = "RotationId"
        case rotationOverrideId = "RotationOverrideId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationId)
        rotationId = rotationIdDecoded
        let rotationOverrideIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationOverrideId)
        rotationOverrideId = rotationOverrideIdDecoded
    }
}

extension GetRotationOverrideOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRotationOverrideOutputBody = try responseDecoder.decode(responseBody: data)
            self.createTime = output.createTime
            self.endTime = output.endTime
            self.newContactIds = output.newContactIds
            self.rotationArn = output.rotationArn
            self.rotationOverrideId = output.rotationOverrideId
            self.startTime = output.startTime
        } else {
            self.createTime = nil
            self.endTime = nil
            self.newContactIds = nil
            self.rotationArn = nil
            self.rotationOverrideId = nil
            self.startTime = nil
        }
    }
}

public struct GetRotationOverrideOutput: Swift.Equatable {
    /// The date and time when the override was created.
    public var createTime: ClientRuntime.Date?
    /// The date and time when the override ends.
    public var endTime: ClientRuntime.Date?
    /// The Amazon Resource Names (ARNs) of the contacts assigned to the override of the on-call rotation.
    public var newContactIds: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the on-call rotation that was overridden.
    public var rotationArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the override to an on-call rotation.
    public var rotationOverrideId: Swift.String?
    /// The date and time when the override goes into effect.
    public var startTime: ClientRuntime.Date?

    public init(
        createTime: ClientRuntime.Date? = nil,
        endTime: ClientRuntime.Date? = nil,
        newContactIds: [Swift.String]? = nil,
        rotationArn: Swift.String? = nil,
        rotationOverrideId: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.createTime = createTime
        self.endTime = endTime
        self.newContactIds = newContactIds
        self.rotationArn = rotationArn
        self.rotationOverrideId = rotationOverrideId
        self.startTime = startTime
    }
}

struct GetRotationOverrideOutputBody: Swift.Equatable {
    let rotationOverrideId: Swift.String?
    let rotationArn: Swift.String?
    let newContactIds: [Swift.String]?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let createTime: ClientRuntime.Date?
}

extension GetRotationOverrideOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case endTime = "EndTime"
        case newContactIds = "NewContactIds"
        case rotationArn = "RotationArn"
        case rotationOverrideId = "RotationOverrideId"
        case startTime = "StartTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationOverrideIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationOverrideId)
        rotationOverrideId = rotationOverrideIdDecoded
        let rotationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationArn)
        rotationArn = rotationArnDecoded
        let newContactIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .newContactIds)
        var newContactIdsDecoded0:[Swift.String]? = nil
        if let newContactIdsContainer = newContactIdsContainer {
            newContactIdsDecoded0 = [Swift.String]()
            for string0 in newContactIdsContainer {
                if let string0 = string0 {
                    newContactIdsDecoded0?.append(string0)
                }
            }
        }
        newContactIds = newContactIdsDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
    }
}

enum GetRotationOverrideOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSMContactsClientTypes.HandOffTime: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hourOfDay = "HourOfDay"
        case minuteOfHour = "MinuteOfHour"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if hourOfDay != 0 {
            try encodeContainer.encode(hourOfDay, forKey: .hourOfDay)
        }
        if minuteOfHour != 0 {
            try encodeContainer.encode(minuteOfHour, forKey: .minuteOfHour)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hourOfDayDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .hourOfDay) ?? 0
        hourOfDay = hourOfDayDecoded
        let minuteOfHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minuteOfHour) ?? 0
        minuteOfHour = minuteOfHourDecoded
    }
}

extension SSMContactsClientTypes {
    /// Details about when an on-call rotation shift begins or ends.
    public struct HandOffTime: Swift.Equatable {
        /// The hour when an on-call rotation shift begins or ends.
        /// This member is required.
        public var hourOfDay: Swift.Int
        /// The minute when an on-call rotation shift begins or ends.
        /// This member is required.
        public var minuteOfHour: Swift.Int

        public init(
            hourOfDay: Swift.Int = 0,
            minuteOfHour: Swift.Int = 0
        )
        {
            self.hourOfDay = hourOfDay
            self.minuteOfHour = minuteOfHour
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Unexpected error occurred while processing the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListContactChannelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListContactChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListContactChannelsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact.
    /// This member is required.
    public var contactId: Swift.String?
    /// The maximum number of contact channels per page.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListContactChannelsInputBody: Swift.Equatable {
    let contactId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListContactChannelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListContactChannelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListContactChannelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.contactChannels = output.contactChannels
            self.nextToken = output.nextToken
        } else {
            self.contactChannels = nil
            self.nextToken = nil
        }
    }
}

public struct ListContactChannelsOutput: Swift.Equatable {
    /// A list of contact channels related to the specified contact.
    /// This member is required.
    public var contactChannels: [SSMContactsClientTypes.ContactChannel]?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init(
        contactChannels: [SSMContactsClientTypes.ContactChannel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactChannels = contactChannels
        self.nextToken = nextToken
    }
}

struct ListContactChannelsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let contactChannels: [SSMContactsClientTypes.ContactChannel]?
}

extension ListContactChannelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannels = "ContactChannels"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let contactChannelsContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.ContactChannel?].self, forKey: .contactChannels)
        var contactChannelsDecoded0:[SSMContactsClientTypes.ContactChannel]? = nil
        if let contactChannelsContainer = contactChannelsContainer {
            contactChannelsDecoded0 = [SSMContactsClientTypes.ContactChannel]()
            for structure0 in contactChannelsContainer {
                if let structure0 = structure0 {
                    contactChannelsDecoded0?.append(structure0)
                }
            }
        }
        contactChannels = contactChannelsDecoded0
    }
}

enum ListContactChannelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DataEncryptionException": return try await DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListContactsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasPrefix = "AliasPrefix"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aliasPrefix = self.aliasPrefix {
            try encodeContainer.encode(aliasPrefix, forKey: .aliasPrefix)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension ListContactsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListContactsInput: Swift.Equatable {
    /// Used to list only contacts who's aliases start with the specified prefix.
    public var aliasPrefix: Swift.String?
    /// The maximum number of contacts and escalation plans per page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// The type of contact. A contact is type PERSONAL and an escalation plan is type ESCALATION.
    public var type: SSMContactsClientTypes.ContactType?

    public init(
        aliasPrefix: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        type: SSMContactsClientTypes.ContactType? = nil
    )
    {
        self.aliasPrefix = aliasPrefix
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.type = type
    }
}

struct ListContactsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let aliasPrefix: Swift.String?
    let type: SSMContactsClientTypes.ContactType?
}

extension ListContactsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aliasPrefix = "AliasPrefix"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let aliasPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aliasPrefix)
        aliasPrefix = aliasPrefixDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.ContactType.self, forKey: .type)
        type = typeDecoded
    }
}

extension ListContactsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListContactsOutputBody = try responseDecoder.decode(responseBody: data)
            self.contacts = output.contacts
            self.nextToken = output.nextToken
        } else {
            self.contacts = nil
            self.nextToken = nil
        }
    }
}

public struct ListContactsOutput: Swift.Equatable {
    /// A list of the contacts and escalation plans in your Incident Manager account.
    public var contacts: [SSMContactsClientTypes.Contact]?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init(
        contacts: [SSMContactsClientTypes.Contact]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contacts = contacts
        self.nextToken = nextToken
    }
}

struct ListContactsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let contacts: [SSMContactsClientTypes.Contact]?
}

extension ListContactsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contacts = "Contacts"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let contactsContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.Contact?].self, forKey: .contacts)
        var contactsDecoded0:[SSMContactsClientTypes.Contact]? = nil
        if let contactsContainer = contactsContainer {
            contactsDecoded0 = [SSMContactsClientTypes.Contact]()
            for structure0 in contactsContainer {
                if let structure0 = structure0 {
                    contactsDecoded0?.append(structure0)
                }
            }
        }
        contacts = contactsDecoded0
    }
}

enum ListContactsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEngagementsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case incidentId = "IncidentId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timeRangeValue = "TimeRangeValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let incidentId = self.incidentId {
            try encodeContainer.encode(incidentId, forKey: .incidentId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let timeRangeValue = self.timeRangeValue {
            try encodeContainer.encode(timeRangeValue, forKey: .timeRangeValue)
        }
    }
}

extension ListEngagementsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEngagementsInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the incident you're listing engagements for.
    public var incidentId: Swift.String?
    /// The maximum number of engagements per page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// The time range to lists engagements for an incident.
    public var timeRangeValue: SSMContactsClientTypes.TimeRange?

    public init(
        incidentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        timeRangeValue: SSMContactsClientTypes.TimeRange? = nil
    )
    {
        self.incidentId = incidentId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timeRangeValue = timeRangeValue
    }
}

struct ListEngagementsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let incidentId: Swift.String?
    let timeRangeValue: SSMContactsClientTypes.TimeRange?
}

extension ListEngagementsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case incidentId = "IncidentId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timeRangeValue = "TimeRangeValue"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let timeRangeValueDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.TimeRange.self, forKey: .timeRangeValue)
        timeRangeValue = timeRangeValueDecoded
    }
}

extension ListEngagementsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEngagementsOutputBody = try responseDecoder.decode(responseBody: data)
            self.engagements = output.engagements
            self.nextToken = output.nextToken
        } else {
            self.engagements = nil
            self.nextToken = nil
        }
    }
}

public struct ListEngagementsOutput: Swift.Equatable {
    /// A list of each engagement that occurred during the specified time range of an incident.
    /// This member is required.
    public var engagements: [SSMContactsClientTypes.Engagement]?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init(
        engagements: [SSMContactsClientTypes.Engagement]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engagements = engagements
        self.nextToken = nextToken
    }
}

struct ListEngagementsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let engagements: [SSMContactsClientTypes.Engagement]?
}

extension ListEngagementsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagements = "Engagements"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let engagementsContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.Engagement?].self, forKey: .engagements)
        var engagementsDecoded0:[SSMContactsClientTypes.Engagement]? = nil
        if let engagementsContainer = engagementsContainer {
            engagementsDecoded0 = [SSMContactsClientTypes.Engagement]()
            for structure0 in engagementsContainer {
                if let structure0 = structure0 {
                    engagementsDecoded0?.append(structure0)
                }
            }
        }
        engagements = engagementsDecoded0
    }
}

enum ListEngagementsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPageReceiptsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pageId = "PageId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pageId = self.pageId {
            try encodeContainer.encode(pageId, forKey: .pageId)
        }
    }
}

extension ListPageReceiptsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPageReceiptsInput: Swift.Equatable {
    /// The maximum number of acknowledgements per page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the engagement to a specific contact channel.
    /// This member is required.
    public var pageId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pageId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pageId = pageId
    }
}

struct ListPageReceiptsInputBody: Swift.Equatable {
    let pageId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPageReceiptsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case pageId = "PageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageId)
        pageId = pageIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPageReceiptsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPageReceiptsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.receipts = output.receipts
        } else {
            self.nextToken = nil
            self.receipts = nil
        }
    }
}

public struct ListPageReceiptsOutput: Swift.Equatable {
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// A list of each acknowledgement.
    public var receipts: [SSMContactsClientTypes.Receipt]?

    public init(
        nextToken: Swift.String? = nil,
        receipts: [SSMContactsClientTypes.Receipt]? = nil
    )
    {
        self.nextToken = nextToken
        self.receipts = receipts
    }
}

struct ListPageReceiptsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let receipts: [SSMContactsClientTypes.Receipt]?
}

extension ListPageReceiptsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case receipts = "Receipts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let receiptsContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.Receipt?].self, forKey: .receipts)
        var receiptsDecoded0:[SSMContactsClientTypes.Receipt]? = nil
        if let receiptsContainer = receiptsContainer {
            receiptsDecoded0 = [SSMContactsClientTypes.Receipt]()
            for structure0 in receiptsContainer {
                if let structure0 = structure0 {
                    receiptsDecoded0?.append(structure0)
                }
            }
        }
        receipts = receiptsDecoded0
    }
}

enum ListPageReceiptsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPageResolutionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case pageId = "PageId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let pageId = self.pageId {
            try encodeContainer.encode(pageId, forKey: .pageId)
        }
    }
}

extension ListPageResolutionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPageResolutionsInput: Swift.Equatable {
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the contact engaged for the incident.
    /// This member is required.
    public var pageId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        pageId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.pageId = pageId
    }
}

struct ListPageResolutionsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let pageId: Swift.String?
}

extension ListPageResolutionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case pageId = "PageId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let pageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageId)
        pageId = pageIdDecoded
    }
}

extension ListPageResolutionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPageResolutionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pageResolutions = output.pageResolutions
        } else {
            self.nextToken = nil
            self.pageResolutions = nil
        }
    }
}

public struct ListPageResolutionsOutput: Swift.Equatable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// Information about the resolution for an engagement.
    /// This member is required.
    public var pageResolutions: [SSMContactsClientTypes.ResolutionContact]?

    public init(
        nextToken: Swift.String? = nil,
        pageResolutions: [SSMContactsClientTypes.ResolutionContact]? = nil
    )
    {
        self.nextToken = nextToken
        self.pageResolutions = pageResolutions
    }
}

struct ListPageResolutionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let pageResolutions: [SSMContactsClientTypes.ResolutionContact]?
}

extension ListPageResolutionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case pageResolutions = "PageResolutions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let pageResolutionsContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.ResolutionContact?].self, forKey: .pageResolutions)
        var pageResolutionsDecoded0:[SSMContactsClientTypes.ResolutionContact]? = nil
        if let pageResolutionsContainer = pageResolutionsContainer {
            pageResolutionsDecoded0 = [SSMContactsClientTypes.ResolutionContact]()
            for structure0 in pageResolutionsContainer {
                if let structure0 = structure0 {
                    pageResolutionsDecoded0?.append(structure0)
                }
            }
        }
        pageResolutions = pageResolutionsDecoded0
    }
}

enum ListPageResolutionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPagesByContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPagesByContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPagesByContactInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact you are retrieving engagements for.
    /// This member is required.
    public var contactId: Swift.String?
    /// The maximum number of engagements to contact channels to list per page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPagesByContactInputBody: Swift.Equatable {
    let contactId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPagesByContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPagesByContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPagesByContactOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pages = output.pages
        } else {
            self.nextToken = nil
            self.pages = nil
        }
    }
}

public struct ListPagesByContactOutput: Swift.Equatable {
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// The list of engagements to a contact's contact channel.
    /// This member is required.
    public var pages: [SSMContactsClientTypes.Page]?

    public init(
        nextToken: Swift.String? = nil,
        pages: [SSMContactsClientTypes.Page]? = nil
    )
    {
        self.nextToken = nextToken
        self.pages = pages
    }
}

struct ListPagesByContactOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let pages: [SSMContactsClientTypes.Page]?
}

extension ListPagesByContactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case pages = "Pages"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let pagesContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.Page?].self, forKey: .pages)
        var pagesDecoded0:[SSMContactsClientTypes.Page]? = nil
        if let pagesContainer = pagesContainer {
            pagesDecoded0 = [SSMContactsClientTypes.Page]()
            for structure0 in pagesContainer {
                if let structure0 = structure0 {
                    pagesDecoded0?.append(structure0)
                }
            }
        }
        pages = pagesDecoded0
    }
}

enum ListPagesByContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPagesByEngagementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementId = "EngagementId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engagementId = self.engagementId {
            try encodeContainer.encode(engagementId, forKey: .engagementId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPagesByEngagementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPagesByEngagementInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the engagement.
    /// This member is required.
    public var engagementId: Swift.String?
    /// The maximum number of engagements to contact channels to list per page of results.
    public var maxResults: Swift.Int?
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?

    public init(
        engagementId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.engagementId = engagementId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPagesByEngagementInputBody: Swift.Equatable {
    let engagementId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPagesByEngagementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementId = "EngagementId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engagementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementId)
        engagementId = engagementIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPagesByEngagementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPagesByEngagementOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pages = output.pages
        } else {
            self.nextToken = nil
            self.pages = nil
        }
    }
}

public struct ListPagesByEngagementOutput: Swift.Equatable {
    /// The pagination token to continue to the next page of results.
    public var nextToken: Swift.String?
    /// The list of engagements to contact channels.
    /// This member is required.
    public var pages: [SSMContactsClientTypes.Page]?

    public init(
        nextToken: Swift.String? = nil,
        pages: [SSMContactsClientTypes.Page]? = nil
    )
    {
        self.nextToken = nextToken
        self.pages = pages
    }
}

struct ListPagesByEngagementOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let pages: [SSMContactsClientTypes.Page]?
}

extension ListPagesByEngagementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case pages = "Pages"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let pagesContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.Page?].self, forKey: .pages)
        var pagesDecoded0:[SSMContactsClientTypes.Page]? = nil
        if let pagesContainer = pagesContainer {
            pagesDecoded0 = [SSMContactsClientTypes.Page]()
            for structure0 in pagesContainer {
                if let structure0 = structure0 {
                    pagesDecoded0?.append(structure0)
                }
            }
        }
        pages = pagesDecoded0
    }
}

enum ListPagesByEngagementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPreviewRotationShiftsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case members = "Members"
        case nextToken = "NextToken"
        case overrides = "Overrides"
        case recurrence = "Recurrence"
        case rotationStartTime = "RotationStartTime"
        case startTime = "StartTime"
        case timeZoneId = "TimeZoneId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for member0 in members {
                try membersContainer.encode(member0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let overrides = overrides {
            var overridesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .overrides)
            for previewoverride0 in overrides {
                try overridesContainer.encode(previewoverride0)
            }
        }
        if let recurrence = self.recurrence {
            try encodeContainer.encode(recurrence, forKey: .recurrence)
        }
        if let rotationStartTime = self.rotationStartTime {
            try encodeContainer.encodeTimestamp(rotationStartTime, format: .epochSeconds, forKey: .rotationStartTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let timeZoneId = self.timeZoneId {
            try encodeContainer.encode(timeZoneId, forKey: .timeZoneId)
        }
    }
}

extension ListPreviewRotationShiftsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPreviewRotationShiftsInput: Swift.Equatable {
    /// The date and time a rotation shift would end.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// The maximum number of items to return for this call. The call also returns a token that can be specified in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// The contacts that would be assigned to a rotation.
    /// This member is required.
    public var members: [Swift.String]?
    /// A token to start the list. This token is used to get the next set of results.
    public var nextToken: Swift.String?
    /// Information about changes that would be made in a rotation override.
    public var overrides: [SSMContactsClientTypes.PreviewOverride]?
    /// Information about how long a rotation would last before restarting at the beginning of the shift order.
    /// This member is required.
    public var recurrence: SSMContactsClientTypes.RecurrenceSettings?
    /// The date and time a rotation would begin. The first shift is calculated from this date and time.
    public var rotationStartTime: ClientRuntime.Date?
    /// Used to filter the range of calculated shifts before sending the response back to the user.
    public var startTime: ClientRuntime.Date?
    /// The time zone the rotation’s activity would be based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul".
    /// This member is required.
    public var timeZoneId: Swift.String?

    public init(
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        members: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        overrides: [SSMContactsClientTypes.PreviewOverride]? = nil,
        recurrence: SSMContactsClientTypes.RecurrenceSettings? = nil,
        rotationStartTime: ClientRuntime.Date? = nil,
        startTime: ClientRuntime.Date? = nil,
        timeZoneId: Swift.String? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.members = members
        self.nextToken = nextToken
        self.overrides = overrides
        self.recurrence = recurrence
        self.rotationStartTime = rotationStartTime
        self.startTime = startTime
        self.timeZoneId = timeZoneId
    }
}

struct ListPreviewRotationShiftsInputBody: Swift.Equatable {
    let rotationStartTime: ClientRuntime.Date?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let members: [Swift.String]?
    let timeZoneId: Swift.String?
    let recurrence: SSMContactsClientTypes.RecurrenceSettings?
    let overrides: [SSMContactsClientTypes.PreviewOverride]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPreviewRotationShiftsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case members = "Members"
        case nextToken = "NextToken"
        case overrides = "Overrides"
        case recurrence = "Recurrence"
        case rotationStartTime = "RotationStartTime"
        case startTime = "StartTime"
        case timeZoneId = "TimeZoneId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .rotationStartTime)
        rotationStartTime = rotationStartTimeDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let membersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .members)
        var membersDecoded0:[Swift.String]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [Swift.String]()
            for string0 in membersContainer {
                if let string0 = string0 {
                    membersDecoded0?.append(string0)
                }
            }
        }
        members = membersDecoded0
        let timeZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZoneId)
        timeZoneId = timeZoneIdDecoded
        let recurrenceDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.RecurrenceSettings.self, forKey: .recurrence)
        recurrence = recurrenceDecoded
        let overridesContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.PreviewOverride?].self, forKey: .overrides)
        var overridesDecoded0:[SSMContactsClientTypes.PreviewOverride]? = nil
        if let overridesContainer = overridesContainer {
            overridesDecoded0 = [SSMContactsClientTypes.PreviewOverride]()
            for structure0 in overridesContainer {
                if let structure0 = structure0 {
                    overridesDecoded0?.append(structure0)
                }
            }
        }
        overrides = overridesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPreviewRotationShiftsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPreviewRotationShiftsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rotationShifts = output.rotationShifts
        } else {
            self.nextToken = nil
            self.rotationShifts = nil
        }
    }
}

public struct ListPreviewRotationShiftsOutput: Swift.Equatable {
    /// The token for the next set of items to return. This token is used to get the next set of results.
    public var nextToken: Swift.String?
    /// Details about a rotation shift, including times, types, and contacts.
    public var rotationShifts: [SSMContactsClientTypes.RotationShift]?

    public init(
        nextToken: Swift.String? = nil,
        rotationShifts: [SSMContactsClientTypes.RotationShift]? = nil
    )
    {
        self.nextToken = nextToken
        self.rotationShifts = rotationShifts
    }
}

struct ListPreviewRotationShiftsOutputBody: Swift.Equatable {
    let rotationShifts: [SSMContactsClientTypes.RotationShift]?
    let nextToken: Swift.String?
}

extension ListPreviewRotationShiftsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case rotationShifts = "RotationShifts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationShiftsContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.RotationShift?].self, forKey: .rotationShifts)
        var rotationShiftsDecoded0:[SSMContactsClientTypes.RotationShift]? = nil
        if let rotationShiftsContainer = rotationShiftsContainer {
            rotationShiftsDecoded0 = [SSMContactsClientTypes.RotationShift]()
            for structure0 in rotationShiftsContainer {
                if let structure0 = structure0 {
                    rotationShiftsDecoded0?.append(structure0)
                }
            }
        }
        rotationShifts = rotationShiftsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPreviewRotationShiftsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRotationOverridesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case rotationId = "RotationId"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let rotationId = self.rotationId {
            try encodeContainer.encode(rotationId, forKey: .rotationId)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension ListRotationOverridesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRotationOverridesInput: Swift.Equatable {
    /// The date and time for the end of a time range for listing overrides.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the rotation to retrieve information about.
    /// This member is required.
    public var rotationId: Swift.String?
    /// The date and time for the beginning of a time range for listing overrides.
    /// This member is required.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        rotationId: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.rotationId = rotationId
        self.startTime = startTime
    }
}

struct ListRotationOverridesInputBody: Swift.Equatable {
    let rotationId: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListRotationOverridesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case rotationId = "RotationId"
        case startTime = "StartTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationId)
        rotationId = rotationIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRotationOverridesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRotationOverridesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rotationOverrides = output.rotationOverrides
        } else {
            self.nextToken = nil
            self.rotationOverrides = nil
        }
    }
}

public struct ListRotationOverridesOutput: Swift.Equatable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A list of rotation overrides in the specified time range.
    public var rotationOverrides: [SSMContactsClientTypes.RotationOverride]?

    public init(
        nextToken: Swift.String? = nil,
        rotationOverrides: [SSMContactsClientTypes.RotationOverride]? = nil
    )
    {
        self.nextToken = nextToken
        self.rotationOverrides = rotationOverrides
    }
}

struct ListRotationOverridesOutputBody: Swift.Equatable {
    let rotationOverrides: [SSMContactsClientTypes.RotationOverride]?
    let nextToken: Swift.String?
}

extension ListRotationOverridesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case rotationOverrides = "RotationOverrides"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationOverridesContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.RotationOverride?].self, forKey: .rotationOverrides)
        var rotationOverridesDecoded0:[SSMContactsClientTypes.RotationOverride]? = nil
        if let rotationOverridesContainer = rotationOverridesContainer {
            rotationOverridesDecoded0 = [SSMContactsClientTypes.RotationOverride]()
            for structure0 in rotationOverridesContainer {
                if let structure0 = structure0 {
                    rotationOverridesDecoded0?.append(structure0)
                }
            }
        }
        rotationOverrides = rotationOverridesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRotationOverridesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRotationShiftsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case rotationId = "RotationId"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let rotationId = self.rotationId {
            try encodeContainer.encode(rotationId, forKey: .rotationId)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }
}

extension ListRotationShiftsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRotationShiftsInput: Swift.Equatable {
    /// The date and time for the end of the time range to list shifts for.
    /// This member is required.
    public var endTime: ClientRuntime.Date?
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the rotation to retrieve shift information about.
    /// This member is required.
    public var rotationId: Swift.String?
    /// The date and time for the beginning of the time range to list shifts for.
    public var startTime: ClientRuntime.Date?

    public init(
        endTime: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        rotationId: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil
    )
    {
        self.endTime = endTime
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.rotationId = rotationId
        self.startTime = startTime
    }
}

struct ListRotationShiftsInputBody: Swift.Equatable {
    let rotationId: Swift.String?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListRotationShiftsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case rotationId = "RotationId"
        case startTime = "StartTime"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationId)
        rotationId = rotationIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRotationShiftsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRotationShiftsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rotationShifts = output.rotationShifts
        } else {
            self.nextToken = nil
            self.rotationShifts = nil
        }
    }
}

public struct ListRotationShiftsOutput: Swift.Equatable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// Information about shifts that meet the filter criteria.
    public var rotationShifts: [SSMContactsClientTypes.RotationShift]?

    public init(
        nextToken: Swift.String? = nil,
        rotationShifts: [SSMContactsClientTypes.RotationShift]? = nil
    )
    {
        self.nextToken = nextToken
        self.rotationShifts = rotationShifts
    }
}

struct ListRotationShiftsOutputBody: Swift.Equatable {
    let rotationShifts: [SSMContactsClientTypes.RotationShift]?
    let nextToken: Swift.String?
}

extension ListRotationShiftsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case rotationShifts = "RotationShifts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationShiftsContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.RotationShift?].self, forKey: .rotationShifts)
        var rotationShiftsDecoded0:[SSMContactsClientTypes.RotationShift]? = nil
        if let rotationShiftsContainer = rotationShiftsContainer {
            rotationShiftsDecoded0 = [SSMContactsClientTypes.RotationShift]()
            for structure0 in rotationShiftsContainer {
                if let structure0 = structure0 {
                    rotationShiftsDecoded0?.append(structure0)
                }
            }
        }
        rotationShifts = rotationShiftsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRotationShiftsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRotationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case rotationNamePrefix = "RotationNamePrefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let rotationNamePrefix = self.rotationNamePrefix {
            try encodeContainer.encode(rotationNamePrefix, forKey: .rotationNamePrefix)
        }
    }
}

extension ListRotationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRotationsInput: Swift.Equatable {
    /// The maximum number of items to return for this call. The call also returns a token that you can specify in a subsequent call to get the next set of results.
    public var maxResults: Swift.Int?
    /// A token to start the list. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// A filter to include rotations in list results based on their common prefix. For example, entering prod returns a list of all rotation names that begin with prod, such as production and prod-1.
    public var rotationNamePrefix: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        rotationNamePrefix: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.rotationNamePrefix = rotationNamePrefix
    }
}

struct ListRotationsInputBody: Swift.Equatable {
    let rotationNamePrefix: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListRotationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case rotationNamePrefix = "RotationNamePrefix"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationNamePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationNamePrefix)
        rotationNamePrefix = rotationNamePrefixDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListRotationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRotationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.rotations = output.rotations
        } else {
            self.nextToken = nil
            self.rotations = nil
        }
    }
}

public struct ListRotationsOutput: Swift.Equatable {
    /// The token for the next set of items to return. Use this token to get the next set of results.
    public var nextToken: Swift.String?
    /// Information about rotations that meet the filter criteria.
    /// This member is required.
    public var rotations: [SSMContactsClientTypes.Rotation]?

    public init(
        nextToken: Swift.String? = nil,
        rotations: [SSMContactsClientTypes.Rotation]? = nil
    )
    {
        self.nextToken = nextToken
        self.rotations = rotations
    }
}

struct ListRotationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let rotations: [SSMContactsClientTypes.Rotation]?
}

extension ListRotationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case rotations = "Rotations"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let rotationsContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.Rotation?].self, forKey: .rotations)
        var rotationsDecoded0:[SSMContactsClientTypes.Rotation]? = nil
        if let rotationsContainer = rotationsContainer {
            rotationsDecoded0 = [SSMContactsClientTypes.Rotation]()
            for structure0 in rotationsContainer {
                if let structure0 = structure0 {
                    rotationsDecoded0?.append(structure0)
                }
            }
        }
        rotations = rotationsDecoded0
    }
}

enum ListRotationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags related to the contact or escalation plan.
    public var tags: [SSMContactsClientTypes.Tag]?

    public init(
        tags: [SSMContactsClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [SSMContactsClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SSMContactsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SSMContactsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSMContactsClientTypes.MonthlySetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfMonth = "DayOfMonth"
        case handOffTime = "HandOffTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfMonth = self.dayOfMonth {
            try encodeContainer.encode(dayOfMonth, forKey: .dayOfMonth)
        }
        if let handOffTime = self.handOffTime {
            try encodeContainer.encode(handOffTime, forKey: .handOffTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dayOfMonthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dayOfMonth)
        dayOfMonth = dayOfMonthDecoded
        let handOffTimeDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.HandOffTime.self, forKey: .handOffTime)
        handOffTime = handOffTimeDecoded
    }
}

extension SSMContactsClientTypes {
    /// Information about on-call rotations that recur monthly.
    public struct MonthlySetting: Swift.Equatable {
        /// The day of the month when monthly recurring on-call rotations begin.
        /// This member is required.
        public var dayOfMonth: Swift.Int?
        /// The time of day when a monthly recurring on-call shift rotation begins.
        /// This member is required.
        public var handOffTime: SSMContactsClientTypes.HandOffTime?

        public init(
            dayOfMonth: Swift.Int? = nil,
            handOffTime: SSMContactsClientTypes.HandOffTime? = nil
        )
        {
            self.dayOfMonth = dayOfMonth
            self.handOffTime = handOffTime
        }
    }

}

extension SSMContactsClientTypes.Page: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case deliveryTime = "DeliveryTime"
        case engagementArn = "EngagementArn"
        case incidentId = "IncidentId"
        case pageArn = "PageArn"
        case readTime = "ReadTime"
        case sender = "Sender"
        case sentTime = "SentTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let deliveryTime = self.deliveryTime {
            try encodeContainer.encodeTimestamp(deliveryTime, format: .epochSeconds, forKey: .deliveryTime)
        }
        if let engagementArn = self.engagementArn {
            try encodeContainer.encode(engagementArn, forKey: .engagementArn)
        }
        if let incidentId = self.incidentId {
            try encodeContainer.encode(incidentId, forKey: .incidentId)
        }
        if let pageArn = self.pageArn {
            try encodeContainer.encode(pageArn, forKey: .pageArn)
        }
        if let readTime = self.readTime {
            try encodeContainer.encodeTimestamp(readTime, format: .epochSeconds, forKey: .readTime)
        }
        if let sender = self.sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let sentTime = self.sentTime {
            try encodeContainer.encodeTimestamp(sentTime, format: .epochSeconds, forKey: .sentTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pageArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pageArn)
        pageArn = pageArnDecoded
        let engagementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementArn)
        engagementArn = engagementArnDecoded
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let senderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sender)
        sender = senderDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let sentTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .sentTime)
        sentTime = sentTimeDecoded
        let deliveryTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .deliveryTime)
        deliveryTime = deliveryTimeDecoded
        let readTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .readTime)
        readTime = readTimeDecoded
    }
}

extension SSMContactsClientTypes {
    /// Incident Manager engaging a contact's contact channel.
    public struct Page: Swift.Equatable {
        /// The ARN of the contact that Incident Manager is engaging.
        /// This member is required.
        public var contactArn: Swift.String?
        /// The time the message was delivered to the contact channel.
        public var deliveryTime: ClientRuntime.Date?
        /// The ARN of the engagement that this page is part of.
        /// This member is required.
        public var engagementArn: Swift.String?
        /// The ARN of the incident that's engaging the contact channel.
        public var incidentId: Swift.String?
        /// The Amazon Resource Name (ARN) of the page to the contact channel.
        /// This member is required.
        public var pageArn: Swift.String?
        /// The time that the contact channel acknowledged engagement.
        public var readTime: ClientRuntime.Date?
        /// The user that started the engagement.
        /// This member is required.
        public var sender: Swift.String?
        /// The time that Incident Manager engaged the contact channel.
        public var sentTime: ClientRuntime.Date?

        public init(
            contactArn: Swift.String? = nil,
            deliveryTime: ClientRuntime.Date? = nil,
            engagementArn: Swift.String? = nil,
            incidentId: Swift.String? = nil,
            pageArn: Swift.String? = nil,
            readTime: ClientRuntime.Date? = nil,
            sender: Swift.String? = nil,
            sentTime: ClientRuntime.Date? = nil
        )
        {
            self.contactArn = contactArn
            self.deliveryTime = deliveryTime
            self.engagementArn = engagementArn
            self.incidentId = incidentId
            self.pageArn = pageArn
            self.readTime = readTime
            self.sender = sender
            self.sentTime = sentTime
        }
    }

}

extension SSMContactsClientTypes.Plan: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rotationIds = "RotationIds"
        case stages = "Stages"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rotationIds = rotationIds {
            var rotationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rotationIds)
            for ssmcontactsarn0 in rotationIds {
                try rotationIdsContainer.encode(ssmcontactsarn0)
            }
        }
        if let stages = stages {
            var stagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stages)
            for stage0 in stages {
                try stagesContainer.encode(stage0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stagesContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.Stage?].self, forKey: .stages)
        var stagesDecoded0:[SSMContactsClientTypes.Stage]? = nil
        if let stagesContainer = stagesContainer {
            stagesDecoded0 = [SSMContactsClientTypes.Stage]()
            for structure0 in stagesContainer {
                if let structure0 = structure0 {
                    stagesDecoded0?.append(structure0)
                }
            }
        }
        stages = stagesDecoded0
        let rotationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rotationIds)
        var rotationIdsDecoded0:[Swift.String]? = nil
        if let rotationIdsContainer = rotationIdsContainer {
            rotationIdsDecoded0 = [Swift.String]()
            for string0 in rotationIdsContainer {
                if let string0 = string0 {
                    rotationIdsDecoded0?.append(string0)
                }
            }
        }
        rotationIds = rotationIdsDecoded0
    }
}

extension SSMContactsClientTypes {
    /// Information about the stages and on-call rotation teams associated with an escalation plan or engagement plan.
    public struct Plan: Swift.Equatable {
        /// The Amazon Resource Names (ARNs) of the on-call rotations associated with the plan.
        public var rotationIds: [Swift.String]?
        /// A list of stages that the escalation plan or engagement plan uses to engage contacts and contact methods.
        public var stages: [SSMContactsClientTypes.Stage]?

        public init(
            rotationIds: [Swift.String]? = nil,
            stages: [SSMContactsClientTypes.Stage]? = nil
        )
        {
            self.rotationIds = rotationIds
            self.stages = stages
        }
    }

}

extension SSMContactsClientTypes.PreviewOverride: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case newMembers = "NewMembers"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let newMembers = newMembers {
            var newMembersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .newMembers)
            for member0 in newMembers {
                try newMembersContainer.encode(member0)
            }
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let newMembersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .newMembers)
        var newMembersDecoded0:[Swift.String]? = nil
        if let newMembersContainer = newMembersContainer {
            newMembersDecoded0 = [Swift.String]()
            for string0 in newMembersContainer {
                if let string0 = string0 {
                    newMembersDecoded0?.append(string0)
                }
            }
        }
        newMembers = newMembersDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension SSMContactsClientTypes {
    /// Information about contacts and times that an on-call override replaces.
    public struct PreviewOverride: Swift.Equatable {
        /// Information about the time a rotation override would end.
        public var endTime: ClientRuntime.Date?
        /// Information about contacts to add to an on-call rotation override.
        public var newMembers: [Swift.String]?
        /// Information about the time a rotation override would begin.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            newMembers: [Swift.String]? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.newMembers = newMembers
            self.startTime = startTime
        }
    }

}

extension PutContactPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case policy = "Policy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
    }
}

extension PutContactPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutContactPolicyInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public var contactArn: Swift.String?
    /// Details of the resource policy.
    /// This member is required.
    public var policy: Swift.String?

    public init(
        contactArn: Swift.String? = nil,
        policy: Swift.String? = nil
    )
    {
        self.contactArn = contactArn
        self.policy = policy
    }
}

struct PutContactPolicyInputBody: Swift.Equatable {
    let contactArn: Swift.String?
    let policy: Swift.String?
}

extension PutContactPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case policy = "Policy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension PutContactPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutContactPolicyOutput: Swift.Equatable {

    public init() { }
}

enum PutContactPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSMContactsClientTypes.Receipt: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelArn = "ContactChannelArn"
        case receiptInfo = "ReceiptInfo"
        case receiptTime = "ReceiptTime"
        case receiptType = "ReceiptType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelArn = self.contactChannelArn {
            try encodeContainer.encode(contactChannelArn, forKey: .contactChannelArn)
        }
        if let receiptInfo = self.receiptInfo {
            try encodeContainer.encode(receiptInfo, forKey: .receiptInfo)
        }
        if let receiptTime = self.receiptTime {
            try encodeContainer.encodeTimestamp(receiptTime, format: .epochSeconds, forKey: .receiptTime)
        }
        if let receiptType = self.receiptType {
            try encodeContainer.encode(receiptType.rawValue, forKey: .receiptType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelArn)
        contactChannelArn = contactChannelArnDecoded
        let receiptTypeDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.ReceiptType.self, forKey: .receiptType)
        receiptType = receiptTypeDecoded
        let receiptInfoDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .receiptInfo)
        receiptInfo = receiptInfoDecoded
        let receiptTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .receiptTime)
        receiptTime = receiptTimeDecoded
    }
}

extension SSMContactsClientTypes {
    /// Records events during an engagement.
    public struct Receipt: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the contact channel Incident Manager engaged.
        public var contactChannelArn: Swift.String?
        /// Information provided during the page acknowledgement.
        public var receiptInfo: Swift.String?
        /// The time receipt was SENT, DELIVERED, or READ.
        /// This member is required.
        public var receiptTime: ClientRuntime.Date?
        /// The type follows the engagement cycle, SENT, DELIVERED, and READ.
        /// This member is required.
        public var receiptType: SSMContactsClientTypes.ReceiptType?

        public init(
            contactChannelArn: Swift.String? = nil,
            receiptInfo: Swift.String? = nil,
            receiptTime: ClientRuntime.Date? = nil,
            receiptType: SSMContactsClientTypes.ReceiptType? = nil
        )
        {
            self.contactChannelArn = contactChannelArn
            self.receiptInfo = receiptInfo
            self.receiptTime = receiptTime
            self.receiptType = receiptType
        }
    }

}

extension SSMContactsClientTypes {
    public enum ReceiptType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delivered
        case error
        case read
        case sent
        case stop
        case sdkUnknown(Swift.String)

        public static var allCases: [ReceiptType] {
            return [
                .delivered,
                .error,
                .read,
                .sent,
                .stop,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delivered: return "DELIVERED"
            case .error: return "ERROR"
            case .read: return "READ"
            case .sent: return "SENT"
            case .stop: return "STOP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReceiptType(rawValue: rawValue) ?? ReceiptType.sdkUnknown(rawValue)
        }
    }
}

extension SSMContactsClientTypes.RecurrenceSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dailySettings = "DailySettings"
        case monthlySettings = "MonthlySettings"
        case numberOfOnCalls = "NumberOfOnCalls"
        case recurrenceMultiplier = "RecurrenceMultiplier"
        case shiftCoverages = "ShiftCoverages"
        case weeklySettings = "WeeklySettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dailySettings = dailySettings {
            var dailySettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dailySettings)
            for handofftime0 in dailySettings {
                try dailySettingsContainer.encode(handofftime0)
            }
        }
        if let monthlySettings = monthlySettings {
            var monthlySettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .monthlySettings)
            for monthlysetting0 in monthlySettings {
                try monthlySettingsContainer.encode(monthlysetting0)
            }
        }
        if let numberOfOnCalls = self.numberOfOnCalls {
            try encodeContainer.encode(numberOfOnCalls, forKey: .numberOfOnCalls)
        }
        if let recurrenceMultiplier = self.recurrenceMultiplier {
            try encodeContainer.encode(recurrenceMultiplier, forKey: .recurrenceMultiplier)
        }
        if let shiftCoverages = shiftCoverages {
            var shiftCoveragesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .shiftCoverages)
            for (dictKey0, shiftCoveragesMap0) in shiftCoverages {
                var shiftCoveragesMap0Container = shiftCoveragesContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for coveragetime1 in shiftCoveragesMap0 {
                    try shiftCoveragesMap0Container.encode(coveragetime1)
                }
            }
        }
        if let weeklySettings = weeklySettings {
            var weeklySettingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .weeklySettings)
            for weeklysetting0 in weeklySettings {
                try weeklySettingsContainer.encode(weeklysetting0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthlySettingsContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.MonthlySetting?].self, forKey: .monthlySettings)
        var monthlySettingsDecoded0:[SSMContactsClientTypes.MonthlySetting]? = nil
        if let monthlySettingsContainer = monthlySettingsContainer {
            monthlySettingsDecoded0 = [SSMContactsClientTypes.MonthlySetting]()
            for structure0 in monthlySettingsContainer {
                if let structure0 = structure0 {
                    monthlySettingsDecoded0?.append(structure0)
                }
            }
        }
        monthlySettings = monthlySettingsDecoded0
        let weeklySettingsContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.WeeklySetting?].self, forKey: .weeklySettings)
        var weeklySettingsDecoded0:[SSMContactsClientTypes.WeeklySetting]? = nil
        if let weeklySettingsContainer = weeklySettingsContainer {
            weeklySettingsDecoded0 = [SSMContactsClientTypes.WeeklySetting]()
            for structure0 in weeklySettingsContainer {
                if let structure0 = structure0 {
                    weeklySettingsDecoded0?.append(structure0)
                }
            }
        }
        weeklySettings = weeklySettingsDecoded0
        let dailySettingsContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.HandOffTime?].self, forKey: .dailySettings)
        var dailySettingsDecoded0:[SSMContactsClientTypes.HandOffTime]? = nil
        if let dailySettingsContainer = dailySettingsContainer {
            dailySettingsDecoded0 = [SSMContactsClientTypes.HandOffTime]()
            for structure0 in dailySettingsContainer {
                if let structure0 = structure0 {
                    dailySettingsDecoded0?.append(structure0)
                }
            }
        }
        dailySettings = dailySettingsDecoded0
        let numberOfOnCallsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfOnCalls)
        numberOfOnCalls = numberOfOnCallsDecoded
        let shiftCoveragesContainer = try containerValues.decodeIfPresent([Swift.String: [SSMContactsClientTypes.CoverageTime?]?].self, forKey: .shiftCoverages)
        var shiftCoveragesDecoded0: [Swift.String:[SSMContactsClientTypes.CoverageTime]]? = nil
        if let shiftCoveragesContainer = shiftCoveragesContainer {
            shiftCoveragesDecoded0 = [Swift.String:[SSMContactsClientTypes.CoverageTime]]()
            for (key0, coveragetimes0) in shiftCoveragesContainer {
                var coveragetimes0Decoded0: [SSMContactsClientTypes.CoverageTime]? = nil
                if let coveragetimes0 = coveragetimes0 {
                    coveragetimes0Decoded0 = [SSMContactsClientTypes.CoverageTime]()
                    for structure1 in coveragetimes0 {
                        if let structure1 = structure1 {
                            coveragetimes0Decoded0?.append(structure1)
                        }
                    }
                }
                shiftCoveragesDecoded0?[key0] = coveragetimes0Decoded0
            }
        }
        shiftCoverages = shiftCoveragesDecoded0
        let recurrenceMultiplierDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recurrenceMultiplier)
        recurrenceMultiplier = recurrenceMultiplierDecoded
    }
}

extension SSMContactsClientTypes {
    /// Information about when an on-call rotation is in effect and how long the rotation period lasts.
    public struct RecurrenceSettings: Swift.Equatable {
        /// Information about on-call rotations that recur daily.
        public var dailySettings: [SSMContactsClientTypes.HandOffTime]?
        /// Information about on-call rotations that recur monthly.
        public var monthlySettings: [SSMContactsClientTypes.MonthlySetting]?
        /// The number of contacts, or shift team members designated to be on call concurrently during a shift. For example, in an on-call schedule containing ten contacts, a value of 2 designates that two of them are on call at any given time.
        /// This member is required.
        public var numberOfOnCalls: Swift.Int?
        /// The number of days, weeks, or months a single rotation lasts.
        /// This member is required.
        public var recurrenceMultiplier: Swift.Int?
        /// Information about the days of the week included in on-call rotation coverage.
        public var shiftCoverages: [Swift.String:[SSMContactsClientTypes.CoverageTime]]?
        /// Information about on-call rotations that recur weekly.
        public var weeklySettings: [SSMContactsClientTypes.WeeklySetting]?

        public init(
            dailySettings: [SSMContactsClientTypes.HandOffTime]? = nil,
            monthlySettings: [SSMContactsClientTypes.MonthlySetting]? = nil,
            numberOfOnCalls: Swift.Int? = nil,
            recurrenceMultiplier: Swift.Int? = nil,
            shiftCoverages: [Swift.String:[SSMContactsClientTypes.CoverageTime]]? = nil,
            weeklySettings: [SSMContactsClientTypes.WeeklySetting]? = nil
        )
        {
            self.dailySettings = dailySettings
            self.monthlySettings = monthlySettings
            self.numberOfOnCalls = numberOfOnCalls
            self.recurrenceMultiplier = recurrenceMultiplier
            self.shiftCoverages = shiftCoverages
            self.weeklySettings = weeklySettings
        }
    }

}

extension SSMContactsClientTypes.ResolutionContact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactArn = "ContactArn"
        case stageIndex = "StageIndex"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactArn = self.contactArn {
            try encodeContainer.encode(contactArn, forKey: .contactArn)
        }
        if let stageIndex = self.stageIndex {
            try encodeContainer.encode(stageIndex, forKey: .stageIndex)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactArn)
        contactArn = contactArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.ContactType.self, forKey: .type)
        type = typeDecoded
        let stageIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .stageIndex)
        stageIndex = stageIndexDecoded
    }
}

extension SSMContactsClientTypes {
    /// Information about the engagement resolution steps. The resolution starts from the first contact, which can be an escalation plan, then resolves to an on-call rotation, and finally to a personal contact. The ResolutionContact structure describes the information for each node or step in that process. It contains information about different contact types, such as the escalation, rotation, and personal contacts.
    public struct ResolutionContact: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of a contact in the engagement resolution process.
        /// This member is required.
        public var contactArn: Swift.String?
        /// The stage in the escalation plan that resolves to this contact.
        public var stageIndex: Swift.Int?
        /// The type of contact for a resolution step.
        /// This member is required.
        public var type: SSMContactsClientTypes.ContactType?

        public init(
            contactArn: Swift.String? = nil,
            stageIndex: Swift.Int? = nil,
            type: SSMContactsClientTypes.ContactType? = nil
        )
        {
            self.contactArn = contactArn
            self.stageIndex = stageIndex
            self.type = type
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request references a resource that doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Hypothetical resource identifier that was not found
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Hypothetical resource type that was not found
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension SSMContactsClientTypes.Rotation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactIds = "ContactIds"
        case name = "Name"
        case recurrence = "Recurrence"
        case rotationArn = "RotationArn"
        case startTime = "StartTime"
        case timeZoneId = "TimeZoneId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactIds = contactIds {
            var contactIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contactIds)
            for ssmcontactsarn0 in contactIds {
                try contactIdsContainer.encode(ssmcontactsarn0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recurrence = self.recurrence {
            try encodeContainer.encode(recurrence, forKey: .recurrence)
        }
        if let rotationArn = self.rotationArn {
            try encodeContainer.encode(rotationArn, forKey: .rotationArn)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let timeZoneId = self.timeZoneId {
            try encodeContainer.encode(timeZoneId, forKey: .timeZoneId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationArn)
        rotationArn = rotationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let contactIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .contactIds)
        var contactIdsDecoded0:[Swift.String]? = nil
        if let contactIdsContainer = contactIdsContainer {
            contactIdsDecoded0 = [Swift.String]()
            for string0 in contactIdsContainer {
                if let string0 = string0 {
                    contactIdsDecoded0?.append(string0)
                }
            }
        }
        contactIds = contactIdsDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let timeZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZoneId)
        timeZoneId = timeZoneIdDecoded
        let recurrenceDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.RecurrenceSettings.self, forKey: .recurrence)
        recurrence = recurrenceDecoded
    }
}

extension SSMContactsClientTypes {
    /// Information about a rotation in an on-call schedule.
    public struct Rotation: Swift.Equatable {
        /// The Amazon Resource Names (ARNs) of the contacts assigned to the rotation team.
        public var contactIds: [Swift.String]?
        /// The name of the rotation.
        /// This member is required.
        public var name: Swift.String?
        /// Information about when an on-call rotation is in effect and how long the rotation period lasts.
        public var recurrence: SSMContactsClientTypes.RecurrenceSettings?
        /// The Amazon Resource Name (ARN) of the rotation.
        /// This member is required.
        public var rotationArn: Swift.String?
        /// The date and time the rotation becomes active.
        public var startTime: ClientRuntime.Date?
        /// The time zone the rotation’s activity is based on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul".
        public var timeZoneId: Swift.String?

        public init(
            contactIds: [Swift.String]? = nil,
            name: Swift.String? = nil,
            recurrence: SSMContactsClientTypes.RecurrenceSettings? = nil,
            rotationArn: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            timeZoneId: Swift.String? = nil
        )
        {
            self.contactIds = contactIds
            self.name = name
            self.recurrence = recurrence
            self.rotationArn = rotationArn
            self.startTime = startTime
            self.timeZoneId = timeZoneId
        }
    }

}

extension SSMContactsClientTypes.RotationOverride: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime = "CreateTime"
        case endTime = "EndTime"
        case newContactIds = "NewContactIds"
        case rotationOverrideId = "RotationOverrideId"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let newContactIds = newContactIds {
            var newContactIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .newContactIds)
            for ssmcontactsarn0 in newContactIds {
                try newContactIdsContainer.encode(ssmcontactsarn0)
            }
        }
        if let rotationOverrideId = self.rotationOverrideId {
            try encodeContainer.encode(rotationOverrideId, forKey: .rotationOverrideId)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationOverrideIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationOverrideId)
        rotationOverrideId = rotationOverrideIdDecoded
        let newContactIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .newContactIds)
        var newContactIdsDecoded0:[Swift.String]? = nil
        if let newContactIdsContainer = newContactIdsContainer {
            newContactIdsDecoded0 = [Swift.String]()
            for string0 in newContactIdsContainer {
                if let string0 = string0 {
                    newContactIdsDecoded0?.append(string0)
                }
            }
        }
        newContactIds = newContactIdsDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
    }
}

extension SSMContactsClientTypes {
    /// Information about an override specified for an on-call rotation.
    public struct RotationOverride: Swift.Equatable {
        /// The time a rotation override was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The time a rotation override ends.
        /// This member is required.
        public var endTime: ClientRuntime.Date?
        /// The Amazon Resource Names (ARNs) of the contacts assigned to the override of the on-call rotation.
        /// This member is required.
        public var newContactIds: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the override to an on-call rotation.
        /// This member is required.
        public var rotationOverrideId: Swift.String?
        /// The time a rotation override begins.
        /// This member is required.
        public var startTime: ClientRuntime.Date?

        public init(
            createTime: ClientRuntime.Date? = nil,
            endTime: ClientRuntime.Date? = nil,
            newContactIds: [Swift.String]? = nil,
            rotationOverrideId: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.createTime = createTime
            self.endTime = endTime
            self.newContactIds = newContactIds
            self.rotationOverrideId = rotationOverrideId
            self.startTime = startTime
        }
    }

}

extension SSMContactsClientTypes.RotationShift: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactIds = "ContactIds"
        case endTime = "EndTime"
        case shiftDetails = "ShiftDetails"
        case startTime = "StartTime"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactIds = contactIds {
            var contactIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contactIds)
            for ssmcontactsarn0 in contactIds {
                try contactIdsContainer.encode(ssmcontactsarn0)
            }
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let shiftDetails = self.shiftDetails {
            try encodeContainer.encode(shiftDetails, forKey: .shiftDetails)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .contactIds)
        var contactIdsDecoded0:[Swift.String]? = nil
        if let contactIdsContainer = contactIdsContainer {
            contactIdsDecoded0 = [Swift.String]()
            for string0 in contactIdsContainer {
                if let string0 = string0 {
                    contactIdsDecoded0?.append(string0)
                }
            }
        }
        contactIds = contactIdsDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.ShiftType.self, forKey: .type)
        type = typeDecoded
        let shiftDetailsDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.ShiftDetails.self, forKey: .shiftDetails)
        shiftDetails = shiftDetailsDecoded
    }
}

extension SSMContactsClientTypes {
    /// Information about a shift that belongs to an on-call rotation.
    public struct RotationShift: Swift.Equatable {
        /// The Amazon Resource Names (ARNs) of the contacts who are part of the shift rotation.
        public var contactIds: [Swift.String]?
        /// The time a shift rotation ends.
        /// This member is required.
        public var endTime: ClientRuntime.Date?
        /// Additional information about an on-call rotation shift.
        public var shiftDetails: SSMContactsClientTypes.ShiftDetails?
        /// The time a shift rotation begins.
        /// This member is required.
        public var startTime: ClientRuntime.Date?
        /// The type of shift rotation.
        public var type: SSMContactsClientTypes.ShiftType?

        public init(
            contactIds: [Swift.String]? = nil,
            endTime: ClientRuntime.Date? = nil,
            shiftDetails: SSMContactsClientTypes.ShiftDetails? = nil,
            startTime: ClientRuntime.Date? = nil,
            type: SSMContactsClientTypes.ShiftType? = nil
        )
        {
            self.contactIds = contactIds
            self.endTime = endTime
            self.shiftDetails = shiftDetails
            self.startTime = startTime
            self.type = type
        }
    }

}

extension SendActivationCodeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = self.contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
    }
}

extension SendActivationCodeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SendActivationCodeInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact channel.
    /// This member is required.
    public var contactChannelId: Swift.String?

    public init(
        contactChannelId: Swift.String? = nil
    )
    {
        self.contactChannelId = contactChannelId
    }
}

struct SendActivationCodeInputBody: Swift.Equatable {
    let contactChannelId: Swift.String?
}

extension SendActivationCodeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
    }
}

extension SendActivationCodeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct SendActivationCodeOutput: Swift.Equatable {

    public init() { }
}

enum SendActivationCodeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DataEncryptionException": return try await DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request would cause a service quota to be exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Service Quotas requirement to identify originating service
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Identifier of the resource affected
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource affected
        public internal(set) var resourceType: Swift.String? = nil
        /// Service Quotas requirement to identify originating quota
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension SSMContactsClientTypes.ShiftDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case overriddenContactIds = "OverriddenContactIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let overriddenContactIds = overriddenContactIds {
            var overriddenContactIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .overriddenContactIds)
            for ssmcontactsarn0 in overriddenContactIds {
                try overriddenContactIdsContainer.encode(ssmcontactsarn0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overriddenContactIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .overriddenContactIds)
        var overriddenContactIdsDecoded0:[Swift.String]? = nil
        if let overriddenContactIdsContainer = overriddenContactIdsContainer {
            overriddenContactIdsDecoded0 = [Swift.String]()
            for string0 in overriddenContactIdsContainer {
                if let string0 = string0 {
                    overriddenContactIdsDecoded0?.append(string0)
                }
            }
        }
        overriddenContactIds = overriddenContactIdsDecoded0
    }
}

extension SSMContactsClientTypes {
    /// Information about overrides to an on-call rotation shift.
    public struct ShiftDetails: Swift.Equatable {
        /// The Amazon Resources Names (ARNs) of the contacts who were replaced in a shift when an override was created. If the override is deleted, these contacts are restored to the shift.
        /// This member is required.
        public var overriddenContactIds: [Swift.String]?

        public init(
            overriddenContactIds: [Swift.String]? = nil
        )
        {
            self.overriddenContactIds = overriddenContactIds
        }
    }

}

extension SSMContactsClientTypes {
    public enum ShiftType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case overridden
        case regular
        case sdkUnknown(Swift.String)

        public static var allCases: [ShiftType] {
            return [
                .overridden,
                .regular,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .overridden: return "OVERRIDDEN"
            case .regular: return "REGULAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ShiftType(rawValue: rawValue) ?? ShiftType.sdkUnknown(rawValue)
        }
    }
}

extension SSMContactsClientTypes.Stage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationInMinutes = "DurationInMinutes"
        case targets = "Targets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInMinutes = self.durationInMinutes {
            try encodeContainer.encode(durationInMinutes, forKey: .durationInMinutes)
        }
        if let targets = targets {
            var targetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targets)
            for target0 in targets {
                try targetsContainer.encode(target0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let durationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInMinutes)
        durationInMinutes = durationInMinutesDecoded
        let targetsContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.Target?].self, forKey: .targets)
        var targetsDecoded0:[SSMContactsClientTypes.Target]? = nil
        if let targetsContainer = targetsContainer {
            targetsDecoded0 = [SSMContactsClientTypes.Target]()
            for structure0 in targetsContainer {
                if let structure0 = structure0 {
                    targetsDecoded0?.append(structure0)
                }
            }
        }
        targets = targetsDecoded0
    }
}

extension SSMContactsClientTypes {
    /// A set amount of time that an escalation plan or engagement plan engages the specified contacts or contact methods.
    public struct Stage: Swift.Equatable {
        /// The time to wait until beginning the next stage. The duration can only be set to 0 if a target is specified.
        /// This member is required.
        public var durationInMinutes: Swift.Int?
        /// The contacts or contact methods that the escalation plan or engagement plan is engaging.
        /// This member is required.
        public var targets: [SSMContactsClientTypes.Target]?

        public init(
            durationInMinutes: Swift.Int? = nil,
            targets: [SSMContactsClientTypes.Target]? = nil
        )
        {
            self.durationInMinutes = durationInMinutes
            self.targets = targets
        }
    }

}

extension StartEngagementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case content = "Content"
        case idempotencyToken = "IdempotencyToken"
        case incidentId = "IncidentId"
        case publicContent = "PublicContent"
        case publicSubject = "PublicSubject"
        case sender = "Sender"
        case subject = "Subject"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let idempotencyToken = self.idempotencyToken {
            try encodeContainer.encode(idempotencyToken, forKey: .idempotencyToken)
        }
        if let incidentId = self.incidentId {
            try encodeContainer.encode(incidentId, forKey: .incidentId)
        }
        if let publicContent = self.publicContent {
            try encodeContainer.encode(publicContent, forKey: .publicContent)
        }
        if let publicSubject = self.publicSubject {
            try encodeContainer.encode(publicSubject, forKey: .publicSubject)
        }
        if let sender = self.sender {
            try encodeContainer.encode(sender, forKey: .sender)
        }
        if let subject = self.subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
    }
}

extension StartEngagementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartEngagementInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact being engaged.
    /// This member is required.
    public var contactId: Swift.String?
    /// The secure content of the message that was sent to the contact. Use this field for engagements to VOICE or EMAIL.
    /// This member is required.
    public var content: Swift.String?
    /// A token ensuring that the operation is called only once with the specified details.
    public var idempotencyToken: Swift.String?
    /// The ARN of the incident that the engagement is part of.
    public var incidentId: Swift.String?
    /// The insecure content of the message that was sent to the contact. Use this field for engagements to SMS.
    public var publicContent: Swift.String?
    /// The insecure subject of the message that was sent to the contact. Use this field for engagements to SMS.
    public var publicSubject: Swift.String?
    /// The user that started the engagement.
    /// This member is required.
    public var sender: Swift.String?
    /// The secure subject of the message that was sent to the contact. Use this field for engagements to VOICE or EMAIL.
    /// This member is required.
    public var subject: Swift.String?

    public init(
        contactId: Swift.String? = nil,
        content: Swift.String? = nil,
        idempotencyToken: Swift.String? = nil,
        incidentId: Swift.String? = nil,
        publicContent: Swift.String? = nil,
        publicSubject: Swift.String? = nil,
        sender: Swift.String? = nil,
        subject: Swift.String? = nil
    )
    {
        self.contactId = contactId
        self.content = content
        self.idempotencyToken = idempotencyToken
        self.incidentId = incidentId
        self.publicContent = publicContent
        self.publicSubject = publicSubject
        self.sender = sender
        self.subject = subject
    }
}

struct StartEngagementInputBody: Swift.Equatable {
    let contactId: Swift.String?
    let sender: Swift.String?
    let subject: Swift.String?
    let content: Swift.String?
    let publicSubject: Swift.String?
    let publicContent: Swift.String?
    let incidentId: Swift.String?
    let idempotencyToken: Swift.String?
}

extension StartEngagementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case content = "Content"
        case idempotencyToken = "IdempotencyToken"
        case incidentId = "IncidentId"
        case publicContent = "PublicContent"
        case publicSubject = "PublicSubject"
        case sender = "Sender"
        case subject = "Subject"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let senderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sender)
        sender = senderDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let publicSubjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicSubject)
        publicSubject = publicSubjectDecoded
        let publicContentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicContent)
        publicContent = publicContentDecoded
        let incidentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .incidentId)
        incidentId = incidentIdDecoded
        let idempotencyTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .idempotencyToken)
        idempotencyToken = idempotencyTokenDecoded
    }
}

extension StartEngagementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartEngagementOutputBody = try responseDecoder.decode(responseBody: data)
            self.engagementArn = output.engagementArn
        } else {
            self.engagementArn = nil
        }
    }
}

public struct StartEngagementOutput: Swift.Equatable {
    /// The ARN of the engagement.
    /// This member is required.
    public var engagementArn: Swift.String?

    public init(
        engagementArn: Swift.String? = nil
    )
    {
        self.engagementArn = engagementArn
    }
}

struct StartEngagementOutputBody: Swift.Equatable {
    let engagementArn: Swift.String?
}

extension StartEngagementOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementArn = "EngagementArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engagementArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementArn)
        engagementArn = engagementArnDecoded
    }
}

enum StartEngagementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DataEncryptionException": return try await DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopEngagementInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementId = "EngagementId"
        case reason = "Reason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let engagementId = self.engagementId {
            try encodeContainer.encode(engagementId, forKey: .engagementId)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }
}

extension StopEngagementInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopEngagementInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the engagement.
    /// This member is required.
    public var engagementId: Swift.String?
    /// The reason that you're stopping the engagement.
    public var reason: Swift.String?

    public init(
        engagementId: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.engagementId = engagementId
        self.reason = reason
    }
}

struct StopEngagementInputBody: Swift.Equatable {
    let engagementId: Swift.String?
    let reason: Swift.String?
}

extension StopEngagementInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case engagementId = "EngagementId"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let engagementIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engagementId)
        engagementId = engagementIdDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension StopEngagementOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopEngagementOutput: Swift.Equatable {

    public init() { }
}

enum StopEngagementOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSMContactsClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SSMContactsClientTypes {
    /// A container of a key-value name pair.
    public struct Tag: Swift.Equatable {
        /// Name of the object key.
        public var key: Swift.String?
        /// Value of the tag.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tags that you are adding to the contact or escalation plan.
    /// This member is required.
    public var tags: [SSMContactsClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [SSMContactsClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [SSMContactsClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SSMContactsClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SSMContactsClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSMContactsClientTypes.Target: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelTargetInfo = "ChannelTargetInfo"
        case contactTargetInfo = "ContactTargetInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelTargetInfo = self.channelTargetInfo {
            try encodeContainer.encode(channelTargetInfo, forKey: .channelTargetInfo)
        }
        if let contactTargetInfo = self.contactTargetInfo {
            try encodeContainer.encode(contactTargetInfo, forKey: .contactTargetInfo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelTargetInfoDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.ChannelTargetInfo.self, forKey: .channelTargetInfo)
        channelTargetInfo = channelTargetInfoDecoded
        let contactTargetInfoDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.ContactTargetInfo.self, forKey: .contactTargetInfo)
        contactTargetInfo = contactTargetInfoDecoded
    }
}

extension SSMContactsClientTypes {
    /// The contact or contact channel that's being engaged.
    public struct Target: Swift.Equatable {
        /// Information about the contact channel Incident Manager is engaging.
        public var channelTargetInfo: SSMContactsClientTypes.ChannelTargetInfo?
        /// Information about the contact that Incident Manager is engaging.
        public var contactTargetInfo: SSMContactsClientTypes.ContactTargetInfo?

        public init(
            channelTargetInfo: SSMContactsClientTypes.ChannelTargetInfo? = nil,
            contactTargetInfo: SSMContactsClientTypes.ContactTargetInfo? = nil
        )
        {
            self.channelTargetInfo = channelTargetInfo
            self.contactTargetInfo = contactTargetInfo
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Service Quotas requirement to identify originating service
        public internal(set) var quotaCode: Swift.String? = nil
        /// Advice to clients on when the call can be safely retried
        public internal(set) var retryAfterSeconds: Swift.Int = 0
        /// Service Quotas requirement to identify originating quota
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let quotaCode: Swift.String?
    let serviceCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case quotaCode = "QuotaCode"
        case serviceCode = "ServiceCode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
    }
}

extension SSMContactsClientTypes.TimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime = "EndTime"
        case startTime = "StartTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
    }
}

extension SSMContactsClientTypes {
    /// A range of between two set times
    public struct TimeRange: Swift.Equatable {
        /// The end of the time range.
        public var endTime: ClientRuntime.Date?
        /// The start of the time range.
        public var startTime: ClientRuntime.Date?

        public init(
            endTime: ClientRuntime.Date? = nil,
            startTime: ClientRuntime.Date? = nil
        )
        {
            self.endTime = endTime
            self.startTime = startTime
        }
    }

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The key of the tag that you want to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateContactChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
        case deliveryAddress = "DeliveryAddress"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactChannelId = self.contactChannelId {
            try encodeContainer.encode(contactChannelId, forKey: .contactChannelId)
        }
        if let deliveryAddress = self.deliveryAddress {
            try encodeContainer.encode(deliveryAddress, forKey: .deliveryAddress)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateContactChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateContactChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact channel you want to update.
    /// This member is required.
    public var contactChannelId: Swift.String?
    /// The details that Incident Manager uses when trying to engage the contact channel.
    public var deliveryAddress: SSMContactsClientTypes.ContactChannelAddress?
    /// The name of the contact channel.
    public var name: Swift.String?

    public init(
        contactChannelId: Swift.String? = nil,
        deliveryAddress: SSMContactsClientTypes.ContactChannelAddress? = nil,
        name: Swift.String? = nil
    )
    {
        self.contactChannelId = contactChannelId
        self.deliveryAddress = deliveryAddress
        self.name = name
    }
}

struct UpdateContactChannelInputBody: Swift.Equatable {
    let contactChannelId: Swift.String?
    let name: Swift.String?
    let deliveryAddress: SSMContactsClientTypes.ContactChannelAddress?
}

extension UpdateContactChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactChannelId = "ContactChannelId"
        case deliveryAddress = "DeliveryAddress"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactChannelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactChannelId)
        contactChannelId = contactChannelIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let deliveryAddressDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.ContactChannelAddress.self, forKey: .deliveryAddress)
        deliveryAddress = deliveryAddressDecoded
    }
}

extension UpdateContactChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateContactChannelOutput: Swift.Equatable {

    public init() { }
}

enum UpdateContactChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DataEncryptionException": return try await DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateContactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case displayName = "DisplayName"
        case plan = "Plan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let plan = self.plan {
            try encodeContainer.encode(plan, forKey: .plan)
        }
    }
}

extension UpdateContactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateContactInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the contact or escalation plan you're updating.
    /// This member is required.
    public var contactId: Swift.String?
    /// The full name of the contact or escalation plan.
    public var displayName: Swift.String?
    /// A list of stages. A contact has an engagement plan with stages for specified contact channels. An escalation plan uses these stages to contact specified contacts.
    public var plan: SSMContactsClientTypes.Plan?

    public init(
        contactId: Swift.String? = nil,
        displayName: Swift.String? = nil,
        plan: SSMContactsClientTypes.Plan? = nil
    )
    {
        self.contactId = contactId
        self.displayName = displayName
        self.plan = plan
    }
}

struct UpdateContactInputBody: Swift.Equatable {
    let contactId: Swift.String?
    let displayName: Swift.String?
    let plan: SSMContactsClientTypes.Plan?
}

extension UpdateContactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case displayName = "DisplayName"
        case plan = "Plan"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let planDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.Plan.self, forKey: .plan)
        plan = planDecoded
    }
}

extension UpdateContactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateContactOutput: Swift.Equatable {

    public init() { }
}

enum UpdateContactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DataEncryptionException": return try await DataEncryptionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRotationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactIds = "ContactIds"
        case recurrence = "Recurrence"
        case rotationId = "RotationId"
        case startTime = "StartTime"
        case timeZoneId = "TimeZoneId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactIds = contactIds {
            var contactIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .contactIds)
            for ssmcontactsarn0 in contactIds {
                try contactIdsContainer.encode(ssmcontactsarn0)
            }
        }
        if let recurrence = self.recurrence {
            try encodeContainer.encode(recurrence, forKey: .recurrence)
        }
        if let rotationId = self.rotationId {
            try encodeContainer.encode(rotationId, forKey: .rotationId)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let timeZoneId = self.timeZoneId {
            try encodeContainer.encode(timeZoneId, forKey: .timeZoneId)
        }
    }
}

extension UpdateRotationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateRotationInput: Swift.Equatable {
    /// The Amazon Resource Names (ARNs) of the contacts to include in the updated rotation. The order in which you list the contacts is their shift order in the rotation schedule.
    public var contactIds: [Swift.String]?
    /// Information about how long the updated rotation lasts before restarting at the beginning of the shift order.
    /// This member is required.
    public var recurrence: SSMContactsClientTypes.RecurrenceSettings?
    /// The Amazon Resource Name (ARN) of the rotation to update.
    /// This member is required.
    public var rotationId: Swift.String?
    /// The date and time the rotation goes into effect.
    public var startTime: ClientRuntime.Date?
    /// The time zone to base the updated rotation’s activity on, in Internet Assigned Numbers Authority (IANA) format. For example: "America/Los_Angeles", "UTC", or "Asia/Seoul". For more information, see the [Time Zone Database](https://www.iana.org/time-zones) on the IANA website. Designators for time zones that don’t support Daylight Savings Time Rules, such as Pacific Standard Time (PST) and Pacific Daylight Time (PDT), aren't supported.
    public var timeZoneId: Swift.String?

    public init(
        contactIds: [Swift.String]? = nil,
        recurrence: SSMContactsClientTypes.RecurrenceSettings? = nil,
        rotationId: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        timeZoneId: Swift.String? = nil
    )
    {
        self.contactIds = contactIds
        self.recurrence = recurrence
        self.rotationId = rotationId
        self.startTime = startTime
        self.timeZoneId = timeZoneId
    }
}

struct UpdateRotationInputBody: Swift.Equatable {
    let rotationId: Swift.String?
    let contactIds: [Swift.String]?
    let startTime: ClientRuntime.Date?
    let timeZoneId: Swift.String?
    let recurrence: SSMContactsClientTypes.RecurrenceSettings?
}

extension UpdateRotationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactIds = "ContactIds"
        case recurrence = "Recurrence"
        case rotationId = "RotationId"
        case startTime = "StartTime"
        case timeZoneId = "TimeZoneId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rotationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rotationId)
        rotationId = rotationIdDecoded
        let contactIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .contactIds)
        var contactIdsDecoded0:[Swift.String]? = nil
        if let contactIdsContainer = contactIdsContainer {
            contactIdsDecoded0 = [Swift.String]()
            for string0 in contactIdsContainer {
                if let string0 = string0 {
                    contactIdsDecoded0?.append(string0)
                }
            }
        }
        contactIds = contactIdsDecoded0
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let timeZoneIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeZoneId)
        timeZoneId = timeZoneIdDecoded
        let recurrenceDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.RecurrenceSettings.self, forKey: .recurrence)
        recurrence = recurrenceDecoded
    }
}

extension UpdateRotationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateRotationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRotationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fields = output.fields
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fields = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The fields that caused the error
        public internal(set) var fields: [SSMContactsClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Reason the request failed validation
        public internal(set) var reason: SSMContactsClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [SSMContactsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: SSMContactsClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: SSMContactsClientTypes.ValidationExceptionReason?
    let fields: [SSMContactsClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields = "Fields"
        case message = "Message"
        case reason = "Reason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([SSMContactsClientTypes.ValidationExceptionField?].self, forKey: .fields)
        var fieldsDecoded0:[SSMContactsClientTypes.ValidationExceptionField]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [SSMContactsClientTypes.ValidationExceptionField]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension SSMContactsClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SSMContactsClientTypes {
    /// Provides information about which field caused the exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Information about what caused the field to cause an exception.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that caused the exception.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension SSMContactsClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension SSMContactsClientTypes.WeeklySetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dayOfWeek = "DayOfWeek"
        case handOffTime = "HandOffTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dayOfWeek = self.dayOfWeek {
            try encodeContainer.encode(dayOfWeek.rawValue, forKey: .dayOfWeek)
        }
        if let handOffTime = self.handOffTime {
            try encodeContainer.encode(handOffTime, forKey: .handOffTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dayOfWeekDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.DayOfWeek.self, forKey: .dayOfWeek)
        dayOfWeek = dayOfWeekDecoded
        let handOffTimeDecoded = try containerValues.decodeIfPresent(SSMContactsClientTypes.HandOffTime.self, forKey: .handOffTime)
        handOffTime = handOffTimeDecoded
    }
}

extension SSMContactsClientTypes {
    /// Information about rotations that recur weekly.
    public struct WeeklySetting: Swift.Equatable {
        /// The day of the week when weekly recurring on-call shift rotations begins.
        /// This member is required.
        public var dayOfWeek: SSMContactsClientTypes.DayOfWeek?
        /// The time of day when a weekly recurring on-call shift rotation begins.
        /// This member is required.
        public var handOffTime: SSMContactsClientTypes.HandOffTime?

        public init(
            dayOfWeek: SSMContactsClientTypes.DayOfWeek? = nil,
            handOffTime: SSMContactsClientTypes.HandOffTime? = nil
        )
        {
            self.dayOfWeek = dayOfWeek
            self.handOffTime = handOffTime
        }
    }

}
