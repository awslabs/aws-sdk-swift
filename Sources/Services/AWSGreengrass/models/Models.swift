// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AssociateRoleToGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension AssociateRoleToGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/role"
    }
}

public struct AssociateRoleToGroupInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The ARN of the role you wish to associate with this group. The existence of the role is not validated.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.roleArn = roleArn
    }
}

struct AssociateRoleToGroupInputBody: Swift.Equatable {
    let roleArn: Swift.String?
}

extension AssociateRoleToGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension AssociateRoleToGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateRoleToGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.associatedAt = output.associatedAt
        } else {
            self.associatedAt = nil
        }
    }
}

public struct AssociateRoleToGroupOutput: Swift.Equatable {
    /// The time, in milliseconds since the epoch, when the role ARN was associated with the group.
    public var associatedAt: Swift.String?

    public init(
        associatedAt: Swift.String? = nil
    )
    {
        self.associatedAt = associatedAt
    }
}

struct AssociateRoleToGroupOutputBody: Swift.Equatable {
    let associatedAt: Swift.String?
}

extension AssociateRoleToGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedAt = "AssociatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedAt)
        associatedAt = associatedAtDecoded
    }
}

enum AssociateRoleToGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateServiceRoleToAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension AssociateServiceRoleToAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/servicerole"
    }
}

public struct AssociateServiceRoleToAccountInput: Swift.Equatable {
    /// The ARN of the service role you wish to associate with your account.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        roleArn: Swift.String? = nil
    )
    {
        self.roleArn = roleArn
    }
}

struct AssociateServiceRoleToAccountInputBody: Swift.Equatable {
    let roleArn: Swift.String?
}

extension AssociateServiceRoleToAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn = "RoleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension AssociateServiceRoleToAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateServiceRoleToAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.associatedAt = output.associatedAt
        } else {
            self.associatedAt = nil
        }
    }
}

public struct AssociateServiceRoleToAccountOutput: Swift.Equatable {
    /// The time when the service role was associated with the account.
    public var associatedAt: Swift.String?

    public init(
        associatedAt: Swift.String? = nil
    )
    {
        self.associatedAt = associatedAt
    }
}

struct AssociateServiceRoleToAccountOutputBody: Swift.Equatable {
    let associatedAt: Swift.String?
}

extension AssociateServiceRoleToAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedAt = "AssociatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedAt)
        associatedAt = associatedAtDecoded
    }
}

enum AssociateServiceRoleToAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorDetails = output.errorDetails
            self.properties.message = output.message
        } else {
            self.properties.errorDetails = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// General error information.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Details about the error.
        public internal(set) var errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil
        /// A message containing information about the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorDetails = errorDetails
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let errorDetails: [GreengrassClientTypes.ErrorDetail]?
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorDetails = "ErrorDetails"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDetailsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.ErrorDetail?].self, forKey: .errorDetails)
        var errorDetailsDecoded0:[GreengrassClientTypes.ErrorDetail]? = nil
        if let errorDetailsContainer = errorDetailsContainer {
            errorDetailsDecoded0 = [GreengrassClientTypes.ErrorDetail]()
            for structure0 in errorDetailsContainer {
                if let structure0 = structure0 {
                    errorDetailsDecoded0?.append(structure0)
                }
            }
        }
        errorDetails = errorDetailsDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GreengrassClientTypes.BulkDeployment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bulkDeploymentArn = "BulkDeploymentArn"
        case bulkDeploymentId = "BulkDeploymentId"
        case createdAt = "CreatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bulkDeploymentArn = self.bulkDeploymentArn {
            try encodeContainer.encode(bulkDeploymentArn, forKey: .bulkDeploymentArn)
        }
        if let bulkDeploymentId = self.bulkDeploymentId {
            try encodeContainer.encode(bulkDeploymentId, forKey: .bulkDeploymentId)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bulkDeploymentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bulkDeploymentArn)
        bulkDeploymentArn = bulkDeploymentArnDecoded
        let bulkDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bulkDeploymentId)
        bulkDeploymentId = bulkDeploymentIdDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a bulk deployment. You cannot start a new bulk deployment while another one is still running or in a non-terminal state.
    public struct BulkDeployment: Swift.Equatable {
        /// The ARN of the bulk deployment.
        public var bulkDeploymentArn: Swift.String?
        /// The ID of the bulk deployment.
        public var bulkDeploymentId: Swift.String?
        /// The time, in ISO format, when the deployment was created.
        public var createdAt: Swift.String?

        public init(
            bulkDeploymentArn: Swift.String? = nil,
            bulkDeploymentId: Swift.String? = nil,
            createdAt: Swift.String? = nil
        )
        {
            self.bulkDeploymentArn = bulkDeploymentArn
            self.bulkDeploymentId = bulkDeploymentId
            self.createdAt = createdAt
        }
    }

}

extension GreengrassClientTypes.BulkDeploymentMetrics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invalidInputRecords = "InvalidInputRecords"
        case recordsProcessed = "RecordsProcessed"
        case retryAttempts = "RetryAttempts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invalidInputRecords = self.invalidInputRecords {
            try encodeContainer.encode(invalidInputRecords, forKey: .invalidInputRecords)
        }
        if let recordsProcessed = self.recordsProcessed {
            try encodeContainer.encode(recordsProcessed, forKey: .recordsProcessed)
        }
        if let retryAttempts = self.retryAttempts {
            try encodeContainer.encode(retryAttempts, forKey: .retryAttempts)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invalidInputRecordsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .invalidInputRecords)
        invalidInputRecords = invalidInputRecordsDecoded
        let recordsProcessedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordsProcessed)
        recordsProcessed = recordsProcessedDecoded
        let retryAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retryAttempts)
        retryAttempts = retryAttemptsDecoded
    }
}

extension GreengrassClientTypes {
    /// Relevant metrics on input records processed during bulk deployment.
    public struct BulkDeploymentMetrics: Swift.Equatable {
        /// The total number of records that returned a non-retryable error. For example, this can occur if a group record from the input file uses an invalid format or specifies a nonexistent group version, or if the execution role doesn't grant permission to deploy a group or group version.
        public var invalidInputRecords: Swift.Int?
        /// The total number of group records from the input file that have been processed so far, or attempted.
        public var recordsProcessed: Swift.Int?
        /// The total number of deployment attempts that returned a retryable error. For example, a retry is triggered if the attempt to deploy a group returns a throttling error. ''StartBulkDeployment'' retries a group deployment up to five times.
        public var retryAttempts: Swift.Int?

        public init(
            invalidInputRecords: Swift.Int? = nil,
            recordsProcessed: Swift.Int? = nil,
            retryAttempts: Swift.Int? = nil
        )
        {
            self.invalidInputRecords = invalidInputRecords
            self.recordsProcessed = recordsProcessed
            self.retryAttempts = retryAttempts
        }
    }

}

extension GreengrassClientTypes.BulkDeploymentResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case deploymentArn = "DeploymentArn"
        case deploymentId = "DeploymentId"
        case deploymentStatus = "DeploymentStatus"
        case deploymentType = "DeploymentType"
        case errorDetails = "ErrorDetails"
        case errorMessage = "ErrorMessage"
        case groupArn = "GroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let deploymentArn = self.deploymentArn {
            try encodeContainer.encode(deploymentArn, forKey: .deploymentArn)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentStatus = self.deploymentStatus {
            try encodeContainer.encode(deploymentStatus, forKey: .deploymentStatus)
        }
        if let deploymentType = self.deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let errorDetails = errorDetails {
            var errorDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errorDetails)
            for errordetail0 in errorDetails {
                try errorDetailsContainer.encode(errordetail0)
            }
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let groupArn = self.groupArn {
            try encodeContainer.encode(groupArn, forKey: .groupArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deploymentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentArn)
        deploymentArn = deploymentArnDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.DeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let errorDetailsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.ErrorDetail?].self, forKey: .errorDetails)
        var errorDetailsDecoded0:[GreengrassClientTypes.ErrorDetail]? = nil
        if let errorDetailsContainer = errorDetailsContainer {
            errorDetailsDecoded0 = [GreengrassClientTypes.ErrorDetail]()
            for structure0 in errorDetailsContainer {
                if let structure0 = structure0 {
                    errorDetailsDecoded0?.append(structure0)
                }
            }
        }
        errorDetails = errorDetailsDecoded0
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let groupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupArn)
        groupArn = groupArnDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about an individual group deployment in a bulk deployment operation.
    public struct BulkDeploymentResult: Swift.Equatable {
        /// The time, in ISO format, when the deployment was created.
        public var createdAt: Swift.String?
        /// The ARN of the group deployment.
        public var deploymentArn: Swift.String?
        /// The ID of the group deployment.
        public var deploymentId: Swift.String?
        /// The current status of the group deployment: ''InProgress'', ''Building'', ''Success'', or ''Failure''.
        public var deploymentStatus: Swift.String?
        /// The type of the deployment.
        public var deploymentType: GreengrassClientTypes.DeploymentType?
        /// Details about the error.
        public var errorDetails: [GreengrassClientTypes.ErrorDetail]?
        /// The error message for a failed deployment
        public var errorMessage: Swift.String?
        /// The ARN of the Greengrass group.
        public var groupArn: Swift.String?

        public init(
            createdAt: Swift.String? = nil,
            deploymentArn: Swift.String? = nil,
            deploymentId: Swift.String? = nil,
            deploymentStatus: Swift.String? = nil,
            deploymentType: GreengrassClientTypes.DeploymentType? = nil,
            errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil,
            errorMessage: Swift.String? = nil,
            groupArn: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.deploymentArn = deploymentArn
            self.deploymentId = deploymentId
            self.deploymentStatus = deploymentStatus
            self.deploymentType = deploymentType
            self.errorDetails = errorDetails
            self.errorMessage = errorMessage
            self.groupArn = groupArn
        }
    }

}

extension GreengrassClientTypes {
    /// The current status of the bulk deployment.
    public enum BulkDeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case initializing
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [BulkDeploymentStatus] {
            return [
                .completed,
                .failed,
                .initializing,
                .running,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .initializing: return "Initializing"
            case .running: return "Running"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BulkDeploymentStatus(rawValue: rawValue) ?? BulkDeploymentStatus.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassClientTypes {
    public enum ConfigurationSyncStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case insync
        case outofsync
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationSyncStatus] {
            return [
                .insync,
                .outofsync,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .insync: return "InSync"
            case .outofsync: return "OutOfSync"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationSyncStatus(rawValue: rawValue) ?? ConfigurationSyncStatus.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassClientTypes.ConnectivityInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostAddress = "HostAddress"
        case id = "Id"
        case metadata = "Metadata"
        case portNumber = "PortNumber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostAddress = self.hostAddress {
            try encodeContainer.encode(hostAddress, forKey: .hostAddress)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let portNumber = self.portNumber {
            try encodeContainer.encode(portNumber, forKey: .portNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostAddress)
        hostAddress = hostAddressDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let portNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .portNumber)
        portNumber = portNumberDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a Greengrass core's connectivity.
    public struct ConnectivityInfo: Swift.Equatable {
        /// The endpoint for the Greengrass core. Can be an IP address or DNS.
        public var hostAddress: Swift.String?
        /// The ID of the connectivity information.
        public var id: Swift.String?
        /// Metadata for this endpoint.
        public var metadata: Swift.String?
        /// The port of the Greengrass core. Usually 8883.
        public var portNumber: Swift.Int?

        public init(
            hostAddress: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: Swift.String? = nil,
            portNumber: Swift.Int? = nil
        )
        {
            self.hostAddress = hostAddress
            self.id = id
            self.metadata = metadata
            self.portNumber = portNumber
        }
    }

}

extension GreengrassClientTypes.Connector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorArn = "ConnectorArn"
        case id = "Id"
        case parameters = "Parameters"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorArn = self.connectorArn {
            try encodeContainer.encode(connectorArn, forKey: .connectorArn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, __mapOf__string0) in parameters {
                try parametersContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorArn)
        connectorArn = connectorArnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in parametersContainer {
                if let __string0 = __string0 {
                    parametersDecoded0?[key0] = __string0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension GreengrassClientTypes {
    /// Information about a connector. Connectors run on the Greengrass core and contain built-in integration with local infrastructure, device protocols, AWS, and other cloud services.
    public struct Connector: Swift.Equatable {
        /// The ARN of the connector.
        /// This member is required.
        public var connectorArn: Swift.String?
        /// A descriptive or arbitrary ID for the connector. This value must be unique within the connector definition version. Max length is 128 characters with pattern [a-zA-Z0-9:_-]+.
        /// This member is required.
        public var id: Swift.String?
        /// The parameters or configuration that the connector uses.
        public var parameters: [Swift.String:Swift.String]?

        public init(
            connectorArn: Swift.String? = nil,
            id: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.connectorArn = connectorArn
            self.id = id
            self.parameters = parameters
        }
    }

}

extension GreengrassClientTypes.ConnectorDefinitionVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectors = "Connectors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectors = connectors {
            var connectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectors)
            for connector0 in connectors {
                try connectorsContainer.encode(connector0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Connector?].self, forKey: .connectors)
        var connectorsDecoded0:[GreengrassClientTypes.Connector]? = nil
        if let connectorsContainer = connectorsContainer {
            connectorsDecoded0 = [GreengrassClientTypes.Connector]()
            for structure0 in connectorsContainer {
                if let structure0 = structure0 {
                    connectorsDecoded0?.append(structure0)
                }
            }
        }
        connectors = connectorsDecoded0
    }
}

extension GreengrassClientTypes {
    /// Information about the connector definition version, which is a container for connectors.
    public struct ConnectorDefinitionVersion: Swift.Equatable {
        /// A list of references to connectors in this version, with their corresponding configuration settings.
        public var connectors: [GreengrassClientTypes.Connector]?

        public init(
            connectors: [GreengrassClientTypes.Connector]? = nil
        )
        {
            self.connectors = connectors
        }
    }

}

extension GreengrassClientTypes.Core: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case id = "Id"
        case syncShadow = "SyncShadow"
        case thingArn = "ThingArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let syncShadow = self.syncShadow {
            try encodeContainer.encode(syncShadow, forKey: .syncShadow)
        }
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let syncShadowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .syncShadow)
        syncShadow = syncShadowDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a core.
    public struct Core: Swift.Equatable {
        /// The ARN of the certificate associated with the core.
        /// This member is required.
        public var certificateArn: Swift.String?
        /// A descriptive or arbitrary ID for the core. This value must be unique within the core definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        /// This member is required.
        public var id: Swift.String?
        /// If true, the core's local shadow is automatically synced with the cloud.
        public var syncShadow: Swift.Bool?
        /// The ARN of the thing which is the core.
        /// This member is required.
        public var thingArn: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            id: Swift.String? = nil,
            syncShadow: Swift.Bool? = nil,
            thingArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.id = id
            self.syncShadow = syncShadow
            self.thingArn = thingArn
        }
    }

}

extension GreengrassClientTypes.CoreDefinitionVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cores = "Cores"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cores = cores {
            var coresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cores)
            for core0 in cores {
                try coresContainer.encode(core0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coresContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Core?].self, forKey: .cores)
        var coresDecoded0:[GreengrassClientTypes.Core]? = nil
        if let coresContainer = coresContainer {
            coresDecoded0 = [GreengrassClientTypes.Core]()
            for structure0 in coresContainer {
                if let structure0 = structure0 {
                    coresDecoded0?.append(structure0)
                }
            }
        }
        cores = coresDecoded0
    }
}

extension GreengrassClientTypes {
    /// Information about a core definition version.
    public struct CoreDefinitionVersion: Swift.Equatable {
        /// A list of cores in the core definition version.
        public var cores: [GreengrassClientTypes.Core]?

        public init(
            cores: [GreengrassClientTypes.Core]? = nil
        )
        {
            self.cores = cores
        }
    }

}

extension CreateConnectorDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = self.initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateConnectorDefinitionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateConnectorDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/connectors"
    }
}

public struct CreateConnectorDefinitionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the connector definition.
    public var initialVersion: GreengrassClientTypes.ConnectorDefinitionVersion?
    /// The name of the connector definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.ConnectorDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateConnectorDefinitionInputBody: Swift.Equatable {
    let initialVersion: GreengrassClientTypes.ConnectorDefinitionVersion?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateConnectorDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.ConnectorDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConnectorDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateConnectorDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateConnectorDefinitionOutput: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateConnectorDefinitionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
}

extension CreateConnectorDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateConnectorDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateConnectorDefinitionVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectors = "Connectors"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectors = connectors {
            var connectorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectors)
            for connector0 in connectors {
                try connectorsContainer.encode(connector0)
            }
        }
    }
}

extension CreateConnectorDefinitionVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateConnectorDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectorDefinitionId = connectorDefinitionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct CreateConnectorDefinitionVersionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?
    /// A list of references to connectors in this version, with their corresponding configuration settings.
    public var connectors: [GreengrassClientTypes.Connector]?

    public init(
        amznClientToken: Swift.String? = nil,
        connectorDefinitionId: Swift.String? = nil,
        connectors: [GreengrassClientTypes.Connector]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.connectorDefinitionId = connectorDefinitionId
        self.connectors = connectors
    }
}

struct CreateConnectorDefinitionVersionInputBody: Swift.Equatable {
    let connectors: [GreengrassClientTypes.Connector]?
}

extension CreateConnectorDefinitionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectors = "Connectors"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Connector?].self, forKey: .connectors)
        var connectorsDecoded0:[GreengrassClientTypes.Connector]? = nil
        if let connectorsContainer = connectorsContainer {
            connectorsDecoded0 = [GreengrassClientTypes.Connector]()
            for structure0 in connectorsContainer {
                if let structure0 = structure0 {
                    connectorsDecoded0?.append(structure0)
                }
            }
        }
        connectors = connectorsDecoded0
    }
}

extension CreateConnectorDefinitionVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateConnectorDefinitionVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateConnectorDefinitionVersionOutput: Swift.Equatable {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateConnectorDefinitionVersionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let version: Swift.String?
}

extension CreateConnectorDefinitionVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum CreateConnectorDefinitionVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateCoreDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = self.initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateCoreDefinitionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateCoreDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/cores"
    }
}

/// Information needed to create a core definition.
public struct CreateCoreDefinitionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the core definition.
    public var initialVersion: GreengrassClientTypes.CoreDefinitionVersion?
    /// The name of the core definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.CoreDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateCoreDefinitionInputBody: Swift.Equatable {
    let initialVersion: GreengrassClientTypes.CoreDefinitionVersion?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateCoreDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.CoreDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateCoreDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCoreDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateCoreDefinitionOutput: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateCoreDefinitionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
}

extension CreateCoreDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateCoreDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateCoreDefinitionVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cores = "Cores"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cores = cores {
            var coresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cores)
            for core0 in cores {
                try coresContainer.encode(core0)
            }
        }
    }
}

extension CreateCoreDefinitionVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateCoreDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreDefinitionId = coreDefinitionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct CreateCoreDefinitionVersionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?
    /// A list of cores in the core definition version.
    public var cores: [GreengrassClientTypes.Core]?

    public init(
        amznClientToken: Swift.String? = nil,
        coreDefinitionId: Swift.String? = nil,
        cores: [GreengrassClientTypes.Core]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.coreDefinitionId = coreDefinitionId
        self.cores = cores
    }
}

struct CreateCoreDefinitionVersionInputBody: Swift.Equatable {
    let cores: [GreengrassClientTypes.Core]?
}

extension CreateCoreDefinitionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cores = "Cores"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coresContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Core?].self, forKey: .cores)
        var coresDecoded0:[GreengrassClientTypes.Core]? = nil
        if let coresContainer = coresContainer {
            coresDecoded0 = [GreengrassClientTypes.Core]()
            for structure0 in coresContainer {
                if let structure0 = structure0 {
                    coresDecoded0?.append(structure0)
                }
            }
        }
        cores = coresDecoded0
    }
}

extension CreateCoreDefinitionVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCoreDefinitionVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateCoreDefinitionVersionOutput: Swift.Equatable {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateCoreDefinitionVersionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let version: Swift.String?
}

extension CreateCoreDefinitionVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum CreateCoreDefinitionVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId = "DeploymentId"
        case deploymentType = "DeploymentType"
        case groupVersionId = "GroupVersionId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentType = self.deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let groupVersionId = self.groupVersionId {
            try encodeContainer.encode(groupVersionId, forKey: .groupVersionId)
        }
    }
}

extension CreateDeploymentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/deployments"
    }
}

public struct CreateDeploymentInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the deployment if you wish to redeploy a previous deployment.
    public var deploymentId: Swift.String?
    /// The type of deployment. When used for ''CreateDeployment'', only ''NewDeployment'' and ''Redeployment'' are valid.
    /// This member is required.
    public var deploymentType: GreengrassClientTypes.DeploymentType?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The ID of the group version to be deployed.
    public var groupVersionId: Swift.String?

    public init(
        amznClientToken: Swift.String? = nil,
        deploymentId: Swift.String? = nil,
        deploymentType: GreengrassClientTypes.DeploymentType? = nil,
        groupId: Swift.String? = nil,
        groupVersionId: Swift.String? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.deploymentId = deploymentId
        self.deploymentType = deploymentType
        self.groupId = groupId
        self.groupVersionId = groupVersionId
    }
}

struct CreateDeploymentInputBody: Swift.Equatable {
    let deploymentId: Swift.String?
    let deploymentType: GreengrassClientTypes.DeploymentType?
    let groupVersionId: Swift.String?
}

extension CreateDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentId = "DeploymentId"
        case deploymentType = "DeploymentType"
        case groupVersionId = "GroupVersionId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.DeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let groupVersionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupVersionId)
        groupVersionId = groupVersionIdDecoded
    }
}

extension CreateDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.deploymentArn = output.deploymentArn
            self.deploymentId = output.deploymentId
        } else {
            self.deploymentArn = nil
            self.deploymentId = nil
        }
    }
}

public struct CreateDeploymentOutput: Swift.Equatable {
    /// The ARN of the deployment.
    public var deploymentArn: Swift.String?
    /// The ID of the deployment.
    public var deploymentId: Swift.String?

    public init(
        deploymentArn: Swift.String? = nil,
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentArn = deploymentArn
        self.deploymentId = deploymentId
    }
}

struct CreateDeploymentOutputBody: Swift.Equatable {
    let deploymentArn: Swift.String?
    let deploymentId: Swift.String?
}

extension CreateDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentArn = "DeploymentArn"
        case deploymentId = "DeploymentId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentArn)
        deploymentArn = deploymentArnDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
    }
}

enum CreateDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDeviceDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = self.initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDeviceDefinitionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateDeviceDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/devices"
    }
}

public struct CreateDeviceDefinitionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the device definition.
    public var initialVersion: GreengrassClientTypes.DeviceDefinitionVersion?
    /// The name of the device definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.DeviceDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateDeviceDefinitionInputBody: Swift.Equatable {
    let initialVersion: GreengrassClientTypes.DeviceDefinitionVersion?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDeviceDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.DeviceDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDeviceDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDeviceDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateDeviceDefinitionOutput: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateDeviceDefinitionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
}

extension CreateDeviceDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateDeviceDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDeviceDefinitionVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices = "Devices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devices = devices {
            var devicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .devices)
            for device0 in devices {
                try devicesContainer.encode(device0)
            }
        }
    }
}

extension CreateDeviceDefinitionVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateDeviceDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceDefinitionId = deviceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct CreateDeviceDefinitionVersionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?
    /// A list of devices in the definition version.
    public var devices: [GreengrassClientTypes.Device]?

    public init(
        amznClientToken: Swift.String? = nil,
        deviceDefinitionId: Swift.String? = nil,
        devices: [GreengrassClientTypes.Device]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.deviceDefinitionId = deviceDefinitionId
        self.devices = devices
    }
}

struct CreateDeviceDefinitionVersionInputBody: Swift.Equatable {
    let devices: [GreengrassClientTypes.Device]?
}

extension CreateDeviceDefinitionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices = "Devices"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Device?].self, forKey: .devices)
        var devicesDecoded0:[GreengrassClientTypes.Device]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [GreengrassClientTypes.Device]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
    }
}

extension CreateDeviceDefinitionVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDeviceDefinitionVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateDeviceDefinitionVersionOutput: Swift.Equatable {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateDeviceDefinitionVersionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let version: Swift.String?
}

extension CreateDeviceDefinitionVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum CreateDeviceDefinitionVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFunctionDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = self.initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateFunctionDefinitionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateFunctionDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/functions"
    }
}

public struct CreateFunctionDefinitionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the function definition.
    public var initialVersion: GreengrassClientTypes.FunctionDefinitionVersion?
    /// The name of the function definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.FunctionDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateFunctionDefinitionInputBody: Swift.Equatable {
    let initialVersion: GreengrassClientTypes.FunctionDefinitionVersion?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateFunctionDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFunctionDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFunctionDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateFunctionDefinitionOutput: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateFunctionDefinitionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
}

extension CreateFunctionDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateFunctionDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFunctionDefinitionVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultConfig = "DefaultConfig"
        case functions = "Functions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultConfig = self.defaultConfig {
            try encodeContainer.encode(defaultConfig, forKey: .defaultConfig)
        }
        if let functions = functions {
            var functionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functions)
            for function0 in functions {
                try functionsContainer.encode(function0)
            }
        }
    }
}

extension CreateFunctionDefinitionVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateFunctionDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionDefinitionId = functionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())/versions"
    }
}

/// Information needed to create a function definition version.
public struct CreateFunctionDefinitionVersionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The default configuration that applies to all Lambda functions in this function definition version. Individual Lambda functions can override these settings.
    public var defaultConfig: GreengrassClientTypes.FunctionDefaultConfig?
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?
    /// A list of Lambda functions in this function definition version.
    public var functions: [GreengrassClientTypes.Function]?

    public init(
        amznClientToken: Swift.String? = nil,
        defaultConfig: GreengrassClientTypes.FunctionDefaultConfig? = nil,
        functionDefinitionId: Swift.String? = nil,
        functions: [GreengrassClientTypes.Function]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.defaultConfig = defaultConfig
        self.functionDefinitionId = functionDefinitionId
        self.functions = functions
    }
}

struct CreateFunctionDefinitionVersionInputBody: Swift.Equatable {
    let defaultConfig: GreengrassClientTypes.FunctionDefaultConfig?
    let functions: [GreengrassClientTypes.Function]?
}

extension CreateFunctionDefinitionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultConfig = "DefaultConfig"
        case functions = "Functions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultConfigDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionDefaultConfig.self, forKey: .defaultConfig)
        defaultConfig = defaultConfigDecoded
        let functionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Function?].self, forKey: .functions)
        var functionsDecoded0:[GreengrassClientTypes.Function]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [GreengrassClientTypes.Function]()
            for structure0 in functionsContainer {
                if let structure0 = structure0 {
                    functionsDecoded0?.append(structure0)
                }
            }
        }
        functions = functionsDecoded0
    }
}

extension CreateFunctionDefinitionVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFunctionDefinitionVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateFunctionDefinitionVersionOutput: Swift.Equatable {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateFunctionDefinitionVersionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let version: Swift.String?
}

extension CreateFunctionDefinitionVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum CreateFunctionDefinitionVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateGroupCertificateAuthorityInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateGroupCertificateAuthorityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/certificateauthorities"
    }
}

public struct CreateGroupCertificateAuthorityInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        amznClientToken: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.groupId = groupId
    }
}

struct CreateGroupCertificateAuthorityInputBody: Swift.Equatable {
}

extension CreateGroupCertificateAuthorityInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CreateGroupCertificateAuthorityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGroupCertificateAuthorityOutputBody = try responseDecoder.decode(responseBody: data)
            self.groupCertificateAuthorityArn = output.groupCertificateAuthorityArn
        } else {
            self.groupCertificateAuthorityArn = nil
        }
    }
}

public struct CreateGroupCertificateAuthorityOutput: Swift.Equatable {
    /// The ARN of the group certificate authority.
    public var groupCertificateAuthorityArn: Swift.String?

    public init(
        groupCertificateAuthorityArn: Swift.String? = nil
    )
    {
        self.groupCertificateAuthorityArn = groupCertificateAuthorityArn
    }
}

struct CreateGroupCertificateAuthorityOutputBody: Swift.Equatable {
    let groupCertificateAuthorityArn: Swift.String?
}

extension CreateGroupCertificateAuthorityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupCertificateAuthorityArn = "GroupCertificateAuthorityArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupCertificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupCertificateAuthorityArn)
        groupCertificateAuthorityArn = groupCertificateAuthorityArnDecoded
    }
}

enum CreateGroupCertificateAuthorityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = self.initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateGroupInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/groups"
    }
}

public struct CreateGroupInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the group.
    public var initialVersion: GreengrassClientTypes.GroupVersion?
    /// The name of the group.
    /// This member is required.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.GroupVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateGroupInputBody: Swift.Equatable {
    let initialVersion: GreengrassClientTypes.GroupVersion?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.GroupVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateGroupOutput: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateGroupOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
}

extension CreateGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateGroupVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorDefinitionVersionArn = "ConnectorDefinitionVersionArn"
        case coreDefinitionVersionArn = "CoreDefinitionVersionArn"
        case deviceDefinitionVersionArn = "DeviceDefinitionVersionArn"
        case functionDefinitionVersionArn = "FunctionDefinitionVersionArn"
        case loggerDefinitionVersionArn = "LoggerDefinitionVersionArn"
        case resourceDefinitionVersionArn = "ResourceDefinitionVersionArn"
        case subscriptionDefinitionVersionArn = "SubscriptionDefinitionVersionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorDefinitionVersionArn = self.connectorDefinitionVersionArn {
            try encodeContainer.encode(connectorDefinitionVersionArn, forKey: .connectorDefinitionVersionArn)
        }
        if let coreDefinitionVersionArn = self.coreDefinitionVersionArn {
            try encodeContainer.encode(coreDefinitionVersionArn, forKey: .coreDefinitionVersionArn)
        }
        if let deviceDefinitionVersionArn = self.deviceDefinitionVersionArn {
            try encodeContainer.encode(deviceDefinitionVersionArn, forKey: .deviceDefinitionVersionArn)
        }
        if let functionDefinitionVersionArn = self.functionDefinitionVersionArn {
            try encodeContainer.encode(functionDefinitionVersionArn, forKey: .functionDefinitionVersionArn)
        }
        if let loggerDefinitionVersionArn = self.loggerDefinitionVersionArn {
            try encodeContainer.encode(loggerDefinitionVersionArn, forKey: .loggerDefinitionVersionArn)
        }
        if let resourceDefinitionVersionArn = self.resourceDefinitionVersionArn {
            try encodeContainer.encode(resourceDefinitionVersionArn, forKey: .resourceDefinitionVersionArn)
        }
        if let subscriptionDefinitionVersionArn = self.subscriptionDefinitionVersionArn {
            try encodeContainer.encode(subscriptionDefinitionVersionArn, forKey: .subscriptionDefinitionVersionArn)
        }
    }
}

extension CreateGroupVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateGroupVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/versions"
    }
}

public struct CreateGroupVersionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ARN of the connector definition version for this group.
    public var connectorDefinitionVersionArn: Swift.String?
    /// The ARN of the core definition version for this group.
    public var coreDefinitionVersionArn: Swift.String?
    /// The ARN of the device definition version for this group.
    public var deviceDefinitionVersionArn: Swift.String?
    /// The ARN of the function definition version for this group.
    public var functionDefinitionVersionArn: Swift.String?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The ARN of the logger definition version for this group.
    public var loggerDefinitionVersionArn: Swift.String?
    /// The ARN of the resource definition version for this group.
    public var resourceDefinitionVersionArn: Swift.String?
    /// The ARN of the subscription definition version for this group.
    public var subscriptionDefinitionVersionArn: Swift.String?

    public init(
        amznClientToken: Swift.String? = nil,
        connectorDefinitionVersionArn: Swift.String? = nil,
        coreDefinitionVersionArn: Swift.String? = nil,
        deviceDefinitionVersionArn: Swift.String? = nil,
        functionDefinitionVersionArn: Swift.String? = nil,
        groupId: Swift.String? = nil,
        loggerDefinitionVersionArn: Swift.String? = nil,
        resourceDefinitionVersionArn: Swift.String? = nil,
        subscriptionDefinitionVersionArn: Swift.String? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.connectorDefinitionVersionArn = connectorDefinitionVersionArn
        self.coreDefinitionVersionArn = coreDefinitionVersionArn
        self.deviceDefinitionVersionArn = deviceDefinitionVersionArn
        self.functionDefinitionVersionArn = functionDefinitionVersionArn
        self.groupId = groupId
        self.loggerDefinitionVersionArn = loggerDefinitionVersionArn
        self.resourceDefinitionVersionArn = resourceDefinitionVersionArn
        self.subscriptionDefinitionVersionArn = subscriptionDefinitionVersionArn
    }
}

struct CreateGroupVersionInputBody: Swift.Equatable {
    let connectorDefinitionVersionArn: Swift.String?
    let coreDefinitionVersionArn: Swift.String?
    let deviceDefinitionVersionArn: Swift.String?
    let functionDefinitionVersionArn: Swift.String?
    let loggerDefinitionVersionArn: Swift.String?
    let resourceDefinitionVersionArn: Swift.String?
    let subscriptionDefinitionVersionArn: Swift.String?
}

extension CreateGroupVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorDefinitionVersionArn = "ConnectorDefinitionVersionArn"
        case coreDefinitionVersionArn = "CoreDefinitionVersionArn"
        case deviceDefinitionVersionArn = "DeviceDefinitionVersionArn"
        case functionDefinitionVersionArn = "FunctionDefinitionVersionArn"
        case loggerDefinitionVersionArn = "LoggerDefinitionVersionArn"
        case resourceDefinitionVersionArn = "ResourceDefinitionVersionArn"
        case subscriptionDefinitionVersionArn = "SubscriptionDefinitionVersionArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorDefinitionVersionArn)
        connectorDefinitionVersionArn = connectorDefinitionVersionArnDecoded
        let coreDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreDefinitionVersionArn)
        coreDefinitionVersionArn = coreDefinitionVersionArnDecoded
        let deviceDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceDefinitionVersionArn)
        deviceDefinitionVersionArn = deviceDefinitionVersionArnDecoded
        let functionDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionDefinitionVersionArn)
        functionDefinitionVersionArn = functionDefinitionVersionArnDecoded
        let loggerDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggerDefinitionVersionArn)
        loggerDefinitionVersionArn = loggerDefinitionVersionArnDecoded
        let resourceDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceDefinitionVersionArn)
        resourceDefinitionVersionArn = resourceDefinitionVersionArnDecoded
        let subscriptionDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionDefinitionVersionArn)
        subscriptionDefinitionVersionArn = subscriptionDefinitionVersionArnDecoded
    }
}

extension CreateGroupVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGroupVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateGroupVersionOutput: Swift.Equatable {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateGroupVersionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let version: Swift.String?
}

extension CreateGroupVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum CreateGroupVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLoggerDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = self.initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateLoggerDefinitionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateLoggerDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/loggers"
    }
}

public struct CreateLoggerDefinitionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the logger definition.
    public var initialVersion: GreengrassClientTypes.LoggerDefinitionVersion?
    /// The name of the logger definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.LoggerDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateLoggerDefinitionInputBody: Swift.Equatable {
    let initialVersion: GreengrassClientTypes.LoggerDefinitionVersion?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateLoggerDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.LoggerDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateLoggerDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLoggerDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateLoggerDefinitionOutput: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateLoggerDefinitionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
}

extension CreateLoggerDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateLoggerDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLoggerDefinitionVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggers = "Loggers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggers = loggers {
            var loggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loggers)
            for logger0 in loggers {
                try loggersContainer.encode(logger0)
            }
        }
    }
}

extension CreateLoggerDefinitionVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateLoggerDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let loggerDefinitionId = loggerDefinitionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct CreateLoggerDefinitionVersionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?
    /// A list of loggers.
    public var loggers: [GreengrassClientTypes.Logger]?

    public init(
        amznClientToken: Swift.String? = nil,
        loggerDefinitionId: Swift.String? = nil,
        loggers: [GreengrassClientTypes.Logger]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.loggerDefinitionId = loggerDefinitionId
        self.loggers = loggers
    }
}

struct CreateLoggerDefinitionVersionInputBody: Swift.Equatable {
    let loggers: [GreengrassClientTypes.Logger]?
}

extension CreateLoggerDefinitionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggers = "Loggers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggersContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Logger?].self, forKey: .loggers)
        var loggersDecoded0:[GreengrassClientTypes.Logger]? = nil
        if let loggersContainer = loggersContainer {
            loggersDecoded0 = [GreengrassClientTypes.Logger]()
            for structure0 in loggersContainer {
                if let structure0 = structure0 {
                    loggersDecoded0?.append(structure0)
                }
            }
        }
        loggers = loggersDecoded0
    }
}

extension CreateLoggerDefinitionVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLoggerDefinitionVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateLoggerDefinitionVersionOutput: Swift.Equatable {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateLoggerDefinitionVersionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let version: Swift.String?
}

extension CreateLoggerDefinitionVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum CreateLoggerDefinitionVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateResourceDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = self.initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateResourceDefinitionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateResourceDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/resources"
    }
}

public struct CreateResourceDefinitionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the resource definition.
    public var initialVersion: GreengrassClientTypes.ResourceDefinitionVersion?
    /// The name of the resource definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.ResourceDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateResourceDefinitionInputBody: Swift.Equatable {
    let initialVersion: GreengrassClientTypes.ResourceDefinitionVersion?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateResourceDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.ResourceDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateResourceDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateResourceDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateResourceDefinitionOutput: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateResourceDefinitionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
}

extension CreateResourceDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateResourceDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateResourceDefinitionVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resources = "Resources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resource0 in resources {
                try resourcesContainer.encode(resource0)
            }
        }
    }
}

extension CreateResourceDefinitionVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateResourceDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceDefinitionId = resourceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct CreateResourceDefinitionVersionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?
    /// A list of resources.
    public var resources: [GreengrassClientTypes.Resource]?

    public init(
        amznClientToken: Swift.String? = nil,
        resourceDefinitionId: Swift.String? = nil,
        resources: [GreengrassClientTypes.Resource]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.resourceDefinitionId = resourceDefinitionId
        self.resources = resources
    }
}

struct CreateResourceDefinitionVersionInputBody: Swift.Equatable {
    let resources: [GreengrassClientTypes.Resource]?
}

extension CreateResourceDefinitionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resources = "Resources"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[GreengrassClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [GreengrassClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension CreateResourceDefinitionVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateResourceDefinitionVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateResourceDefinitionVersionOutput: Swift.Equatable {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateResourceDefinitionVersionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let version: Swift.String?
}

extension CreateResourceDefinitionVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum CreateResourceDefinitionVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSoftwareUpdateJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3UrlSignerRole = "S3UrlSignerRole"
        case softwareToUpdate = "SoftwareToUpdate"
        case updateAgentLogLevel = "UpdateAgentLogLevel"
        case updateTargets = "UpdateTargets"
        case updateTargetsArchitecture = "UpdateTargetsArchitecture"
        case updateTargetsOperatingSystem = "UpdateTargetsOperatingSystem"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3UrlSignerRole = self.s3UrlSignerRole {
            try encodeContainer.encode(s3UrlSignerRole, forKey: .s3UrlSignerRole)
        }
        if let softwareToUpdate = self.softwareToUpdate {
            try encodeContainer.encode(softwareToUpdate.rawValue, forKey: .softwareToUpdate)
        }
        if let updateAgentLogLevel = self.updateAgentLogLevel {
            try encodeContainer.encode(updateAgentLogLevel.rawValue, forKey: .updateAgentLogLevel)
        }
        if let updateTargets = updateTargets {
            var updateTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .updateTargets)
            for __string0 in updateTargets {
                try updateTargetsContainer.encode(__string0)
            }
        }
        if let updateTargetsArchitecture = self.updateTargetsArchitecture {
            try encodeContainer.encode(updateTargetsArchitecture.rawValue, forKey: .updateTargetsArchitecture)
        }
        if let updateTargetsOperatingSystem = self.updateTargetsOperatingSystem {
            try encodeContainer.encode(updateTargetsOperatingSystem.rawValue, forKey: .updateTargetsOperatingSystem)
        }
    }
}

extension CreateSoftwareUpdateJobInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateSoftwareUpdateJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/updates"
    }
}

public struct CreateSoftwareUpdateJobInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The IAM Role that Greengrass will use to create pre-signed URLs pointing towards the update artifact.
    /// This member is required.
    public var s3UrlSignerRole: Swift.String?
    /// The piece of software on the Greengrass core that will be updated.
    /// This member is required.
    public var softwareToUpdate: GreengrassClientTypes.SoftwareToUpdate?
    /// The minimum level of log statements that should be logged by the OTA Agent during an update.
    public var updateAgentLogLevel: GreengrassClientTypes.UpdateAgentLogLevel?
    /// The ARNs of the targets (IoT things or IoT thing groups) that this update will be applied to.
    /// This member is required.
    public var updateTargets: [Swift.String]?
    /// The architecture of the cores which are the targets of an update.
    /// This member is required.
    public var updateTargetsArchitecture: GreengrassClientTypes.UpdateTargetsArchitecture?
    /// The operating system of the cores which are the targets of an update.
    /// This member is required.
    public var updateTargetsOperatingSystem: GreengrassClientTypes.UpdateTargetsOperatingSystem?

    public init(
        amznClientToken: Swift.String? = nil,
        s3UrlSignerRole: Swift.String? = nil,
        softwareToUpdate: GreengrassClientTypes.SoftwareToUpdate? = nil,
        updateAgentLogLevel: GreengrassClientTypes.UpdateAgentLogLevel? = nil,
        updateTargets: [Swift.String]? = nil,
        updateTargetsArchitecture: GreengrassClientTypes.UpdateTargetsArchitecture? = nil,
        updateTargetsOperatingSystem: GreengrassClientTypes.UpdateTargetsOperatingSystem? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.s3UrlSignerRole = s3UrlSignerRole
        self.softwareToUpdate = softwareToUpdate
        self.updateAgentLogLevel = updateAgentLogLevel
        self.updateTargets = updateTargets
        self.updateTargetsArchitecture = updateTargetsArchitecture
        self.updateTargetsOperatingSystem = updateTargetsOperatingSystem
    }
}

struct CreateSoftwareUpdateJobInputBody: Swift.Equatable {
    let s3UrlSignerRole: Swift.String?
    let softwareToUpdate: GreengrassClientTypes.SoftwareToUpdate?
    let updateAgentLogLevel: GreengrassClientTypes.UpdateAgentLogLevel?
    let updateTargets: [Swift.String]?
    let updateTargetsArchitecture: GreengrassClientTypes.UpdateTargetsArchitecture?
    let updateTargetsOperatingSystem: GreengrassClientTypes.UpdateTargetsOperatingSystem?
}

extension CreateSoftwareUpdateJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3UrlSignerRole = "S3UrlSignerRole"
        case softwareToUpdate = "SoftwareToUpdate"
        case updateAgentLogLevel = "UpdateAgentLogLevel"
        case updateTargets = "UpdateTargets"
        case updateTargetsArchitecture = "UpdateTargetsArchitecture"
        case updateTargetsOperatingSystem = "UpdateTargetsOperatingSystem"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UrlSignerRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3UrlSignerRole)
        s3UrlSignerRole = s3UrlSignerRoleDecoded
        let softwareToUpdateDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.SoftwareToUpdate.self, forKey: .softwareToUpdate)
        softwareToUpdate = softwareToUpdateDecoded
        let updateAgentLogLevelDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.UpdateAgentLogLevel.self, forKey: .updateAgentLogLevel)
        updateAgentLogLevel = updateAgentLogLevelDecoded
        let updateTargetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .updateTargets)
        var updateTargetsDecoded0:[Swift.String]? = nil
        if let updateTargetsContainer = updateTargetsContainer {
            updateTargetsDecoded0 = [Swift.String]()
            for string0 in updateTargetsContainer {
                if let string0 = string0 {
                    updateTargetsDecoded0?.append(string0)
                }
            }
        }
        updateTargets = updateTargetsDecoded0
        let updateTargetsArchitectureDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.UpdateTargetsArchitecture.self, forKey: .updateTargetsArchitecture)
        updateTargetsArchitecture = updateTargetsArchitectureDecoded
        let updateTargetsOperatingSystemDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.UpdateTargetsOperatingSystem.self, forKey: .updateTargetsOperatingSystem)
        updateTargetsOperatingSystem = updateTargetsOperatingSystemDecoded
    }
}

extension CreateSoftwareUpdateJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSoftwareUpdateJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.iotJobArn = output.iotJobArn
            self.iotJobId = output.iotJobId
            self.platformSoftwareVersion = output.platformSoftwareVersion
        } else {
            self.iotJobArn = nil
            self.iotJobId = nil
            self.platformSoftwareVersion = nil
        }
    }
}

public struct CreateSoftwareUpdateJobOutput: Swift.Equatable {
    /// The IoT Job ARN corresponding to this update.
    public var iotJobArn: Swift.String?
    /// The IoT Job Id corresponding to this update.
    public var iotJobId: Swift.String?
    /// The software version installed on the device or devices after the update.
    public var platformSoftwareVersion: Swift.String?

    public init(
        iotJobArn: Swift.String? = nil,
        iotJobId: Swift.String? = nil,
        platformSoftwareVersion: Swift.String? = nil
    )
    {
        self.iotJobArn = iotJobArn
        self.iotJobId = iotJobId
        self.platformSoftwareVersion = platformSoftwareVersion
    }
}

struct CreateSoftwareUpdateJobOutputBody: Swift.Equatable {
    let iotJobArn: Swift.String?
    let iotJobId: Swift.String?
    let platformSoftwareVersion: Swift.String?
}

extension CreateSoftwareUpdateJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iotJobArn = "IotJobArn"
        case iotJobId = "IotJobId"
        case platformSoftwareVersion = "PlatformSoftwareVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iotJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotJobArn)
        iotJobArn = iotJobArnDecoded
        let iotJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iotJobId)
        iotJobId = iotJobIdDecoded
        let platformSoftwareVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platformSoftwareVersion)
        platformSoftwareVersion = platformSoftwareVersionDecoded
    }
}

enum CreateSoftwareUpdateJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSubscriptionDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initialVersion = self.initialVersion {
            try encodeContainer.encode(initialVersion, forKey: .initialVersion)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSubscriptionDefinitionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateSubscriptionDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/subscriptions"
    }
}

public struct CreateSubscriptionDefinitionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the subscription definition.
    public var initialVersion: GreengrassClientTypes.SubscriptionDefinitionVersion?
    /// The name of the subscription definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.SubscriptionDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

struct CreateSubscriptionDefinitionInputBody: Swift.Equatable {
    let initialVersion: GreengrassClientTypes.SubscriptionDefinitionVersion?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSubscriptionDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialVersion = "InitialVersion"
        case name = "Name"
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialVersionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.SubscriptionDefinitionVersion.self, forKey: .initialVersion)
        initialVersion = initialVersionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSubscriptionDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSubscriptionDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
        }
    }
}

public struct CreateSubscriptionDefinitionOutput: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

struct CreateSubscriptionDefinitionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
}

extension CreateSubscriptionDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateSubscriptionDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSubscriptionDefinitionVersionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptions = "Subscriptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subscriptions = subscriptions {
            var subscriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscriptions)
            for subscription0 in subscriptions {
                try subscriptionsContainer.encode(subscription0)
            }
        }
    }
}

extension CreateSubscriptionDefinitionVersionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateSubscriptionDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriptionDefinitionId = subscriptionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct CreateSubscriptionDefinitionVersionInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?
    /// A list of subscriptions.
    public var subscriptions: [GreengrassClientTypes.Subscription]?

    public init(
        amznClientToken: Swift.String? = nil,
        subscriptionDefinitionId: Swift.String? = nil,
        subscriptions: [GreengrassClientTypes.Subscription]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.subscriptionDefinitionId = subscriptionDefinitionId
        self.subscriptions = subscriptions
    }
}

struct CreateSubscriptionDefinitionVersionInputBody: Swift.Equatable {
    let subscriptions: [GreengrassClientTypes.Subscription]?
}

extension CreateSubscriptionDefinitionVersionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptions = "Subscriptions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Subscription?].self, forKey: .subscriptions)
        var subscriptionsDecoded0:[GreengrassClientTypes.Subscription]? = nil
        if let subscriptionsContainer = subscriptionsContainer {
            subscriptionsDecoded0 = [GreengrassClientTypes.Subscription]()
            for structure0 in subscriptionsContainer {
                if let structure0 = structure0 {
                    subscriptionsDecoded0?.append(structure0)
                }
            }
        }
        subscriptions = subscriptionsDecoded0
    }
}

extension CreateSubscriptionDefinitionVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSubscriptionDefinitionVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct CreateSubscriptionDefinitionVersionOutput: Swift.Equatable {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

struct CreateSubscriptionDefinitionVersionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let version: Swift.String?
}

extension CreateSubscriptionDefinitionVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum CreateSubscriptionDefinitionVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GreengrassClientTypes.DefinitionInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTimestamp = self.creationTimestamp {
            try encodeContainer.encode(creationTimestamp, forKey: .creationTimestamp)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp, forKey: .lastUpdatedTimestamp)
        }
        if let latestVersion = self.latestVersion {
            try encodeContainer.encode(latestVersion, forKey: .latestVersion)
        }
        if let latestVersionArn = self.latestVersionArn {
            try encodeContainer.encode(latestVersionArn, forKey: .latestVersionArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GreengrassClientTypes {
    /// Information about a definition.
    public struct DefinitionInformation: Swift.Equatable {
        /// The ARN of the definition.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public var creationTimestamp: Swift.String?
        /// The ID of the definition.
        public var id: Swift.String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public var lastUpdatedTimestamp: Swift.String?
        /// The ID of the latest version associated with the definition.
        public var latestVersion: Swift.String?
        /// The ARN of the latest version associated with the definition.
        public var latestVersionArn: Swift.String?
        /// The name of the definition.
        public var name: Swift.String?
        /// Tag(s) attached to the resource arn.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            creationTimestamp: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedTimestamp: Swift.String? = nil,
            latestVersion: Swift.String? = nil,
            latestVersionArn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
            self.tags = tags
        }
    }

}

extension DeleteConnectorDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectorDefinitionId = connectorDefinitionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteConnectorDefinitionInput: Swift.Equatable {
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?

    public init(
        connectorDefinitionId: Swift.String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
    }
}

struct DeleteConnectorDefinitionInputBody: Swift.Equatable {
}

extension DeleteConnectorDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConnectorDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteConnectorDefinitionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteConnectorDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCoreDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreDefinitionId = coreDefinitionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteCoreDefinitionInput: Swift.Equatable {
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?

    public init(
        coreDefinitionId: Swift.String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
    }
}

struct DeleteCoreDefinitionInputBody: Swift.Equatable {
}

extension DeleteCoreDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCoreDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCoreDefinitionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCoreDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDeviceDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceDefinitionId = deviceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteDeviceDefinitionInput: Swift.Equatable {
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?

    public init(
        deviceDefinitionId: Swift.String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
    }
}

struct DeleteDeviceDefinitionInputBody: Swift.Equatable {
}

extension DeleteDeviceDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeviceDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDeviceDefinitionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDeviceDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFunctionDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionDefinitionId = functionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteFunctionDefinitionInput: Swift.Equatable {
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?

    public init(
        functionDefinitionId: Swift.String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
    }
}

struct DeleteFunctionDefinitionInputBody: Swift.Equatable {
}

extension DeleteFunctionDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFunctionDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFunctionDefinitionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFunctionDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())"
    }
}

public struct DeleteGroupInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct DeleteGroupInputBody: Swift.Equatable {
}

extension DeleteGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteGroupOutput: Swift.Equatable {

    public init() { }
}

enum DeleteGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLoggerDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let loggerDefinitionId = loggerDefinitionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteLoggerDefinitionInput: Swift.Equatable {
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?

    public init(
        loggerDefinitionId: Swift.String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
    }
}

struct DeleteLoggerDefinitionInputBody: Swift.Equatable {
}

extension DeleteLoggerDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLoggerDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLoggerDefinitionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLoggerDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteResourceDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceDefinitionId = resourceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteResourceDefinitionInput: Swift.Equatable {
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?

    public init(
        resourceDefinitionId: Swift.String? = nil
    )
    {
        self.resourceDefinitionId = resourceDefinitionId
    }
}

struct DeleteResourceDefinitionInputBody: Swift.Equatable {
}

extension DeleteResourceDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteResourceDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteResourceDefinitionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteResourceDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSubscriptionDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriptionDefinitionId = subscriptionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteSubscriptionDefinitionInput: Swift.Equatable {
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?

    public init(
        subscriptionDefinitionId: Swift.String? = nil
    )
    {
        self.subscriptionDefinitionId = subscriptionDefinitionId
    }
}

struct DeleteSubscriptionDefinitionInputBody: Swift.Equatable {
}

extension DeleteSubscriptionDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSubscriptionDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSubscriptionDefinitionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSubscriptionDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GreengrassClientTypes.Deployment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "CreatedAt"
        case deploymentArn = "DeploymentArn"
        case deploymentId = "DeploymentId"
        case deploymentType = "DeploymentType"
        case groupArn = "GroupArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let deploymentArn = self.deploymentArn {
            try encodeContainer.encode(deploymentArn, forKey: .deploymentArn)
        }
        if let deploymentId = self.deploymentId {
            try encodeContainer.encode(deploymentId, forKey: .deploymentId)
        }
        if let deploymentType = self.deploymentType {
            try encodeContainer.encode(deploymentType.rawValue, forKey: .deploymentType)
        }
        if let groupArn = self.groupArn {
            try encodeContainer.encode(groupArn, forKey: .groupArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let deploymentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentArn)
        deploymentArn = deploymentArnDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.DeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let groupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupArn)
        groupArn = groupArnDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a deployment.
    public struct Deployment: Swift.Equatable {
        /// The time, in milliseconds since the epoch, when the deployment was created.
        public var createdAt: Swift.String?
        /// The ARN of the deployment.
        public var deploymentArn: Swift.String?
        /// The ID of the deployment.
        public var deploymentId: Swift.String?
        /// The type of the deployment.
        public var deploymentType: GreengrassClientTypes.DeploymentType?
        /// The ARN of the group for this deployment.
        public var groupArn: Swift.String?

        public init(
            createdAt: Swift.String? = nil,
            deploymentArn: Swift.String? = nil,
            deploymentId: Swift.String? = nil,
            deploymentType: GreengrassClientTypes.DeploymentType? = nil,
            groupArn: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.deploymentArn = deploymentArn
            self.deploymentId = deploymentId
            self.deploymentType = deploymentType
            self.groupArn = groupArn
        }
    }

}

extension GreengrassClientTypes {
    /// The type of deployment. When used for ''CreateDeployment'', only ''NewDeployment'' and ''Redeployment'' are valid.
    public enum DeploymentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case forceresetdeployment
        case newdeployment
        case redeployment
        case resetdeployment
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentType] {
            return [
                .forceresetdeployment,
                .newdeployment,
                .redeployment,
                .resetdeployment,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .forceresetdeployment: return "ForceResetDeployment"
            case .newdeployment: return "NewDeployment"
            case .redeployment: return "Redeployment"
            case .resetdeployment: return "ResetDeployment"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeploymentType(rawValue: rawValue) ?? DeploymentType.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassClientTypes.Device: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn = "CertificateArn"
        case id = "Id"
        case syncShadow = "SyncShadow"
        case thingArn = "ThingArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let syncShadow = self.syncShadow {
            try encodeContainer.encode(syncShadow, forKey: .syncShadow)
        }
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let syncShadowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .syncShadow)
        syncShadow = syncShadowDecoded
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a device.
    public struct Device: Swift.Equatable {
        /// The ARN of the certificate associated with the device.
        /// This member is required.
        public var certificateArn: Swift.String?
        /// A descriptive or arbitrary ID for the device. This value must be unique within the device definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        /// This member is required.
        public var id: Swift.String?
        /// If true, the device's local shadow will be automatically synced with the cloud.
        public var syncShadow: Swift.Bool?
        /// The thing ARN of the device.
        /// This member is required.
        public var thingArn: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            id: Swift.String? = nil,
            syncShadow: Swift.Bool? = nil,
            thingArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.id = id
            self.syncShadow = syncShadow
            self.thingArn = thingArn
        }
    }

}

extension GreengrassClientTypes.DeviceDefinitionVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices = "Devices"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devices = devices {
            var devicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .devices)
            for device0 in devices {
                try devicesContainer.encode(device0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Device?].self, forKey: .devices)
        var devicesDecoded0:[GreengrassClientTypes.Device]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [GreengrassClientTypes.Device]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
    }
}

extension GreengrassClientTypes {
    /// Information about a device definition version.
    public struct DeviceDefinitionVersion: Swift.Equatable {
        /// A list of devices in the definition version.
        public var devices: [GreengrassClientTypes.Device]?

        public init(
            devices: [GreengrassClientTypes.Device]? = nil
        )
        {
            self.devices = devices
        }
    }

}

extension DisassociateRoleFromGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/role"
    }
}

public struct DisassociateRoleFromGroupInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct DisassociateRoleFromGroupInputBody: Swift.Equatable {
}

extension DisassociateRoleFromGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateRoleFromGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateRoleFromGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.disassociatedAt = output.disassociatedAt
        } else {
            self.disassociatedAt = nil
        }
    }
}

public struct DisassociateRoleFromGroupOutput: Swift.Equatable {
    /// The time, in milliseconds since the epoch, when the role was disassociated from the group.
    public var disassociatedAt: Swift.String?

    public init(
        disassociatedAt: Swift.String? = nil
    )
    {
        self.disassociatedAt = disassociatedAt
    }
}

struct DisassociateRoleFromGroupOutputBody: Swift.Equatable {
    let disassociatedAt: Swift.String?
}

extension DisassociateRoleFromGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disassociatedAt = "DisassociatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disassociatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .disassociatedAt)
        disassociatedAt = disassociatedAtDecoded
    }
}

enum DisassociateRoleFromGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateServiceRoleFromAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/servicerole"
    }
}

public struct DisassociateServiceRoleFromAccountInput: Swift.Equatable {

    public init() { }
}

struct DisassociateServiceRoleFromAccountInputBody: Swift.Equatable {
}

extension DisassociateServiceRoleFromAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateServiceRoleFromAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateServiceRoleFromAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.disassociatedAt = output.disassociatedAt
        } else {
            self.disassociatedAt = nil
        }
    }
}

public struct DisassociateServiceRoleFromAccountOutput: Swift.Equatable {
    /// The time when the service role was disassociated from the account.
    public var disassociatedAt: Swift.String?

    public init(
        disassociatedAt: Swift.String? = nil
    )
    {
        self.disassociatedAt = disassociatedAt
    }
}

struct DisassociateServiceRoleFromAccountOutputBody: Swift.Equatable {
    let disassociatedAt: Swift.String?
}

extension DisassociateServiceRoleFromAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disassociatedAt = "DisassociatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let disassociatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .disassociatedAt)
        disassociatedAt = disassociatedAtDecoded
    }
}

enum DisassociateServiceRoleFromAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GreengrassClientTypes {
    public enum EncodingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case binary
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [EncodingType] {
            return [
                .binary,
                .json,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .binary: return "binary"
            case .json: return "json"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncodingType(rawValue: rawValue) ?? EncodingType.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassClientTypes.ErrorDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detailedErrorCode = "DetailedErrorCode"
        case detailedErrorMessage = "DetailedErrorMessage"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detailedErrorCode = self.detailedErrorCode {
            try encodeContainer.encode(detailedErrorCode, forKey: .detailedErrorCode)
        }
        if let detailedErrorMessage = self.detailedErrorMessage {
            try encodeContainer.encode(detailedErrorMessage, forKey: .detailedErrorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailedErrorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedErrorCode)
        detailedErrorCode = detailedErrorCodeDecoded
        let detailedErrorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedErrorMessage)
        detailedErrorMessage = detailedErrorMessageDecoded
    }
}

extension GreengrassClientTypes {
    /// Details about the error.
    public struct ErrorDetail: Swift.Equatable {
        /// A detailed error code.
        public var detailedErrorCode: Swift.String?
        /// A detailed error message.
        public var detailedErrorMessage: Swift.String?

        public init(
            detailedErrorCode: Swift.String? = nil,
            detailedErrorMessage: Swift.String? = nil
        )
        {
            self.detailedErrorCode = detailedErrorCode
            self.detailedErrorMessage = detailedErrorMessage
        }
    }

}

extension GreengrassClientTypes.Function: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case functionArn = "FunctionArn"
        case functionConfiguration = "FunctionConfiguration"
        case id = "Id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let functionArn = self.functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let functionConfiguration = self.functionConfiguration {
            try encodeContainer.encode(functionConfiguration, forKey: .functionConfiguration)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let functionConfigurationDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionConfiguration.self, forKey: .functionConfiguration)
        functionConfiguration = functionConfigurationDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a Lambda function.
    public struct Function: Swift.Equatable {
        /// The ARN of the Lambda function.
        public var functionArn: Swift.String?
        /// The configuration of the Lambda function.
        public var functionConfiguration: GreengrassClientTypes.FunctionConfiguration?
        /// A descriptive or arbitrary ID for the function. This value must be unique within the function definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        /// This member is required.
        public var id: Swift.String?

        public init(
            functionArn: Swift.String? = nil,
            functionConfiguration: GreengrassClientTypes.FunctionConfiguration? = nil,
            id: Swift.String? = nil
        )
        {
            self.functionArn = functionArn
            self.functionConfiguration = functionConfiguration
            self.id = id
        }
    }

}

extension GreengrassClientTypes.FunctionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encodingType = "EncodingType"
        case environment = "Environment"
        case execArgs = "ExecArgs"
        case executable = "Executable"
        case functionRuntimeOverride = "FunctionRuntimeOverride"
        case memorySize = "MemorySize"
        case pinned = "Pinned"
        case timeout = "Timeout"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encodingType = self.encodingType {
            try encodeContainer.encode(encodingType.rawValue, forKey: .encodingType)
        }
        if let environment = self.environment {
            try encodeContainer.encode(environment, forKey: .environment)
        }
        if let execArgs = self.execArgs {
            try encodeContainer.encode(execArgs, forKey: .execArgs)
        }
        if let executable = self.executable {
            try encodeContainer.encode(executable, forKey: .executable)
        }
        if let functionRuntimeOverride = self.functionRuntimeOverride {
            try encodeContainer.encode(functionRuntimeOverride, forKey: .functionRuntimeOverride)
        }
        if let memorySize = self.memorySize {
            try encodeContainer.encode(memorySize, forKey: .memorySize)
        }
        if let pinned = self.pinned {
            try encodeContainer.encode(pinned, forKey: .pinned)
        }
        if let timeout = self.timeout {
            try encodeContainer.encode(timeout, forKey: .timeout)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encodingTypeDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.EncodingType.self, forKey: .encodingType)
        encodingType = encodingTypeDecoded
        let environmentDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionConfigurationEnvironment.self, forKey: .environment)
        environment = environmentDecoded
        let execArgsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .execArgs)
        execArgs = execArgsDecoded
        let executableDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executable)
        executable = executableDecoded
        let memorySizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySize)
        memorySize = memorySizeDecoded
        let pinnedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .pinned)
        pinned = pinnedDecoded
        let timeoutDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeout)
        timeout = timeoutDecoded
        let functionRuntimeOverrideDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionRuntimeOverride)
        functionRuntimeOverride = functionRuntimeOverrideDecoded
    }
}

extension GreengrassClientTypes {
    /// The configuration of the Lambda function.
    public struct FunctionConfiguration: Swift.Equatable {
        /// The expected encoding type of the input payload for the function. The default is ''json''.
        public var encodingType: GreengrassClientTypes.EncodingType?
        /// The environment configuration of the function.
        public var environment: GreengrassClientTypes.FunctionConfigurationEnvironment?
        /// The execution arguments.
        public var execArgs: Swift.String?
        /// The name of the function executable.
        public var executable: Swift.String?
        /// The Lambda runtime supported by Greengrass which is to be used instead of the one specified in the Lambda function.
        public var functionRuntimeOverride: Swift.String?
        /// The memory size, in KB, which the function requires. This setting is not applicable and should be cleared when you run the Lambda function without containerization.
        public var memorySize: Swift.Int?
        /// True if the function is pinned. Pinned means the function is long-lived and starts when the core starts.
        public var pinned: Swift.Bool?
        /// The allowed function execution time, after which Lambda should terminate the function. This timeout still applies to pinned Lambda functions for each request.
        public var timeout: Swift.Int?

        public init(
            encodingType: GreengrassClientTypes.EncodingType? = nil,
            environment: GreengrassClientTypes.FunctionConfigurationEnvironment? = nil,
            execArgs: Swift.String? = nil,
            executable: Swift.String? = nil,
            functionRuntimeOverride: Swift.String? = nil,
            memorySize: Swift.Int? = nil,
            pinned: Swift.Bool? = nil,
            timeout: Swift.Int? = nil
        )
        {
            self.encodingType = encodingType
            self.environment = environment
            self.execArgs = execArgs
            self.executable = executable
            self.functionRuntimeOverride = functionRuntimeOverride
            self.memorySize = memorySize
            self.pinned = pinned
            self.timeout = timeout
        }
    }

}

extension GreengrassClientTypes.FunctionConfigurationEnvironment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessSysfs = "AccessSysfs"
        case execution = "Execution"
        case resourceAccessPolicies = "ResourceAccessPolicies"
        case variables = "Variables"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessSysfs = self.accessSysfs {
            try encodeContainer.encode(accessSysfs, forKey: .accessSysfs)
        }
        if let execution = self.execution {
            try encodeContainer.encode(execution, forKey: .execution)
        }
        if let resourceAccessPolicies = resourceAccessPolicies {
            var resourceAccessPoliciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceAccessPolicies)
            for resourceaccesspolicy0 in resourceAccessPolicies {
                try resourceAccessPoliciesContainer.encode(resourceaccesspolicy0)
            }
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variables)
            for (dictKey0, __mapOf__string0) in variables {
                try variablesContainer.encode(__mapOf__string0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessSysfsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .accessSysfs)
        accessSysfs = accessSysfsDecoded
        let executionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionExecutionConfig.self, forKey: .execution)
        execution = executionDecoded
        let resourceAccessPoliciesContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.ResourceAccessPolicy?].self, forKey: .resourceAccessPolicies)
        var resourceAccessPoliciesDecoded0:[GreengrassClientTypes.ResourceAccessPolicy]? = nil
        if let resourceAccessPoliciesContainer = resourceAccessPoliciesContainer {
            resourceAccessPoliciesDecoded0 = [GreengrassClientTypes.ResourceAccessPolicy]()
            for structure0 in resourceAccessPoliciesContainer {
                if let structure0 = structure0 {
                    resourceAccessPoliciesDecoded0?.append(structure0)
                }
            }
        }
        resourceAccessPolicies = resourceAccessPoliciesDecoded0
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:Swift.String]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in variablesContainer {
                if let __string0 = __string0 {
                    variablesDecoded0?[key0] = __string0
                }
            }
        }
        variables = variablesDecoded0
    }
}

extension GreengrassClientTypes {
    /// The environment configuration of the function.
    public struct FunctionConfigurationEnvironment: Swift.Equatable {
        /// If true, the Lambda function is allowed to access the host's /sys folder. Use this when the Lambda function needs to read device information from /sys. This setting applies only when you run the Lambda function in a Greengrass container.
        public var accessSysfs: Swift.Bool?
        /// Configuration related to executing the Lambda function
        public var execution: GreengrassClientTypes.FunctionExecutionConfig?
        /// A list of the resources, with their permissions, to which the Lambda function will be granted access. A Lambda function can have at most 10 resources. ResourceAccessPolicies apply only when you run the Lambda function in a Greengrass container.
        public var resourceAccessPolicies: [GreengrassClientTypes.ResourceAccessPolicy]?
        /// Environment variables for the Lambda function's configuration.
        public var variables: [Swift.String:Swift.String]?

        public init(
            accessSysfs: Swift.Bool? = nil,
            execution: GreengrassClientTypes.FunctionExecutionConfig? = nil,
            resourceAccessPolicies: [GreengrassClientTypes.ResourceAccessPolicy]? = nil,
            variables: [Swift.String:Swift.String]? = nil
        )
        {
            self.accessSysfs = accessSysfs
            self.execution = execution
            self.resourceAccessPolicies = resourceAccessPolicies
            self.variables = variables
        }
    }

}

extension GreengrassClientTypes.FunctionDefaultConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case execution = "Execution"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let execution = self.execution {
            try encodeContainer.encode(execution, forKey: .execution)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionDefaultExecutionConfig.self, forKey: .execution)
        execution = executionDecoded
    }
}

extension GreengrassClientTypes {
    /// The default configuration that applies to all Lambda functions in the group. Individual Lambda functions can override these settings.
    public struct FunctionDefaultConfig: Swift.Equatable {
        /// Configuration information that specifies how a Lambda function runs.
        public var execution: GreengrassClientTypes.FunctionDefaultExecutionConfig?

        public init(
            execution: GreengrassClientTypes.FunctionDefaultExecutionConfig? = nil
        )
        {
            self.execution = execution
        }
    }

}

extension GreengrassClientTypes.FunctionDefaultExecutionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isolationMode = "IsolationMode"
        case runAs = "RunAs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isolationMode = self.isolationMode {
            try encodeContainer.encode(isolationMode.rawValue, forKey: .isolationMode)
        }
        if let runAs = self.runAs {
            try encodeContainer.encode(runAs, forKey: .runAs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isolationModeDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionIsolationMode.self, forKey: .isolationMode)
        isolationMode = isolationModeDecoded
        let runAsDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionRunAsConfig.self, forKey: .runAs)
        runAs = runAsDecoded
    }
}

extension GreengrassClientTypes {
    /// Configuration information that specifies how a Lambda function runs.
    public struct FunctionDefaultExecutionConfig: Swift.Equatable {
        /// Specifies whether the Lambda function runs in a Greengrass container (default) or without containerization. Unless your scenario requires that you run without containerization, we recommend that you run in a Greengrass container. Omit this value to run the Lambda function with the default containerization for the group.
        public var isolationMode: GreengrassClientTypes.FunctionIsolationMode?
        /// Specifies the user and group whose permissions are used when running the Lambda function. You can specify one or both values to override the default values. We recommend that you avoid running as root unless absolutely necessary to minimize the risk of unintended changes or malicious attacks. To run as root, you must set ''IsolationMode'' to ''NoContainer'' and update config.json in ''greengrass-root/config'' to set ''allowFunctionsToRunAsRoot'' to ''yes''.
        public var runAs: GreengrassClientTypes.FunctionRunAsConfig?

        public init(
            isolationMode: GreengrassClientTypes.FunctionIsolationMode? = nil,
            runAs: GreengrassClientTypes.FunctionRunAsConfig? = nil
        )
        {
            self.isolationMode = isolationMode
            self.runAs = runAs
        }
    }

}

extension GreengrassClientTypes.FunctionDefinitionVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultConfig = "DefaultConfig"
        case functions = "Functions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultConfig = self.defaultConfig {
            try encodeContainer.encode(defaultConfig, forKey: .defaultConfig)
        }
        if let functions = functions {
            var functionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .functions)
            for function0 in functions {
                try functionsContainer.encode(function0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultConfigDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionDefaultConfig.self, forKey: .defaultConfig)
        defaultConfig = defaultConfigDecoded
        let functionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Function?].self, forKey: .functions)
        var functionsDecoded0:[GreengrassClientTypes.Function]? = nil
        if let functionsContainer = functionsContainer {
            functionsDecoded0 = [GreengrassClientTypes.Function]()
            for structure0 in functionsContainer {
                if let structure0 = structure0 {
                    functionsDecoded0?.append(structure0)
                }
            }
        }
        functions = functionsDecoded0
    }
}

extension GreengrassClientTypes {
    /// Information about a function definition version.
    public struct FunctionDefinitionVersion: Swift.Equatable {
        /// The default configuration that applies to all Lambda functions in this function definition version. Individual Lambda functions can override these settings.
        public var defaultConfig: GreengrassClientTypes.FunctionDefaultConfig?
        /// A list of Lambda functions in this function definition version.
        public var functions: [GreengrassClientTypes.Function]?

        public init(
            defaultConfig: GreengrassClientTypes.FunctionDefaultConfig? = nil,
            functions: [GreengrassClientTypes.Function]? = nil
        )
        {
            self.defaultConfig = defaultConfig
            self.functions = functions
        }
    }

}

extension GreengrassClientTypes.FunctionExecutionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isolationMode = "IsolationMode"
        case runAs = "RunAs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isolationMode = self.isolationMode {
            try encodeContainer.encode(isolationMode.rawValue, forKey: .isolationMode)
        }
        if let runAs = self.runAs {
            try encodeContainer.encode(runAs, forKey: .runAs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isolationModeDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionIsolationMode.self, forKey: .isolationMode)
        isolationMode = isolationModeDecoded
        let runAsDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionRunAsConfig.self, forKey: .runAs)
        runAs = runAsDecoded
    }
}

extension GreengrassClientTypes {
    /// Configuration information that specifies how a Lambda function runs.
    public struct FunctionExecutionConfig: Swift.Equatable {
        /// Specifies whether the Lambda function runs in a Greengrass container (default) or without containerization. Unless your scenario requires that you run without containerization, we recommend that you run in a Greengrass container. Omit this value to run the Lambda function with the default containerization for the group.
        public var isolationMode: GreengrassClientTypes.FunctionIsolationMode?
        /// Specifies the user and group whose permissions are used when running the Lambda function. You can specify one or both values to override the default values. We recommend that you avoid running as root unless absolutely necessary to minimize the risk of unintended changes or malicious attacks. To run as root, you must set ''IsolationMode'' to ''NoContainer'' and update config.json in ''greengrass-root/config'' to set ''allowFunctionsToRunAsRoot'' to ''yes''.
        public var runAs: GreengrassClientTypes.FunctionRunAsConfig?

        public init(
            isolationMode: GreengrassClientTypes.FunctionIsolationMode? = nil,
            runAs: GreengrassClientTypes.FunctionRunAsConfig? = nil
        )
        {
            self.isolationMode = isolationMode
            self.runAs = runAs
        }
    }

}

extension GreengrassClientTypes {
    /// Specifies whether the Lambda function runs in a Greengrass container (default) or without containerization. Unless your scenario requires that you run without containerization, we recommend that you run in a Greengrass container. Omit this value to run the Lambda function with the default containerization for the group.
    public enum FunctionIsolationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case greengrasscontainer
        case nocontainer
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionIsolationMode] {
            return [
                .greengrasscontainer,
                .nocontainer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .greengrasscontainer: return "GreengrassContainer"
            case .nocontainer: return "NoContainer"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FunctionIsolationMode(rawValue: rawValue) ?? FunctionIsolationMode.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassClientTypes.FunctionRunAsConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gid = "Gid"
        case uid = "Uid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gid = self.gid {
            try encodeContainer.encode(gid, forKey: .gid)
        }
        if let uid = self.uid {
            try encodeContainer.encode(uid, forKey: .uid)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gid)
        gid = gidDecoded
        let uidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uid)
        uid = uidDecoded
    }
}

extension GreengrassClientTypes {
    /// Specifies the user and group whose permissions are used when running the Lambda function. You can specify one or both values to override the default values. We recommend that you avoid running as root unless absolutely necessary to minimize the risk of unintended changes or malicious attacks. To run as root, you must set ''IsolationMode'' to ''NoContainer'' and update config.json in ''greengrass-root/config'' to set ''allowFunctionsToRunAsRoot'' to ''yes''.
    public struct FunctionRunAsConfig: Swift.Equatable {
        /// The group ID whose permissions are used to run a Lambda function.
        public var gid: Swift.Int?
        /// The user ID whose permissions are used to run a Lambda function.
        public var uid: Swift.Int?

        public init(
            gid: Swift.Int? = nil,
            uid: Swift.Int? = nil
        )
        {
            self.gid = gid
            self.uid = uid
        }
    }

}

extension GetAssociatedRoleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/role"
    }
}

public struct GetAssociatedRoleInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct GetAssociatedRoleInputBody: Swift.Equatable {
}

extension GetAssociatedRoleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAssociatedRoleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAssociatedRoleOutputBody = try responseDecoder.decode(responseBody: data)
            self.associatedAt = output.associatedAt
            self.roleArn = output.roleArn
        } else {
            self.associatedAt = nil
            self.roleArn = nil
        }
    }
}

public struct GetAssociatedRoleOutput: Swift.Equatable {
    /// The time when the role was associated with the group.
    public var associatedAt: Swift.String?
    /// The ARN of the role that is associated with the group.
    public var roleArn: Swift.String?

    public init(
        associatedAt: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.associatedAt = associatedAt
        self.roleArn = roleArn
    }
}

struct GetAssociatedRoleOutputBody: Swift.Equatable {
    let associatedAt: Swift.String?
    let roleArn: Swift.String?
}

extension GetAssociatedRoleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedAt = "AssociatedAt"
        case roleArn = "RoleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedAt)
        associatedAt = associatedAtDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

enum GetAssociatedRoleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetBulkDeploymentStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bulkDeploymentId = bulkDeploymentId else {
            return nil
        }
        return "/greengrass/bulk/deployments/\(bulkDeploymentId.urlPercentEncoding())/status"
    }
}

public struct GetBulkDeploymentStatusInput: Swift.Equatable {
    /// The ID of the bulk deployment.
    /// This member is required.
    public var bulkDeploymentId: Swift.String?

    public init(
        bulkDeploymentId: Swift.String? = nil
    )
    {
        self.bulkDeploymentId = bulkDeploymentId
    }
}

struct GetBulkDeploymentStatusInputBody: Swift.Equatable {
}

extension GetBulkDeploymentStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetBulkDeploymentStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBulkDeploymentStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.bulkDeploymentMetrics = output.bulkDeploymentMetrics
            self.bulkDeploymentStatus = output.bulkDeploymentStatus
            self.createdAt = output.createdAt
            self.errorDetails = output.errorDetails
            self.errorMessage = output.errorMessage
            self.tags = output.tags
        } else {
            self.bulkDeploymentMetrics = nil
            self.bulkDeploymentStatus = nil
            self.createdAt = nil
            self.errorDetails = nil
            self.errorMessage = nil
            self.tags = nil
        }
    }
}

public struct GetBulkDeploymentStatusOutput: Swift.Equatable {
    /// Relevant metrics on input records processed during bulk deployment.
    public var bulkDeploymentMetrics: GreengrassClientTypes.BulkDeploymentMetrics?
    /// The status of the bulk deployment.
    public var bulkDeploymentStatus: GreengrassClientTypes.BulkDeploymentStatus?
    /// The time, in ISO format, when the deployment was created.
    public var createdAt: Swift.String?
    /// Error details
    public var errorDetails: [GreengrassClientTypes.ErrorDetail]?
    /// Error message
    public var errorMessage: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init(
        bulkDeploymentMetrics: GreengrassClientTypes.BulkDeploymentMetrics? = nil,
        bulkDeploymentStatus: GreengrassClientTypes.BulkDeploymentStatus? = nil,
        createdAt: Swift.String? = nil,
        errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil,
        errorMessage: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.bulkDeploymentMetrics = bulkDeploymentMetrics
        self.bulkDeploymentStatus = bulkDeploymentStatus
        self.createdAt = createdAt
        self.errorDetails = errorDetails
        self.errorMessage = errorMessage
        self.tags = tags
    }
}

struct GetBulkDeploymentStatusOutputBody: Swift.Equatable {
    let bulkDeploymentMetrics: GreengrassClientTypes.BulkDeploymentMetrics?
    let bulkDeploymentStatus: GreengrassClientTypes.BulkDeploymentStatus?
    let createdAt: Swift.String?
    let errorDetails: [GreengrassClientTypes.ErrorDetail]?
    let errorMessage: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetBulkDeploymentStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bulkDeploymentMetrics = "BulkDeploymentMetrics"
        case bulkDeploymentStatus = "BulkDeploymentStatus"
        case createdAt = "CreatedAt"
        case errorDetails = "ErrorDetails"
        case errorMessage = "ErrorMessage"
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bulkDeploymentMetricsDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.BulkDeploymentMetrics.self, forKey: .bulkDeploymentMetrics)
        bulkDeploymentMetrics = bulkDeploymentMetricsDecoded
        let bulkDeploymentStatusDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.BulkDeploymentStatus.self, forKey: .bulkDeploymentStatus)
        bulkDeploymentStatus = bulkDeploymentStatusDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let errorDetailsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.ErrorDetail?].self, forKey: .errorDetails)
        var errorDetailsDecoded0:[GreengrassClientTypes.ErrorDetail]? = nil
        if let errorDetailsContainer = errorDetailsContainer {
            errorDetailsDecoded0 = [GreengrassClientTypes.ErrorDetail]()
            for structure0 in errorDetailsContainer {
                if let structure0 = structure0 {
                    errorDetailsDecoded0?.append(structure0)
                }
            }
        }
        errorDetails = errorDetailsDecoded0
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetBulkDeploymentStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetConnectivityInfoInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/greengrass/things/\(thingName.urlPercentEncoding())/connectivityInfo"
    }
}

public struct GetConnectivityInfoInput: Swift.Equatable {
    /// The thing name.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        thingName: Swift.String? = nil
    )
    {
        self.thingName = thingName
    }
}

struct GetConnectivityInfoInputBody: Swift.Equatable {
}

extension GetConnectivityInfoInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetConnectivityInfoOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConnectivityInfoOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectivityInfo = output.connectivityInfo
            self.message = output.message
        } else {
            self.connectivityInfo = nil
            self.message = nil
        }
    }
}

public struct GetConnectivityInfoOutput: Swift.Equatable {
    /// Connectivity info list.
    public var connectivityInfo: [GreengrassClientTypes.ConnectivityInfo]?
    /// A message about the connectivity info request.
    public var message: Swift.String?

    public init(
        connectivityInfo: [GreengrassClientTypes.ConnectivityInfo]? = nil,
        message: Swift.String? = nil
    )
    {
        self.connectivityInfo = connectivityInfo
        self.message = message
    }
}

struct GetConnectivityInfoOutputBody: Swift.Equatable {
    let connectivityInfo: [GreengrassClientTypes.ConnectivityInfo]?
    let message: Swift.String?
}

extension GetConnectivityInfoOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectivityInfo = "ConnectivityInfo"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectivityInfoContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.ConnectivityInfo?].self, forKey: .connectivityInfo)
        var connectivityInfoDecoded0:[GreengrassClientTypes.ConnectivityInfo]? = nil
        if let connectivityInfoContainer = connectivityInfoContainer {
            connectivityInfoDecoded0 = [GreengrassClientTypes.ConnectivityInfo]()
            for structure0 in connectivityInfoContainer {
                if let structure0 = structure0 {
                    connectivityInfoDecoded0?.append(structure0)
                }
            }
        }
        connectivityInfo = connectivityInfoDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum GetConnectivityInfoOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetConnectorDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectorDefinitionId = connectorDefinitionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())"
    }
}

public struct GetConnectorDefinitionInput: Swift.Equatable {
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?

    public init(
        connectorDefinitionId: Swift.String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
    }
}

struct GetConnectorDefinitionInputBody: Swift.Equatable {
}

extension GetConnectorDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetConnectorDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConnectorDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetConnectorDefinitionOutput: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetConnectorDefinitionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetConnectorDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetConnectorDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetConnectorDefinitionVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension GetConnectorDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectorDefinitionId = connectorDefinitionId else {
            return nil
        }
        guard let connectorDefinitionVersionId = connectorDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())/versions/\(connectorDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetConnectorDefinitionVersionInput: Swift.Equatable {
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?
    /// The ID of the connector definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListConnectorDefinitionVersions'' requests. If the version is the last one that was associated with a connector definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var connectorDefinitionVersionId: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        connectorDefinitionId: Swift.String? = nil,
        connectorDefinitionVersionId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
        self.connectorDefinitionVersionId = connectorDefinitionVersionId
        self.nextToken = nextToken
    }
}

struct GetConnectorDefinitionVersionInputBody: Swift.Equatable {
}

extension GetConnectorDefinitionVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetConnectorDefinitionVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConnectorDefinitionVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.nextToken = output.nextToken
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.nextToken = nil
            self.version = nil
        }
    }
}

public struct GetConnectorDefinitionVersionOutput: Swift.Equatable {
    /// The ARN of the connector definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the connector definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the connector definition version.
    public var definition: GreengrassClientTypes.ConnectorDefinitionVersion?
    /// The ID of the connector definition version.
    public var id: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The version of the connector definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.ConnectorDefinitionVersion? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

struct GetConnectorDefinitionVersionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let definition: GreengrassClientTypes.ConnectorDefinitionVersion?
    let id: Swift.String?
    let nextToken: Swift.String?
    let version: Swift.String?
}

extension GetConnectorDefinitionVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case nextToken = "NextToken"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.ConnectorDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum GetConnectorDefinitionVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCoreDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreDefinitionId = coreDefinitionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())"
    }
}

public struct GetCoreDefinitionInput: Swift.Equatable {
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?

    public init(
        coreDefinitionId: Swift.String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
    }
}

struct GetCoreDefinitionInputBody: Swift.Equatable {
}

extension GetCoreDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCoreDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCoreDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetCoreDefinitionOutput: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetCoreDefinitionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetCoreDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetCoreDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCoreDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreDefinitionId = coreDefinitionId else {
            return nil
        }
        guard let coreDefinitionVersionId = coreDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())/versions/\(coreDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetCoreDefinitionVersionInput: Swift.Equatable {
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?
    /// The ID of the core definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListCoreDefinitionVersions'' requests. If the version is the last one that was associated with a core definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var coreDefinitionVersionId: Swift.String?

    public init(
        coreDefinitionId: Swift.String? = nil,
        coreDefinitionVersionId: Swift.String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
        self.coreDefinitionVersionId = coreDefinitionVersionId
    }
}

struct GetCoreDefinitionVersionInputBody: Swift.Equatable {
}

extension GetCoreDefinitionVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCoreDefinitionVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCoreDefinitionVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.nextToken = output.nextToken
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.nextToken = nil
            self.version = nil
        }
    }
}

public struct GetCoreDefinitionVersionOutput: Swift.Equatable {
    /// The ARN of the core definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the core definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the core definition version.
    public var definition: GreengrassClientTypes.CoreDefinitionVersion?
    /// The ID of the core definition version.
    public var id: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The version of the core definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.CoreDefinitionVersion? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

struct GetCoreDefinitionVersionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let definition: GreengrassClientTypes.CoreDefinitionVersion?
    let id: Swift.String?
    let nextToken: Swift.String?
    let version: Swift.String?
}

extension GetCoreDefinitionVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case nextToken = "NextToken"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.CoreDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum GetCoreDefinitionVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDeploymentStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        guard let deploymentId = deploymentId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())/status"
    }
}

public struct GetDeploymentStatusInput: Swift.Equatable {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.groupId = groupId
    }
}

struct GetDeploymentStatusInputBody: Swift.Equatable {
}

extension GetDeploymentStatusInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDeploymentStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeploymentStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.deploymentStatus = output.deploymentStatus
            self.deploymentType = output.deploymentType
            self.errorDetails = output.errorDetails
            self.errorMessage = output.errorMessage
            self.updatedAt = output.updatedAt
        } else {
            self.deploymentStatus = nil
            self.deploymentType = nil
            self.errorDetails = nil
            self.errorMessage = nil
            self.updatedAt = nil
        }
    }
}

public struct GetDeploymentStatusOutput: Swift.Equatable {
    /// The status of the deployment: ''InProgress'', ''Building'', ''Success'', or ''Failure''.
    public var deploymentStatus: Swift.String?
    /// The type of the deployment.
    public var deploymentType: GreengrassClientTypes.DeploymentType?
    /// Error details
    public var errorDetails: [GreengrassClientTypes.ErrorDetail]?
    /// Error message
    public var errorMessage: Swift.String?
    /// The time, in milliseconds since the epoch, when the deployment status was updated.
    public var updatedAt: Swift.String?

    public init(
        deploymentStatus: Swift.String? = nil,
        deploymentType: GreengrassClientTypes.DeploymentType? = nil,
        errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil,
        errorMessage: Swift.String? = nil,
        updatedAt: Swift.String? = nil
    )
    {
        self.deploymentStatus = deploymentStatus
        self.deploymentType = deploymentType
        self.errorDetails = errorDetails
        self.errorMessage = errorMessage
        self.updatedAt = updatedAt
    }
}

struct GetDeploymentStatusOutputBody: Swift.Equatable {
    let deploymentStatus: Swift.String?
    let deploymentType: GreengrassClientTypes.DeploymentType?
    let errorDetails: [GreengrassClientTypes.ErrorDetail]?
    let errorMessage: Swift.String?
    let updatedAt: Swift.String?
}

extension GetDeploymentStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentStatus = "DeploymentStatus"
        case deploymentType = "DeploymentType"
        case errorDetails = "ErrorDetails"
        case errorMessage = "ErrorMessage"
        case updatedAt = "UpdatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentStatus)
        deploymentStatus = deploymentStatusDecoded
        let deploymentTypeDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.DeploymentType.self, forKey: .deploymentType)
        deploymentType = deploymentTypeDecoded
        let errorDetailsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.ErrorDetail?].self, forKey: .errorDetails)
        var errorDetailsDecoded0:[GreengrassClientTypes.ErrorDetail]? = nil
        if let errorDetailsContainer = errorDetailsContainer {
            errorDetailsDecoded0 = [GreengrassClientTypes.ErrorDetail]()
            for structure0 in errorDetailsContainer {
                if let structure0 = structure0 {
                    errorDetailsDecoded0?.append(structure0)
                }
            }
        }
        errorDetails = errorDetailsDecoded0
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

enum GetDeploymentStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDeviceDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceDefinitionId = deviceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())"
    }
}

public struct GetDeviceDefinitionInput: Swift.Equatable {
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?

    public init(
        deviceDefinitionId: Swift.String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
    }
}

struct GetDeviceDefinitionInputBody: Swift.Equatable {
}

extension GetDeviceDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDeviceDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeviceDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetDeviceDefinitionOutput: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetDeviceDefinitionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetDeviceDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetDeviceDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDeviceDefinitionVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension GetDeviceDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceDefinitionId = deviceDefinitionId else {
            return nil
        }
        guard let deviceDefinitionVersionId = deviceDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())/versions/\(deviceDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetDeviceDefinitionVersionInput: Swift.Equatable {
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?
    /// The ID of the device definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListDeviceDefinitionVersions'' requests. If the version is the last one that was associated with a device definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var deviceDefinitionVersionId: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        deviceDefinitionId: Swift.String? = nil,
        deviceDefinitionVersionId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
        self.deviceDefinitionVersionId = deviceDefinitionVersionId
        self.nextToken = nextToken
    }
}

struct GetDeviceDefinitionVersionInputBody: Swift.Equatable {
}

extension GetDeviceDefinitionVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDeviceDefinitionVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeviceDefinitionVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.nextToken = output.nextToken
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.nextToken = nil
            self.version = nil
        }
    }
}

public struct GetDeviceDefinitionVersionOutput: Swift.Equatable {
    /// The ARN of the device definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the device definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the device definition version.
    public var definition: GreengrassClientTypes.DeviceDefinitionVersion?
    /// The ID of the device definition version.
    public var id: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The version of the device definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.DeviceDefinitionVersion? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

struct GetDeviceDefinitionVersionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let definition: GreengrassClientTypes.DeviceDefinitionVersion?
    let id: Swift.String?
    let nextToken: Swift.String?
    let version: Swift.String?
}

extension GetDeviceDefinitionVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case nextToken = "NextToken"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.DeviceDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum GetDeviceDefinitionVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFunctionDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionDefinitionId = functionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())"
    }
}

public struct GetFunctionDefinitionInput: Swift.Equatable {
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?

    public init(
        functionDefinitionId: Swift.String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
    }
}

struct GetFunctionDefinitionInputBody: Swift.Equatable {
}

extension GetFunctionDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFunctionDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetFunctionDefinitionOutput: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetFunctionDefinitionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetFunctionDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetFunctionDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFunctionDefinitionVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension GetFunctionDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionDefinitionId = functionDefinitionId else {
            return nil
        }
        guard let functionDefinitionVersionId = functionDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())/versions/\(functionDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetFunctionDefinitionVersionInput: Swift.Equatable {
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?
    /// The ID of the function definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListFunctionDefinitionVersions'' requests. If the version is the last one that was associated with a function definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var functionDefinitionVersionId: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        functionDefinitionId: Swift.String? = nil,
        functionDefinitionVersionId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
        self.functionDefinitionVersionId = functionDefinitionVersionId
        self.nextToken = nextToken
    }
}

struct GetFunctionDefinitionVersionInputBody: Swift.Equatable {
}

extension GetFunctionDefinitionVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFunctionDefinitionVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFunctionDefinitionVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.nextToken = output.nextToken
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.nextToken = nil
            self.version = nil
        }
    }
}

public struct GetFunctionDefinitionVersionOutput: Swift.Equatable {
    /// The ARN of the function definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the function definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information on the definition.
    public var definition: GreengrassClientTypes.FunctionDefinitionVersion?
    /// The ID of the function definition version.
    public var id: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The version of the function definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.FunctionDefinitionVersion? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

struct GetFunctionDefinitionVersionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let definition: GreengrassClientTypes.FunctionDefinitionVersion?
    let id: Swift.String?
    let nextToken: Swift.String?
    let version: Swift.String?
}

extension GetFunctionDefinitionVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case nextToken = "NextToken"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.FunctionDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum GetFunctionDefinitionVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGroupCertificateAuthorityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        guard let certificateAuthorityId = certificateAuthorityId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/certificateauthorities/\(certificateAuthorityId.urlPercentEncoding())"
    }
}

public struct GetGroupCertificateAuthorityInput: Swift.Equatable {
    /// The ID of the certificate authority.
    /// This member is required.
    public var certificateAuthorityId: Swift.String?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        certificateAuthorityId: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.certificateAuthorityId = certificateAuthorityId
        self.groupId = groupId
    }
}

struct GetGroupCertificateAuthorityInputBody: Swift.Equatable {
}

extension GetGroupCertificateAuthorityInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGroupCertificateAuthorityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGroupCertificateAuthorityOutputBody = try responseDecoder.decode(responseBody: data)
            self.groupCertificateAuthorityArn = output.groupCertificateAuthorityArn
            self.groupCertificateAuthorityId = output.groupCertificateAuthorityId
            self.pemEncodedCertificate = output.pemEncodedCertificate
        } else {
            self.groupCertificateAuthorityArn = nil
            self.groupCertificateAuthorityId = nil
            self.pemEncodedCertificate = nil
        }
    }
}

public struct GetGroupCertificateAuthorityOutput: Swift.Equatable {
    /// The ARN of the certificate authority for the group.
    public var groupCertificateAuthorityArn: Swift.String?
    /// The ID of the certificate authority for the group.
    public var groupCertificateAuthorityId: Swift.String?
    /// The PEM encoded certificate for the group.
    public var pemEncodedCertificate: Swift.String?

    public init(
        groupCertificateAuthorityArn: Swift.String? = nil,
        groupCertificateAuthorityId: Swift.String? = nil,
        pemEncodedCertificate: Swift.String? = nil
    )
    {
        self.groupCertificateAuthorityArn = groupCertificateAuthorityArn
        self.groupCertificateAuthorityId = groupCertificateAuthorityId
        self.pemEncodedCertificate = pemEncodedCertificate
    }
}

struct GetGroupCertificateAuthorityOutputBody: Swift.Equatable {
    let groupCertificateAuthorityArn: Swift.String?
    let groupCertificateAuthorityId: Swift.String?
    let pemEncodedCertificate: Swift.String?
}

extension GetGroupCertificateAuthorityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupCertificateAuthorityArn = "GroupCertificateAuthorityArn"
        case groupCertificateAuthorityId = "GroupCertificateAuthorityId"
        case pemEncodedCertificate = "PemEncodedCertificate"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupCertificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupCertificateAuthorityArn)
        groupCertificateAuthorityArn = groupCertificateAuthorityArnDecoded
        let groupCertificateAuthorityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupCertificateAuthorityId)
        groupCertificateAuthorityId = groupCertificateAuthorityIdDecoded
        let pemEncodedCertificateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pemEncodedCertificate)
        pemEncodedCertificate = pemEncodedCertificateDecoded
    }
}

enum GetGroupCertificateAuthorityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGroupCertificateConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/certificateauthorities/configuration/expiry"
    }
}

public struct GetGroupCertificateConfigurationInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct GetGroupCertificateConfigurationInputBody: Swift.Equatable {
}

extension GetGroupCertificateConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGroupCertificateConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGroupCertificateConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificateAuthorityExpiryInMilliseconds = output.certificateAuthorityExpiryInMilliseconds
            self.certificateExpiryInMilliseconds = output.certificateExpiryInMilliseconds
            self.groupId = output.groupId
        } else {
            self.certificateAuthorityExpiryInMilliseconds = nil
            self.certificateExpiryInMilliseconds = nil
            self.groupId = nil
        }
    }
}

public struct GetGroupCertificateConfigurationOutput: Swift.Equatable {
    /// The amount of time remaining before the certificate authority expires, in milliseconds.
    public var certificateAuthorityExpiryInMilliseconds: Swift.String?
    /// The amount of time remaining before the certificate expires, in milliseconds.
    public var certificateExpiryInMilliseconds: Swift.String?
    /// The ID of the group certificate configuration.
    public var groupId: Swift.String?

    public init(
        certificateAuthorityExpiryInMilliseconds: Swift.String? = nil,
        certificateExpiryInMilliseconds: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.certificateAuthorityExpiryInMilliseconds = certificateAuthorityExpiryInMilliseconds
        self.certificateExpiryInMilliseconds = certificateExpiryInMilliseconds
        self.groupId = groupId
    }
}

struct GetGroupCertificateConfigurationOutputBody: Swift.Equatable {
    let certificateAuthorityExpiryInMilliseconds: Swift.String?
    let certificateExpiryInMilliseconds: Swift.String?
    let groupId: Swift.String?
}

extension GetGroupCertificateConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityExpiryInMilliseconds = "CertificateAuthorityExpiryInMilliseconds"
        case certificateExpiryInMilliseconds = "CertificateExpiryInMilliseconds"
        case groupId = "GroupId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityExpiryInMillisecondsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityExpiryInMilliseconds)
        certificateAuthorityExpiryInMilliseconds = certificateAuthorityExpiryInMillisecondsDecoded
        let certificateExpiryInMillisecondsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateExpiryInMilliseconds)
        certificateExpiryInMilliseconds = certificateExpiryInMillisecondsDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

enum GetGroupCertificateConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())"
    }
}

public struct GetGroupInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct GetGroupInputBody: Swift.Equatable {
}

extension GetGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetGroupOutput: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetGroupOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetGroupVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        guard let groupVersionId = groupVersionId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/versions/\(groupVersionId.urlPercentEncoding())"
    }
}

public struct GetGroupVersionInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The ID of the group version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListGroupVersions'' requests. If the version is the last one that was associated with a group, the value also maps to the ''LatestVersion'' property of the corresponding ''GroupInformation'' object.
    /// This member is required.
    public var groupVersionId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        groupVersionId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.groupVersionId = groupVersionId
    }
}

struct GetGroupVersionInputBody: Swift.Equatable {
}

extension GetGroupVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetGroupVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetGroupVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct GetGroupVersionOutput: Swift.Equatable {
    /// The ARN of the group version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the group version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the group version definition.
    public var definition: GreengrassClientTypes.GroupVersion?
    /// The ID of the group that the version is associated with.
    public var id: Swift.String?
    /// The ID of the group version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.GroupVersion? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.version = version
    }
}

struct GetGroupVersionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let definition: GreengrassClientTypes.GroupVersion?
    let id: Swift.String?
    let version: Swift.String?
}

extension GetGroupVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.GroupVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum GetGroupVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLoggerDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let loggerDefinitionId = loggerDefinitionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())"
    }
}

public struct GetLoggerDefinitionInput: Swift.Equatable {
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?

    public init(
        loggerDefinitionId: Swift.String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
    }
}

struct GetLoggerDefinitionInputBody: Swift.Equatable {
}

extension GetLoggerDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLoggerDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLoggerDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetLoggerDefinitionOutput: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetLoggerDefinitionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetLoggerDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetLoggerDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLoggerDefinitionVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension GetLoggerDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let loggerDefinitionId = loggerDefinitionId else {
            return nil
        }
        guard let loggerDefinitionVersionId = loggerDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())/versions/\(loggerDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetLoggerDefinitionVersionInput: Swift.Equatable {
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?
    /// The ID of the logger definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListLoggerDefinitionVersions'' requests. If the version is the last one that was associated with a logger definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var loggerDefinitionVersionId: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        loggerDefinitionId: Swift.String? = nil,
        loggerDefinitionVersionId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
        self.loggerDefinitionVersionId = loggerDefinitionVersionId
        self.nextToken = nextToken
    }
}

struct GetLoggerDefinitionVersionInputBody: Swift.Equatable {
}

extension GetLoggerDefinitionVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLoggerDefinitionVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLoggerDefinitionVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct GetLoggerDefinitionVersionOutput: Swift.Equatable {
    /// The ARN of the logger definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the logger definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the logger definition version.
    public var definition: GreengrassClientTypes.LoggerDefinitionVersion?
    /// The ID of the logger definition version.
    public var id: Swift.String?
    /// The version of the logger definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.LoggerDefinitionVersion? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.version = version
    }
}

struct GetLoggerDefinitionVersionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let definition: GreengrassClientTypes.LoggerDefinitionVersion?
    let id: Swift.String?
    let version: Swift.String?
}

extension GetLoggerDefinitionVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.LoggerDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum GetLoggerDefinitionVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourceDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceDefinitionId = resourceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())"
    }
}

public struct GetResourceDefinitionInput: Swift.Equatable {
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?

    public init(
        resourceDefinitionId: Swift.String? = nil
    )
    {
        self.resourceDefinitionId = resourceDefinitionId
    }
}

struct GetResourceDefinitionInputBody: Swift.Equatable {
}

extension GetResourceDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetResourceDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourceDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetResourceDefinitionOutput: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetResourceDefinitionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetResourceDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetResourceDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetResourceDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceDefinitionId = resourceDefinitionId else {
            return nil
        }
        guard let resourceDefinitionVersionId = resourceDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())/versions/\(resourceDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetResourceDefinitionVersionInput: Swift.Equatable {
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?
    /// The ID of the resource definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListResourceDefinitionVersions'' requests. If the version is the last one that was associated with a resource definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var resourceDefinitionVersionId: Swift.String?

    public init(
        resourceDefinitionId: Swift.String? = nil,
        resourceDefinitionVersionId: Swift.String? = nil
    )
    {
        self.resourceDefinitionId = resourceDefinitionId
        self.resourceDefinitionVersionId = resourceDefinitionVersionId
    }
}

struct GetResourceDefinitionVersionInputBody: Swift.Equatable {
}

extension GetResourceDefinitionVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetResourceDefinitionVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetResourceDefinitionVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.version = nil
        }
    }
}

public struct GetResourceDefinitionVersionOutput: Swift.Equatable {
    /// Arn of the resource definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the resource definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the definition.
    public var definition: GreengrassClientTypes.ResourceDefinitionVersion?
    /// The ID of the resource definition version.
    public var id: Swift.String?
    /// The version of the resource definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.ResourceDefinitionVersion? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.version = version
    }
}

struct GetResourceDefinitionVersionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let definition: GreengrassClientTypes.ResourceDefinitionVersion?
    let id: Swift.String?
    let version: Swift.String?
}

extension GetResourceDefinitionVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.ResourceDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum GetResourceDefinitionVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServiceRoleForAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/servicerole"
    }
}

public struct GetServiceRoleForAccountInput: Swift.Equatable {

    public init() { }
}

struct GetServiceRoleForAccountInputBody: Swift.Equatable {
}

extension GetServiceRoleForAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetServiceRoleForAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServiceRoleForAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.associatedAt = output.associatedAt
            self.roleArn = output.roleArn
        } else {
            self.associatedAt = nil
            self.roleArn = nil
        }
    }
}

public struct GetServiceRoleForAccountOutput: Swift.Equatable {
    /// The time when the service role was associated with the account.
    public var associatedAt: Swift.String?
    /// The ARN of the role which is associated with the account.
    public var roleArn: Swift.String?

    public init(
        associatedAt: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.associatedAt = associatedAt
        self.roleArn = roleArn
    }
}

struct GetServiceRoleForAccountOutputBody: Swift.Equatable {
    let associatedAt: Swift.String?
    let roleArn: Swift.String?
}

extension GetServiceRoleForAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedAt = "AssociatedAt"
        case roleArn = "RoleArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let associatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedAt)
        associatedAt = associatedAtDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

enum GetServiceRoleForAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSubscriptionDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriptionDefinitionId = subscriptionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())"
    }
}

public struct GetSubscriptionDefinitionInput: Swift.Equatable {
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?

    public init(
        subscriptionDefinitionId: Swift.String? = nil
    )
    {
        self.subscriptionDefinitionId = subscriptionDefinitionId
    }
}

struct GetSubscriptionDefinitionInputBody: Swift.Equatable {
}

extension GetSubscriptionDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSubscriptionDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSubscriptionDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.id = output.id
            self.lastUpdatedTimestamp = output.lastUpdatedTimestamp
            self.latestVersion = output.latestVersion
            self.latestVersionArn = output.latestVersionArn
            self.name = output.name
            self.tags = output.tags
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.id = nil
            self.lastUpdatedTimestamp = nil
            self.latestVersion = nil
            self.latestVersionArn = nil
            self.name = nil
            self.tags = nil
        }
    }
}

public struct GetSubscriptionDefinitionOutput: Swift.Equatable {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

struct GetSubscriptionDefinitionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let id: Swift.String?
    let lastUpdatedTimestamp: Swift.String?
    let latestVersion: Swift.String?
    let latestVersionArn: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetSubscriptionDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetSubscriptionDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSubscriptionDefinitionVersionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension GetSubscriptionDefinitionVersionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriptionDefinitionId = subscriptionDefinitionId else {
            return nil
        }
        guard let subscriptionDefinitionVersionId = subscriptionDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())/versions/\(subscriptionDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetSubscriptionDefinitionVersionInput: Swift.Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?
    /// The ID of the subscription definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListSubscriptionDefinitionVersions'' requests. If the version is the last one that was associated with a subscription definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var subscriptionDefinitionVersionId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        subscriptionDefinitionId: Swift.String? = nil,
        subscriptionDefinitionVersionId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptionDefinitionId = subscriptionDefinitionId
        self.subscriptionDefinitionVersionId = subscriptionDefinitionVersionId
    }
}

struct GetSubscriptionDefinitionVersionInputBody: Swift.Equatable {
}

extension GetSubscriptionDefinitionVersionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSubscriptionDefinitionVersionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSubscriptionDefinitionVersionOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationTimestamp = output.creationTimestamp
            self.definition = output.definition
            self.id = output.id
            self.nextToken = output.nextToken
            self.version = output.version
        } else {
            self.arn = nil
            self.creationTimestamp = nil
            self.definition = nil
            self.id = nil
            self.nextToken = nil
            self.version = nil
        }
    }
}

public struct GetSubscriptionDefinitionVersionOutput: Swift.Equatable {
    /// The ARN of the subscription definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the subscription definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the subscription definition version.
    public var definition: GreengrassClientTypes.SubscriptionDefinitionVersion?
    /// The ID of the subscription definition version.
    public var id: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The version of the subscription definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.SubscriptionDefinitionVersion? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

struct GetSubscriptionDefinitionVersionOutputBody: Swift.Equatable {
    let arn: Swift.String?
    let creationTimestamp: Swift.String?
    let definition: GreengrassClientTypes.SubscriptionDefinitionVersion?
    let id: Swift.String?
    let nextToken: Swift.String?
    let version: Swift.String?
}

extension GetSubscriptionDefinitionVersionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case definition = "Definition"
        case id = "Id"
        case nextToken = "NextToken"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.SubscriptionDefinitionVersion.self, forKey: .definition)
        definition = definitionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum GetSubscriptionDefinitionVersionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetThingRuntimeConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/greengrass/things/\(thingName.urlPercentEncoding())/runtimeconfig"
    }
}

public struct GetThingRuntimeConfigurationInput: Swift.Equatable {
    /// The thing name.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        thingName: Swift.String? = nil
    )
    {
        self.thingName = thingName
    }
}

struct GetThingRuntimeConfigurationInputBody: Swift.Equatable {
}

extension GetThingRuntimeConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetThingRuntimeConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetThingRuntimeConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.runtimeConfiguration = output.runtimeConfiguration
        } else {
            self.runtimeConfiguration = nil
        }
    }
}

public struct GetThingRuntimeConfigurationOutput: Swift.Equatable {
    /// Runtime configuration for a thing.
    public var runtimeConfiguration: GreengrassClientTypes.RuntimeConfiguration?

    public init(
        runtimeConfiguration: GreengrassClientTypes.RuntimeConfiguration? = nil
    )
    {
        self.runtimeConfiguration = runtimeConfiguration
    }
}

struct GetThingRuntimeConfigurationOutputBody: Swift.Equatable {
    let runtimeConfiguration: GreengrassClientTypes.RuntimeConfiguration?
}

extension GetThingRuntimeConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case runtimeConfiguration = "RuntimeConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeConfigurationDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.RuntimeConfiguration.self, forKey: .runtimeConfiguration)
        runtimeConfiguration = runtimeConfigurationDecoded
    }
}

enum GetThingRuntimeConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GreengrassClientTypes.GroupCertificateAuthorityProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupCertificateAuthorityArn = "GroupCertificateAuthorityArn"
        case groupCertificateAuthorityId = "GroupCertificateAuthorityId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupCertificateAuthorityArn = self.groupCertificateAuthorityArn {
            try encodeContainer.encode(groupCertificateAuthorityArn, forKey: .groupCertificateAuthorityArn)
        }
        if let groupCertificateAuthorityId = self.groupCertificateAuthorityId {
            try encodeContainer.encode(groupCertificateAuthorityId, forKey: .groupCertificateAuthorityId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupCertificateAuthorityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupCertificateAuthorityArn)
        groupCertificateAuthorityArn = groupCertificateAuthorityArnDecoded
        let groupCertificateAuthorityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupCertificateAuthorityId)
        groupCertificateAuthorityId = groupCertificateAuthorityIdDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a certificate authority for a group.
    public struct GroupCertificateAuthorityProperties: Swift.Equatable {
        /// The ARN of the certificate authority for the group.
        public var groupCertificateAuthorityArn: Swift.String?
        /// The ID of the certificate authority for the group.
        public var groupCertificateAuthorityId: Swift.String?

        public init(
            groupCertificateAuthorityArn: Swift.String? = nil,
            groupCertificateAuthorityId: Swift.String? = nil
        )
        {
            self.groupCertificateAuthorityArn = groupCertificateAuthorityArn
            self.groupCertificateAuthorityId = groupCertificateAuthorityId
        }
    }

}

extension GreengrassClientTypes.GroupInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case latestVersion = "LatestVersion"
        case latestVersionArn = "LatestVersionArn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTimestamp = self.creationTimestamp {
            try encodeContainer.encode(creationTimestamp, forKey: .creationTimestamp)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encode(lastUpdatedTimestamp, forKey: .lastUpdatedTimestamp)
        }
        if let latestVersion = self.latestVersion {
            try encodeContainer.encode(latestVersion, forKey: .latestVersion)
        }
        if let latestVersionArn = self.latestVersionArn {
            try encodeContainer.encode(latestVersionArn, forKey: .latestVersionArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let latestVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersionArn)
        latestVersionArn = latestVersionArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a group.
    public struct GroupInformation: Swift.Equatable {
        /// The ARN of the group.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the group was created.
        public var creationTimestamp: Swift.String?
        /// The ID of the group.
        public var id: Swift.String?
        /// The time, in milliseconds since the epoch, when the group was last updated.
        public var lastUpdatedTimestamp: Swift.String?
        /// The ID of the latest version associated with the group.
        public var latestVersion: Swift.String?
        /// The ARN of the latest version associated with the group.
        public var latestVersionArn: Swift.String?
        /// The name of the group.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTimestamp: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedTimestamp: Swift.String? = nil,
            latestVersion: Swift.String? = nil,
            latestVersionArn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
        }
    }

}

extension GreengrassClientTypes.GroupOwnerSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoAddGroupOwner = "AutoAddGroupOwner"
        case groupOwner = "GroupOwner"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoAddGroupOwner = self.autoAddGroupOwner {
            try encodeContainer.encode(autoAddGroupOwner, forKey: .autoAddGroupOwner)
        }
        if let groupOwner = self.groupOwner {
            try encodeContainer.encode(groupOwner, forKey: .groupOwner)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoAddGroupOwnerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoAddGroupOwner)
        autoAddGroupOwner = autoAddGroupOwnerDecoded
        let groupOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupOwner)
        groupOwner = groupOwnerDecoded
    }
}

extension GreengrassClientTypes {
    /// Group owner related settings for local resources.
    public struct GroupOwnerSetting: Swift.Equatable {
        /// If true, AWS IoT Greengrass automatically adds the specified Linux OS group owner of the resource to the Lambda process privileges. Thus the Lambda process will have the file access permissions of the added Linux group.
        public var autoAddGroupOwner: Swift.Bool?
        /// The name of the Linux OS group whose privileges will be added to the Lambda process. This field is optional.
        public var groupOwner: Swift.String?

        public init(
            autoAddGroupOwner: Swift.Bool? = nil,
            groupOwner: Swift.String? = nil
        )
        {
            self.autoAddGroupOwner = autoAddGroupOwner
            self.groupOwner = groupOwner
        }
    }

}

extension GreengrassClientTypes.GroupVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorDefinitionVersionArn = "ConnectorDefinitionVersionArn"
        case coreDefinitionVersionArn = "CoreDefinitionVersionArn"
        case deviceDefinitionVersionArn = "DeviceDefinitionVersionArn"
        case functionDefinitionVersionArn = "FunctionDefinitionVersionArn"
        case loggerDefinitionVersionArn = "LoggerDefinitionVersionArn"
        case resourceDefinitionVersionArn = "ResourceDefinitionVersionArn"
        case subscriptionDefinitionVersionArn = "SubscriptionDefinitionVersionArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorDefinitionVersionArn = self.connectorDefinitionVersionArn {
            try encodeContainer.encode(connectorDefinitionVersionArn, forKey: .connectorDefinitionVersionArn)
        }
        if let coreDefinitionVersionArn = self.coreDefinitionVersionArn {
            try encodeContainer.encode(coreDefinitionVersionArn, forKey: .coreDefinitionVersionArn)
        }
        if let deviceDefinitionVersionArn = self.deviceDefinitionVersionArn {
            try encodeContainer.encode(deviceDefinitionVersionArn, forKey: .deviceDefinitionVersionArn)
        }
        if let functionDefinitionVersionArn = self.functionDefinitionVersionArn {
            try encodeContainer.encode(functionDefinitionVersionArn, forKey: .functionDefinitionVersionArn)
        }
        if let loggerDefinitionVersionArn = self.loggerDefinitionVersionArn {
            try encodeContainer.encode(loggerDefinitionVersionArn, forKey: .loggerDefinitionVersionArn)
        }
        if let resourceDefinitionVersionArn = self.resourceDefinitionVersionArn {
            try encodeContainer.encode(resourceDefinitionVersionArn, forKey: .resourceDefinitionVersionArn)
        }
        if let subscriptionDefinitionVersionArn = self.subscriptionDefinitionVersionArn {
            try encodeContainer.encode(subscriptionDefinitionVersionArn, forKey: .subscriptionDefinitionVersionArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorDefinitionVersionArn)
        connectorDefinitionVersionArn = connectorDefinitionVersionArnDecoded
        let coreDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreDefinitionVersionArn)
        coreDefinitionVersionArn = coreDefinitionVersionArnDecoded
        let deviceDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceDefinitionVersionArn)
        deviceDefinitionVersionArn = deviceDefinitionVersionArnDecoded
        let functionDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionDefinitionVersionArn)
        functionDefinitionVersionArn = functionDefinitionVersionArnDecoded
        let loggerDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .loggerDefinitionVersionArn)
        loggerDefinitionVersionArn = loggerDefinitionVersionArnDecoded
        let resourceDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceDefinitionVersionArn)
        resourceDefinitionVersionArn = resourceDefinitionVersionArnDecoded
        let subscriptionDefinitionVersionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subscriptionDefinitionVersionArn)
        subscriptionDefinitionVersionArn = subscriptionDefinitionVersionArnDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a group version.
    public struct GroupVersion: Swift.Equatable {
        /// The ARN of the connector definition version for this group.
        public var connectorDefinitionVersionArn: Swift.String?
        /// The ARN of the core definition version for this group.
        public var coreDefinitionVersionArn: Swift.String?
        /// The ARN of the device definition version for this group.
        public var deviceDefinitionVersionArn: Swift.String?
        /// The ARN of the function definition version for this group.
        public var functionDefinitionVersionArn: Swift.String?
        /// The ARN of the logger definition version for this group.
        public var loggerDefinitionVersionArn: Swift.String?
        /// The ARN of the resource definition version for this group.
        public var resourceDefinitionVersionArn: Swift.String?
        /// The ARN of the subscription definition version for this group.
        public var subscriptionDefinitionVersionArn: Swift.String?

        public init(
            connectorDefinitionVersionArn: Swift.String? = nil,
            coreDefinitionVersionArn: Swift.String? = nil,
            deviceDefinitionVersionArn: Swift.String? = nil,
            functionDefinitionVersionArn: Swift.String? = nil,
            loggerDefinitionVersionArn: Swift.String? = nil,
            resourceDefinitionVersionArn: Swift.String? = nil,
            subscriptionDefinitionVersionArn: Swift.String? = nil
        )
        {
            self.connectorDefinitionVersionArn = connectorDefinitionVersionArn
            self.coreDefinitionVersionArn = coreDefinitionVersionArn
            self.deviceDefinitionVersionArn = deviceDefinitionVersionArn
            self.functionDefinitionVersionArn = functionDefinitionVersionArn
            self.loggerDefinitionVersionArn = loggerDefinitionVersionArn
            self.resourceDefinitionVersionArn = resourceDefinitionVersionArn
            self.subscriptionDefinitionVersionArn = subscriptionDefinitionVersionArn
        }
    }

}

extension InternalServerErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.errorDetails = output.errorDetails
            self.properties.message = output.message
        } else {
            self.properties.errorDetails = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// General error information.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Details about the error.
        public internal(set) var errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil
        /// A message containing information about the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorDetails = errorDetails
        self.properties.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let errorDetails: [GreengrassClientTypes.ErrorDetail]?
    let message: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorDetails = "ErrorDetails"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDetailsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.ErrorDetail?].self, forKey: .errorDetails)
        var errorDetailsDecoded0:[GreengrassClientTypes.ErrorDetail]? = nil
        if let errorDetailsContainer = errorDetailsContainer {
            errorDetailsDecoded0 = [GreengrassClientTypes.ErrorDetail]()
            for structure0 in errorDetailsContainer {
                if let structure0 = structure0 {
                    errorDetailsDecoded0?.append(structure0)
                }
            }
        }
        errorDetails = errorDetailsDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListBulkDeploymentDetailedReportsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBulkDeploymentDetailedReportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bulkDeploymentId = bulkDeploymentId else {
            return nil
        }
        return "/greengrass/bulk/deployments/\(bulkDeploymentId.urlPercentEncoding())/detailed-reports"
    }
}

public struct ListBulkDeploymentDetailedReportsInput: Swift.Equatable {
    /// The ID of the bulk deployment.
    /// This member is required.
    public var bulkDeploymentId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        bulkDeploymentId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.bulkDeploymentId = bulkDeploymentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBulkDeploymentDetailedReportsInputBody: Swift.Equatable {
}

extension ListBulkDeploymentDetailedReportsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBulkDeploymentDetailedReportsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBulkDeploymentDetailedReportsOutputBody = try responseDecoder.decode(responseBody: data)
            self.deployments = output.deployments
            self.nextToken = output.nextToken
        } else {
            self.deployments = nil
            self.nextToken = nil
        }
    }
}

public struct ListBulkDeploymentDetailedReportsOutput: Swift.Equatable {
    /// A list of the individual group deployments in the bulk deployment operation.
    public var deployments: [GreengrassClientTypes.BulkDeploymentResult]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        deployments: [GreengrassClientTypes.BulkDeploymentResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deployments = deployments
        self.nextToken = nextToken
    }
}

struct ListBulkDeploymentDetailedReportsOutputBody: Swift.Equatable {
    let deployments: [GreengrassClientTypes.BulkDeploymentResult]?
    let nextToken: Swift.String?
}

extension ListBulkDeploymentDetailedReportsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployments = "Deployments"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.BulkDeploymentResult?].self, forKey: .deployments)
        var deploymentsDecoded0:[GreengrassClientTypes.BulkDeploymentResult]? = nil
        if let deploymentsContainer = deploymentsContainer {
            deploymentsDecoded0 = [GreengrassClientTypes.BulkDeploymentResult]()
            for structure0 in deploymentsContainer {
                if let structure0 = structure0 {
                    deploymentsDecoded0?.append(structure0)
                }
            }
        }
        deployments = deploymentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBulkDeploymentDetailedReportsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListBulkDeploymentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBulkDeploymentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/bulk/deployments"
    }
}

public struct ListBulkDeploymentsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBulkDeploymentsInputBody: Swift.Equatable {
}

extension ListBulkDeploymentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBulkDeploymentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBulkDeploymentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.bulkDeployments = output.bulkDeployments
            self.nextToken = output.nextToken
        } else {
            self.bulkDeployments = nil
            self.nextToken = nil
        }
    }
}

public struct ListBulkDeploymentsOutput: Swift.Equatable {
    /// A list of bulk deployments.
    public var bulkDeployments: [GreengrassClientTypes.BulkDeployment]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        bulkDeployments: [GreengrassClientTypes.BulkDeployment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.bulkDeployments = bulkDeployments
        self.nextToken = nextToken
    }
}

struct ListBulkDeploymentsOutputBody: Swift.Equatable {
    let bulkDeployments: [GreengrassClientTypes.BulkDeployment]?
    let nextToken: Swift.String?
}

extension ListBulkDeploymentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bulkDeployments = "BulkDeployments"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bulkDeploymentsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.BulkDeployment?].self, forKey: .bulkDeployments)
        var bulkDeploymentsDecoded0:[GreengrassClientTypes.BulkDeployment]? = nil
        if let bulkDeploymentsContainer = bulkDeploymentsContainer {
            bulkDeploymentsDecoded0 = [GreengrassClientTypes.BulkDeployment]()
            for structure0 in bulkDeploymentsContainer {
                if let structure0 = structure0 {
                    bulkDeploymentsDecoded0?.append(structure0)
                }
            }
        }
        bulkDeployments = bulkDeploymentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBulkDeploymentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListConnectorDefinitionVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListConnectorDefinitionVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectorDefinitionId = connectorDefinitionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListConnectorDefinitionVersionsInput: Swift.Equatable {
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        connectorDefinitionId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConnectorDefinitionVersionsInputBody: Swift.Equatable {
}

extension ListConnectorDefinitionVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListConnectorDefinitionVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConnectorDefinitionVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListConnectorDefinitionVersionsOutput: Swift.Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListConnectorDefinitionVersionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let versions: [GreengrassClientTypes.VersionInformation]?
}

extension ListConnectorDefinitionVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[GreengrassClientTypes.VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [GreengrassClientTypes.VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

enum ListConnectorDefinitionVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListConnectorDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListConnectorDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/connectors"
    }
}

public struct ListConnectorDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConnectorDefinitionsInputBody: Swift.Equatable {
}

extension ListConnectorDefinitionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListConnectorDefinitionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConnectorDefinitionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListConnectorDefinitionsOutput: Swift.Equatable {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListConnectorDefinitionsOutputBody: Swift.Equatable {
    let definitions: [GreengrassClientTypes.DefinitionInformation]?
    let nextToken: Swift.String?
}

extension ListConnectorDefinitionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[GreengrassClientTypes.DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [GreengrassClientTypes.DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListConnectorDefinitionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCoreDefinitionVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListCoreDefinitionVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreDefinitionId = coreDefinitionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListCoreDefinitionVersionsInput: Swift.Equatable {
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        coreDefinitionId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCoreDefinitionVersionsInputBody: Swift.Equatable {
}

extension ListCoreDefinitionVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCoreDefinitionVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCoreDefinitionVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListCoreDefinitionVersionsOutput: Swift.Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListCoreDefinitionVersionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let versions: [GreengrassClientTypes.VersionInformation]?
}

extension ListCoreDefinitionVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[GreengrassClientTypes.VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [GreengrassClientTypes.VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

enum ListCoreDefinitionVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCoreDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListCoreDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/cores"
    }
}

public struct ListCoreDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCoreDefinitionsInputBody: Swift.Equatable {
}

extension ListCoreDefinitionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCoreDefinitionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCoreDefinitionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListCoreDefinitionsOutput: Swift.Equatable {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListCoreDefinitionsOutputBody: Swift.Equatable {
    let definitions: [GreengrassClientTypes.DefinitionInformation]?
    let nextToken: Swift.String?
}

extension ListCoreDefinitionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[GreengrassClientTypes.DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [GreengrassClientTypes.DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCoreDefinitionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDeploymentsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDeploymentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/deployments"
    }
}

public struct ListDeploymentsInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeploymentsInputBody: Swift.Equatable {
}

extension ListDeploymentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDeploymentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDeploymentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.deployments = output.deployments
            self.nextToken = output.nextToken
        } else {
            self.deployments = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeploymentsOutput: Swift.Equatable {
    /// A list of deployments for the requested groups.
    public var deployments: [GreengrassClientTypes.Deployment]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        deployments: [GreengrassClientTypes.Deployment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deployments = deployments
        self.nextToken = nextToken
    }
}

struct ListDeploymentsOutputBody: Swift.Equatable {
    let deployments: [GreengrassClientTypes.Deployment]?
    let nextToken: Swift.String?
}

extension ListDeploymentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployments = "Deployments"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Deployment?].self, forKey: .deployments)
        var deploymentsDecoded0:[GreengrassClientTypes.Deployment]? = nil
        if let deploymentsContainer = deploymentsContainer {
            deploymentsDecoded0 = [GreengrassClientTypes.Deployment]()
            for structure0 in deploymentsContainer {
                if let structure0 = structure0 {
                    deploymentsDecoded0?.append(structure0)
                }
            }
        }
        deployments = deploymentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDeploymentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDeviceDefinitionVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDeviceDefinitionVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceDefinitionId = deviceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListDeviceDefinitionVersionsInput: Swift.Equatable {
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        deviceDefinitionId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeviceDefinitionVersionsInputBody: Swift.Equatable {
}

extension ListDeviceDefinitionVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDeviceDefinitionVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDeviceDefinitionVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListDeviceDefinitionVersionsOutput: Swift.Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListDeviceDefinitionVersionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let versions: [GreengrassClientTypes.VersionInformation]?
}

extension ListDeviceDefinitionVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[GreengrassClientTypes.VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [GreengrassClientTypes.VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

enum ListDeviceDefinitionVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDeviceDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDeviceDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/devices"
    }
}

public struct ListDeviceDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDeviceDefinitionsInputBody: Swift.Equatable {
}

extension ListDeviceDefinitionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDeviceDefinitionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDeviceDefinitionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListDeviceDefinitionsOutput: Swift.Equatable {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListDeviceDefinitionsOutputBody: Swift.Equatable {
    let definitions: [GreengrassClientTypes.DefinitionInformation]?
    let nextToken: Swift.String?
}

extension ListDeviceDefinitionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[GreengrassClientTypes.DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [GreengrassClientTypes.DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDeviceDefinitionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFunctionDefinitionVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListFunctionDefinitionVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionDefinitionId = functionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListFunctionDefinitionVersionsInput: Swift.Equatable {
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        functionDefinitionId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFunctionDefinitionVersionsInputBody: Swift.Equatable {
}

extension ListFunctionDefinitionVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionDefinitionVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFunctionDefinitionVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListFunctionDefinitionVersionsOutput: Swift.Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListFunctionDefinitionVersionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let versions: [GreengrassClientTypes.VersionInformation]?
}

extension ListFunctionDefinitionVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[GreengrassClientTypes.VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [GreengrassClientTypes.VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

enum ListFunctionDefinitionVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFunctionDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListFunctionDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/functions"
    }
}

public struct ListFunctionDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFunctionDefinitionsInputBody: Swift.Equatable {
}

extension ListFunctionDefinitionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFunctionDefinitionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFunctionDefinitionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListFunctionDefinitionsOutput: Swift.Equatable {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListFunctionDefinitionsOutputBody: Swift.Equatable {
    let definitions: [GreengrassClientTypes.DefinitionInformation]?
    let nextToken: Swift.String?
}

extension ListFunctionDefinitionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[GreengrassClientTypes.DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [GreengrassClientTypes.DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFunctionDefinitionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListGroupCertificateAuthoritiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/certificateauthorities"
    }
}

public struct ListGroupCertificateAuthoritiesInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

struct ListGroupCertificateAuthoritiesInputBody: Swift.Equatable {
}

extension ListGroupCertificateAuthoritiesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListGroupCertificateAuthoritiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGroupCertificateAuthoritiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.groupCertificateAuthorities = output.groupCertificateAuthorities
        } else {
            self.groupCertificateAuthorities = nil
        }
    }
}

public struct ListGroupCertificateAuthoritiesOutput: Swift.Equatable {
    /// A list of certificate authorities associated with the group.
    public var groupCertificateAuthorities: [GreengrassClientTypes.GroupCertificateAuthorityProperties]?

    public init(
        groupCertificateAuthorities: [GreengrassClientTypes.GroupCertificateAuthorityProperties]? = nil
    )
    {
        self.groupCertificateAuthorities = groupCertificateAuthorities
    }
}

struct ListGroupCertificateAuthoritiesOutputBody: Swift.Equatable {
    let groupCertificateAuthorities: [GreengrassClientTypes.GroupCertificateAuthorityProperties]?
}

extension ListGroupCertificateAuthoritiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupCertificateAuthorities = "GroupCertificateAuthorities"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupCertificateAuthoritiesContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.GroupCertificateAuthorityProperties?].self, forKey: .groupCertificateAuthorities)
        var groupCertificateAuthoritiesDecoded0:[GreengrassClientTypes.GroupCertificateAuthorityProperties]? = nil
        if let groupCertificateAuthoritiesContainer = groupCertificateAuthoritiesContainer {
            groupCertificateAuthoritiesDecoded0 = [GreengrassClientTypes.GroupCertificateAuthorityProperties]()
            for structure0 in groupCertificateAuthoritiesContainer {
                if let structure0 = structure0 {
                    groupCertificateAuthoritiesDecoded0?.append(structure0)
                }
            }
        }
        groupCertificateAuthorities = groupCertificateAuthoritiesDecoded0
    }
}

enum ListGroupCertificateAuthoritiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListGroupVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListGroupVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/versions"
    }
}

public struct ListGroupVersionsInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGroupVersionsInputBody: Swift.Equatable {
}

extension ListGroupVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListGroupVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGroupVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListGroupVersionsOutput: Swift.Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListGroupVersionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let versions: [GreengrassClientTypes.VersionInformation]?
}

extension ListGroupVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[GreengrassClientTypes.VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [GreengrassClientTypes.VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

enum ListGroupVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/groups"
    }
}

public struct ListGroupsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGroupsInputBody: Swift.Equatable {
}

extension ListGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.groups = output.groups
            self.nextToken = output.nextToken
        } else {
            self.groups = nil
            self.nextToken = nil
        }
    }
}

public struct ListGroupsOutput: Swift.Equatable {
    /// Information about a group.
    public var groups: [GreengrassClientTypes.GroupInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        groups: [GreengrassClientTypes.GroupInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groups = groups
        self.nextToken = nextToken
    }
}

struct ListGroupsOutputBody: Swift.Equatable {
    let groups: [GreengrassClientTypes.GroupInformation]?
    let nextToken: Swift.String?
}

extension ListGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.GroupInformation?].self, forKey: .groups)
        var groupsDecoded0:[GreengrassClientTypes.GroupInformation]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [GreengrassClientTypes.GroupInformation]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLoggerDefinitionVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListLoggerDefinitionVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let loggerDefinitionId = loggerDefinitionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListLoggerDefinitionVersionsInput: Swift.Equatable {
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        loggerDefinitionId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLoggerDefinitionVersionsInputBody: Swift.Equatable {
}

extension ListLoggerDefinitionVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListLoggerDefinitionVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLoggerDefinitionVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListLoggerDefinitionVersionsOutput: Swift.Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListLoggerDefinitionVersionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let versions: [GreengrassClientTypes.VersionInformation]?
}

extension ListLoggerDefinitionVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[GreengrassClientTypes.VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [GreengrassClientTypes.VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

enum ListLoggerDefinitionVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLoggerDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListLoggerDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/loggers"
    }
}

public struct ListLoggerDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLoggerDefinitionsInputBody: Swift.Equatable {
}

extension ListLoggerDefinitionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListLoggerDefinitionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLoggerDefinitionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListLoggerDefinitionsOutput: Swift.Equatable {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListLoggerDefinitionsOutputBody: Swift.Equatable {
    let definitions: [GreengrassClientTypes.DefinitionInformation]?
    let nextToken: Swift.String?
}

extension ListLoggerDefinitionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[GreengrassClientTypes.DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [GreengrassClientTypes.DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLoggerDefinitionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResourceDefinitionVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListResourceDefinitionVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceDefinitionId = resourceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListResourceDefinitionVersionsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        resourceDefinitionId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceDefinitionId = resourceDefinitionId
    }
}

struct ListResourceDefinitionVersionsInputBody: Swift.Equatable {
}

extension ListResourceDefinitionVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListResourceDefinitionVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResourceDefinitionVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListResourceDefinitionVersionsOutput: Swift.Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListResourceDefinitionVersionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let versions: [GreengrassClientTypes.VersionInformation]?
}

extension ListResourceDefinitionVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[GreengrassClientTypes.VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [GreengrassClientTypes.VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

enum ListResourceDefinitionVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListResourceDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListResourceDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/resources"
    }
}

public struct ListResourceDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListResourceDefinitionsInputBody: Swift.Equatable {
}

extension ListResourceDefinitionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListResourceDefinitionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListResourceDefinitionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListResourceDefinitionsOutput: Swift.Equatable {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListResourceDefinitionsOutputBody: Swift.Equatable {
    let definitions: [GreengrassClientTypes.DefinitionInformation]?
    let nextToken: Swift.String?
}

extension ListResourceDefinitionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[GreengrassClientTypes.DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [GreengrassClientTypes.DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListResourceDefinitionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSubscriptionDefinitionVersionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSubscriptionDefinitionVersionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriptionDefinitionId = subscriptionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListSubscriptionDefinitionVersionsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        subscriptionDefinitionId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subscriptionDefinitionId = subscriptionDefinitionId
    }
}

struct ListSubscriptionDefinitionVersionsInputBody: Swift.Equatable {
}

extension ListSubscriptionDefinitionVersionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSubscriptionDefinitionVersionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSubscriptionDefinitionVersionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.versions = output.versions
        } else {
            self.nextToken = nil
            self.versions = nil
        }
    }
}

public struct ListSubscriptionDefinitionVersionsOutput: Swift.Equatable {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

struct ListSubscriptionDefinitionVersionsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let versions: [GreengrassClientTypes.VersionInformation]?
}

extension ListSubscriptionDefinitionVersionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case versions = "Versions"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let versionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.VersionInformation?].self, forKey: .versions)
        var versionsDecoded0:[GreengrassClientTypes.VersionInformation]? = nil
        if let versionsContainer = versionsContainer {
            versionsDecoded0 = [GreengrassClientTypes.VersionInformation]()
            for structure0 in versionsContainer {
                if let structure0 = structure0 {
                    versionsDecoded0?.append(structure0)
                }
            }
        }
        versions = versionsDecoded0
    }
}

enum ListSubscriptionDefinitionVersionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSubscriptionDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListSubscriptionDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/definition/subscriptions"
    }
}

public struct ListSubscriptionDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSubscriptionDefinitionsInputBody: Swift.Equatable {
}

extension ListSubscriptionDefinitionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSubscriptionDefinitionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSubscriptionDefinitionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.definitions = output.definitions
            self.nextToken = output.nextToken
        } else {
            self.definitions = nil
            self.nextToken = nil
        }
    }
}

public struct ListSubscriptionDefinitionsOutput: Swift.Equatable {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

struct ListSubscriptionDefinitionsOutputBody: Swift.Equatable {
    let definitions: [GreengrassClientTypes.DefinitionInformation]?
    let nextToken: Swift.String?
}

extension ListSubscriptionDefinitionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case definitions = "Definitions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let definitionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.DefinitionInformation?].self, forKey: .definitions)
        var definitionsDecoded0:[GreengrassClientTypes.DefinitionInformation]? = nil
        if let definitionsContainer = definitionsContainer {
            definitionsDecoded0 = [GreengrassClientTypes.DefinitionInformation]()
            for structure0 in definitionsContainer {
                if let structure0 = structure0 {
                    definitionsDecoded0?.append(structure0)
                }
            }
        }
        definitions = definitionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSubscriptionDefinitionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The key-value pair for the resource tag.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GreengrassClientTypes.LocalDeviceResourceData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupOwnerSetting = "GroupOwnerSetting"
        case sourcePath = "SourcePath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupOwnerSetting = self.groupOwnerSetting {
            try encodeContainer.encode(groupOwnerSetting, forKey: .groupOwnerSetting)
        }
        if let sourcePath = self.sourcePath {
            try encodeContainer.encode(sourcePath, forKey: .sourcePath)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupOwnerSettingDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.GroupOwnerSetting.self, forKey: .groupOwnerSetting)
        groupOwnerSetting = groupOwnerSettingDecoded
        let sourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePath)
        sourcePath = sourcePathDecoded
    }
}

extension GreengrassClientTypes {
    /// Attributes that define a local device resource.
    public struct LocalDeviceResourceData: Swift.Equatable {
        /// Group/owner related settings for local resources.
        public var groupOwnerSetting: GreengrassClientTypes.GroupOwnerSetting?
        /// The local absolute path of the device resource. The source path for a device resource can refer only to a character device or block device under ''/dev''.
        public var sourcePath: Swift.String?

        public init(
            groupOwnerSetting: GreengrassClientTypes.GroupOwnerSetting? = nil,
            sourcePath: Swift.String? = nil
        )
        {
            self.groupOwnerSetting = groupOwnerSetting
            self.sourcePath = sourcePath
        }
    }

}

extension GreengrassClientTypes.LocalVolumeResourceData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationPath = "DestinationPath"
        case groupOwnerSetting = "GroupOwnerSetting"
        case sourcePath = "SourcePath"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationPath = self.destinationPath {
            try encodeContainer.encode(destinationPath, forKey: .destinationPath)
        }
        if let groupOwnerSetting = self.groupOwnerSetting {
            try encodeContainer.encode(groupOwnerSetting, forKey: .groupOwnerSetting)
        }
        if let sourcePath = self.sourcePath {
            try encodeContainer.encode(sourcePath, forKey: .sourcePath)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPath)
        destinationPath = destinationPathDecoded
        let groupOwnerSettingDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.GroupOwnerSetting.self, forKey: .groupOwnerSetting)
        groupOwnerSetting = groupOwnerSettingDecoded
        let sourcePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourcePath)
        sourcePath = sourcePathDecoded
    }
}

extension GreengrassClientTypes {
    /// Attributes that define a local volume resource.
    public struct LocalVolumeResourceData: Swift.Equatable {
        /// The absolute local path of the resource inside the Lambda environment.
        public var destinationPath: Swift.String?
        /// Allows you to configure additional group privileges for the Lambda process. This field is optional.
        public var groupOwnerSetting: GreengrassClientTypes.GroupOwnerSetting?
        /// The local absolute path of the volume resource on the host. The source path for a volume resource type cannot start with ''/sys''.
        public var sourcePath: Swift.String?

        public init(
            destinationPath: Swift.String? = nil,
            groupOwnerSetting: GreengrassClientTypes.GroupOwnerSetting? = nil,
            sourcePath: Swift.String? = nil
        )
        {
            self.destinationPath = destinationPath
            self.groupOwnerSetting = groupOwnerSetting
            self.sourcePath = sourcePath
        }
    }

}

extension GreengrassClientTypes.Logger: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case component = "Component"
        case id = "Id"
        case level = "Level"
        case space = "Space"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let component = self.component {
            try encodeContainer.encode(component.rawValue, forKey: .component)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let level = self.level {
            try encodeContainer.encode(level.rawValue, forKey: .level)
        }
        if let space = self.space {
            try encodeContainer.encode(space, forKey: .space)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let componentDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.LoggerComponent.self, forKey: .component)
        component = componentDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let levelDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.LoggerLevel.self, forKey: .level)
        level = levelDecoded
        let spaceDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .space)
        space = spaceDecoded
        let typeDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.LoggerType.self, forKey: .type)
        type = typeDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a logger
    public struct Logger: Swift.Equatable {
        /// The component that will be subject to logging.
        /// This member is required.
        public var component: GreengrassClientTypes.LoggerComponent?
        /// A descriptive or arbitrary ID for the logger. This value must be unique within the logger definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        /// This member is required.
        public var id: Swift.String?
        /// The level of the logs.
        /// This member is required.
        public var level: GreengrassClientTypes.LoggerLevel?
        /// The amount of file space, in KB, to use if the local file system is used for logging purposes.
        public var space: Swift.Int?
        /// The type of log output which will be used.
        /// This member is required.
        public var type: GreengrassClientTypes.LoggerType?

        public init(
            component: GreengrassClientTypes.LoggerComponent? = nil,
            id: Swift.String? = nil,
            level: GreengrassClientTypes.LoggerLevel? = nil,
            space: Swift.Int? = nil,
            type: GreengrassClientTypes.LoggerType? = nil
        )
        {
            self.component = component
            self.id = id
            self.level = level
            self.space = space
            self.type = type
        }
    }

}

extension GreengrassClientTypes {
    public enum LoggerComponent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case greengrasssystem
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggerComponent] {
            return [
                .greengrasssystem,
                .lambda,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .greengrasssystem: return "GreengrassSystem"
            case .lambda: return "Lambda"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoggerComponent(rawValue: rawValue) ?? LoggerComponent.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassClientTypes.LoggerDefinitionVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggers = "Loggers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggers = loggers {
            var loggersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loggers)
            for logger0 in loggers {
                try loggersContainer.encode(logger0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggersContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Logger?].self, forKey: .loggers)
        var loggersDecoded0:[GreengrassClientTypes.Logger]? = nil
        if let loggersContainer = loggersContainer {
            loggersDecoded0 = [GreengrassClientTypes.Logger]()
            for structure0 in loggersContainer {
                if let structure0 = structure0 {
                    loggersDecoded0?.append(structure0)
                }
            }
        }
        loggers = loggersDecoded0
    }
}

extension GreengrassClientTypes {
    /// Information about a logger definition version.
    public struct LoggerDefinitionVersion: Swift.Equatable {
        /// A list of loggers.
        public var loggers: [GreengrassClientTypes.Logger]?

        public init(
            loggers: [GreengrassClientTypes.Logger]? = nil
        )
        {
            self.loggers = loggers
        }
    }

}

extension GreengrassClientTypes {
    public enum LoggerLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case debug
        case error
        case fatal
        case info
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggerLevel] {
            return [
                .debug,
                .error,
                .fatal,
                .info,
                .warn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .error: return "ERROR"
            case .fatal: return "FATAL"
            case .info: return "INFO"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoggerLevel(rawValue: rawValue) ?? LoggerLevel.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassClientTypes {
    public enum LoggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awscloudwatch
        case filesystem
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggerType] {
            return [
                .awscloudwatch,
                .filesystem,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awscloudwatch: return "AWSCloudWatch"
            case .filesystem: return "FileSystem"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoggerType(rawValue: rawValue) ?? LoggerType.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassClientTypes {
    /// The type of permission a function has to access a resource.
    public enum Permission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ro
        case rw
        case sdkUnknown(Swift.String)

        public static var allCases: [Permission] {
            return [
                .ro,
                .rw,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ro: return "ro"
            case .rw: return "rw"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
        }
    }
}

extension ResetDeploymentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force = "Force"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let force = self.force {
            try encodeContainer.encode(force, forKey: .force)
        }
    }
}

extension ResetDeploymentsInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension ResetDeploymentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/deployments/$reset"
    }
}

/// Information needed to reset deployments.
public struct ResetDeploymentsInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// If true, performs a best-effort only core reset.
    public var force: Swift.Bool?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        amznClientToken: Swift.String? = nil,
        force: Swift.Bool? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.force = force
        self.groupId = groupId
    }
}

struct ResetDeploymentsInputBody: Swift.Equatable {
    let force: Swift.Bool?
}

extension ResetDeploymentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force = "Force"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension ResetDeploymentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResetDeploymentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.deploymentArn = output.deploymentArn
            self.deploymentId = output.deploymentId
        } else {
            self.deploymentArn = nil
            self.deploymentId = nil
        }
    }
}

public struct ResetDeploymentsOutput: Swift.Equatable {
    /// The ARN of the deployment.
    public var deploymentArn: Swift.String?
    /// The ID of the deployment.
    public var deploymentId: Swift.String?

    public init(
        deploymentArn: Swift.String? = nil,
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentArn = deploymentArn
        self.deploymentId = deploymentId
    }
}

struct ResetDeploymentsOutputBody: Swift.Equatable {
    let deploymentArn: Swift.String?
    let deploymentId: Swift.String?
}

extension ResetDeploymentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deploymentArn = "DeploymentArn"
        case deploymentId = "DeploymentId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deploymentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentArn)
        deploymentArn = deploymentArnDecoded
        let deploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentId)
        deploymentId = deploymentIdDecoded
    }
}

enum ResetDeploymentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GreengrassClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case name = "Name"
        case resourceDataContainer = "ResourceDataContainer"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceDataContainer = self.resourceDataContainer {
            try encodeContainer.encode(resourceDataContainer, forKey: .resourceDataContainer)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourceDataContainerDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.ResourceDataContainer.self, forKey: .resourceDataContainer)
        resourceDataContainer = resourceDataContainerDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a resource.
    public struct Resource: Swift.Equatable {
        /// The resource ID, used to refer to a resource in the Lambda function configuration. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''. This must be unique within a Greengrass group.
        /// This member is required.
        public var id: Swift.String?
        /// The descriptive resource name, which is displayed on the AWS IoT Greengrass console. Max length 128 characters with pattern ''[a-zA-Z0-9:_-]+''. This must be unique within a Greengrass group.
        /// This member is required.
        public var name: Swift.String?
        /// A container of data for all resource types.
        /// This member is required.
        public var resourceDataContainer: GreengrassClientTypes.ResourceDataContainer?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            resourceDataContainer: GreengrassClientTypes.ResourceDataContainer? = nil
        )
        {
            self.id = id
            self.name = name
            self.resourceDataContainer = resourceDataContainer
        }
    }

}

extension GreengrassClientTypes.ResourceAccessPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permission = "Permission"
        case resourceId = "ResourceId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permission = self.permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.Permission.self, forKey: .permission)
        permission = permissionDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension GreengrassClientTypes {
    /// A policy used by the function to access a resource.
    public struct ResourceAccessPolicy: Swift.Equatable {
        /// The permissions that the Lambda function has to the resource. Can be one of ''rw'' (read/write) or ''ro'' (read-only).
        public var permission: GreengrassClientTypes.Permission?
        /// The ID of the resource. (This ID is assigned to the resource when you create the resource definiton.)
        /// This member is required.
        public var resourceId: Swift.String?

        public init(
            permission: GreengrassClientTypes.Permission? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.permission = permission
            self.resourceId = resourceId
        }
    }

}

extension GreengrassClientTypes.ResourceDataContainer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case localDeviceResourceData = "LocalDeviceResourceData"
        case localVolumeResourceData = "LocalVolumeResourceData"
        case s3MachineLearningModelResourceData = "S3MachineLearningModelResourceData"
        case sageMakerMachineLearningModelResourceData = "SageMakerMachineLearningModelResourceData"
        case secretsManagerSecretResourceData = "SecretsManagerSecretResourceData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let localDeviceResourceData = self.localDeviceResourceData {
            try encodeContainer.encode(localDeviceResourceData, forKey: .localDeviceResourceData)
        }
        if let localVolumeResourceData = self.localVolumeResourceData {
            try encodeContainer.encode(localVolumeResourceData, forKey: .localVolumeResourceData)
        }
        if let s3MachineLearningModelResourceData = self.s3MachineLearningModelResourceData {
            try encodeContainer.encode(s3MachineLearningModelResourceData, forKey: .s3MachineLearningModelResourceData)
        }
        if let sageMakerMachineLearningModelResourceData = self.sageMakerMachineLearningModelResourceData {
            try encodeContainer.encode(sageMakerMachineLearningModelResourceData, forKey: .sageMakerMachineLearningModelResourceData)
        }
        if let secretsManagerSecretResourceData = self.secretsManagerSecretResourceData {
            try encodeContainer.encode(secretsManagerSecretResourceData, forKey: .secretsManagerSecretResourceData)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localDeviceResourceDataDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.LocalDeviceResourceData.self, forKey: .localDeviceResourceData)
        localDeviceResourceData = localDeviceResourceDataDecoded
        let localVolumeResourceDataDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.LocalVolumeResourceData.self, forKey: .localVolumeResourceData)
        localVolumeResourceData = localVolumeResourceDataDecoded
        let s3MachineLearningModelResourceDataDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.S3MachineLearningModelResourceData.self, forKey: .s3MachineLearningModelResourceData)
        s3MachineLearningModelResourceData = s3MachineLearningModelResourceDataDecoded
        let sageMakerMachineLearningModelResourceDataDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.SageMakerMachineLearningModelResourceData.self, forKey: .sageMakerMachineLearningModelResourceData)
        sageMakerMachineLearningModelResourceData = sageMakerMachineLearningModelResourceDataDecoded
        let secretsManagerSecretResourceDataDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.SecretsManagerSecretResourceData.self, forKey: .secretsManagerSecretResourceData)
        secretsManagerSecretResourceData = secretsManagerSecretResourceDataDecoded
    }
}

extension GreengrassClientTypes {
    /// A container for resource data. The container takes only one of the following supported resource data types: ''LocalDeviceResourceData'', ''LocalVolumeResourceData'', ''SageMakerMachineLearningModelResourceData'', ''S3MachineLearningModelResourceData'', ''SecretsManagerSecretResourceData''.
    public struct ResourceDataContainer: Swift.Equatable {
        /// Attributes that define the local device resource.
        public var localDeviceResourceData: GreengrassClientTypes.LocalDeviceResourceData?
        /// Attributes that define the local volume resource.
        public var localVolumeResourceData: GreengrassClientTypes.LocalVolumeResourceData?
        /// Attributes that define an Amazon S3 machine learning resource.
        public var s3MachineLearningModelResourceData: GreengrassClientTypes.S3MachineLearningModelResourceData?
        /// Attributes that define an Amazon SageMaker machine learning resource.
        public var sageMakerMachineLearningModelResourceData: GreengrassClientTypes.SageMakerMachineLearningModelResourceData?
        /// Attributes that define a secret resource, which references a secret from AWS Secrets Manager.
        public var secretsManagerSecretResourceData: GreengrassClientTypes.SecretsManagerSecretResourceData?

        public init(
            localDeviceResourceData: GreengrassClientTypes.LocalDeviceResourceData? = nil,
            localVolumeResourceData: GreengrassClientTypes.LocalVolumeResourceData? = nil,
            s3MachineLearningModelResourceData: GreengrassClientTypes.S3MachineLearningModelResourceData? = nil,
            sageMakerMachineLearningModelResourceData: GreengrassClientTypes.SageMakerMachineLearningModelResourceData? = nil,
            secretsManagerSecretResourceData: GreengrassClientTypes.SecretsManagerSecretResourceData? = nil
        )
        {
            self.localDeviceResourceData = localDeviceResourceData
            self.localVolumeResourceData = localVolumeResourceData
            self.s3MachineLearningModelResourceData = s3MachineLearningModelResourceData
            self.sageMakerMachineLearningModelResourceData = sageMakerMachineLearningModelResourceData
            self.secretsManagerSecretResourceData = secretsManagerSecretResourceData
        }
    }

}

extension GreengrassClientTypes.ResourceDefinitionVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resources = "Resources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resource0 in resources {
                try resourcesContainer.encode(resource0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[GreengrassClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [GreengrassClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension GreengrassClientTypes {
    /// Information about a resource definition version.
    public struct ResourceDefinitionVersion: Swift.Equatable {
        /// A list of resources.
        public var resources: [GreengrassClientTypes.Resource]?

        public init(
            resources: [GreengrassClientTypes.Resource]? = nil
        )
        {
            self.resources = resources
        }
    }

}

extension GreengrassClientTypes.ResourceDownloadOwnerSetting: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupOwner = "GroupOwner"
        case groupPermission = "GroupPermission"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupOwner = self.groupOwner {
            try encodeContainer.encode(groupOwner, forKey: .groupOwner)
        }
        if let groupPermission = self.groupPermission {
            try encodeContainer.encode(groupPermission.rawValue, forKey: .groupPermission)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupOwnerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupOwner)
        groupOwner = groupOwnerDecoded
        let groupPermissionDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.Permission.self, forKey: .groupPermission)
        groupPermission = groupPermissionDecoded
    }
}

extension GreengrassClientTypes {
    /// The owner setting for downloaded machine learning resources.
    public struct ResourceDownloadOwnerSetting: Swift.Equatable {
        /// The group owner of the resource. This is the name of an existing Linux OS group on the system or a GID. The group's permissions are added to the Lambda process.
        /// This member is required.
        public var groupOwner: Swift.String?
        /// The permissions that the group owner has to the resource. Valid values are ''rw'' (read/write) or ''ro'' (read-only).
        /// This member is required.
        public var groupPermission: GreengrassClientTypes.Permission?

        public init(
            groupOwner: Swift.String? = nil,
            groupPermission: GreengrassClientTypes.Permission? = nil
        )
        {
            self.groupOwner = groupOwner
            self.groupPermission = groupPermission
        }
    }

}

extension GreengrassClientTypes.RuntimeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case telemetryConfiguration = "TelemetryConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let telemetryConfiguration = self.telemetryConfiguration {
            try encodeContainer.encode(telemetryConfiguration, forKey: .telemetryConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let telemetryConfigurationDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.TelemetryConfiguration.self, forKey: .telemetryConfiguration)
        telemetryConfiguration = telemetryConfigurationDecoded
    }
}

extension GreengrassClientTypes {
    /// Runtime configuration for a thing.
    public struct RuntimeConfiguration: Swift.Equatable {
        /// Configuration for telemetry service.
        public var telemetryConfiguration: GreengrassClientTypes.TelemetryConfiguration?

        public init(
            telemetryConfiguration: GreengrassClientTypes.TelemetryConfiguration? = nil
        )
        {
            self.telemetryConfiguration = telemetryConfiguration
        }
    }

}

extension GreengrassClientTypes.S3MachineLearningModelResourceData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationPath = "DestinationPath"
        case ownerSetting = "OwnerSetting"
        case s3Uri = "S3Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationPath = self.destinationPath {
            try encodeContainer.encode(destinationPath, forKey: .destinationPath)
        }
        if let ownerSetting = self.ownerSetting {
            try encodeContainer.encode(ownerSetting, forKey: .ownerSetting)
        }
        if let s3Uri = self.s3Uri {
            try encodeContainer.encode(s3Uri, forKey: .s3Uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPath)
        destinationPath = destinationPathDecoded
        let ownerSettingDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.ResourceDownloadOwnerSetting.self, forKey: .ownerSetting)
        ownerSetting = ownerSettingDecoded
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
    }
}

extension GreengrassClientTypes {
    /// Attributes that define an Amazon S3 machine learning resource.
    public struct S3MachineLearningModelResourceData: Swift.Equatable {
        /// The absolute local path of the resource inside the Lambda environment.
        public var destinationPath: Swift.String?
        /// The owner setting for downloaded machine learning resources.
        public var ownerSetting: GreengrassClientTypes.ResourceDownloadOwnerSetting?
        /// The URI of the source model in an S3 bucket. The model package must be in tar.gz or .zip format.
        public var s3Uri: Swift.String?

        public init(
            destinationPath: Swift.String? = nil,
            ownerSetting: GreengrassClientTypes.ResourceDownloadOwnerSetting? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.destinationPath = destinationPath
            self.ownerSetting = ownerSetting
            self.s3Uri = s3Uri
        }
    }

}

extension GreengrassClientTypes.SageMakerMachineLearningModelResourceData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationPath = "DestinationPath"
        case ownerSetting = "OwnerSetting"
        case sageMakerJobArn = "SageMakerJobArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationPath = self.destinationPath {
            try encodeContainer.encode(destinationPath, forKey: .destinationPath)
        }
        if let ownerSetting = self.ownerSetting {
            try encodeContainer.encode(ownerSetting, forKey: .ownerSetting)
        }
        if let sageMakerJobArn = self.sageMakerJobArn {
            try encodeContainer.encode(sageMakerJobArn, forKey: .sageMakerJobArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationPath)
        destinationPath = destinationPathDecoded
        let ownerSettingDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.ResourceDownloadOwnerSetting.self, forKey: .ownerSetting)
        ownerSetting = ownerSettingDecoded
        let sageMakerJobArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sageMakerJobArn)
        sageMakerJobArn = sageMakerJobArnDecoded
    }
}

extension GreengrassClientTypes {
    /// Attributes that define an Amazon SageMaker machine learning resource.
    public struct SageMakerMachineLearningModelResourceData: Swift.Equatable {
        /// The absolute local path of the resource inside the Lambda environment.
        public var destinationPath: Swift.String?
        /// The owner setting for downloaded machine learning resources.
        public var ownerSetting: GreengrassClientTypes.ResourceDownloadOwnerSetting?
        /// The ARN of the Amazon SageMaker training job that represents the source model.
        public var sageMakerJobArn: Swift.String?

        public init(
            destinationPath: Swift.String? = nil,
            ownerSetting: GreengrassClientTypes.ResourceDownloadOwnerSetting? = nil,
            sageMakerJobArn: Swift.String? = nil
        )
        {
            self.destinationPath = destinationPath
            self.ownerSetting = ownerSetting
            self.sageMakerJobArn = sageMakerJobArn
        }
    }

}

extension GreengrassClientTypes.SecretsManagerSecretResourceData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case additionalStagingLabelsToDownload = "AdditionalStagingLabelsToDownload"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let additionalStagingLabelsToDownload = additionalStagingLabelsToDownload {
            var additionalStagingLabelsToDownloadContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalStagingLabelsToDownload)
            for __string0 in additionalStagingLabelsToDownload {
                try additionalStagingLabelsToDownloadContainer.encode(__string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let additionalStagingLabelsToDownloadContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .additionalStagingLabelsToDownload)
        var additionalStagingLabelsToDownloadDecoded0:[Swift.String]? = nil
        if let additionalStagingLabelsToDownloadContainer = additionalStagingLabelsToDownloadContainer {
            additionalStagingLabelsToDownloadDecoded0 = [Swift.String]()
            for string0 in additionalStagingLabelsToDownloadContainer {
                if let string0 = string0 {
                    additionalStagingLabelsToDownloadDecoded0?.append(string0)
                }
            }
        }
        additionalStagingLabelsToDownload = additionalStagingLabelsToDownloadDecoded0
    }
}

extension GreengrassClientTypes {
    /// Attributes that define a secret resource, which references a secret from AWS Secrets Manager. AWS IoT Greengrass stores a local, encrypted copy of the secret on the Greengrass core, where it can be securely accessed by connectors and Lambda functions.
    public struct SecretsManagerSecretResourceData: Swift.Equatable {
        /// Optional. The staging labels whose values you want to make available on the core, in addition to ''AWSCURRENT''.
        public var additionalStagingLabelsToDownload: [Swift.String]?
        /// The ARN of the Secrets Manager secret to make available on the core. The value of the secret's latest version (represented by the ''AWSCURRENT'' staging label) is included by default.
        public var arn: Swift.String?

        public init(
            additionalStagingLabelsToDownload: [Swift.String]? = nil,
            arn: Swift.String? = nil
        )
        {
            self.additionalStagingLabelsToDownload = additionalStagingLabelsToDownload
            self.arn = arn
        }
    }

}

extension GreengrassClientTypes {
    /// The piece of software on the Greengrass core that will be updated.
    public enum SoftwareToUpdate: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case core
        case otaAgent
        case sdkUnknown(Swift.String)

        public static var allCases: [SoftwareToUpdate] {
            return [
                .core,
                .otaAgent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .core: return "core"
            case .otaAgent: return "ota_agent"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SoftwareToUpdate(rawValue: rawValue) ?? SoftwareToUpdate.sdkUnknown(rawValue)
        }
    }
}

extension StartBulkDeploymentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionRoleArn = "ExecutionRoleArn"
        case inputFileUri = "InputFileUri"
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let inputFileUri = self.inputFileUri {
            try encodeContainer.encode(inputFileUri, forKey: .inputFileUri)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartBulkDeploymentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension StartBulkDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/greengrass/bulk/deployments"
    }
}

public struct StartBulkDeploymentInput: Swift.Equatable {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ARN of the execution role to associate with the bulk deployment operation. This IAM role must allow the ''greengrass:CreateDeployment'' action for all group versions that are listed in the input file. This IAM role must have access to the S3 bucket containing the input file.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The URI of the input file contained in the S3 bucket. The execution role must have ''getObject'' permissions on this bucket to access the input file. The input file is a JSON-serialized, line delimited file with UTF-8 encoding that provides a list of group and version IDs and the deployment type. This file must be less than 100 MB. Currently, AWS IoT Greengrass supports only ''NewDeployment'' deployment types.
    /// This member is required.
    public var inputFileUri: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        inputFileUri: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.executionRoleArn = executionRoleArn
        self.inputFileUri = inputFileUri
        self.tags = tags
    }
}

struct StartBulkDeploymentInputBody: Swift.Equatable {
    let executionRoleArn: Swift.String?
    let inputFileUri: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension StartBulkDeploymentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case executionRoleArn = "ExecutionRoleArn"
        case inputFileUri = "InputFileUri"
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let inputFileUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputFileUri)
        inputFileUri = inputFileUriDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartBulkDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartBulkDeploymentOutputBody = try responseDecoder.decode(responseBody: data)
            self.bulkDeploymentArn = output.bulkDeploymentArn
            self.bulkDeploymentId = output.bulkDeploymentId
        } else {
            self.bulkDeploymentArn = nil
            self.bulkDeploymentId = nil
        }
    }
}

public struct StartBulkDeploymentOutput: Swift.Equatable {
    /// The ARN of the bulk deployment.
    public var bulkDeploymentArn: Swift.String?
    /// The ID of the bulk deployment.
    public var bulkDeploymentId: Swift.String?

    public init(
        bulkDeploymentArn: Swift.String? = nil,
        bulkDeploymentId: Swift.String? = nil
    )
    {
        self.bulkDeploymentArn = bulkDeploymentArn
        self.bulkDeploymentId = bulkDeploymentId
    }
}

struct StartBulkDeploymentOutputBody: Swift.Equatable {
    let bulkDeploymentArn: Swift.String?
    let bulkDeploymentId: Swift.String?
}

extension StartBulkDeploymentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bulkDeploymentArn = "BulkDeploymentArn"
        case bulkDeploymentId = "BulkDeploymentId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bulkDeploymentArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bulkDeploymentArn)
        bulkDeploymentArn = bulkDeploymentArnDecoded
        let bulkDeploymentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bulkDeploymentId)
        bulkDeploymentId = bulkDeploymentIdDecoded
    }
}

enum StartBulkDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopBulkDeploymentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let bulkDeploymentId = bulkDeploymentId else {
            return nil
        }
        return "/greengrass/bulk/deployments/\(bulkDeploymentId.urlPercentEncoding())/$stop"
    }
}

public struct StopBulkDeploymentInput: Swift.Equatable {
    /// The ID of the bulk deployment.
    /// This member is required.
    public var bulkDeploymentId: Swift.String?

    public init(
        bulkDeploymentId: Swift.String? = nil
    )
    {
        self.bulkDeploymentId = bulkDeploymentId
    }
}

struct StopBulkDeploymentInputBody: Swift.Equatable {
}

extension StopBulkDeploymentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopBulkDeploymentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopBulkDeploymentOutput: Swift.Equatable {

    public init() { }
}

enum StopBulkDeploymentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GreengrassClientTypes.Subscription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "Id"
        case source = "Source"
        case subject = "Subject"
        case target = "Target"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let subject = self.subject {
            try encodeContainer.encode(subject, forKey: .subject)
        }
        if let target = self.target {
            try encodeContainer.encode(target, forKey: .target)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let subjectDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subject)
        subject = subjectDecoded
        let targetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .target)
        target = targetDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a subscription.
    public struct Subscription: Swift.Equatable {
        /// A descriptive or arbitrary ID for the subscription. This value must be unique within the subscription definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        /// This member is required.
        public var id: Swift.String?
        /// The source of the subscription. Can be a thing ARN, a Lambda function ARN, a connector ARN, 'cloud' (which represents the AWS IoT cloud), or 'GGShadowService'.
        /// This member is required.
        public var source: Swift.String?
        /// The MQTT topic used to route the message.
        /// This member is required.
        public var subject: Swift.String?
        /// Where the message is sent to. Can be a thing ARN, a Lambda function ARN, a connector ARN, 'cloud' (which represents the AWS IoT cloud), or 'GGShadowService'.
        /// This member is required.
        public var target: Swift.String?

        public init(
            id: Swift.String? = nil,
            source: Swift.String? = nil,
            subject: Swift.String? = nil,
            target: Swift.String? = nil
        )
        {
            self.id = id
            self.source = source
            self.subject = subject
            self.target = target
        }
    }

}

extension GreengrassClientTypes.SubscriptionDefinitionVersion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case subscriptions = "Subscriptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let subscriptions = subscriptions {
            var subscriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscriptions)
            for subscription0 in subscriptions {
                try subscriptionsContainer.encode(subscription0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionsContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.Subscription?].self, forKey: .subscriptions)
        var subscriptionsDecoded0:[GreengrassClientTypes.Subscription]? = nil
        if let subscriptionsContainer = subscriptionsContainer {
            subscriptionsDecoded0 = [GreengrassClientTypes.Subscription]()
            for structure0 in subscriptionsContainer {
                if let structure0 = structure0 {
                    subscriptionsDecoded0?.append(structure0)
                }
            }
        }
        subscriptions = subscriptionsDecoded0
    }
}

extension GreengrassClientTypes {
    /// Information about a subscription definition version.
    public struct SubscriptionDefinitionVersion: Swift.Equatable {
        /// A list of subscriptions.
        public var subscriptions: [GreengrassClientTypes.Subscription]?

        public init(
            subscriptions: [GreengrassClientTypes.Subscription]? = nil
        )
        {
            self.subscriptions = subscriptions
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

/// A map of the key-value pairs for the resource tag.
public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value pair for the resource tag.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, __string0) in tagsContainer {
                if let __string0 = __string0 {
                    tagsDecoded0?[key0] = __string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GreengrassClientTypes {
    public enum Telemetry: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case off
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [Telemetry] {
            return [
                .off,
                .on,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .off: return "Off"
            case .on: return "On"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Telemetry(rawValue: rawValue) ?? Telemetry.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassClientTypes.TelemetryConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationSyncStatus = "ConfigurationSyncStatus"
        case telemetry = "Telemetry"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configurationSyncStatus = self.configurationSyncStatus {
            try encodeContainer.encode(configurationSyncStatus.rawValue, forKey: .configurationSyncStatus)
        }
        if let telemetry = self.telemetry {
            try encodeContainer.encode(telemetry.rawValue, forKey: .telemetry)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationSyncStatusDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.ConfigurationSyncStatus.self, forKey: .configurationSyncStatus)
        configurationSyncStatus = configurationSyncStatusDecoded
        let telemetryDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.Telemetry.self, forKey: .telemetry)
        telemetry = telemetryDecoded
    }
}

extension GreengrassClientTypes {
    /// Configuration settings for running telemetry.
    public struct TelemetryConfiguration: Swift.Equatable {
        /// Synchronization status of the device reported configuration with the desired configuration.
        public var configurationSyncStatus: GreengrassClientTypes.ConfigurationSyncStatus?
        /// Configure telemetry to be on or off.
        /// This member is required.
        public var telemetry: GreengrassClientTypes.Telemetry?

        public init(
            configurationSyncStatus: GreengrassClientTypes.ConfigurationSyncStatus? = nil,
            telemetry: GreengrassClientTypes.Telemetry? = nil
        )
        {
            self.configurationSyncStatus = configurationSyncStatus
            self.telemetry = telemetry
        }
    }

}

extension GreengrassClientTypes.TelemetryConfigurationUpdate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case telemetry = "Telemetry"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let telemetry = self.telemetry {
            try encodeContainer.encode(telemetry.rawValue, forKey: .telemetry)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let telemetryDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.Telemetry.self, forKey: .telemetry)
        telemetry = telemetryDecoded
    }
}

extension GreengrassClientTypes {
    /// Configuration settings for running telemetry.
    public struct TelemetryConfigurationUpdate: Swift.Equatable {
        /// Configure telemetry to be on or off.
        /// This member is required.
        public var telemetry: GreengrassClientTypes.Telemetry?

        public init(
            telemetry: GreengrassClientTypes.Telemetry? = nil
        )
        {
            self.telemetry = telemetry
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of tag keys to delete
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GreengrassClientTypes {
    /// The minimum level of log statements that should be logged by the OTA Agent during an update.
    public enum UpdateAgentLogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case debug
        case error
        case fatal
        case info
        case `none`
        case trace
        case verbose
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateAgentLogLevel] {
            return [
                .debug,
                .error,
                .fatal,
                .info,
                .none,
                .trace,
                .verbose,
                .warn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .error: return "ERROR"
            case .fatal: return "FATAL"
            case .info: return "INFO"
            case .none: return "NONE"
            case .trace: return "TRACE"
            case .verbose: return "VERBOSE"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateAgentLogLevel(rawValue: rawValue) ?? UpdateAgentLogLevel.sdkUnknown(rawValue)
        }
    }
}

extension UpdateConnectivityInfoInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectivityInfo = "ConnectivityInfo"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectivityInfo = connectivityInfo {
            var connectivityInfoContainer = encodeContainer.nestedUnkeyedContainer(forKey: .connectivityInfo)
            for connectivityinfo0 in connectivityInfo {
                try connectivityInfoContainer.encode(connectivityinfo0)
            }
        }
    }
}

extension UpdateConnectivityInfoInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/greengrass/things/\(thingName.urlPercentEncoding())/connectivityInfo"
    }
}

/// Connectivity information.
public struct UpdateConnectivityInfoInput: Swift.Equatable {
    /// A list of connectivity info.
    public var connectivityInfo: [GreengrassClientTypes.ConnectivityInfo]?
    /// The thing name.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        connectivityInfo: [GreengrassClientTypes.ConnectivityInfo]? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.connectivityInfo = connectivityInfo
        self.thingName = thingName
    }
}

struct UpdateConnectivityInfoInputBody: Swift.Equatable {
    let connectivityInfo: [GreengrassClientTypes.ConnectivityInfo]?
}

extension UpdateConnectivityInfoInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectivityInfo = "ConnectivityInfo"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectivityInfoContainer = try containerValues.decodeIfPresent([GreengrassClientTypes.ConnectivityInfo?].self, forKey: .connectivityInfo)
        var connectivityInfoDecoded0:[GreengrassClientTypes.ConnectivityInfo]? = nil
        if let connectivityInfoContainer = connectivityInfoContainer {
            connectivityInfoDecoded0 = [GreengrassClientTypes.ConnectivityInfo]()
            for structure0 in connectivityInfoContainer {
                if let structure0 = structure0 {
                    connectivityInfoDecoded0?.append(structure0)
                }
            }
        }
        connectivityInfo = connectivityInfoDecoded0
    }
}

extension UpdateConnectivityInfoOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateConnectivityInfoOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.version = output.version
        } else {
            self.message = nil
            self.version = nil
        }
    }
}

public struct UpdateConnectivityInfoOutput: Swift.Equatable {
    /// A message about the connectivity info update request.
    public var message: Swift.String?
    /// The new version of the connectivity info.
    public var version: Swift.String?

    public init(
        message: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.message = message
        self.version = version
    }
}

struct UpdateConnectivityInfoOutputBody: Swift.Equatable {
    let message: Swift.String?
    let version: Swift.String?
}

extension UpdateConnectivityInfoOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
        case version = "Version"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

enum UpdateConnectivityInfoOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateConnectorDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateConnectorDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let connectorDefinitionId = connectorDefinitionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())"
    }
}

public struct UpdateConnectorDefinitionInput: Swift.Equatable {
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        connectorDefinitionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
        self.name = name
    }
}

struct UpdateConnectorDefinitionInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateConnectorDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateConnectorDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateConnectorDefinitionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateConnectorDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCoreDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateCoreDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let coreDefinitionId = coreDefinitionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())"
    }
}

public struct UpdateCoreDefinitionInput: Swift.Equatable {
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        coreDefinitionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
        self.name = name
    }
}

struct UpdateCoreDefinitionInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateCoreDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateCoreDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateCoreDefinitionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateCoreDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDeviceDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateDeviceDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let deviceDefinitionId = deviceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())"
    }
}

public struct UpdateDeviceDefinitionInput: Swift.Equatable {
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        deviceDefinitionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
        self.name = name
    }
}

struct UpdateDeviceDefinitionInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateDeviceDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateDeviceDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDeviceDefinitionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDeviceDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFunctionDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateFunctionDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let functionDefinitionId = functionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())"
    }
}

public struct UpdateFunctionDefinitionInput: Swift.Equatable {
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        functionDefinitionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
        self.name = name
    }
}

struct UpdateFunctionDefinitionInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateFunctionDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateFunctionDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateFunctionDefinitionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateFunctionDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGroupCertificateConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateExpiryInMilliseconds = "CertificateExpiryInMilliseconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateExpiryInMilliseconds = self.certificateExpiryInMilliseconds {
            try encodeContainer.encode(certificateExpiryInMilliseconds, forKey: .certificateExpiryInMilliseconds)
        }
    }
}

extension UpdateGroupCertificateConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/certificateauthorities/configuration/expiry"
    }
}

public struct UpdateGroupCertificateConfigurationInput: Swift.Equatable {
    /// The amount of time remaining before the certificate expires, in milliseconds.
    public var certificateExpiryInMilliseconds: Swift.String?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        certificateExpiryInMilliseconds: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.certificateExpiryInMilliseconds = certificateExpiryInMilliseconds
        self.groupId = groupId
    }
}

struct UpdateGroupCertificateConfigurationInputBody: Swift.Equatable {
    let certificateExpiryInMilliseconds: Swift.String?
}

extension UpdateGroupCertificateConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateExpiryInMilliseconds = "CertificateExpiryInMilliseconds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateExpiryInMillisecondsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateExpiryInMilliseconds)
        certificateExpiryInMilliseconds = certificateExpiryInMillisecondsDecoded
    }
}

extension UpdateGroupCertificateConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateGroupCertificateConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.certificateAuthorityExpiryInMilliseconds = output.certificateAuthorityExpiryInMilliseconds
            self.certificateExpiryInMilliseconds = output.certificateExpiryInMilliseconds
            self.groupId = output.groupId
        } else {
            self.certificateAuthorityExpiryInMilliseconds = nil
            self.certificateExpiryInMilliseconds = nil
            self.groupId = nil
        }
    }
}

public struct UpdateGroupCertificateConfigurationOutput: Swift.Equatable {
    /// The amount of time remaining before the certificate authority expires, in milliseconds.
    public var certificateAuthorityExpiryInMilliseconds: Swift.String?
    /// The amount of time remaining before the certificate expires, in milliseconds.
    public var certificateExpiryInMilliseconds: Swift.String?
    /// The ID of the group certificate configuration.
    public var groupId: Swift.String?

    public init(
        certificateAuthorityExpiryInMilliseconds: Swift.String? = nil,
        certificateExpiryInMilliseconds: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.certificateAuthorityExpiryInMilliseconds = certificateAuthorityExpiryInMilliseconds
        self.certificateExpiryInMilliseconds = certificateExpiryInMilliseconds
        self.groupId = groupId
    }
}

struct UpdateGroupCertificateConfigurationOutputBody: Swift.Equatable {
    let certificateAuthorityExpiryInMilliseconds: Swift.String?
    let certificateExpiryInMilliseconds: Swift.String?
    let groupId: Swift.String?
}

extension UpdateGroupCertificateConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateAuthorityExpiryInMilliseconds = "CertificateAuthorityExpiryInMilliseconds"
        case certificateExpiryInMilliseconds = "CertificateExpiryInMilliseconds"
        case groupId = "GroupId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let certificateAuthorityExpiryInMillisecondsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateAuthorityExpiryInMilliseconds)
        certificateAuthorityExpiryInMilliseconds = certificateAuthorityExpiryInMillisecondsDecoded
        let certificateExpiryInMillisecondsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateExpiryInMilliseconds)
        certificateExpiryInMilliseconds = certificateExpiryInMillisecondsDecoded
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
    }
}

enum UpdateGroupCertificateConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let groupId = groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())"
    }
}

public struct UpdateGroupInput: Swift.Equatable {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.name = name
    }
}

struct UpdateGroupInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateGroupOutput: Swift.Equatable {

    public init() { }
}

enum UpdateGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLoggerDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateLoggerDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let loggerDefinitionId = loggerDefinitionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())"
    }
}

public struct UpdateLoggerDefinitionInput: Swift.Equatable {
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        loggerDefinitionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
        self.name = name
    }
}

struct UpdateLoggerDefinitionInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateLoggerDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateLoggerDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateLoggerDefinitionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateLoggerDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateResourceDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateResourceDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceDefinitionId = resourceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())"
    }
}

public struct UpdateResourceDefinitionInput: Swift.Equatable {
    /// The name of the definition.
    public var name: Swift.String?
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?

    public init(
        name: Swift.String? = nil,
        resourceDefinitionId: Swift.String? = nil
    )
    {
        self.name = name
        self.resourceDefinitionId = resourceDefinitionId
    }
}

struct UpdateResourceDefinitionInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateResourceDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateResourceDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateResourceDefinitionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateResourceDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSubscriptionDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateSubscriptionDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let subscriptionDefinitionId = subscriptionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())"
    }
}

public struct UpdateSubscriptionDefinitionInput: Swift.Equatable {
    /// The name of the definition.
    public var name: Swift.String?
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?

    public init(
        name: Swift.String? = nil,
        subscriptionDefinitionId: Swift.String? = nil
    )
    {
        self.name = name
        self.subscriptionDefinitionId = subscriptionDefinitionId
    }
}

struct UpdateSubscriptionDefinitionInputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateSubscriptionDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateSubscriptionDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateSubscriptionDefinitionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateSubscriptionDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GreengrassClientTypes {
    /// The architecture of the cores which are the targets of an update.
    public enum UpdateTargetsArchitecture: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aarch64
        case armv6l
        case armv7l
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateTargetsArchitecture] {
            return [
                .aarch64,
                .armv6l,
                .armv7l,
                .x8664,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aarch64: return "aarch64"
            case .armv6l: return "armv6l"
            case .armv7l: return "armv7l"
            case .x8664: return "x86_64"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateTargetsArchitecture(rawValue: rawValue) ?? UpdateTargetsArchitecture.sdkUnknown(rawValue)
        }
    }
}

extension GreengrassClientTypes {
    /// The operating system of the cores which are the targets of an update.
    public enum UpdateTargetsOperatingSystem: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonLinux
        case openwrt
        case raspbian
        case ubuntu
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateTargetsOperatingSystem] {
            return [
                .amazonLinux,
                .openwrt,
                .raspbian,
                .ubuntu,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonLinux: return "amazon_linux"
            case .openwrt: return "openwrt"
            case .raspbian: return "raspbian"
            case .ubuntu: return "ubuntu"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateTargetsOperatingSystem(rawValue: rawValue) ?? UpdateTargetsOperatingSystem.sdkUnknown(rawValue)
        }
    }
}

extension UpdateThingRuntimeConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case telemetryConfiguration = "TelemetryConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let telemetryConfiguration = self.telemetryConfiguration {
            try encodeContainer.encode(telemetryConfiguration, forKey: .telemetryConfiguration)
        }
    }
}

extension UpdateThingRuntimeConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let thingName = thingName else {
            return nil
        }
        return "/greengrass/things/\(thingName.urlPercentEncoding())/runtimeconfig"
    }
}

public struct UpdateThingRuntimeConfigurationInput: Swift.Equatable {
    /// Configuration for telemetry service.
    public var telemetryConfiguration: GreengrassClientTypes.TelemetryConfigurationUpdate?
    /// The thing name.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        telemetryConfiguration: GreengrassClientTypes.TelemetryConfigurationUpdate? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.telemetryConfiguration = telemetryConfiguration
        self.thingName = thingName
    }
}

struct UpdateThingRuntimeConfigurationInputBody: Swift.Equatable {
    let telemetryConfiguration: GreengrassClientTypes.TelemetryConfigurationUpdate?
}

extension UpdateThingRuntimeConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case telemetryConfiguration = "TelemetryConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let telemetryConfigurationDecoded = try containerValues.decodeIfPresent(GreengrassClientTypes.TelemetryConfigurationUpdate.self, forKey: .telemetryConfiguration)
        telemetryConfiguration = telemetryConfigurationDecoded
    }
}

extension UpdateThingRuntimeConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateThingRuntimeConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateThingRuntimeConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GreengrassClientTypes.VersionInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTimestamp = "CreationTimestamp"
        case id = "Id"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTimestamp = self.creationTimestamp {
            try encodeContainer.encode(creationTimestamp, forKey: .creationTimestamp)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let creationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationTimestamp)
        creationTimestamp = creationTimestampDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension GreengrassClientTypes {
    /// Information about a version.
    public struct VersionInformation: Swift.Equatable {
        /// The ARN of the version.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the version was created.
        public var creationTimestamp: Swift.String?
        /// The ID of the parent definition that the version is associated with.
        public var id: Swift.String?
        /// The ID of the version.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTimestamp: Swift.String? = nil,
            id: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.version = version
        }
    }

}
