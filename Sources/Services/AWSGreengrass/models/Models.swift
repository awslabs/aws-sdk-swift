// Code generated by smithy-swift-codegen. DO NOT EDIT!
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension AssociateRoleToGroupInput {

    static func urlPathProvider(_ value: AssociateRoleToGroupInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/role"
    }
}

extension AssociateRoleToGroupInput {

    static func write(value: AssociateRoleToGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoleArn"].write(value.roleArn)
    }
}

public struct AssociateRoleToGroupInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The ARN of the role you wish to associate with this group. The existence of the role is not validated.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.roleArn = roleArn
    }
}

extension AssociateRoleToGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> AssociateRoleToGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateRoleToGroupOutput()
        value.associatedAt = try reader["AssociatedAt"].readIfPresent()
        return value
    }
}

public struct AssociateRoleToGroupOutput {
    /// The time, in milliseconds since the epoch, when the role ARN was associated with the group.
    public var associatedAt: Swift.String?

    public init(
        associatedAt: Swift.String? = nil
    )
    {
        self.associatedAt = associatedAt
    }
}

enum AssociateRoleToGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AssociateServiceRoleToAccountInput {

    static func urlPathProvider(_ value: AssociateServiceRoleToAccountInput) -> Swift.String? {
        return "/greengrass/servicerole"
    }
}

extension AssociateServiceRoleToAccountInput {

    static func write(value: AssociateServiceRoleToAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoleArn"].write(value.roleArn)
    }
}

public struct AssociateServiceRoleToAccountInput {
    /// The ARN of the service role you wish to associate with your account.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        roleArn: Swift.String? = nil
    )
    {
        self.roleArn = roleArn
    }
}

extension AssociateServiceRoleToAccountOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> AssociateServiceRoleToAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateServiceRoleToAccountOutput()
        value.associatedAt = try reader["AssociatedAt"].readIfPresent()
        return value
    }
}

public struct AssociateServiceRoleToAccountOutput {
    /// The time when the service role was associated with the account.
    public var associatedAt: Swift.String?

    public init(
        associatedAt: Swift.String? = nil
    )
    {
        self.associatedAt = associatedAt
    }
}

enum AssociateServiceRoleToAccountOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.errorDetails = try reader["ErrorDetails"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.ErrorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// General error information.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Details about the error.
        public internal(set) var errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil
        /// A message containing information about the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorDetails = errorDetails
        self.properties.message = message
    }
}

extension GreengrassClientTypes.BulkDeployment {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.BulkDeployment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.BulkDeployment()
        value.bulkDeploymentArn = try reader["BulkDeploymentArn"].readIfPresent()
        value.bulkDeploymentId = try reader["BulkDeploymentId"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a bulk deployment. You cannot start a new bulk deployment while another one is still running or in a non-terminal state.
    public struct BulkDeployment {
        /// The ARN of the bulk deployment.
        public var bulkDeploymentArn: Swift.String?
        /// The ID of the bulk deployment.
        public var bulkDeploymentId: Swift.String?
        /// The time, in ISO format, when the deployment was created.
        public var createdAt: Swift.String?

        public init(
            bulkDeploymentArn: Swift.String? = nil,
            bulkDeploymentId: Swift.String? = nil,
            createdAt: Swift.String? = nil
        )
        {
            self.bulkDeploymentArn = bulkDeploymentArn
            self.bulkDeploymentId = bulkDeploymentId
            self.createdAt = createdAt
        }
    }

}

extension GreengrassClientTypes.BulkDeploymentMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.BulkDeploymentMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.BulkDeploymentMetrics()
        value.invalidInputRecords = try reader["InvalidInputRecords"].readIfPresent()
        value.recordsProcessed = try reader["RecordsProcessed"].readIfPresent()
        value.retryAttempts = try reader["RetryAttempts"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Relevant metrics on input records processed during bulk deployment.
    public struct BulkDeploymentMetrics {
        /// The total number of records that returned a non-retryable error. For example, this can occur if a group record from the input file uses an invalid format or specifies a nonexistent group version, or if the execution role doesn't grant permission to deploy a group or group version.
        public var invalidInputRecords: Swift.Int?
        /// The total number of group records from the input file that have been processed so far, or attempted.
        public var recordsProcessed: Swift.Int?
        /// The total number of deployment attempts that returned a retryable error. For example, a retry is triggered if the attempt to deploy a group returns a throttling error. ''StartBulkDeployment'' retries a group deployment up to five times.
        public var retryAttempts: Swift.Int?

        public init(
            invalidInputRecords: Swift.Int? = nil,
            recordsProcessed: Swift.Int? = nil,
            retryAttempts: Swift.Int? = nil
        )
        {
            self.invalidInputRecords = invalidInputRecords
            self.recordsProcessed = recordsProcessed
            self.retryAttempts = retryAttempts
        }
    }

}

extension GreengrassClientTypes.BulkDeploymentResult {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.BulkDeploymentResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.BulkDeploymentResult()
        value.createdAt = try reader["CreatedAt"].readIfPresent()
        value.deploymentArn = try reader["DeploymentArn"].readIfPresent()
        value.deploymentId = try reader["DeploymentId"].readIfPresent()
        value.deploymentStatus = try reader["DeploymentStatus"].readIfPresent()
        value.deploymentType = try reader["DeploymentType"].readIfPresent()
        value.errorDetails = try reader["ErrorDetails"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.ErrorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.groupArn = try reader["GroupArn"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about an individual group deployment in a bulk deployment operation.
    public struct BulkDeploymentResult {
        /// The time, in ISO format, when the deployment was created.
        public var createdAt: Swift.String?
        /// The ARN of the group deployment.
        public var deploymentArn: Swift.String?
        /// The ID of the group deployment.
        public var deploymentId: Swift.String?
        /// The current status of the group deployment: ''InProgress'', ''Building'', ''Success'', or ''Failure''.
        public var deploymentStatus: Swift.String?
        /// The type of the deployment.
        public var deploymentType: GreengrassClientTypes.DeploymentType?
        /// Details about the error.
        public var errorDetails: [GreengrassClientTypes.ErrorDetail]?
        /// The error message for a failed deployment
        public var errorMessage: Swift.String?
        /// The ARN of the Greengrass group.
        public var groupArn: Swift.String?

        public init(
            createdAt: Swift.String? = nil,
            deploymentArn: Swift.String? = nil,
            deploymentId: Swift.String? = nil,
            deploymentStatus: Swift.String? = nil,
            deploymentType: GreengrassClientTypes.DeploymentType? = nil,
            errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil,
            errorMessage: Swift.String? = nil,
            groupArn: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.deploymentArn = deploymentArn
            self.deploymentId = deploymentId
            self.deploymentStatus = deploymentStatus
            self.deploymentType = deploymentType
            self.errorDetails = errorDetails
            self.errorMessage = errorMessage
            self.groupArn = groupArn
        }
    }

}

extension GreengrassClientTypes {

    /// The current status of the bulk deployment.
    public enum BulkDeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case initializing
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [BulkDeploymentStatus] {
            return [
                .completed,
                .failed,
                .initializing,
                .running,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .initializing: return "Initializing"
            case .running: return "Running"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes {

    public enum ConfigurationSyncStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case insync
        case outofsync
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationSyncStatus] {
            return [
                .insync,
                .outofsync,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .insync: return "InSync"
            case .outofsync: return "OutOfSync"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes.ConnectivityInfo {

    static func write(value: GreengrassClientTypes.ConnectivityInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HostAddress"].write(value.hostAddress)
        try writer["Id"].write(value.id)
        try writer["Metadata"].write(value.metadata)
        try writer["PortNumber"].write(value.portNumber)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.ConnectivityInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.ConnectivityInfo()
        value.hostAddress = try reader["HostAddress"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.metadata = try reader["Metadata"].readIfPresent()
        value.portNumber = try reader["PortNumber"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a Greengrass core's connectivity.
    public struct ConnectivityInfo {
        /// The endpoint for the Greengrass core. Can be an IP address or DNS.
        public var hostAddress: Swift.String?
        /// The ID of the connectivity information.
        public var id: Swift.String?
        /// Metadata for this endpoint.
        public var metadata: Swift.String?
        /// The port of the Greengrass core. Usually 8883.
        public var portNumber: Swift.Int?

        public init(
            hostAddress: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: Swift.String? = nil,
            portNumber: Swift.Int? = nil
        )
        {
            self.hostAddress = hostAddress
            self.id = id
            self.metadata = metadata
            self.portNumber = portNumber
        }
    }

}

extension GreengrassClientTypes.Connector {

    static func write(value: GreengrassClientTypes.Connector?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectorArn"].write(value.connectorArn)
        try writer["Id"].write(value.id)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.Connector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.Connector()
        value.connectorArn = try reader["ConnectorArn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a connector. Connectors run on the Greengrass core and contain built-in integration with local infrastructure, device protocols, AWS, and other cloud services.
    public struct Connector {
        /// The ARN of the connector.
        /// This member is required.
        public var connectorArn: Swift.String?
        /// A descriptive or arbitrary ID for the connector. This value must be unique within the connector definition version. Max length is 128 characters with pattern [a-zA-Z0-9:_-]+.
        /// This member is required.
        public var id: Swift.String?
        /// The parameters or configuration that the connector uses.
        public var parameters: [Swift.String:Swift.String]?

        public init(
            connectorArn: Swift.String? = nil,
            id: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil
        )
        {
            self.connectorArn = connectorArn
            self.id = id
            self.parameters = parameters
        }
    }

}

extension GreengrassClientTypes.ConnectorDefinitionVersion {

    static func write(value: GreengrassClientTypes.ConnectorDefinitionVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Connectors"].writeList(value.connectors, memberWritingClosure: GreengrassClientTypes.Connector.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.ConnectorDefinitionVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.ConnectorDefinitionVersion()
        value.connectors = try reader["Connectors"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.Connector.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about the connector definition version, which is a container for connectors.
    public struct ConnectorDefinitionVersion {
        /// A list of references to connectors in this version, with their corresponding configuration settings.
        public var connectors: [GreengrassClientTypes.Connector]?

        public init(
            connectors: [GreengrassClientTypes.Connector]? = nil
        )
        {
            self.connectors = connectors
        }
    }

}

extension GreengrassClientTypes.Core {

    static func write(value: GreengrassClientTypes.Core?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateArn"].write(value.certificateArn)
        try writer["Id"].write(value.id)
        try writer["SyncShadow"].write(value.syncShadow)
        try writer["ThingArn"].write(value.thingArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.Core {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.Core()
        value.certificateArn = try reader["CertificateArn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.syncShadow = try reader["SyncShadow"].readIfPresent()
        value.thingArn = try reader["ThingArn"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a core.
    public struct Core {
        /// The ARN of the certificate associated with the core.
        /// This member is required.
        public var certificateArn: Swift.String?
        /// A descriptive or arbitrary ID for the core. This value must be unique within the core definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        /// This member is required.
        public var id: Swift.String?
        /// If true, the core's local shadow is automatically synced with the cloud.
        public var syncShadow: Swift.Bool?
        /// The ARN of the thing which is the core.
        /// This member is required.
        public var thingArn: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            id: Swift.String? = nil,
            syncShadow: Swift.Bool? = nil,
            thingArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.id = id
            self.syncShadow = syncShadow
            self.thingArn = thingArn
        }
    }

}

extension GreengrassClientTypes.CoreDefinitionVersion {

    static func write(value: GreengrassClientTypes.CoreDefinitionVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Cores"].writeList(value.cores, memberWritingClosure: GreengrassClientTypes.Core.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.CoreDefinitionVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.CoreDefinitionVersion()
        value.cores = try reader["Cores"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.Core.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a core definition version.
    public struct CoreDefinitionVersion {
        /// A list of cores in the core definition version.
        public var cores: [GreengrassClientTypes.Core]?

        public init(
            cores: [GreengrassClientTypes.Core]? = nil
        )
        {
            self.cores = cores
        }
    }

}

extension CreateConnectorDefinitionInput {

    static func headerProvider(_ value: CreateConnectorDefinitionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateConnectorDefinitionInput {

    static func urlPathProvider(_ value: CreateConnectorDefinitionInput) -> Swift.String? {
        return "/greengrass/definition/connectors"
    }
}

extension CreateConnectorDefinitionInput {

    static func write(value: CreateConnectorDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialVersion"].write(value.initialVersion, with: GreengrassClientTypes.ConnectorDefinitionVersion.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateConnectorDefinitionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the connector definition.
    public var initialVersion: GreengrassClientTypes.ConnectorDefinitionVersion?
    /// The name of the connector definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.ConnectorDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

extension CreateConnectorDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateConnectorDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConnectorDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

public struct CreateConnectorDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

enum CreateConnectorDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateConnectorDefinitionVersionInput {

    static func headerProvider(_ value: CreateConnectorDefinitionVersionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateConnectorDefinitionVersionInput {

    static func urlPathProvider(_ value: CreateConnectorDefinitionVersionInput) -> Swift.String? {
        guard let connectorDefinitionId = value.connectorDefinitionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())/versions"
    }
}

extension CreateConnectorDefinitionVersionInput {

    static func write(value: CreateConnectorDefinitionVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Connectors"].writeList(value.connectors, memberWritingClosure: GreengrassClientTypes.Connector.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateConnectorDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?
    /// A list of references to connectors in this version, with their corresponding configuration settings.
    public var connectors: [GreengrassClientTypes.Connector]?

    public init(
        amznClientToken: Swift.String? = nil,
        connectorDefinitionId: Swift.String? = nil,
        connectors: [GreengrassClientTypes.Connector]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.connectorDefinitionId = connectorDefinitionId
        self.connectors = connectors
    }
}

extension CreateConnectorDefinitionVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateConnectorDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConnectorDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

public struct CreateConnectorDefinitionVersionOutput {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

enum CreateConnectorDefinitionVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateCoreDefinitionInput {

    static func headerProvider(_ value: CreateCoreDefinitionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateCoreDefinitionInput {

    static func urlPathProvider(_ value: CreateCoreDefinitionInput) -> Swift.String? {
        return "/greengrass/definition/cores"
    }
}

extension CreateCoreDefinitionInput {

    static func write(value: CreateCoreDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialVersion"].write(value.initialVersion, with: GreengrassClientTypes.CoreDefinitionVersion.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

/// Information needed to create a core definition.
public struct CreateCoreDefinitionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the core definition.
    public var initialVersion: GreengrassClientTypes.CoreDefinitionVersion?
    /// The name of the core definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.CoreDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

extension CreateCoreDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateCoreDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCoreDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

public struct CreateCoreDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

enum CreateCoreDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateCoreDefinitionVersionInput {

    static func headerProvider(_ value: CreateCoreDefinitionVersionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateCoreDefinitionVersionInput {

    static func urlPathProvider(_ value: CreateCoreDefinitionVersionInput) -> Swift.String? {
        guard let coreDefinitionId = value.coreDefinitionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())/versions"
    }
}

extension CreateCoreDefinitionVersionInput {

    static func write(value: CreateCoreDefinitionVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Cores"].writeList(value.cores, memberWritingClosure: GreengrassClientTypes.Core.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateCoreDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?
    /// A list of cores in the core definition version.
    public var cores: [GreengrassClientTypes.Core]?

    public init(
        amznClientToken: Swift.String? = nil,
        coreDefinitionId: Swift.String? = nil,
        cores: [GreengrassClientTypes.Core]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.coreDefinitionId = coreDefinitionId
        self.cores = cores
    }
}

extension CreateCoreDefinitionVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateCoreDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCoreDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

public struct CreateCoreDefinitionVersionOutput {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

enum CreateCoreDefinitionVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateDeploymentInput {

    static func headerProvider(_ value: CreateDeploymentInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateDeploymentInput {

    static func urlPathProvider(_ value: CreateDeploymentInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/deployments"
    }
}

extension CreateDeploymentInput {

    static func write(value: CreateDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeploymentId"].write(value.deploymentId)
        try writer["DeploymentType"].write(value.deploymentType)
        try writer["GroupVersionId"].write(value.groupVersionId)
    }
}

public struct CreateDeploymentInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the deployment if you wish to redeploy a previous deployment.
    public var deploymentId: Swift.String?
    /// The type of deployment. When used for ''CreateDeployment'', only ''NewDeployment'' and ''Redeployment'' are valid.
    /// This member is required.
    public var deploymentType: GreengrassClientTypes.DeploymentType?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The ID of the group version to be deployed.
    public var groupVersionId: Swift.String?

    public init(
        amznClientToken: Swift.String? = nil,
        deploymentId: Swift.String? = nil,
        deploymentType: GreengrassClientTypes.DeploymentType? = nil,
        groupId: Swift.String? = nil,
        groupVersionId: Swift.String? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.deploymentId = deploymentId
        self.deploymentType = deploymentType
        self.groupId = groupId
        self.groupVersionId = groupVersionId
    }
}

extension CreateDeploymentOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDeploymentOutput()
        value.deploymentArn = try reader["DeploymentArn"].readIfPresent()
        value.deploymentId = try reader["DeploymentId"].readIfPresent()
        return value
    }
}

public struct CreateDeploymentOutput {
    /// The ARN of the deployment.
    public var deploymentArn: Swift.String?
    /// The ID of the deployment.
    public var deploymentId: Swift.String?

    public init(
        deploymentArn: Swift.String? = nil,
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentArn = deploymentArn
        self.deploymentId = deploymentId
    }
}

enum CreateDeploymentOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateDeviceDefinitionInput {

    static func headerProvider(_ value: CreateDeviceDefinitionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateDeviceDefinitionInput {

    static func urlPathProvider(_ value: CreateDeviceDefinitionInput) -> Swift.String? {
        return "/greengrass/definition/devices"
    }
}

extension CreateDeviceDefinitionInput {

    static func write(value: CreateDeviceDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialVersion"].write(value.initialVersion, with: GreengrassClientTypes.DeviceDefinitionVersion.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateDeviceDefinitionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the device definition.
    public var initialVersion: GreengrassClientTypes.DeviceDefinitionVersion?
    /// The name of the device definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.DeviceDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

extension CreateDeviceDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateDeviceDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDeviceDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

public struct CreateDeviceDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

enum CreateDeviceDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateDeviceDefinitionVersionInput {

    static func headerProvider(_ value: CreateDeviceDefinitionVersionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateDeviceDefinitionVersionInput {

    static func urlPathProvider(_ value: CreateDeviceDefinitionVersionInput) -> Swift.String? {
        guard let deviceDefinitionId = value.deviceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())/versions"
    }
}

extension CreateDeviceDefinitionVersionInput {

    static func write(value: CreateDeviceDefinitionVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Devices"].writeList(value.devices, memberWritingClosure: GreengrassClientTypes.Device.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateDeviceDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?
    /// A list of devices in the definition version.
    public var devices: [GreengrassClientTypes.Device]?

    public init(
        amznClientToken: Swift.String? = nil,
        deviceDefinitionId: Swift.String? = nil,
        devices: [GreengrassClientTypes.Device]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.deviceDefinitionId = deviceDefinitionId
        self.devices = devices
    }
}

extension CreateDeviceDefinitionVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateDeviceDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDeviceDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

public struct CreateDeviceDefinitionVersionOutput {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

enum CreateDeviceDefinitionVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateFunctionDefinitionInput {

    static func headerProvider(_ value: CreateFunctionDefinitionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateFunctionDefinitionInput {

    static func urlPathProvider(_ value: CreateFunctionDefinitionInput) -> Swift.String? {
        return "/greengrass/definition/functions"
    }
}

extension CreateFunctionDefinitionInput {

    static func write(value: CreateFunctionDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialVersion"].write(value.initialVersion, with: GreengrassClientTypes.FunctionDefinitionVersion.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateFunctionDefinitionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the function definition.
    public var initialVersion: GreengrassClientTypes.FunctionDefinitionVersion?
    /// The name of the function definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.FunctionDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

extension CreateFunctionDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateFunctionDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFunctionDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

public struct CreateFunctionDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

enum CreateFunctionDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateFunctionDefinitionVersionInput {

    static func headerProvider(_ value: CreateFunctionDefinitionVersionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateFunctionDefinitionVersionInput {

    static func urlPathProvider(_ value: CreateFunctionDefinitionVersionInput) -> Swift.String? {
        guard let functionDefinitionId = value.functionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())/versions"
    }
}

extension CreateFunctionDefinitionVersionInput {

    static func write(value: CreateFunctionDefinitionVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultConfig"].write(value.defaultConfig, with: GreengrassClientTypes.FunctionDefaultConfig.write(value:to:))
        try writer["Functions"].writeList(value.functions, memberWritingClosure: GreengrassClientTypes.Function.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

/// Information needed to create a function definition version.
public struct CreateFunctionDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The default configuration that applies to all Lambda functions in this function definition version. Individual Lambda functions can override these settings.
    public var defaultConfig: GreengrassClientTypes.FunctionDefaultConfig?
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?
    /// A list of Lambda functions in this function definition version.
    public var functions: [GreengrassClientTypes.Function]?

    public init(
        amznClientToken: Swift.String? = nil,
        defaultConfig: GreengrassClientTypes.FunctionDefaultConfig? = nil,
        functionDefinitionId: Swift.String? = nil,
        functions: [GreengrassClientTypes.Function]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.defaultConfig = defaultConfig
        self.functionDefinitionId = functionDefinitionId
        self.functions = functions
    }
}

extension CreateFunctionDefinitionVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateFunctionDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFunctionDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

public struct CreateFunctionDefinitionVersionOutput {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

enum CreateFunctionDefinitionVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateGroupCertificateAuthorityInput {

    static func headerProvider(_ value: CreateGroupCertificateAuthorityInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateGroupCertificateAuthorityInput {

    static func urlPathProvider(_ value: CreateGroupCertificateAuthorityInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/certificateauthorities"
    }
}

public struct CreateGroupCertificateAuthorityInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        amznClientToken: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.groupId = groupId
    }
}

extension CreateGroupCertificateAuthorityOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateGroupCertificateAuthorityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGroupCertificateAuthorityOutput()
        value.groupCertificateAuthorityArn = try reader["GroupCertificateAuthorityArn"].readIfPresent()
        return value
    }
}

public struct CreateGroupCertificateAuthorityOutput {
    /// The ARN of the group certificate authority.
    public var groupCertificateAuthorityArn: Swift.String?

    public init(
        groupCertificateAuthorityArn: Swift.String? = nil
    )
    {
        self.groupCertificateAuthorityArn = groupCertificateAuthorityArn
    }
}

enum CreateGroupCertificateAuthorityOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateGroupInput {

    static func headerProvider(_ value: CreateGroupInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateGroupInput {

    static func urlPathProvider(_ value: CreateGroupInput) -> Swift.String? {
        return "/greengrass/groups"
    }
}

extension CreateGroupInput {

    static func write(value: CreateGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialVersion"].write(value.initialVersion, with: GreengrassClientTypes.GroupVersion.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateGroupInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the group.
    public var initialVersion: GreengrassClientTypes.GroupVersion?
    /// The name of the group.
    /// This member is required.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.GroupVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

extension CreateGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGroupOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

public struct CreateGroupOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

enum CreateGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateGroupVersionInput {

    static func headerProvider(_ value: CreateGroupVersionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateGroupVersionInput {

    static func urlPathProvider(_ value: CreateGroupVersionInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/versions"
    }
}

extension CreateGroupVersionInput {

    static func write(value: CreateGroupVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectorDefinitionVersionArn"].write(value.connectorDefinitionVersionArn)
        try writer["CoreDefinitionVersionArn"].write(value.coreDefinitionVersionArn)
        try writer["DeviceDefinitionVersionArn"].write(value.deviceDefinitionVersionArn)
        try writer["FunctionDefinitionVersionArn"].write(value.functionDefinitionVersionArn)
        try writer["LoggerDefinitionVersionArn"].write(value.loggerDefinitionVersionArn)
        try writer["ResourceDefinitionVersionArn"].write(value.resourceDefinitionVersionArn)
        try writer["SubscriptionDefinitionVersionArn"].write(value.subscriptionDefinitionVersionArn)
    }
}

public struct CreateGroupVersionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ARN of the connector definition version for this group.
    public var connectorDefinitionVersionArn: Swift.String?
    /// The ARN of the core definition version for this group.
    public var coreDefinitionVersionArn: Swift.String?
    /// The ARN of the device definition version for this group.
    public var deviceDefinitionVersionArn: Swift.String?
    /// The ARN of the function definition version for this group.
    public var functionDefinitionVersionArn: Swift.String?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The ARN of the logger definition version for this group.
    public var loggerDefinitionVersionArn: Swift.String?
    /// The ARN of the resource definition version for this group.
    public var resourceDefinitionVersionArn: Swift.String?
    /// The ARN of the subscription definition version for this group.
    public var subscriptionDefinitionVersionArn: Swift.String?

    public init(
        amznClientToken: Swift.String? = nil,
        connectorDefinitionVersionArn: Swift.String? = nil,
        coreDefinitionVersionArn: Swift.String? = nil,
        deviceDefinitionVersionArn: Swift.String? = nil,
        functionDefinitionVersionArn: Swift.String? = nil,
        groupId: Swift.String? = nil,
        loggerDefinitionVersionArn: Swift.String? = nil,
        resourceDefinitionVersionArn: Swift.String? = nil,
        subscriptionDefinitionVersionArn: Swift.String? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.connectorDefinitionVersionArn = connectorDefinitionVersionArn
        self.coreDefinitionVersionArn = coreDefinitionVersionArn
        self.deviceDefinitionVersionArn = deviceDefinitionVersionArn
        self.functionDefinitionVersionArn = functionDefinitionVersionArn
        self.groupId = groupId
        self.loggerDefinitionVersionArn = loggerDefinitionVersionArn
        self.resourceDefinitionVersionArn = resourceDefinitionVersionArn
        self.subscriptionDefinitionVersionArn = subscriptionDefinitionVersionArn
    }
}

extension CreateGroupVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateGroupVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGroupVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

public struct CreateGroupVersionOutput {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

enum CreateGroupVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateLoggerDefinitionInput {

    static func headerProvider(_ value: CreateLoggerDefinitionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateLoggerDefinitionInput {

    static func urlPathProvider(_ value: CreateLoggerDefinitionInput) -> Swift.String? {
        return "/greengrass/definition/loggers"
    }
}

extension CreateLoggerDefinitionInput {

    static func write(value: CreateLoggerDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialVersion"].write(value.initialVersion, with: GreengrassClientTypes.LoggerDefinitionVersion.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateLoggerDefinitionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the logger definition.
    public var initialVersion: GreengrassClientTypes.LoggerDefinitionVersion?
    /// The name of the logger definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.LoggerDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

extension CreateLoggerDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateLoggerDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLoggerDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

public struct CreateLoggerDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

enum CreateLoggerDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateLoggerDefinitionVersionInput {

    static func headerProvider(_ value: CreateLoggerDefinitionVersionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateLoggerDefinitionVersionInput {

    static func urlPathProvider(_ value: CreateLoggerDefinitionVersionInput) -> Swift.String? {
        guard let loggerDefinitionId = value.loggerDefinitionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())/versions"
    }
}

extension CreateLoggerDefinitionVersionInput {

    static func write(value: CreateLoggerDefinitionVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Loggers"].writeList(value.loggers, memberWritingClosure: GreengrassClientTypes.Logger.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateLoggerDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?
    /// A list of loggers.
    public var loggers: [GreengrassClientTypes.Logger]?

    public init(
        amznClientToken: Swift.String? = nil,
        loggerDefinitionId: Swift.String? = nil,
        loggers: [GreengrassClientTypes.Logger]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.loggerDefinitionId = loggerDefinitionId
        self.loggers = loggers
    }
}

extension CreateLoggerDefinitionVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateLoggerDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLoggerDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

public struct CreateLoggerDefinitionVersionOutput {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

enum CreateLoggerDefinitionVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateResourceDefinitionInput {

    static func headerProvider(_ value: CreateResourceDefinitionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateResourceDefinitionInput {

    static func urlPathProvider(_ value: CreateResourceDefinitionInput) -> Swift.String? {
        return "/greengrass/definition/resources"
    }
}

extension CreateResourceDefinitionInput {

    static func write(value: CreateResourceDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialVersion"].write(value.initialVersion, with: GreengrassClientTypes.ResourceDefinitionVersion.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateResourceDefinitionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the resource definition.
    public var initialVersion: GreengrassClientTypes.ResourceDefinitionVersion?
    /// The name of the resource definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.ResourceDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

extension CreateResourceDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateResourceDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateResourceDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

public struct CreateResourceDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

enum CreateResourceDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateResourceDefinitionVersionInput {

    static func headerProvider(_ value: CreateResourceDefinitionVersionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateResourceDefinitionVersionInput {

    static func urlPathProvider(_ value: CreateResourceDefinitionVersionInput) -> Swift.String? {
        guard let resourceDefinitionId = value.resourceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())/versions"
    }
}

extension CreateResourceDefinitionVersionInput {

    static func write(value: CreateResourceDefinitionVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Resources"].writeList(value.resources, memberWritingClosure: GreengrassClientTypes.Resource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateResourceDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?
    /// A list of resources.
    public var resources: [GreengrassClientTypes.Resource]?

    public init(
        amznClientToken: Swift.String? = nil,
        resourceDefinitionId: Swift.String? = nil,
        resources: [GreengrassClientTypes.Resource]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.resourceDefinitionId = resourceDefinitionId
        self.resources = resources
    }
}

extension CreateResourceDefinitionVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateResourceDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateResourceDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

public struct CreateResourceDefinitionVersionOutput {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

enum CreateResourceDefinitionVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateSoftwareUpdateJobInput {

    static func headerProvider(_ value: CreateSoftwareUpdateJobInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateSoftwareUpdateJobInput {

    static func urlPathProvider(_ value: CreateSoftwareUpdateJobInput) -> Swift.String? {
        return "/greengrass/updates"
    }
}

extension CreateSoftwareUpdateJobInput {

    static func write(value: CreateSoftwareUpdateJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3UrlSignerRole"].write(value.s3UrlSignerRole)
        try writer["SoftwareToUpdate"].write(value.softwareToUpdate)
        try writer["UpdateAgentLogLevel"].write(value.updateAgentLogLevel)
        try writer["UpdateTargets"].writeList(value.updateTargets, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UpdateTargetsArchitecture"].write(value.updateTargetsArchitecture)
        try writer["UpdateTargetsOperatingSystem"].write(value.updateTargetsOperatingSystem)
    }
}

public struct CreateSoftwareUpdateJobInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The IAM Role that Greengrass will use to create pre-signed URLs pointing towards the update artifact.
    /// This member is required.
    public var s3UrlSignerRole: Swift.String?
    /// The piece of software on the Greengrass core that will be updated.
    /// This member is required.
    public var softwareToUpdate: GreengrassClientTypes.SoftwareToUpdate?
    /// The minimum level of log statements that should be logged by the OTA Agent during an update.
    public var updateAgentLogLevel: GreengrassClientTypes.UpdateAgentLogLevel?
    /// The ARNs of the targets (IoT things or IoT thing groups) that this update will be applied to.
    /// This member is required.
    public var updateTargets: [Swift.String]?
    /// The architecture of the cores which are the targets of an update.
    /// This member is required.
    public var updateTargetsArchitecture: GreengrassClientTypes.UpdateTargetsArchitecture?
    /// The operating system of the cores which are the targets of an update.
    /// This member is required.
    public var updateTargetsOperatingSystem: GreengrassClientTypes.UpdateTargetsOperatingSystem?

    public init(
        amznClientToken: Swift.String? = nil,
        s3UrlSignerRole: Swift.String? = nil,
        softwareToUpdate: GreengrassClientTypes.SoftwareToUpdate? = nil,
        updateAgentLogLevel: GreengrassClientTypes.UpdateAgentLogLevel? = nil,
        updateTargets: [Swift.String]? = nil,
        updateTargetsArchitecture: GreengrassClientTypes.UpdateTargetsArchitecture? = nil,
        updateTargetsOperatingSystem: GreengrassClientTypes.UpdateTargetsOperatingSystem? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.s3UrlSignerRole = s3UrlSignerRole
        self.softwareToUpdate = softwareToUpdate
        self.updateAgentLogLevel = updateAgentLogLevel
        self.updateTargets = updateTargets
        self.updateTargetsArchitecture = updateTargetsArchitecture
        self.updateTargetsOperatingSystem = updateTargetsOperatingSystem
    }
}

extension CreateSoftwareUpdateJobOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateSoftwareUpdateJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSoftwareUpdateJobOutput()
        value.iotJobArn = try reader["IotJobArn"].readIfPresent()
        value.iotJobId = try reader["IotJobId"].readIfPresent()
        value.platformSoftwareVersion = try reader["PlatformSoftwareVersion"].readIfPresent()
        return value
    }
}

public struct CreateSoftwareUpdateJobOutput {
    /// The IoT Job ARN corresponding to this update.
    public var iotJobArn: Swift.String?
    /// The IoT Job Id corresponding to this update.
    public var iotJobId: Swift.String?
    /// The software version installed on the device or devices after the update.
    public var platformSoftwareVersion: Swift.String?

    public init(
        iotJobArn: Swift.String? = nil,
        iotJobId: Swift.String? = nil,
        platformSoftwareVersion: Swift.String? = nil
    )
    {
        self.iotJobArn = iotJobArn
        self.iotJobId = iotJobId
        self.platformSoftwareVersion = platformSoftwareVersion
    }
}

enum CreateSoftwareUpdateJobOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateSubscriptionDefinitionInput {

    static func headerProvider(_ value: CreateSubscriptionDefinitionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateSubscriptionDefinitionInput {

    static func urlPathProvider(_ value: CreateSubscriptionDefinitionInput) -> Swift.String? {
        return "/greengrass/definition/subscriptions"
    }
}

extension CreateSubscriptionDefinitionInput {

    static func write(value: CreateSubscriptionDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialVersion"].write(value.initialVersion, with: GreengrassClientTypes.SubscriptionDefinitionVersion.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct CreateSubscriptionDefinitionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the subscription definition.
    public var initialVersion: GreengrassClientTypes.SubscriptionDefinitionVersion?
    /// The name of the subscription definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.SubscriptionDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

extension CreateSubscriptionDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateSubscriptionDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSubscriptionDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

public struct CreateSubscriptionDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

enum CreateSubscriptionDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateSubscriptionDefinitionVersionInput {

    static func headerProvider(_ value: CreateSubscriptionDefinitionVersionInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateSubscriptionDefinitionVersionInput {

    static func urlPathProvider(_ value: CreateSubscriptionDefinitionVersionInput) -> Swift.String? {
        guard let subscriptionDefinitionId = value.subscriptionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())/versions"
    }
}

extension CreateSubscriptionDefinitionVersionInput {

    static func write(value: CreateSubscriptionDefinitionVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Subscriptions"].writeList(value.subscriptions, memberWritingClosure: GreengrassClientTypes.Subscription.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct CreateSubscriptionDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?
    /// A list of subscriptions.
    public var subscriptions: [GreengrassClientTypes.Subscription]?

    public init(
        amznClientToken: Swift.String? = nil,
        subscriptionDefinitionId: Swift.String? = nil,
        subscriptions: [GreengrassClientTypes.Subscription]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.subscriptionDefinitionId = subscriptionDefinitionId
        self.subscriptions = subscriptions
    }
}

extension CreateSubscriptionDefinitionVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateSubscriptionDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSubscriptionDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

public struct CreateSubscriptionDefinitionVersionOutput {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

enum CreateSubscriptionDefinitionVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GreengrassClientTypes.DefinitionInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.DefinitionInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.DefinitionInformation()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a definition.
    public struct DefinitionInformation {
        /// The ARN of the definition.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public var creationTimestamp: Swift.String?
        /// The ID of the definition.
        public var id: Swift.String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public var lastUpdatedTimestamp: Swift.String?
        /// The ID of the latest version associated with the definition.
        public var latestVersion: Swift.String?
        /// The ARN of the latest version associated with the definition.
        public var latestVersionArn: Swift.String?
        /// The name of the definition.
        public var name: Swift.String?
        /// Tag(s) attached to the resource arn.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            creationTimestamp: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedTimestamp: Swift.String? = nil,
            latestVersion: Swift.String? = nil,
            latestVersionArn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
            self.tags = tags
        }
    }

}

extension DeleteConnectorDefinitionInput {

    static func urlPathProvider(_ value: DeleteConnectorDefinitionInput) -> Swift.String? {
        guard let connectorDefinitionId = value.connectorDefinitionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteConnectorDefinitionInput {
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?

    public init(
        connectorDefinitionId: Swift.String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
    }
}

extension DeleteConnectorDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteConnectorDefinitionOutput {
        return DeleteConnectorDefinitionOutput()
    }
}

public struct DeleteConnectorDefinitionOutput {

    public init() { }
}

enum DeleteConnectorDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteCoreDefinitionInput {

    static func urlPathProvider(_ value: DeleteCoreDefinitionInput) -> Swift.String? {
        guard let coreDefinitionId = value.coreDefinitionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteCoreDefinitionInput {
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?

    public init(
        coreDefinitionId: Swift.String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
    }
}

extension DeleteCoreDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteCoreDefinitionOutput {
        return DeleteCoreDefinitionOutput()
    }
}

public struct DeleteCoreDefinitionOutput {

    public init() { }
}

enum DeleteCoreDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteDeviceDefinitionInput {

    static func urlPathProvider(_ value: DeleteDeviceDefinitionInput) -> Swift.String? {
        guard let deviceDefinitionId = value.deviceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteDeviceDefinitionInput {
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?

    public init(
        deviceDefinitionId: Swift.String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
    }
}

extension DeleteDeviceDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteDeviceDefinitionOutput {
        return DeleteDeviceDefinitionOutput()
    }
}

public struct DeleteDeviceDefinitionOutput {

    public init() { }
}

enum DeleteDeviceDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteFunctionDefinitionInput {

    static func urlPathProvider(_ value: DeleteFunctionDefinitionInput) -> Swift.String? {
        guard let functionDefinitionId = value.functionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteFunctionDefinitionInput {
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?

    public init(
        functionDefinitionId: Swift.String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
    }
}

extension DeleteFunctionDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteFunctionDefinitionOutput {
        return DeleteFunctionDefinitionOutput()
    }
}

public struct DeleteFunctionDefinitionOutput {

    public init() { }
}

enum DeleteFunctionDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteGroupInput {

    static func urlPathProvider(_ value: DeleteGroupInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())"
    }
}

public struct DeleteGroupInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

extension DeleteGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteGroupOutput {
        return DeleteGroupOutput()
    }
}

public struct DeleteGroupOutput {

    public init() { }
}

enum DeleteGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteLoggerDefinitionInput {

    static func urlPathProvider(_ value: DeleteLoggerDefinitionInput) -> Swift.String? {
        guard let loggerDefinitionId = value.loggerDefinitionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteLoggerDefinitionInput {
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?

    public init(
        loggerDefinitionId: Swift.String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
    }
}

extension DeleteLoggerDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteLoggerDefinitionOutput {
        return DeleteLoggerDefinitionOutput()
    }
}

public struct DeleteLoggerDefinitionOutput {

    public init() { }
}

enum DeleteLoggerDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteResourceDefinitionInput {

    static func urlPathProvider(_ value: DeleteResourceDefinitionInput) -> Swift.String? {
        guard let resourceDefinitionId = value.resourceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteResourceDefinitionInput {
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?

    public init(
        resourceDefinitionId: Swift.String? = nil
    )
    {
        self.resourceDefinitionId = resourceDefinitionId
    }
}

extension DeleteResourceDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteResourceDefinitionOutput {
        return DeleteResourceDefinitionOutput()
    }
}

public struct DeleteResourceDefinitionOutput {

    public init() { }
}

enum DeleteResourceDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteSubscriptionDefinitionInput {

    static func urlPathProvider(_ value: DeleteSubscriptionDefinitionInput) -> Swift.String? {
        guard let subscriptionDefinitionId = value.subscriptionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteSubscriptionDefinitionInput {
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?

    public init(
        subscriptionDefinitionId: Swift.String? = nil
    )
    {
        self.subscriptionDefinitionId = subscriptionDefinitionId
    }
}

extension DeleteSubscriptionDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteSubscriptionDefinitionOutput {
        return DeleteSubscriptionDefinitionOutput()
    }
}

public struct DeleteSubscriptionDefinitionOutput {

    public init() { }
}

enum DeleteSubscriptionDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GreengrassClientTypes.Deployment {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.Deployment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.Deployment()
        value.createdAt = try reader["CreatedAt"].readIfPresent()
        value.deploymentArn = try reader["DeploymentArn"].readIfPresent()
        value.deploymentId = try reader["DeploymentId"].readIfPresent()
        value.deploymentType = try reader["DeploymentType"].readIfPresent()
        value.groupArn = try reader["GroupArn"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a deployment.
    public struct Deployment {
        /// The time, in milliseconds since the epoch, when the deployment was created.
        public var createdAt: Swift.String?
        /// The ARN of the deployment.
        public var deploymentArn: Swift.String?
        /// The ID of the deployment.
        public var deploymentId: Swift.String?
        /// The type of the deployment.
        public var deploymentType: GreengrassClientTypes.DeploymentType?
        /// The ARN of the group for this deployment.
        public var groupArn: Swift.String?

        public init(
            createdAt: Swift.String? = nil,
            deploymentArn: Swift.String? = nil,
            deploymentId: Swift.String? = nil,
            deploymentType: GreengrassClientTypes.DeploymentType? = nil,
            groupArn: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.deploymentArn = deploymentArn
            self.deploymentId = deploymentId
            self.deploymentType = deploymentType
            self.groupArn = groupArn
        }
    }

}

extension GreengrassClientTypes {

    /// The type of deployment. When used for ''CreateDeployment'', only ''NewDeployment'' and ''Redeployment'' are valid.
    public enum DeploymentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case forceresetdeployment
        case newdeployment
        case redeployment
        case resetdeployment
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentType] {
            return [
                .forceresetdeployment,
                .newdeployment,
                .redeployment,
                .resetdeployment,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .forceresetdeployment: return "ForceResetDeployment"
            case .newdeployment: return "NewDeployment"
            case .redeployment: return "Redeployment"
            case .resetdeployment: return "ResetDeployment"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes.Device {

    static func write(value: GreengrassClientTypes.Device?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateArn"].write(value.certificateArn)
        try writer["Id"].write(value.id)
        try writer["SyncShadow"].write(value.syncShadow)
        try writer["ThingArn"].write(value.thingArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.Device {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.Device()
        value.certificateArn = try reader["CertificateArn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.syncShadow = try reader["SyncShadow"].readIfPresent()
        value.thingArn = try reader["ThingArn"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a device.
    public struct Device {
        /// The ARN of the certificate associated with the device.
        /// This member is required.
        public var certificateArn: Swift.String?
        /// A descriptive or arbitrary ID for the device. This value must be unique within the device definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        /// This member is required.
        public var id: Swift.String?
        /// If true, the device's local shadow will be automatically synced with the cloud.
        public var syncShadow: Swift.Bool?
        /// The thing ARN of the device.
        /// This member is required.
        public var thingArn: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            id: Swift.String? = nil,
            syncShadow: Swift.Bool? = nil,
            thingArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.id = id
            self.syncShadow = syncShadow
            self.thingArn = thingArn
        }
    }

}

extension GreengrassClientTypes.DeviceDefinitionVersion {

    static func write(value: GreengrassClientTypes.DeviceDefinitionVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Devices"].writeList(value.devices, memberWritingClosure: GreengrassClientTypes.Device.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.DeviceDefinitionVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.DeviceDefinitionVersion()
        value.devices = try reader["Devices"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.Device.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a device definition version.
    public struct DeviceDefinitionVersion {
        /// A list of devices in the definition version.
        public var devices: [GreengrassClientTypes.Device]?

        public init(
            devices: [GreengrassClientTypes.Device]? = nil
        )
        {
            self.devices = devices
        }
    }

}

extension DisassociateRoleFromGroupInput {

    static func urlPathProvider(_ value: DisassociateRoleFromGroupInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/role"
    }
}

public struct DisassociateRoleFromGroupInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

extension DisassociateRoleFromGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DisassociateRoleFromGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateRoleFromGroupOutput()
        value.disassociatedAt = try reader["DisassociatedAt"].readIfPresent()
        return value
    }
}

public struct DisassociateRoleFromGroupOutput {
    /// The time, in milliseconds since the epoch, when the role was disassociated from the group.
    public var disassociatedAt: Swift.String?

    public init(
        disassociatedAt: Swift.String? = nil
    )
    {
        self.disassociatedAt = disassociatedAt
    }
}

enum DisassociateRoleFromGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DisassociateServiceRoleFromAccountInput {

    static func urlPathProvider(_ value: DisassociateServiceRoleFromAccountInput) -> Swift.String? {
        return "/greengrass/servicerole"
    }
}

public struct DisassociateServiceRoleFromAccountInput {

    public init() { }
}

extension DisassociateServiceRoleFromAccountOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DisassociateServiceRoleFromAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateServiceRoleFromAccountOutput()
        value.disassociatedAt = try reader["DisassociatedAt"].readIfPresent()
        return value
    }
}

public struct DisassociateServiceRoleFromAccountOutput {
    /// The time when the service role was disassociated from the account.
    public var disassociatedAt: Swift.String?

    public init(
        disassociatedAt: Swift.String? = nil
    )
    {
        self.disassociatedAt = disassociatedAt
    }
}

enum DisassociateServiceRoleFromAccountOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GreengrassClientTypes {

    public enum EncodingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case binary
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [EncodingType] {
            return [
                .binary,
                .json,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .binary: return "binary"
            case .json: return "json"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes.ErrorDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.ErrorDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.ErrorDetail()
        value.detailedErrorCode = try reader["DetailedErrorCode"].readIfPresent()
        value.detailedErrorMessage = try reader["DetailedErrorMessage"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Details about the error.
    public struct ErrorDetail {
        /// A detailed error code.
        public var detailedErrorCode: Swift.String?
        /// A detailed error message.
        public var detailedErrorMessage: Swift.String?

        public init(
            detailedErrorCode: Swift.String? = nil,
            detailedErrorMessage: Swift.String? = nil
        )
        {
            self.detailedErrorCode = detailedErrorCode
            self.detailedErrorMessage = detailedErrorMessage
        }
    }

}

extension GreengrassClientTypes.Function {

    static func write(value: GreengrassClientTypes.Function?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FunctionArn"].write(value.functionArn)
        try writer["FunctionConfiguration"].write(value.functionConfiguration, with: GreengrassClientTypes.FunctionConfiguration.write(value:to:))
        try writer["Id"].write(value.id)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.Function {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.Function()
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.functionConfiguration = try reader["FunctionConfiguration"].readIfPresent(with: GreengrassClientTypes.FunctionConfiguration.read(from:))
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a Lambda function.
    public struct Function {
        /// The ARN of the Lambda function.
        public var functionArn: Swift.String?
        /// The configuration of the Lambda function.
        public var functionConfiguration: GreengrassClientTypes.FunctionConfiguration?
        /// A descriptive or arbitrary ID for the function. This value must be unique within the function definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        /// This member is required.
        public var id: Swift.String?

        public init(
            functionArn: Swift.String? = nil,
            functionConfiguration: GreengrassClientTypes.FunctionConfiguration? = nil,
            id: Swift.String? = nil
        )
        {
            self.functionArn = functionArn
            self.functionConfiguration = functionConfiguration
            self.id = id
        }
    }

}

extension GreengrassClientTypes.FunctionConfiguration {

    static func write(value: GreengrassClientTypes.FunctionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EncodingType"].write(value.encodingType)
        try writer["Environment"].write(value.environment, with: GreengrassClientTypes.FunctionConfigurationEnvironment.write(value:to:))
        try writer["ExecArgs"].write(value.execArgs)
        try writer["Executable"].write(value.executable)
        try writer["FunctionRuntimeOverride"].write(value.functionRuntimeOverride)
        try writer["MemorySize"].write(value.memorySize)
        try writer["Pinned"].write(value.pinned)
        try writer["Timeout"].write(value.timeout)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.FunctionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.FunctionConfiguration()
        value.encodingType = try reader["EncodingType"].readIfPresent()
        value.environment = try reader["Environment"].readIfPresent(with: GreengrassClientTypes.FunctionConfigurationEnvironment.read(from:))
        value.execArgs = try reader["ExecArgs"].readIfPresent()
        value.executable = try reader["Executable"].readIfPresent()
        value.memorySize = try reader["MemorySize"].readIfPresent()
        value.pinned = try reader["Pinned"].readIfPresent()
        value.timeout = try reader["Timeout"].readIfPresent()
        value.functionRuntimeOverride = try reader["FunctionRuntimeOverride"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// The configuration of the Lambda function.
    public struct FunctionConfiguration {
        /// The expected encoding type of the input payload for the function. The default is ''json''.
        public var encodingType: GreengrassClientTypes.EncodingType?
        /// The environment configuration of the function.
        public var environment: GreengrassClientTypes.FunctionConfigurationEnvironment?
        /// The execution arguments.
        public var execArgs: Swift.String?
        /// The name of the function executable.
        public var executable: Swift.String?
        /// The Lambda runtime supported by Greengrass which is to be used instead of the one specified in the Lambda function.
        public var functionRuntimeOverride: Swift.String?
        /// The memory size, in KB, which the function requires. This setting is not applicable and should be cleared when you run the Lambda function without containerization.
        public var memorySize: Swift.Int?
        /// True if the function is pinned. Pinned means the function is long-lived and starts when the core starts.
        public var pinned: Swift.Bool?
        /// The allowed function execution time, after which Lambda should terminate the function. This timeout still applies to pinned Lambda functions for each request.
        public var timeout: Swift.Int?

        public init(
            encodingType: GreengrassClientTypes.EncodingType? = nil,
            environment: GreengrassClientTypes.FunctionConfigurationEnvironment? = nil,
            execArgs: Swift.String? = nil,
            executable: Swift.String? = nil,
            functionRuntimeOverride: Swift.String? = nil,
            memorySize: Swift.Int? = nil,
            pinned: Swift.Bool? = nil,
            timeout: Swift.Int? = nil
        )
        {
            self.encodingType = encodingType
            self.environment = environment
            self.execArgs = execArgs
            self.executable = executable
            self.functionRuntimeOverride = functionRuntimeOverride
            self.memorySize = memorySize
            self.pinned = pinned
            self.timeout = timeout
        }
    }

}

extension GreengrassClientTypes.FunctionConfigurationEnvironment {

    static func write(value: GreengrassClientTypes.FunctionConfigurationEnvironment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessSysfs"].write(value.accessSysfs)
        try writer["Execution"].write(value.execution, with: GreengrassClientTypes.FunctionExecutionConfig.write(value:to:))
        try writer["ResourceAccessPolicies"].writeList(value.resourceAccessPolicies, memberWritingClosure: GreengrassClientTypes.ResourceAccessPolicy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Variables"].writeMap(value.variables, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.FunctionConfigurationEnvironment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.FunctionConfigurationEnvironment()
        value.accessSysfs = try reader["AccessSysfs"].readIfPresent()
        value.execution = try reader["Execution"].readIfPresent(with: GreengrassClientTypes.FunctionExecutionConfig.read(from:))
        value.resourceAccessPolicies = try reader["ResourceAccessPolicies"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.ResourceAccessPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.variables = try reader["Variables"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes {
    /// The environment configuration of the function.
    public struct FunctionConfigurationEnvironment {
        /// If true, the Lambda function is allowed to access the host's /sys folder. Use this when the Lambda function needs to read device information from /sys. This setting applies only when you run the Lambda function in a Greengrass container.
        public var accessSysfs: Swift.Bool?
        /// Configuration related to executing the Lambda function
        public var execution: GreengrassClientTypes.FunctionExecutionConfig?
        /// A list of the resources, with their permissions, to which the Lambda function will be granted access. A Lambda function can have at most 10 resources. ResourceAccessPolicies apply only when you run the Lambda function in a Greengrass container.
        public var resourceAccessPolicies: [GreengrassClientTypes.ResourceAccessPolicy]?
        /// Environment variables for the Lambda function's configuration.
        public var variables: [Swift.String:Swift.String]?

        public init(
            accessSysfs: Swift.Bool? = nil,
            execution: GreengrassClientTypes.FunctionExecutionConfig? = nil,
            resourceAccessPolicies: [GreengrassClientTypes.ResourceAccessPolicy]? = nil,
            variables: [Swift.String:Swift.String]? = nil
        )
        {
            self.accessSysfs = accessSysfs
            self.execution = execution
            self.resourceAccessPolicies = resourceAccessPolicies
            self.variables = variables
        }
    }

}

extension GreengrassClientTypes.FunctionDefaultConfig {

    static func write(value: GreengrassClientTypes.FunctionDefaultConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Execution"].write(value.execution, with: GreengrassClientTypes.FunctionDefaultExecutionConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.FunctionDefaultConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.FunctionDefaultConfig()
        value.execution = try reader["Execution"].readIfPresent(with: GreengrassClientTypes.FunctionDefaultExecutionConfig.read(from:))
        return value
    }
}

extension GreengrassClientTypes {
    /// The default configuration that applies to all Lambda functions in the group. Individual Lambda functions can override these settings.
    public struct FunctionDefaultConfig {
        /// Configuration information that specifies how a Lambda function runs.
        public var execution: GreengrassClientTypes.FunctionDefaultExecutionConfig?

        public init(
            execution: GreengrassClientTypes.FunctionDefaultExecutionConfig? = nil
        )
        {
            self.execution = execution
        }
    }

}

extension GreengrassClientTypes.FunctionDefaultExecutionConfig {

    static func write(value: GreengrassClientTypes.FunctionDefaultExecutionConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IsolationMode"].write(value.isolationMode)
        try writer["RunAs"].write(value.runAs, with: GreengrassClientTypes.FunctionRunAsConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.FunctionDefaultExecutionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.FunctionDefaultExecutionConfig()
        value.isolationMode = try reader["IsolationMode"].readIfPresent()
        value.runAs = try reader["RunAs"].readIfPresent(with: GreengrassClientTypes.FunctionRunAsConfig.read(from:))
        return value
    }
}

extension GreengrassClientTypes {
    /// Configuration information that specifies how a Lambda function runs.
    public struct FunctionDefaultExecutionConfig {
        /// Specifies whether the Lambda function runs in a Greengrass container (default) or without containerization. Unless your scenario requires that you run without containerization, we recommend that you run in a Greengrass container. Omit this value to run the Lambda function with the default containerization for the group.
        public var isolationMode: GreengrassClientTypes.FunctionIsolationMode?
        /// Specifies the user and group whose permissions are used when running the Lambda function. You can specify one or both values to override the default values. We recommend that you avoid running as root unless absolutely necessary to minimize the risk of unintended changes or malicious attacks. To run as root, you must set ''IsolationMode'' to ''NoContainer'' and update config.json in ''greengrass-root/config'' to set ''allowFunctionsToRunAsRoot'' to ''yes''.
        public var runAs: GreengrassClientTypes.FunctionRunAsConfig?

        public init(
            isolationMode: GreengrassClientTypes.FunctionIsolationMode? = nil,
            runAs: GreengrassClientTypes.FunctionRunAsConfig? = nil
        )
        {
            self.isolationMode = isolationMode
            self.runAs = runAs
        }
    }

}

extension GreengrassClientTypes.FunctionDefinitionVersion {

    static func write(value: GreengrassClientTypes.FunctionDefinitionVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultConfig"].write(value.defaultConfig, with: GreengrassClientTypes.FunctionDefaultConfig.write(value:to:))
        try writer["Functions"].writeList(value.functions, memberWritingClosure: GreengrassClientTypes.Function.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.FunctionDefinitionVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.FunctionDefinitionVersion()
        value.defaultConfig = try reader["DefaultConfig"].readIfPresent(with: GreengrassClientTypes.FunctionDefaultConfig.read(from:))
        value.functions = try reader["Functions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.Function.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a function definition version.
    public struct FunctionDefinitionVersion {
        /// The default configuration that applies to all Lambda functions in this function definition version. Individual Lambda functions can override these settings.
        public var defaultConfig: GreengrassClientTypes.FunctionDefaultConfig?
        /// A list of Lambda functions in this function definition version.
        public var functions: [GreengrassClientTypes.Function]?

        public init(
            defaultConfig: GreengrassClientTypes.FunctionDefaultConfig? = nil,
            functions: [GreengrassClientTypes.Function]? = nil
        )
        {
            self.defaultConfig = defaultConfig
            self.functions = functions
        }
    }

}

extension GreengrassClientTypes.FunctionExecutionConfig {

    static func write(value: GreengrassClientTypes.FunctionExecutionConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IsolationMode"].write(value.isolationMode)
        try writer["RunAs"].write(value.runAs, with: GreengrassClientTypes.FunctionRunAsConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.FunctionExecutionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.FunctionExecutionConfig()
        value.isolationMode = try reader["IsolationMode"].readIfPresent()
        value.runAs = try reader["RunAs"].readIfPresent(with: GreengrassClientTypes.FunctionRunAsConfig.read(from:))
        return value
    }
}

extension GreengrassClientTypes {
    /// Configuration information that specifies how a Lambda function runs.
    public struct FunctionExecutionConfig {
        /// Specifies whether the Lambda function runs in a Greengrass container (default) or without containerization. Unless your scenario requires that you run without containerization, we recommend that you run in a Greengrass container. Omit this value to run the Lambda function with the default containerization for the group.
        public var isolationMode: GreengrassClientTypes.FunctionIsolationMode?
        /// Specifies the user and group whose permissions are used when running the Lambda function. You can specify one or both values to override the default values. We recommend that you avoid running as root unless absolutely necessary to minimize the risk of unintended changes or malicious attacks. To run as root, you must set ''IsolationMode'' to ''NoContainer'' and update config.json in ''greengrass-root/config'' to set ''allowFunctionsToRunAsRoot'' to ''yes''.
        public var runAs: GreengrassClientTypes.FunctionRunAsConfig?

        public init(
            isolationMode: GreengrassClientTypes.FunctionIsolationMode? = nil,
            runAs: GreengrassClientTypes.FunctionRunAsConfig? = nil
        )
        {
            self.isolationMode = isolationMode
            self.runAs = runAs
        }
    }

}

extension GreengrassClientTypes {

    /// Specifies whether the Lambda function runs in a Greengrass container (default) or without containerization. Unless your scenario requires that you run without containerization, we recommend that you run in a Greengrass container. Omit this value to run the Lambda function with the default containerization for the group.
    public enum FunctionIsolationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case greengrasscontainer
        case nocontainer
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionIsolationMode] {
            return [
                .greengrasscontainer,
                .nocontainer,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .greengrasscontainer: return "GreengrassContainer"
            case .nocontainer: return "NoContainer"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes.FunctionRunAsConfig {

    static func write(value: GreengrassClientTypes.FunctionRunAsConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Gid"].write(value.gid)
        try writer["Uid"].write(value.uid)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.FunctionRunAsConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.FunctionRunAsConfig()
        value.gid = try reader["Gid"].readIfPresent()
        value.uid = try reader["Uid"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Specifies the user and group whose permissions are used when running the Lambda function. You can specify one or both values to override the default values. We recommend that you avoid running as root unless absolutely necessary to minimize the risk of unintended changes or malicious attacks. To run as root, you must set ''IsolationMode'' to ''NoContainer'' and update config.json in ''greengrass-root/config'' to set ''allowFunctionsToRunAsRoot'' to ''yes''.
    public struct FunctionRunAsConfig {
        /// The group ID whose permissions are used to run a Lambda function.
        public var gid: Swift.Int?
        /// The user ID whose permissions are used to run a Lambda function.
        public var uid: Swift.Int?

        public init(
            gid: Swift.Int? = nil,
            uid: Swift.Int? = nil
        )
        {
            self.gid = gid
            self.uid = uid
        }
    }

}

extension GetAssociatedRoleInput {

    static func urlPathProvider(_ value: GetAssociatedRoleInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/role"
    }
}

public struct GetAssociatedRoleInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

extension GetAssociatedRoleOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetAssociatedRoleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssociatedRoleOutput()
        value.associatedAt = try reader["AssociatedAt"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        return value
    }
}

public struct GetAssociatedRoleOutput {
    /// The time when the role was associated with the group.
    public var associatedAt: Swift.String?
    /// The ARN of the role that is associated with the group.
    public var roleArn: Swift.String?

    public init(
        associatedAt: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.associatedAt = associatedAt
        self.roleArn = roleArn
    }
}

enum GetAssociatedRoleOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetBulkDeploymentStatusInput {

    static func urlPathProvider(_ value: GetBulkDeploymentStatusInput) -> Swift.String? {
        guard let bulkDeploymentId = value.bulkDeploymentId else {
            return nil
        }
        return "/greengrass/bulk/deployments/\(bulkDeploymentId.urlPercentEncoding())/status"
    }
}

public struct GetBulkDeploymentStatusInput {
    /// The ID of the bulk deployment.
    /// This member is required.
    public var bulkDeploymentId: Swift.String?

    public init(
        bulkDeploymentId: Swift.String? = nil
    )
    {
        self.bulkDeploymentId = bulkDeploymentId
    }
}

extension GetBulkDeploymentStatusOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetBulkDeploymentStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBulkDeploymentStatusOutput()
        value.bulkDeploymentMetrics = try reader["BulkDeploymentMetrics"].readIfPresent(with: GreengrassClientTypes.BulkDeploymentMetrics.read(from:))
        value.bulkDeploymentStatus = try reader["BulkDeploymentStatus"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readIfPresent()
        value.errorDetails = try reader["ErrorDetails"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.ErrorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct GetBulkDeploymentStatusOutput {
    /// Relevant metrics on input records processed during bulk deployment.
    public var bulkDeploymentMetrics: GreengrassClientTypes.BulkDeploymentMetrics?
    /// The status of the bulk deployment.
    public var bulkDeploymentStatus: GreengrassClientTypes.BulkDeploymentStatus?
    /// The time, in ISO format, when the deployment was created.
    public var createdAt: Swift.String?
    /// Error details
    public var errorDetails: [GreengrassClientTypes.ErrorDetail]?
    /// Error message
    public var errorMessage: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init(
        bulkDeploymentMetrics: GreengrassClientTypes.BulkDeploymentMetrics? = nil,
        bulkDeploymentStatus: GreengrassClientTypes.BulkDeploymentStatus? = nil,
        createdAt: Swift.String? = nil,
        errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil,
        errorMessage: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.bulkDeploymentMetrics = bulkDeploymentMetrics
        self.bulkDeploymentStatus = bulkDeploymentStatus
        self.createdAt = createdAt
        self.errorDetails = errorDetails
        self.errorMessage = errorMessage
        self.tags = tags
    }
}

enum GetBulkDeploymentStatusOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetConnectivityInfoInput {

    static func urlPathProvider(_ value: GetConnectivityInfoInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/greengrass/things/\(thingName.urlPercentEncoding())/connectivityInfo"
    }
}

public struct GetConnectivityInfoInput {
    /// The thing name.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        thingName: Swift.String? = nil
    )
    {
        self.thingName = thingName
    }
}

extension GetConnectivityInfoOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetConnectivityInfoOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectivityInfoOutput()
        value.connectivityInfo = try reader["ConnectivityInfo"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.ConnectivityInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

public struct GetConnectivityInfoOutput {
    /// Connectivity info list.
    public var connectivityInfo: [GreengrassClientTypes.ConnectivityInfo]?
    /// A message about the connectivity info request.
    public var message: Swift.String?

    public init(
        connectivityInfo: [GreengrassClientTypes.ConnectivityInfo]? = nil,
        message: Swift.String? = nil
    )
    {
        self.connectivityInfo = connectivityInfo
        self.message = message
    }
}

enum GetConnectivityInfoOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetConnectorDefinitionInput {

    static func urlPathProvider(_ value: GetConnectorDefinitionInput) -> Swift.String? {
        guard let connectorDefinitionId = value.connectorDefinitionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())"
    }
}

public struct GetConnectorDefinitionInput {
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?

    public init(
        connectorDefinitionId: Swift.String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
    }
}

extension GetConnectorDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetConnectorDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectorDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct GetConnectorDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

enum GetConnectorDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetConnectorDefinitionVersionInput {

    static func queryItemProvider(_ value: GetConnectorDefinitionVersionInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension GetConnectorDefinitionVersionInput {

    static func urlPathProvider(_ value: GetConnectorDefinitionVersionInput) -> Swift.String? {
        guard let connectorDefinitionId = value.connectorDefinitionId else {
            return nil
        }
        guard let connectorDefinitionVersionId = value.connectorDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())/versions/\(connectorDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetConnectorDefinitionVersionInput {
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?
    /// The ID of the connector definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListConnectorDefinitionVersions'' requests. If the version is the last one that was associated with a connector definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var connectorDefinitionVersionId: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        connectorDefinitionId: Swift.String? = nil,
        connectorDefinitionVersionId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
        self.connectorDefinitionVersionId = connectorDefinitionVersionId
        self.nextToken = nextToken
    }
}

extension GetConnectorDefinitionVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetConnectorDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectorDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.definition = try reader["Definition"].readIfPresent(with: GreengrassClientTypes.ConnectorDefinitionVersion.read(from:))
        value.id = try reader["Id"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

public struct GetConnectorDefinitionVersionOutput {
    /// The ARN of the connector definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the connector definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the connector definition version.
    public var definition: GreengrassClientTypes.ConnectorDefinitionVersion?
    /// The ID of the connector definition version.
    public var id: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The version of the connector definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.ConnectorDefinitionVersion? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

enum GetConnectorDefinitionVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetCoreDefinitionInput {

    static func urlPathProvider(_ value: GetCoreDefinitionInput) -> Swift.String? {
        guard let coreDefinitionId = value.coreDefinitionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())"
    }
}

public struct GetCoreDefinitionInput {
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?

    public init(
        coreDefinitionId: Swift.String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
    }
}

extension GetCoreDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetCoreDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCoreDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct GetCoreDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

enum GetCoreDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetCoreDefinitionVersionInput {

    static func urlPathProvider(_ value: GetCoreDefinitionVersionInput) -> Swift.String? {
        guard let coreDefinitionId = value.coreDefinitionId else {
            return nil
        }
        guard let coreDefinitionVersionId = value.coreDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())/versions/\(coreDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetCoreDefinitionVersionInput {
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?
    /// The ID of the core definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListCoreDefinitionVersions'' requests. If the version is the last one that was associated with a core definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var coreDefinitionVersionId: Swift.String?

    public init(
        coreDefinitionId: Swift.String? = nil,
        coreDefinitionVersionId: Swift.String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
        self.coreDefinitionVersionId = coreDefinitionVersionId
    }
}

extension GetCoreDefinitionVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetCoreDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCoreDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.definition = try reader["Definition"].readIfPresent(with: GreengrassClientTypes.CoreDefinitionVersion.read(from:))
        value.id = try reader["Id"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

public struct GetCoreDefinitionVersionOutput {
    /// The ARN of the core definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the core definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the core definition version.
    public var definition: GreengrassClientTypes.CoreDefinitionVersion?
    /// The ID of the core definition version.
    public var id: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The version of the core definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.CoreDefinitionVersion? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

enum GetCoreDefinitionVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetDeploymentStatusInput {

    static func urlPathProvider(_ value: GetDeploymentStatusInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        guard let deploymentId = value.deploymentId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())/status"
    }
}

public struct GetDeploymentStatusInput {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.groupId = groupId
    }
}

extension GetDeploymentStatusOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetDeploymentStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeploymentStatusOutput()
        value.deploymentStatus = try reader["DeploymentStatus"].readIfPresent()
        value.deploymentType = try reader["DeploymentType"].readIfPresent()
        value.errorDetails = try reader["ErrorDetails"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.ErrorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readIfPresent()
        return value
    }
}

public struct GetDeploymentStatusOutput {
    /// The status of the deployment: ''InProgress'', ''Building'', ''Success'', or ''Failure''.
    public var deploymentStatus: Swift.String?
    /// The type of the deployment.
    public var deploymentType: GreengrassClientTypes.DeploymentType?
    /// Error details
    public var errorDetails: [GreengrassClientTypes.ErrorDetail]?
    /// Error message
    public var errorMessage: Swift.String?
    /// The time, in milliseconds since the epoch, when the deployment status was updated.
    public var updatedAt: Swift.String?

    public init(
        deploymentStatus: Swift.String? = nil,
        deploymentType: GreengrassClientTypes.DeploymentType? = nil,
        errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil,
        errorMessage: Swift.String? = nil,
        updatedAt: Swift.String? = nil
    )
    {
        self.deploymentStatus = deploymentStatus
        self.deploymentType = deploymentType
        self.errorDetails = errorDetails
        self.errorMessage = errorMessage
        self.updatedAt = updatedAt
    }
}

enum GetDeploymentStatusOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetDeviceDefinitionInput {

    static func urlPathProvider(_ value: GetDeviceDefinitionInput) -> Swift.String? {
        guard let deviceDefinitionId = value.deviceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())"
    }
}

public struct GetDeviceDefinitionInput {
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?

    public init(
        deviceDefinitionId: Swift.String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
    }
}

extension GetDeviceDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetDeviceDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeviceDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct GetDeviceDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

enum GetDeviceDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetDeviceDefinitionVersionInput {

    static func queryItemProvider(_ value: GetDeviceDefinitionVersionInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension GetDeviceDefinitionVersionInput {

    static func urlPathProvider(_ value: GetDeviceDefinitionVersionInput) -> Swift.String? {
        guard let deviceDefinitionId = value.deviceDefinitionId else {
            return nil
        }
        guard let deviceDefinitionVersionId = value.deviceDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())/versions/\(deviceDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetDeviceDefinitionVersionInput {
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?
    /// The ID of the device definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListDeviceDefinitionVersions'' requests. If the version is the last one that was associated with a device definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var deviceDefinitionVersionId: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        deviceDefinitionId: Swift.String? = nil,
        deviceDefinitionVersionId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
        self.deviceDefinitionVersionId = deviceDefinitionVersionId
        self.nextToken = nextToken
    }
}

extension GetDeviceDefinitionVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetDeviceDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeviceDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.definition = try reader["Definition"].readIfPresent(with: GreengrassClientTypes.DeviceDefinitionVersion.read(from:))
        value.id = try reader["Id"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

public struct GetDeviceDefinitionVersionOutput {
    /// The ARN of the device definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the device definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the device definition version.
    public var definition: GreengrassClientTypes.DeviceDefinitionVersion?
    /// The ID of the device definition version.
    public var id: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The version of the device definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.DeviceDefinitionVersion? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

enum GetDeviceDefinitionVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetFunctionDefinitionInput {

    static func urlPathProvider(_ value: GetFunctionDefinitionInput) -> Swift.String? {
        guard let functionDefinitionId = value.functionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())"
    }
}

public struct GetFunctionDefinitionInput {
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?

    public init(
        functionDefinitionId: Swift.String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
    }
}

extension GetFunctionDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetFunctionDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFunctionDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct GetFunctionDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

enum GetFunctionDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetFunctionDefinitionVersionInput {

    static func queryItemProvider(_ value: GetFunctionDefinitionVersionInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension GetFunctionDefinitionVersionInput {

    static func urlPathProvider(_ value: GetFunctionDefinitionVersionInput) -> Swift.String? {
        guard let functionDefinitionId = value.functionDefinitionId else {
            return nil
        }
        guard let functionDefinitionVersionId = value.functionDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())/versions/\(functionDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetFunctionDefinitionVersionInput {
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?
    /// The ID of the function definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListFunctionDefinitionVersions'' requests. If the version is the last one that was associated with a function definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var functionDefinitionVersionId: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        functionDefinitionId: Swift.String? = nil,
        functionDefinitionVersionId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
        self.functionDefinitionVersionId = functionDefinitionVersionId
        self.nextToken = nextToken
    }
}

extension GetFunctionDefinitionVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetFunctionDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFunctionDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.definition = try reader["Definition"].readIfPresent(with: GreengrassClientTypes.FunctionDefinitionVersion.read(from:))
        value.id = try reader["Id"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

public struct GetFunctionDefinitionVersionOutput {
    /// The ARN of the function definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the function definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information on the definition.
    public var definition: GreengrassClientTypes.FunctionDefinitionVersion?
    /// The ID of the function definition version.
    public var id: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The version of the function definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.FunctionDefinitionVersion? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

enum GetFunctionDefinitionVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetGroupCertificateAuthorityInput {

    static func urlPathProvider(_ value: GetGroupCertificateAuthorityInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        guard let certificateAuthorityId = value.certificateAuthorityId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/certificateauthorities/\(certificateAuthorityId.urlPercentEncoding())"
    }
}

public struct GetGroupCertificateAuthorityInput {
    /// The ID of the certificate authority.
    /// This member is required.
    public var certificateAuthorityId: Swift.String?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        certificateAuthorityId: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.certificateAuthorityId = certificateAuthorityId
        self.groupId = groupId
    }
}

extension GetGroupCertificateAuthorityOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetGroupCertificateAuthorityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGroupCertificateAuthorityOutput()
        value.groupCertificateAuthorityArn = try reader["GroupCertificateAuthorityArn"].readIfPresent()
        value.groupCertificateAuthorityId = try reader["GroupCertificateAuthorityId"].readIfPresent()
        value.pemEncodedCertificate = try reader["PemEncodedCertificate"].readIfPresent()
        return value
    }
}

public struct GetGroupCertificateAuthorityOutput {
    /// The ARN of the certificate authority for the group.
    public var groupCertificateAuthorityArn: Swift.String?
    /// The ID of the certificate authority for the group.
    public var groupCertificateAuthorityId: Swift.String?
    /// The PEM encoded certificate for the group.
    public var pemEncodedCertificate: Swift.String?

    public init(
        groupCertificateAuthorityArn: Swift.String? = nil,
        groupCertificateAuthorityId: Swift.String? = nil,
        pemEncodedCertificate: Swift.String? = nil
    )
    {
        self.groupCertificateAuthorityArn = groupCertificateAuthorityArn
        self.groupCertificateAuthorityId = groupCertificateAuthorityId
        self.pemEncodedCertificate = pemEncodedCertificate
    }
}

enum GetGroupCertificateAuthorityOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetGroupCertificateConfigurationInput {

    static func urlPathProvider(_ value: GetGroupCertificateConfigurationInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/certificateauthorities/configuration/expiry"
    }
}

public struct GetGroupCertificateConfigurationInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

extension GetGroupCertificateConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetGroupCertificateConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGroupCertificateConfigurationOutput()
        value.certificateAuthorityExpiryInMilliseconds = try reader["CertificateAuthorityExpiryInMilliseconds"].readIfPresent()
        value.certificateExpiryInMilliseconds = try reader["CertificateExpiryInMilliseconds"].readIfPresent()
        value.groupId = try reader["GroupId"].readIfPresent()
        return value
    }
}

public struct GetGroupCertificateConfigurationOutput {
    /// The amount of time remaining before the certificate authority expires, in milliseconds.
    public var certificateAuthorityExpiryInMilliseconds: Swift.String?
    /// The amount of time remaining before the certificate expires, in milliseconds.
    public var certificateExpiryInMilliseconds: Swift.String?
    /// The ID of the group certificate configuration.
    public var groupId: Swift.String?

    public init(
        certificateAuthorityExpiryInMilliseconds: Swift.String? = nil,
        certificateExpiryInMilliseconds: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.certificateAuthorityExpiryInMilliseconds = certificateAuthorityExpiryInMilliseconds
        self.certificateExpiryInMilliseconds = certificateExpiryInMilliseconds
        self.groupId = groupId
    }
}

enum GetGroupCertificateConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetGroupInput {

    static func urlPathProvider(_ value: GetGroupInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())"
    }
}

public struct GetGroupInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

extension GetGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGroupOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct GetGroupOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

enum GetGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetGroupVersionInput {

    static func urlPathProvider(_ value: GetGroupVersionInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        guard let groupVersionId = value.groupVersionId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/versions/\(groupVersionId.urlPercentEncoding())"
    }
}

public struct GetGroupVersionInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The ID of the group version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListGroupVersions'' requests. If the version is the last one that was associated with a group, the value also maps to the ''LatestVersion'' property of the corresponding ''GroupInformation'' object.
    /// This member is required.
    public var groupVersionId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        groupVersionId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.groupVersionId = groupVersionId
    }
}

extension GetGroupVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetGroupVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGroupVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.definition = try reader["Definition"].readIfPresent(with: GreengrassClientTypes.GroupVersion.read(from:))
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

public struct GetGroupVersionOutput {
    /// The ARN of the group version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the group version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the group version definition.
    public var definition: GreengrassClientTypes.GroupVersion?
    /// The ID of the group that the version is associated with.
    public var id: Swift.String?
    /// The ID of the group version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.GroupVersion? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.version = version
    }
}

enum GetGroupVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetLoggerDefinitionInput {

    static func urlPathProvider(_ value: GetLoggerDefinitionInput) -> Swift.String? {
        guard let loggerDefinitionId = value.loggerDefinitionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())"
    }
}

public struct GetLoggerDefinitionInput {
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?

    public init(
        loggerDefinitionId: Swift.String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
    }
}

extension GetLoggerDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetLoggerDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLoggerDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct GetLoggerDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

enum GetLoggerDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetLoggerDefinitionVersionInput {

    static func queryItemProvider(_ value: GetLoggerDefinitionVersionInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension GetLoggerDefinitionVersionInput {

    static func urlPathProvider(_ value: GetLoggerDefinitionVersionInput) -> Swift.String? {
        guard let loggerDefinitionId = value.loggerDefinitionId else {
            return nil
        }
        guard let loggerDefinitionVersionId = value.loggerDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())/versions/\(loggerDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetLoggerDefinitionVersionInput {
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?
    /// The ID of the logger definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListLoggerDefinitionVersions'' requests. If the version is the last one that was associated with a logger definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var loggerDefinitionVersionId: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        loggerDefinitionId: Swift.String? = nil,
        loggerDefinitionVersionId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
        self.loggerDefinitionVersionId = loggerDefinitionVersionId
        self.nextToken = nextToken
    }
}

extension GetLoggerDefinitionVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetLoggerDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLoggerDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.definition = try reader["Definition"].readIfPresent(with: GreengrassClientTypes.LoggerDefinitionVersion.read(from:))
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

public struct GetLoggerDefinitionVersionOutput {
    /// The ARN of the logger definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the logger definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the logger definition version.
    public var definition: GreengrassClientTypes.LoggerDefinitionVersion?
    /// The ID of the logger definition version.
    public var id: Swift.String?
    /// The version of the logger definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.LoggerDefinitionVersion? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.version = version
    }
}

enum GetLoggerDefinitionVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetResourceDefinitionInput {

    static func urlPathProvider(_ value: GetResourceDefinitionInput) -> Swift.String? {
        guard let resourceDefinitionId = value.resourceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())"
    }
}

public struct GetResourceDefinitionInput {
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?

    public init(
        resourceDefinitionId: Swift.String? = nil
    )
    {
        self.resourceDefinitionId = resourceDefinitionId
    }
}

extension GetResourceDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetResourceDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct GetResourceDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

enum GetResourceDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetResourceDefinitionVersionInput {

    static func urlPathProvider(_ value: GetResourceDefinitionVersionInput) -> Swift.String? {
        guard let resourceDefinitionId = value.resourceDefinitionId else {
            return nil
        }
        guard let resourceDefinitionVersionId = value.resourceDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())/versions/\(resourceDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetResourceDefinitionVersionInput {
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?
    /// The ID of the resource definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListResourceDefinitionVersions'' requests. If the version is the last one that was associated with a resource definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var resourceDefinitionVersionId: Swift.String?

    public init(
        resourceDefinitionId: Swift.String? = nil,
        resourceDefinitionVersionId: Swift.String? = nil
    )
    {
        self.resourceDefinitionId = resourceDefinitionId
        self.resourceDefinitionVersionId = resourceDefinitionVersionId
    }
}

extension GetResourceDefinitionVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetResourceDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.definition = try reader["Definition"].readIfPresent(with: GreengrassClientTypes.ResourceDefinitionVersion.read(from:))
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

public struct GetResourceDefinitionVersionOutput {
    /// Arn of the resource definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the resource definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the definition.
    public var definition: GreengrassClientTypes.ResourceDefinitionVersion?
    /// The ID of the resource definition version.
    public var id: Swift.String?
    /// The version of the resource definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.ResourceDefinitionVersion? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.version = version
    }
}

enum GetResourceDefinitionVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetServiceRoleForAccountInput {

    static func urlPathProvider(_ value: GetServiceRoleForAccountInput) -> Swift.String? {
        return "/greengrass/servicerole"
    }
}

public struct GetServiceRoleForAccountInput {

    public init() { }
}

extension GetServiceRoleForAccountOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetServiceRoleForAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceRoleForAccountOutput()
        value.associatedAt = try reader["AssociatedAt"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        return value
    }
}

public struct GetServiceRoleForAccountOutput {
    /// The time when the service role was associated with the account.
    public var associatedAt: Swift.String?
    /// The ARN of the role which is associated with the account.
    public var roleArn: Swift.String?

    public init(
        associatedAt: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.associatedAt = associatedAt
        self.roleArn = roleArn
    }
}

enum GetServiceRoleForAccountOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetSubscriptionDefinitionInput {

    static func urlPathProvider(_ value: GetSubscriptionDefinitionInput) -> Swift.String? {
        guard let subscriptionDefinitionId = value.subscriptionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())"
    }
}

public struct GetSubscriptionDefinitionInput {
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?

    public init(
        subscriptionDefinitionId: Swift.String? = nil
    )
    {
        self.subscriptionDefinitionId = subscriptionDefinitionId
    }
}

extension GetSubscriptionDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetSubscriptionDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSubscriptionDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct GetSubscriptionDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

enum GetSubscriptionDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetSubscriptionDefinitionVersionInput {

    static func queryItemProvider(_ value: GetSubscriptionDefinitionVersionInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension GetSubscriptionDefinitionVersionInput {

    static func urlPathProvider(_ value: GetSubscriptionDefinitionVersionInput) -> Swift.String? {
        guard let subscriptionDefinitionId = value.subscriptionDefinitionId else {
            return nil
        }
        guard let subscriptionDefinitionVersionId = value.subscriptionDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())/versions/\(subscriptionDefinitionVersionId.urlPercentEncoding())"
    }
}

public struct GetSubscriptionDefinitionVersionInput {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?
    /// The ID of the subscription definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListSubscriptionDefinitionVersions'' requests. If the version is the last one that was associated with a subscription definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var subscriptionDefinitionVersionId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        subscriptionDefinitionId: Swift.String? = nil,
        subscriptionDefinitionVersionId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptionDefinitionId = subscriptionDefinitionId
        self.subscriptionDefinitionVersionId = subscriptionDefinitionVersionId
    }
}

extension GetSubscriptionDefinitionVersionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetSubscriptionDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSubscriptionDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.definition = try reader["Definition"].readIfPresent(with: GreengrassClientTypes.SubscriptionDefinitionVersion.read(from:))
        value.id = try reader["Id"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

public struct GetSubscriptionDefinitionVersionOutput {
    /// The ARN of the subscription definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the subscription definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the subscription definition version.
    public var definition: GreengrassClientTypes.SubscriptionDefinitionVersion?
    /// The ID of the subscription definition version.
    public var id: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The version of the subscription definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.SubscriptionDefinitionVersion? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

enum GetSubscriptionDefinitionVersionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetThingRuntimeConfigurationInput {

    static func urlPathProvider(_ value: GetThingRuntimeConfigurationInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/greengrass/things/\(thingName.urlPercentEncoding())/runtimeconfig"
    }
}

public struct GetThingRuntimeConfigurationInput {
    /// The thing name.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        thingName: Swift.String? = nil
    )
    {
        self.thingName = thingName
    }
}

extension GetThingRuntimeConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetThingRuntimeConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetThingRuntimeConfigurationOutput()
        value.runtimeConfiguration = try reader["RuntimeConfiguration"].readIfPresent(with: GreengrassClientTypes.RuntimeConfiguration.read(from:))
        return value
    }
}

public struct GetThingRuntimeConfigurationOutput {
    /// Runtime configuration for a thing.
    public var runtimeConfiguration: GreengrassClientTypes.RuntimeConfiguration?

    public init(
        runtimeConfiguration: GreengrassClientTypes.RuntimeConfiguration? = nil
    )
    {
        self.runtimeConfiguration = runtimeConfiguration
    }
}

enum GetThingRuntimeConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

public enum GreengrassClientTypes {}

extension GreengrassClientTypes.GroupCertificateAuthorityProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.GroupCertificateAuthorityProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.GroupCertificateAuthorityProperties()
        value.groupCertificateAuthorityArn = try reader["GroupCertificateAuthorityArn"].readIfPresent()
        value.groupCertificateAuthorityId = try reader["GroupCertificateAuthorityId"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a certificate authority for a group.
    public struct GroupCertificateAuthorityProperties {
        /// The ARN of the certificate authority for the group.
        public var groupCertificateAuthorityArn: Swift.String?
        /// The ID of the certificate authority for the group.
        public var groupCertificateAuthorityId: Swift.String?

        public init(
            groupCertificateAuthorityArn: Swift.String? = nil,
            groupCertificateAuthorityId: Swift.String? = nil
        )
        {
            self.groupCertificateAuthorityArn = groupCertificateAuthorityArn
            self.groupCertificateAuthorityId = groupCertificateAuthorityId
        }
    }

}

extension GreengrassClientTypes.GroupInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.GroupInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.GroupInformation()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a group.
    public struct GroupInformation {
        /// The ARN of the group.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the group was created.
        public var creationTimestamp: Swift.String?
        /// The ID of the group.
        public var id: Swift.String?
        /// The time, in milliseconds since the epoch, when the group was last updated.
        public var lastUpdatedTimestamp: Swift.String?
        /// The ID of the latest version associated with the group.
        public var latestVersion: Swift.String?
        /// The ARN of the latest version associated with the group.
        public var latestVersionArn: Swift.String?
        /// The name of the group.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTimestamp: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedTimestamp: Swift.String? = nil,
            latestVersion: Swift.String? = nil,
            latestVersionArn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
        }
    }

}

extension GreengrassClientTypes.GroupOwnerSetting {

    static func write(value: GreengrassClientTypes.GroupOwnerSetting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoAddGroupOwner"].write(value.autoAddGroupOwner)
        try writer["GroupOwner"].write(value.groupOwner)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.GroupOwnerSetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.GroupOwnerSetting()
        value.autoAddGroupOwner = try reader["AutoAddGroupOwner"].readIfPresent()
        value.groupOwner = try reader["GroupOwner"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Group owner related settings for local resources.
    public struct GroupOwnerSetting {
        /// If true, AWS IoT Greengrass automatically adds the specified Linux OS group owner of the resource to the Lambda process privileges. Thus the Lambda process will have the file access permissions of the added Linux group.
        public var autoAddGroupOwner: Swift.Bool?
        /// The name of the Linux OS group whose privileges will be added to the Lambda process. This field is optional.
        public var groupOwner: Swift.String?

        public init(
            autoAddGroupOwner: Swift.Bool? = nil,
            groupOwner: Swift.String? = nil
        )
        {
            self.autoAddGroupOwner = autoAddGroupOwner
            self.groupOwner = groupOwner
        }
    }

}

extension GreengrassClientTypes.GroupVersion {

    static func write(value: GreengrassClientTypes.GroupVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectorDefinitionVersionArn"].write(value.connectorDefinitionVersionArn)
        try writer["CoreDefinitionVersionArn"].write(value.coreDefinitionVersionArn)
        try writer["DeviceDefinitionVersionArn"].write(value.deviceDefinitionVersionArn)
        try writer["FunctionDefinitionVersionArn"].write(value.functionDefinitionVersionArn)
        try writer["LoggerDefinitionVersionArn"].write(value.loggerDefinitionVersionArn)
        try writer["ResourceDefinitionVersionArn"].write(value.resourceDefinitionVersionArn)
        try writer["SubscriptionDefinitionVersionArn"].write(value.subscriptionDefinitionVersionArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.GroupVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.GroupVersion()
        value.connectorDefinitionVersionArn = try reader["ConnectorDefinitionVersionArn"].readIfPresent()
        value.coreDefinitionVersionArn = try reader["CoreDefinitionVersionArn"].readIfPresent()
        value.deviceDefinitionVersionArn = try reader["DeviceDefinitionVersionArn"].readIfPresent()
        value.functionDefinitionVersionArn = try reader["FunctionDefinitionVersionArn"].readIfPresent()
        value.loggerDefinitionVersionArn = try reader["LoggerDefinitionVersionArn"].readIfPresent()
        value.resourceDefinitionVersionArn = try reader["ResourceDefinitionVersionArn"].readIfPresent()
        value.subscriptionDefinitionVersionArn = try reader["SubscriptionDefinitionVersionArn"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a group version.
    public struct GroupVersion {
        /// The ARN of the connector definition version for this group.
        public var connectorDefinitionVersionArn: Swift.String?
        /// The ARN of the core definition version for this group.
        public var coreDefinitionVersionArn: Swift.String?
        /// The ARN of the device definition version for this group.
        public var deviceDefinitionVersionArn: Swift.String?
        /// The ARN of the function definition version for this group.
        public var functionDefinitionVersionArn: Swift.String?
        /// The ARN of the logger definition version for this group.
        public var loggerDefinitionVersionArn: Swift.String?
        /// The ARN of the resource definition version for this group.
        public var resourceDefinitionVersionArn: Swift.String?
        /// The ARN of the subscription definition version for this group.
        public var subscriptionDefinitionVersionArn: Swift.String?

        public init(
            connectorDefinitionVersionArn: Swift.String? = nil,
            coreDefinitionVersionArn: Swift.String? = nil,
            deviceDefinitionVersionArn: Swift.String? = nil,
            functionDefinitionVersionArn: Swift.String? = nil,
            loggerDefinitionVersionArn: Swift.String? = nil,
            resourceDefinitionVersionArn: Swift.String? = nil,
            subscriptionDefinitionVersionArn: Swift.String? = nil
        )
        {
            self.connectorDefinitionVersionArn = connectorDefinitionVersionArn
            self.coreDefinitionVersionArn = coreDefinitionVersionArn
            self.deviceDefinitionVersionArn = deviceDefinitionVersionArn
            self.functionDefinitionVersionArn = functionDefinitionVersionArn
            self.loggerDefinitionVersionArn = loggerDefinitionVersionArn
            self.resourceDefinitionVersionArn = resourceDefinitionVersionArn
            self.subscriptionDefinitionVersionArn = subscriptionDefinitionVersionArn
        }
    }

}

extension InternalServerErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServerErrorException()
        value.properties.errorDetails = try reader["ErrorDetails"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.ErrorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// General error information.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Details about the error.
        public internal(set) var errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil
        /// A message containing information about the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorDetails = errorDetails
        self.properties.message = message
    }
}

extension ListBulkDeploymentDetailedReportsInput {

    static func queryItemProvider(_ value: ListBulkDeploymentDetailedReportsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListBulkDeploymentDetailedReportsInput {

    static func urlPathProvider(_ value: ListBulkDeploymentDetailedReportsInput) -> Swift.String? {
        guard let bulkDeploymentId = value.bulkDeploymentId else {
            return nil
        }
        return "/greengrass/bulk/deployments/\(bulkDeploymentId.urlPercentEncoding())/detailed-reports"
    }
}

public struct ListBulkDeploymentDetailedReportsInput {
    /// The ID of the bulk deployment.
    /// This member is required.
    public var bulkDeploymentId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        bulkDeploymentId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.bulkDeploymentId = bulkDeploymentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListBulkDeploymentDetailedReportsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListBulkDeploymentDetailedReportsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBulkDeploymentDetailedReportsOutput()
        value.deployments = try reader["Deployments"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.BulkDeploymentResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListBulkDeploymentDetailedReportsOutput {
    /// A list of the individual group deployments in the bulk deployment operation.
    public var deployments: [GreengrassClientTypes.BulkDeploymentResult]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        deployments: [GreengrassClientTypes.BulkDeploymentResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deployments = deployments
        self.nextToken = nextToken
    }
}

enum ListBulkDeploymentDetailedReportsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListBulkDeploymentsInput {

    static func queryItemProvider(_ value: ListBulkDeploymentsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListBulkDeploymentsInput {

    static func urlPathProvider(_ value: ListBulkDeploymentsInput) -> Swift.String? {
        return "/greengrass/bulk/deployments"
    }
}

public struct ListBulkDeploymentsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListBulkDeploymentsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListBulkDeploymentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBulkDeploymentsOutput()
        value.bulkDeployments = try reader["BulkDeployments"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.BulkDeployment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListBulkDeploymentsOutput {
    /// A list of bulk deployments.
    public var bulkDeployments: [GreengrassClientTypes.BulkDeployment]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        bulkDeployments: [GreengrassClientTypes.BulkDeployment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.bulkDeployments = bulkDeployments
        self.nextToken = nextToken
    }
}

enum ListBulkDeploymentsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListConnectorDefinitionVersionsInput {

    static func queryItemProvider(_ value: ListConnectorDefinitionVersionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListConnectorDefinitionVersionsInput {

    static func urlPathProvider(_ value: ListConnectorDefinitionVersionsInput) -> Swift.String? {
        guard let connectorDefinitionId = value.connectorDefinitionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListConnectorDefinitionVersionsInput {
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        connectorDefinitionId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListConnectorDefinitionVersionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListConnectorDefinitionVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConnectorDefinitionVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.VersionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListConnectorDefinitionVersionsOutput {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

enum ListConnectorDefinitionVersionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListConnectorDefinitionsInput {

    static func queryItemProvider(_ value: ListConnectorDefinitionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListConnectorDefinitionsInput {

    static func urlPathProvider(_ value: ListConnectorDefinitionsInput) -> Swift.String? {
        return "/greengrass/definition/connectors"
    }
}

public struct ListConnectorDefinitionsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListConnectorDefinitionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListConnectorDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConnectorDefinitionsOutput()
        value.definitions = try reader["Definitions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.DefinitionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListConnectorDefinitionsOutput {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

enum ListConnectorDefinitionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListCoreDefinitionVersionsInput {

    static func queryItemProvider(_ value: ListCoreDefinitionVersionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCoreDefinitionVersionsInput {

    static func urlPathProvider(_ value: ListCoreDefinitionVersionsInput) -> Swift.String? {
        guard let coreDefinitionId = value.coreDefinitionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListCoreDefinitionVersionsInput {
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        coreDefinitionId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListCoreDefinitionVersionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListCoreDefinitionVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCoreDefinitionVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.VersionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListCoreDefinitionVersionsOutput {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

enum ListCoreDefinitionVersionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListCoreDefinitionsInput {

    static func queryItemProvider(_ value: ListCoreDefinitionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCoreDefinitionsInput {

    static func urlPathProvider(_ value: ListCoreDefinitionsInput) -> Swift.String? {
        return "/greengrass/definition/cores"
    }
}

public struct ListCoreDefinitionsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListCoreDefinitionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListCoreDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCoreDefinitionsOutput()
        value.definitions = try reader["Definitions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.DefinitionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListCoreDefinitionsOutput {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

enum ListCoreDefinitionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListDeploymentsInput {

    static func queryItemProvider(_ value: ListDeploymentsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDeploymentsInput {

    static func urlPathProvider(_ value: ListDeploymentsInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/deployments"
    }
}

public struct ListDeploymentsInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListDeploymentsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListDeploymentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDeploymentsOutput()
        value.deployments = try reader["Deployments"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.Deployment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListDeploymentsOutput {
    /// A list of deployments for the requested groups.
    public var deployments: [GreengrassClientTypes.Deployment]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        deployments: [GreengrassClientTypes.Deployment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deployments = deployments
        self.nextToken = nextToken
    }
}

enum ListDeploymentsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListDeviceDefinitionVersionsInput {

    static func queryItemProvider(_ value: ListDeviceDefinitionVersionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDeviceDefinitionVersionsInput {

    static func urlPathProvider(_ value: ListDeviceDefinitionVersionsInput) -> Swift.String? {
        guard let deviceDefinitionId = value.deviceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListDeviceDefinitionVersionsInput {
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        deviceDefinitionId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListDeviceDefinitionVersionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListDeviceDefinitionVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDeviceDefinitionVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.VersionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListDeviceDefinitionVersionsOutput {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

enum ListDeviceDefinitionVersionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListDeviceDefinitionsInput {

    static func queryItemProvider(_ value: ListDeviceDefinitionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDeviceDefinitionsInput {

    static func urlPathProvider(_ value: ListDeviceDefinitionsInput) -> Swift.String? {
        return "/greengrass/definition/devices"
    }
}

public struct ListDeviceDefinitionsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListDeviceDefinitionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListDeviceDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDeviceDefinitionsOutput()
        value.definitions = try reader["Definitions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.DefinitionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListDeviceDefinitionsOutput {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

enum ListDeviceDefinitionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListFunctionDefinitionVersionsInput {

    static func queryItemProvider(_ value: ListFunctionDefinitionVersionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFunctionDefinitionVersionsInput {

    static func urlPathProvider(_ value: ListFunctionDefinitionVersionsInput) -> Swift.String? {
        guard let functionDefinitionId = value.functionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListFunctionDefinitionVersionsInput {
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        functionDefinitionId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListFunctionDefinitionVersionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListFunctionDefinitionVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFunctionDefinitionVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.VersionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListFunctionDefinitionVersionsOutput {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

enum ListFunctionDefinitionVersionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListFunctionDefinitionsInput {

    static func queryItemProvider(_ value: ListFunctionDefinitionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFunctionDefinitionsInput {

    static func urlPathProvider(_ value: ListFunctionDefinitionsInput) -> Swift.String? {
        return "/greengrass/definition/functions"
    }
}

public struct ListFunctionDefinitionsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListFunctionDefinitionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListFunctionDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFunctionDefinitionsOutput()
        value.definitions = try reader["Definitions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.DefinitionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListFunctionDefinitionsOutput {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

enum ListFunctionDefinitionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListGroupCertificateAuthoritiesInput {

    static func urlPathProvider(_ value: ListGroupCertificateAuthoritiesInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/certificateauthorities"
    }
}

public struct ListGroupCertificateAuthoritiesInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

extension ListGroupCertificateAuthoritiesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListGroupCertificateAuthoritiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGroupCertificateAuthoritiesOutput()
        value.groupCertificateAuthorities = try reader["GroupCertificateAuthorities"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.GroupCertificateAuthorityProperties.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListGroupCertificateAuthoritiesOutput {
    /// A list of certificate authorities associated with the group.
    public var groupCertificateAuthorities: [GreengrassClientTypes.GroupCertificateAuthorityProperties]?

    public init(
        groupCertificateAuthorities: [GreengrassClientTypes.GroupCertificateAuthorityProperties]? = nil
    )
    {
        self.groupCertificateAuthorities = groupCertificateAuthorities
    }
}

enum ListGroupCertificateAuthoritiesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListGroupVersionsInput {

    static func queryItemProvider(_ value: ListGroupVersionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListGroupVersionsInput {

    static func urlPathProvider(_ value: ListGroupVersionsInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/versions"
    }
}

public struct ListGroupVersionsInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListGroupVersionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListGroupVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGroupVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.VersionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListGroupVersionsOutput {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

enum ListGroupVersionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListGroupsInput {

    static func queryItemProvider(_ value: ListGroupsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListGroupsInput {

    static func urlPathProvider(_ value: ListGroupsInput) -> Swift.String? {
        return "/greengrass/groups"
    }
}

public struct ListGroupsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListGroupsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGroupsOutput()
        value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.GroupInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListGroupsOutput {
    /// Information about a group.
    public var groups: [GreengrassClientTypes.GroupInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        groups: [GreengrassClientTypes.GroupInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groups = groups
        self.nextToken = nextToken
    }
}

enum ListGroupsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListLoggerDefinitionVersionsInput {

    static func queryItemProvider(_ value: ListLoggerDefinitionVersionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListLoggerDefinitionVersionsInput {

    static func urlPathProvider(_ value: ListLoggerDefinitionVersionsInput) -> Swift.String? {
        guard let loggerDefinitionId = value.loggerDefinitionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListLoggerDefinitionVersionsInput {
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        loggerDefinitionId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListLoggerDefinitionVersionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListLoggerDefinitionVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLoggerDefinitionVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.VersionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListLoggerDefinitionVersionsOutput {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

enum ListLoggerDefinitionVersionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListLoggerDefinitionsInput {

    static func queryItemProvider(_ value: ListLoggerDefinitionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListLoggerDefinitionsInput {

    static func urlPathProvider(_ value: ListLoggerDefinitionsInput) -> Swift.String? {
        return "/greengrass/definition/loggers"
    }
}

public struct ListLoggerDefinitionsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListLoggerDefinitionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListLoggerDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLoggerDefinitionsOutput()
        value.definitions = try reader["Definitions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.DefinitionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListLoggerDefinitionsOutput {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

enum ListLoggerDefinitionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListResourceDefinitionVersionsInput {

    static func queryItemProvider(_ value: ListResourceDefinitionVersionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListResourceDefinitionVersionsInput {

    static func urlPathProvider(_ value: ListResourceDefinitionVersionsInput) -> Swift.String? {
        guard let resourceDefinitionId = value.resourceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListResourceDefinitionVersionsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        resourceDefinitionId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceDefinitionId = resourceDefinitionId
    }
}

extension ListResourceDefinitionVersionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListResourceDefinitionVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourceDefinitionVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.VersionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListResourceDefinitionVersionsOutput {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

enum ListResourceDefinitionVersionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListResourceDefinitionsInput {

    static func queryItemProvider(_ value: ListResourceDefinitionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListResourceDefinitionsInput {

    static func urlPathProvider(_ value: ListResourceDefinitionsInput) -> Swift.String? {
        return "/greengrass/definition/resources"
    }
}

public struct ListResourceDefinitionsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListResourceDefinitionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListResourceDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourceDefinitionsOutput()
        value.definitions = try reader["Definitions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.DefinitionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListResourceDefinitionsOutput {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

enum ListResourceDefinitionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListSubscriptionDefinitionVersionsInput {

    static func queryItemProvider(_ value: ListSubscriptionDefinitionVersionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSubscriptionDefinitionVersionsInput {

    static func urlPathProvider(_ value: ListSubscriptionDefinitionVersionsInput) -> Swift.String? {
        guard let subscriptionDefinitionId = value.subscriptionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())/versions"
    }
}

public struct ListSubscriptionDefinitionVersionsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        subscriptionDefinitionId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subscriptionDefinitionId = subscriptionDefinitionId
    }
}

extension ListSubscriptionDefinitionVersionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListSubscriptionDefinitionVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSubscriptionDefinitionVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.VersionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListSubscriptionDefinitionVersionsOutput {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

enum ListSubscriptionDefinitionVersionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListSubscriptionDefinitionsInput {

    static func queryItemProvider(_ value: ListSubscriptionDefinitionsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSubscriptionDefinitionsInput {

    static func urlPathProvider(_ value: ListSubscriptionDefinitionsInput) -> Swift.String? {
        return "/greengrass/definition/subscriptions"
    }
}

public struct ListSubscriptionDefinitionsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListSubscriptionDefinitionsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListSubscriptionDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSubscriptionDefinitionsOutput()
        value.definitions = try reader["Definitions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.DefinitionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListSubscriptionDefinitionsOutput {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

enum ListSubscriptionDefinitionsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct ListTagsForResourceOutput {
    /// The key-value pair for the resource tag.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GreengrassClientTypes.LocalDeviceResourceData {

    static func write(value: GreengrassClientTypes.LocalDeviceResourceData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupOwnerSetting"].write(value.groupOwnerSetting, with: GreengrassClientTypes.GroupOwnerSetting.write(value:to:))
        try writer["SourcePath"].write(value.sourcePath)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.LocalDeviceResourceData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.LocalDeviceResourceData()
        value.groupOwnerSetting = try reader["GroupOwnerSetting"].readIfPresent(with: GreengrassClientTypes.GroupOwnerSetting.read(from:))
        value.sourcePath = try reader["SourcePath"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Attributes that define a local device resource.
    public struct LocalDeviceResourceData {
        /// Group/owner related settings for local resources.
        public var groupOwnerSetting: GreengrassClientTypes.GroupOwnerSetting?
        /// The local absolute path of the device resource. The source path for a device resource can refer only to a character device or block device under ''/dev''.
        public var sourcePath: Swift.String?

        public init(
            groupOwnerSetting: GreengrassClientTypes.GroupOwnerSetting? = nil,
            sourcePath: Swift.String? = nil
        )
        {
            self.groupOwnerSetting = groupOwnerSetting
            self.sourcePath = sourcePath
        }
    }

}

extension GreengrassClientTypes.LocalVolumeResourceData {

    static func write(value: GreengrassClientTypes.LocalVolumeResourceData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationPath"].write(value.destinationPath)
        try writer["GroupOwnerSetting"].write(value.groupOwnerSetting, with: GreengrassClientTypes.GroupOwnerSetting.write(value:to:))
        try writer["SourcePath"].write(value.sourcePath)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.LocalVolumeResourceData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.LocalVolumeResourceData()
        value.destinationPath = try reader["DestinationPath"].readIfPresent()
        value.groupOwnerSetting = try reader["GroupOwnerSetting"].readIfPresent(with: GreengrassClientTypes.GroupOwnerSetting.read(from:))
        value.sourcePath = try reader["SourcePath"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Attributes that define a local volume resource.
    public struct LocalVolumeResourceData {
        /// The absolute local path of the resource inside the Lambda environment.
        public var destinationPath: Swift.String?
        /// Allows you to configure additional group privileges for the Lambda process. This field is optional.
        public var groupOwnerSetting: GreengrassClientTypes.GroupOwnerSetting?
        /// The local absolute path of the volume resource on the host. The source path for a volume resource type cannot start with ''/sys''.
        public var sourcePath: Swift.String?

        public init(
            destinationPath: Swift.String? = nil,
            groupOwnerSetting: GreengrassClientTypes.GroupOwnerSetting? = nil,
            sourcePath: Swift.String? = nil
        )
        {
            self.destinationPath = destinationPath
            self.groupOwnerSetting = groupOwnerSetting
            self.sourcePath = sourcePath
        }
    }

}

extension GreengrassClientTypes.Logger {

    static func write(value: GreengrassClientTypes.Logger?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Component"].write(value.component)
        try writer["Id"].write(value.id)
        try writer["Level"].write(value.level)
        try writer["Space"].write(value.space)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.Logger {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.Logger()
        value.component = try reader["Component"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.level = try reader["Level"].readIfPresent()
        value.space = try reader["Space"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a logger
    public struct Logger {
        /// The component that will be subject to logging.
        /// This member is required.
        public var component: GreengrassClientTypes.LoggerComponent?
        /// A descriptive or arbitrary ID for the logger. This value must be unique within the logger definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        /// This member is required.
        public var id: Swift.String?
        /// The level of the logs.
        /// This member is required.
        public var level: GreengrassClientTypes.LoggerLevel?
        /// The amount of file space, in KB, to use if the local file system is used for logging purposes.
        public var space: Swift.Int?
        /// The type of log output which will be used.
        /// This member is required.
        public var type: GreengrassClientTypes.LoggerType?

        public init(
            component: GreengrassClientTypes.LoggerComponent? = nil,
            id: Swift.String? = nil,
            level: GreengrassClientTypes.LoggerLevel? = nil,
            space: Swift.Int? = nil,
            type: GreengrassClientTypes.LoggerType? = nil
        )
        {
            self.component = component
            self.id = id
            self.level = level
            self.space = space
            self.type = type
        }
    }

}

extension GreengrassClientTypes {

    public enum LoggerComponent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case greengrasssystem
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggerComponent] {
            return [
                .greengrasssystem,
                .lambda,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .greengrasssystem: return "GreengrassSystem"
            case .lambda: return "Lambda"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes.LoggerDefinitionVersion {

    static func write(value: GreengrassClientTypes.LoggerDefinitionVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Loggers"].writeList(value.loggers, memberWritingClosure: GreengrassClientTypes.Logger.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.LoggerDefinitionVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.LoggerDefinitionVersion()
        value.loggers = try reader["Loggers"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.Logger.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a logger definition version.
    public struct LoggerDefinitionVersion {
        /// A list of loggers.
        public var loggers: [GreengrassClientTypes.Logger]?

        public init(
            loggers: [GreengrassClientTypes.Logger]? = nil
        )
        {
            self.loggers = loggers
        }
    }

}

extension GreengrassClientTypes {

    public enum LoggerLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case debug
        case error
        case fatal
        case info
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggerLevel] {
            return [
                .debug,
                .error,
                .fatal,
                .info,
                .warn,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .error: return "ERROR"
            case .fatal: return "FATAL"
            case .info: return "INFO"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes {

    public enum LoggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awscloudwatch
        case filesystem
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggerType] {
            return [
                .awscloudwatch,
                .filesystem,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awscloudwatch: return "AWSCloudWatch"
            case .filesystem: return "FileSystem"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes {

    /// The type of permission a function has to access a resource.
    public enum Permission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ro
        case rw
        case sdkUnknown(Swift.String)

        public static var allCases: [Permission] {
            return [
                .ro,
                .rw,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ro: return "ro"
            case .rw: return "rw"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ResetDeploymentsInput {

    static func headerProvider(_ value: ResetDeploymentsInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension ResetDeploymentsInput {

    static func urlPathProvider(_ value: ResetDeploymentsInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/deployments/$reset"
    }
}

extension ResetDeploymentsInput {

    static func write(value: ResetDeploymentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Force"].write(value.force)
    }
}

/// Information needed to reset deployments.
public struct ResetDeploymentsInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// If true, performs a best-effort only core reset.
    public var force: Swift.Bool?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        amznClientToken: Swift.String? = nil,
        force: Swift.Bool? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.force = force
        self.groupId = groupId
    }
}

extension ResetDeploymentsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ResetDeploymentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ResetDeploymentsOutput()
        value.deploymentArn = try reader["DeploymentArn"].readIfPresent()
        value.deploymentId = try reader["DeploymentId"].readIfPresent()
        return value
    }
}

public struct ResetDeploymentsOutput {
    /// The ARN of the deployment.
    public var deploymentArn: Swift.String?
    /// The ID of the deployment.
    public var deploymentId: Swift.String?

    public init(
        deploymentArn: Swift.String? = nil,
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentArn = deploymentArn
        self.deploymentId = deploymentId
    }
}

enum ResetDeploymentsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GreengrassClientTypes.Resource {

    static func write(value: GreengrassClientTypes.Resource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["Name"].write(value.name)
        try writer["ResourceDataContainer"].write(value.resourceDataContainer, with: GreengrassClientTypes.ResourceDataContainer.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.Resource()
        value.id = try reader["Id"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.resourceDataContainer = try reader["ResourceDataContainer"].readIfPresent(with: GreengrassClientTypes.ResourceDataContainer.read(from:))
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a resource.
    public struct Resource {
        /// The resource ID, used to refer to a resource in the Lambda function configuration. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''. This must be unique within a Greengrass group.
        /// This member is required.
        public var id: Swift.String?
        /// The descriptive resource name, which is displayed on the AWS IoT Greengrass console. Max length 128 characters with pattern ''[a-zA-Z0-9:_-]+''. This must be unique within a Greengrass group.
        /// This member is required.
        public var name: Swift.String?
        /// A container of data for all resource types.
        /// This member is required.
        public var resourceDataContainer: GreengrassClientTypes.ResourceDataContainer?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            resourceDataContainer: GreengrassClientTypes.ResourceDataContainer? = nil
        )
        {
            self.id = id
            self.name = name
            self.resourceDataContainer = resourceDataContainer
        }
    }

}

extension GreengrassClientTypes.ResourceAccessPolicy {

    static func write(value: GreengrassClientTypes.ResourceAccessPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Permission"].write(value.permission)
        try writer["ResourceId"].write(value.resourceId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.ResourceAccessPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.ResourceAccessPolicy()
        value.permission = try reader["Permission"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// A policy used by the function to access a resource.
    public struct ResourceAccessPolicy {
        /// The permissions that the Lambda function has to the resource. Can be one of ''rw'' (read/write) or ''ro'' (read-only).
        public var permission: GreengrassClientTypes.Permission?
        /// The ID of the resource. (This ID is assigned to the resource when you create the resource definiton.)
        /// This member is required.
        public var resourceId: Swift.String?

        public init(
            permission: GreengrassClientTypes.Permission? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.permission = permission
            self.resourceId = resourceId
        }
    }

}

extension GreengrassClientTypes.ResourceDataContainer {

    static func write(value: GreengrassClientTypes.ResourceDataContainer?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LocalDeviceResourceData"].write(value.localDeviceResourceData, with: GreengrassClientTypes.LocalDeviceResourceData.write(value:to:))
        try writer["LocalVolumeResourceData"].write(value.localVolumeResourceData, with: GreengrassClientTypes.LocalVolumeResourceData.write(value:to:))
        try writer["S3MachineLearningModelResourceData"].write(value.s3MachineLearningModelResourceData, with: GreengrassClientTypes.S3MachineLearningModelResourceData.write(value:to:))
        try writer["SageMakerMachineLearningModelResourceData"].write(value.sageMakerMachineLearningModelResourceData, with: GreengrassClientTypes.SageMakerMachineLearningModelResourceData.write(value:to:))
        try writer["SecretsManagerSecretResourceData"].write(value.secretsManagerSecretResourceData, with: GreengrassClientTypes.SecretsManagerSecretResourceData.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.ResourceDataContainer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.ResourceDataContainer()
        value.localDeviceResourceData = try reader["LocalDeviceResourceData"].readIfPresent(with: GreengrassClientTypes.LocalDeviceResourceData.read(from:))
        value.localVolumeResourceData = try reader["LocalVolumeResourceData"].readIfPresent(with: GreengrassClientTypes.LocalVolumeResourceData.read(from:))
        value.s3MachineLearningModelResourceData = try reader["S3MachineLearningModelResourceData"].readIfPresent(with: GreengrassClientTypes.S3MachineLearningModelResourceData.read(from:))
        value.sageMakerMachineLearningModelResourceData = try reader["SageMakerMachineLearningModelResourceData"].readIfPresent(with: GreengrassClientTypes.SageMakerMachineLearningModelResourceData.read(from:))
        value.secretsManagerSecretResourceData = try reader["SecretsManagerSecretResourceData"].readIfPresent(with: GreengrassClientTypes.SecretsManagerSecretResourceData.read(from:))
        return value
    }
}

extension GreengrassClientTypes {
    /// A container for resource data. The container takes only one of the following supported resource data types: ''LocalDeviceResourceData'', ''LocalVolumeResourceData'', ''SageMakerMachineLearningModelResourceData'', ''S3MachineLearningModelResourceData'', ''SecretsManagerSecretResourceData''.
    public struct ResourceDataContainer {
        /// Attributes that define the local device resource.
        public var localDeviceResourceData: GreengrassClientTypes.LocalDeviceResourceData?
        /// Attributes that define the local volume resource.
        public var localVolumeResourceData: GreengrassClientTypes.LocalVolumeResourceData?
        /// Attributes that define an Amazon S3 machine learning resource.
        public var s3MachineLearningModelResourceData: GreengrassClientTypes.S3MachineLearningModelResourceData?
        /// Attributes that define an Amazon SageMaker machine learning resource.
        public var sageMakerMachineLearningModelResourceData: GreengrassClientTypes.SageMakerMachineLearningModelResourceData?
        /// Attributes that define a secret resource, which references a secret from AWS Secrets Manager.
        public var secretsManagerSecretResourceData: GreengrassClientTypes.SecretsManagerSecretResourceData?

        public init(
            localDeviceResourceData: GreengrassClientTypes.LocalDeviceResourceData? = nil,
            localVolumeResourceData: GreengrassClientTypes.LocalVolumeResourceData? = nil,
            s3MachineLearningModelResourceData: GreengrassClientTypes.S3MachineLearningModelResourceData? = nil,
            sageMakerMachineLearningModelResourceData: GreengrassClientTypes.SageMakerMachineLearningModelResourceData? = nil,
            secretsManagerSecretResourceData: GreengrassClientTypes.SecretsManagerSecretResourceData? = nil
        )
        {
            self.localDeviceResourceData = localDeviceResourceData
            self.localVolumeResourceData = localVolumeResourceData
            self.s3MachineLearningModelResourceData = s3MachineLearningModelResourceData
            self.sageMakerMachineLearningModelResourceData = sageMakerMachineLearningModelResourceData
            self.secretsManagerSecretResourceData = secretsManagerSecretResourceData
        }
    }

}

extension GreengrassClientTypes.ResourceDefinitionVersion {

    static func write(value: GreengrassClientTypes.ResourceDefinitionVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Resources"].writeList(value.resources, memberWritingClosure: GreengrassClientTypes.Resource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.ResourceDefinitionVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.ResourceDefinitionVersion()
        value.resources = try reader["Resources"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a resource definition version.
    public struct ResourceDefinitionVersion {
        /// A list of resources.
        public var resources: [GreengrassClientTypes.Resource]?

        public init(
            resources: [GreengrassClientTypes.Resource]? = nil
        )
        {
            self.resources = resources
        }
    }

}

extension GreengrassClientTypes.ResourceDownloadOwnerSetting {

    static func write(value: GreengrassClientTypes.ResourceDownloadOwnerSetting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupOwner"].write(value.groupOwner)
        try writer["GroupPermission"].write(value.groupPermission)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.ResourceDownloadOwnerSetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.ResourceDownloadOwnerSetting()
        value.groupOwner = try reader["GroupOwner"].readIfPresent()
        value.groupPermission = try reader["GroupPermission"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// The owner setting for downloaded machine learning resources.
    public struct ResourceDownloadOwnerSetting {
        /// The group owner of the resource. This is the name of an existing Linux OS group on the system or a GID. The group's permissions are added to the Lambda process.
        /// This member is required.
        public var groupOwner: Swift.String?
        /// The permissions that the group owner has to the resource. Valid values are ''rw'' (read/write) or ''ro'' (read-only).
        /// This member is required.
        public var groupPermission: GreengrassClientTypes.Permission?

        public init(
            groupOwner: Swift.String? = nil,
            groupPermission: GreengrassClientTypes.Permission? = nil
        )
        {
            self.groupOwner = groupOwner
            self.groupPermission = groupPermission
        }
    }

}

extension GreengrassClientTypes.RuntimeConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.RuntimeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.RuntimeConfiguration()
        value.telemetryConfiguration = try reader["TelemetryConfiguration"].readIfPresent(with: GreengrassClientTypes.TelemetryConfiguration.read(from:))
        return value
    }
}

extension GreengrassClientTypes {
    /// Runtime configuration for a thing.
    public struct RuntimeConfiguration {
        /// Configuration for telemetry service.
        public var telemetryConfiguration: GreengrassClientTypes.TelemetryConfiguration?

        public init(
            telemetryConfiguration: GreengrassClientTypes.TelemetryConfiguration? = nil
        )
        {
            self.telemetryConfiguration = telemetryConfiguration
        }
    }

}

extension GreengrassClientTypes.S3MachineLearningModelResourceData {

    static func write(value: GreengrassClientTypes.S3MachineLearningModelResourceData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationPath"].write(value.destinationPath)
        try writer["OwnerSetting"].write(value.ownerSetting, with: GreengrassClientTypes.ResourceDownloadOwnerSetting.write(value:to:))
        try writer["S3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.S3MachineLearningModelResourceData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.S3MachineLearningModelResourceData()
        value.destinationPath = try reader["DestinationPath"].readIfPresent()
        value.ownerSetting = try reader["OwnerSetting"].readIfPresent(with: GreengrassClientTypes.ResourceDownloadOwnerSetting.read(from:))
        value.s3Uri = try reader["S3Uri"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Attributes that define an Amazon S3 machine learning resource.
    public struct S3MachineLearningModelResourceData {
        /// The absolute local path of the resource inside the Lambda environment.
        public var destinationPath: Swift.String?
        /// The owner setting for downloaded machine learning resources.
        public var ownerSetting: GreengrassClientTypes.ResourceDownloadOwnerSetting?
        /// The URI of the source model in an S3 bucket. The model package must be in tar.gz or .zip format.
        public var s3Uri: Swift.String?

        public init(
            destinationPath: Swift.String? = nil,
            ownerSetting: GreengrassClientTypes.ResourceDownloadOwnerSetting? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.destinationPath = destinationPath
            self.ownerSetting = ownerSetting
            self.s3Uri = s3Uri
        }
    }

}

extension GreengrassClientTypes.SageMakerMachineLearningModelResourceData {

    static func write(value: GreengrassClientTypes.SageMakerMachineLearningModelResourceData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationPath"].write(value.destinationPath)
        try writer["OwnerSetting"].write(value.ownerSetting, with: GreengrassClientTypes.ResourceDownloadOwnerSetting.write(value:to:))
        try writer["SageMakerJobArn"].write(value.sageMakerJobArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.SageMakerMachineLearningModelResourceData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.SageMakerMachineLearningModelResourceData()
        value.destinationPath = try reader["DestinationPath"].readIfPresent()
        value.ownerSetting = try reader["OwnerSetting"].readIfPresent(with: GreengrassClientTypes.ResourceDownloadOwnerSetting.read(from:))
        value.sageMakerJobArn = try reader["SageMakerJobArn"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Attributes that define an Amazon SageMaker machine learning resource.
    public struct SageMakerMachineLearningModelResourceData {
        /// The absolute local path of the resource inside the Lambda environment.
        public var destinationPath: Swift.String?
        /// The owner setting for downloaded machine learning resources.
        public var ownerSetting: GreengrassClientTypes.ResourceDownloadOwnerSetting?
        /// The ARN of the Amazon SageMaker training job that represents the source model.
        public var sageMakerJobArn: Swift.String?

        public init(
            destinationPath: Swift.String? = nil,
            ownerSetting: GreengrassClientTypes.ResourceDownloadOwnerSetting? = nil,
            sageMakerJobArn: Swift.String? = nil
        )
        {
            self.destinationPath = destinationPath
            self.ownerSetting = ownerSetting
            self.sageMakerJobArn = sageMakerJobArn
        }
    }

}

extension GreengrassClientTypes.SecretsManagerSecretResourceData {

    static func write(value: GreengrassClientTypes.SecretsManagerSecretResourceData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ARN"].write(value.arn)
        try writer["AdditionalStagingLabelsToDownload"].writeList(value.additionalStagingLabelsToDownload, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.SecretsManagerSecretResourceData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.SecretsManagerSecretResourceData()
        value.arn = try reader["ARN"].readIfPresent()
        value.additionalStagingLabelsToDownload = try reader["AdditionalStagingLabelsToDownload"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes {
    /// Attributes that define a secret resource, which references a secret from AWS Secrets Manager. AWS IoT Greengrass stores a local, encrypted copy of the secret on the Greengrass core, where it can be securely accessed by connectors and Lambda functions.
    public struct SecretsManagerSecretResourceData {
        /// Optional. The staging labels whose values you want to make available on the core, in addition to ''AWSCURRENT''.
        public var additionalStagingLabelsToDownload: [Swift.String]?
        /// The ARN of the Secrets Manager secret to make available on the core. The value of the secret's latest version (represented by the ''AWSCURRENT'' staging label) is included by default.
        public var arn: Swift.String?

        public init(
            additionalStagingLabelsToDownload: [Swift.String]? = nil,
            arn: Swift.String? = nil
        )
        {
            self.additionalStagingLabelsToDownload = additionalStagingLabelsToDownload
            self.arn = arn
        }
    }

}

extension GreengrassClientTypes {

    /// The piece of software on the Greengrass core that will be updated.
    public enum SoftwareToUpdate: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case core
        case otaAgent
        case sdkUnknown(Swift.String)

        public static var allCases: [SoftwareToUpdate] {
            return [
                .core,
                .otaAgent,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .core: return "core"
            case .otaAgent: return "ota_agent"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension StartBulkDeploymentInput {

    static func headerProvider(_ value: StartBulkDeploymentInput) -> ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension StartBulkDeploymentInput {

    static func urlPathProvider(_ value: StartBulkDeploymentInput) -> Swift.String? {
        return "/greengrass/bulk/deployments"
    }
}

extension StartBulkDeploymentInput {

    static func write(value: StartBulkDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExecutionRoleArn"].write(value.executionRoleArn)
        try writer["InputFileUri"].write(value.inputFileUri)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

public struct StartBulkDeploymentInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ARN of the execution role to associate with the bulk deployment operation. This IAM role must allow the ''greengrass:CreateDeployment'' action for all group versions that are listed in the input file. This IAM role must have access to the S3 bucket containing the input file.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The URI of the input file contained in the S3 bucket. The execution role must have ''getObject'' permissions on this bucket to access the input file. The input file is a JSON-serialized, line delimited file with UTF-8 encoding that provides a list of group and version IDs and the deployment type. This file must be less than 100 MB. Currently, AWS IoT Greengrass supports only ''NewDeployment'' deployment types.
    /// This member is required.
    public var inputFileUri: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        inputFileUri: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.executionRoleArn = executionRoleArn
        self.inputFileUri = inputFileUri
        self.tags = tags
    }
}

extension StartBulkDeploymentOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StartBulkDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartBulkDeploymentOutput()
        value.bulkDeploymentArn = try reader["BulkDeploymentArn"].readIfPresent()
        value.bulkDeploymentId = try reader["BulkDeploymentId"].readIfPresent()
        return value
    }
}

public struct StartBulkDeploymentOutput {
    /// The ARN of the bulk deployment.
    public var bulkDeploymentArn: Swift.String?
    /// The ID of the bulk deployment.
    public var bulkDeploymentId: Swift.String?

    public init(
        bulkDeploymentArn: Swift.String? = nil,
        bulkDeploymentId: Swift.String? = nil
    )
    {
        self.bulkDeploymentArn = bulkDeploymentArn
        self.bulkDeploymentId = bulkDeploymentId
    }
}

enum StartBulkDeploymentOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension StopBulkDeploymentInput {

    static func urlPathProvider(_ value: StopBulkDeploymentInput) -> Swift.String? {
        guard let bulkDeploymentId = value.bulkDeploymentId else {
            return nil
        }
        return "/greengrass/bulk/deployments/\(bulkDeploymentId.urlPercentEncoding())/$stop"
    }
}

public struct StopBulkDeploymentInput {
    /// The ID of the bulk deployment.
    /// This member is required.
    public var bulkDeploymentId: Swift.String?

    public init(
        bulkDeploymentId: Swift.String? = nil
    )
    {
        self.bulkDeploymentId = bulkDeploymentId
    }
}

extension StopBulkDeploymentOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> StopBulkDeploymentOutput {
        return StopBulkDeploymentOutput()
    }
}

public struct StopBulkDeploymentOutput {

    public init() { }
}

enum StopBulkDeploymentOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GreengrassClientTypes.Subscription {

    static func write(value: GreengrassClientTypes.Subscription?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["Source"].write(value.source)
        try writer["Subject"].write(value.subject)
        try writer["Target"].write(value.target)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.Subscription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.Subscription()
        value.id = try reader["Id"].readIfPresent()
        value.source = try reader["Source"].readIfPresent()
        value.subject = try reader["Subject"].readIfPresent()
        value.target = try reader["Target"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a subscription.
    public struct Subscription {
        /// A descriptive or arbitrary ID for the subscription. This value must be unique within the subscription definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        /// This member is required.
        public var id: Swift.String?
        /// The source of the subscription. Can be a thing ARN, a Lambda function ARN, a connector ARN, 'cloud' (which represents the AWS IoT cloud), or 'GGShadowService'.
        /// This member is required.
        public var source: Swift.String?
        /// The MQTT topic used to route the message.
        /// This member is required.
        public var subject: Swift.String?
        /// Where the message is sent to. Can be a thing ARN, a Lambda function ARN, a connector ARN, 'cloud' (which represents the AWS IoT cloud), or 'GGShadowService'.
        /// This member is required.
        public var target: Swift.String?

        public init(
            id: Swift.String? = nil,
            source: Swift.String? = nil,
            subject: Swift.String? = nil,
            target: Swift.String? = nil
        )
        {
            self.id = id
            self.source = source
            self.subject = subject
            self.target = target
        }
    }

}

extension GreengrassClientTypes.SubscriptionDefinitionVersion {

    static func write(value: GreengrassClientTypes.SubscriptionDefinitionVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Subscriptions"].writeList(value.subscriptions, memberWritingClosure: GreengrassClientTypes.Subscription.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.SubscriptionDefinitionVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.SubscriptionDefinitionVersion()
        value.subscriptions = try reader["Subscriptions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.Subscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a subscription definition version.
    public struct SubscriptionDefinitionVersion {
        /// A list of subscriptions.
        public var subscriptions: [GreengrassClientTypes.Subscription]?

        public init(
            subscriptions: [GreengrassClientTypes.Subscription]? = nil
        )
        {
            self.subscriptions = subscriptions
        }
    }

}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

/// A map of the key-value pairs for the resource tag.
public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value pair for the resource tag.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GreengrassClientTypes {

    public enum Telemetry: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case off
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [Telemetry] {
            return [
                .off,
                .on,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .off: return "Off"
            case .on: return "On"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes.TelemetryConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.TelemetryConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.TelemetryConfiguration()
        value.configurationSyncStatus = try reader["ConfigurationSyncStatus"].readIfPresent()
        value.telemetry = try reader["Telemetry"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Configuration settings for running telemetry.
    public struct TelemetryConfiguration {
        /// Synchronization status of the device reported configuration with the desired configuration.
        public var configurationSyncStatus: GreengrassClientTypes.ConfigurationSyncStatus?
        /// Configure telemetry to be on or off.
        /// This member is required.
        public var telemetry: GreengrassClientTypes.Telemetry?

        public init(
            configurationSyncStatus: GreengrassClientTypes.ConfigurationSyncStatus? = nil,
            telemetry: GreengrassClientTypes.Telemetry? = nil
        )
        {
            self.configurationSyncStatus = configurationSyncStatus
            self.telemetry = telemetry
        }
    }

}

extension GreengrassClientTypes.TelemetryConfigurationUpdate {

    static func write(value: GreengrassClientTypes.TelemetryConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Telemetry"].write(value.telemetry)
    }
}

extension GreengrassClientTypes {
    /// Configuration settings for running telemetry.
    public struct TelemetryConfigurationUpdate {
        /// Configure telemetry to be on or off.
        /// This member is required.
        public var telemetry: GreengrassClientTypes.Telemetry?

        public init(
            telemetry: GreengrassClientTypes.Telemetry? = nil
        )
        {
            self.telemetry = telemetry
        }
    }

}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of tag keys to delete
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GreengrassClientTypes {

    /// The minimum level of log statements that should be logged by the OTA Agent during an update.
    public enum UpdateAgentLogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case debug
        case error
        case fatal
        case info
        case `none`
        case trace
        case verbose
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateAgentLogLevel] {
            return [
                .debug,
                .error,
                .fatal,
                .info,
                .none,
                .trace,
                .verbose,
                .warn,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .error: return "ERROR"
            case .fatal: return "FATAL"
            case .info: return "INFO"
            case .none: return "NONE"
            case .trace: return "TRACE"
            case .verbose: return "VERBOSE"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension UpdateConnectivityInfoInput {

    static func urlPathProvider(_ value: UpdateConnectivityInfoInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/greengrass/things/\(thingName.urlPercentEncoding())/connectivityInfo"
    }
}

extension UpdateConnectivityInfoInput {

    static func write(value: UpdateConnectivityInfoInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectivityInfo"].writeList(value.connectivityInfo, memberWritingClosure: GreengrassClientTypes.ConnectivityInfo.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

/// Connectivity information.
public struct UpdateConnectivityInfoInput {
    /// A list of connectivity info.
    public var connectivityInfo: [GreengrassClientTypes.ConnectivityInfo]?
    /// The thing name.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        connectivityInfo: [GreengrassClientTypes.ConnectivityInfo]? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.connectivityInfo = connectivityInfo
        self.thingName = thingName
    }
}

extension UpdateConnectivityInfoOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateConnectivityInfoOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConnectivityInfoOutput()
        value.message = try reader["message"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

public struct UpdateConnectivityInfoOutput {
    /// A message about the connectivity info update request.
    public var message: Swift.String?
    /// The new version of the connectivity info.
    public var version: Swift.String?

    public init(
        message: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.message = message
        self.version = version
    }
}

enum UpdateConnectivityInfoOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateConnectorDefinitionInput {

    static func urlPathProvider(_ value: UpdateConnectorDefinitionInput) -> Swift.String? {
        guard let connectorDefinitionId = value.connectorDefinitionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())"
    }
}

extension UpdateConnectorDefinitionInput {

    static func write(value: UpdateConnectorDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

public struct UpdateConnectorDefinitionInput {
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        connectorDefinitionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
        self.name = name
    }
}

extension UpdateConnectorDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateConnectorDefinitionOutput {
        return UpdateConnectorDefinitionOutput()
    }
}

public struct UpdateConnectorDefinitionOutput {

    public init() { }
}

enum UpdateConnectorDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateCoreDefinitionInput {

    static func urlPathProvider(_ value: UpdateCoreDefinitionInput) -> Swift.String? {
        guard let coreDefinitionId = value.coreDefinitionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())"
    }
}

extension UpdateCoreDefinitionInput {

    static func write(value: UpdateCoreDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

public struct UpdateCoreDefinitionInput {
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        coreDefinitionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
        self.name = name
    }
}

extension UpdateCoreDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateCoreDefinitionOutput {
        return UpdateCoreDefinitionOutput()
    }
}

public struct UpdateCoreDefinitionOutput {

    public init() { }
}

enum UpdateCoreDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateDeviceDefinitionInput {

    static func urlPathProvider(_ value: UpdateDeviceDefinitionInput) -> Swift.String? {
        guard let deviceDefinitionId = value.deviceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())"
    }
}

extension UpdateDeviceDefinitionInput {

    static func write(value: UpdateDeviceDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

public struct UpdateDeviceDefinitionInput {
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        deviceDefinitionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
        self.name = name
    }
}

extension UpdateDeviceDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateDeviceDefinitionOutput {
        return UpdateDeviceDefinitionOutput()
    }
}

public struct UpdateDeviceDefinitionOutput {

    public init() { }
}

enum UpdateDeviceDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateFunctionDefinitionInput {

    static func urlPathProvider(_ value: UpdateFunctionDefinitionInput) -> Swift.String? {
        guard let functionDefinitionId = value.functionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())"
    }
}

extension UpdateFunctionDefinitionInput {

    static func write(value: UpdateFunctionDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

public struct UpdateFunctionDefinitionInput {
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        functionDefinitionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
        self.name = name
    }
}

extension UpdateFunctionDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateFunctionDefinitionOutput {
        return UpdateFunctionDefinitionOutput()
    }
}

public struct UpdateFunctionDefinitionOutput {

    public init() { }
}

enum UpdateFunctionDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateGroupCertificateConfigurationInput {

    static func urlPathProvider(_ value: UpdateGroupCertificateConfigurationInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/certificateauthorities/configuration/expiry"
    }
}

extension UpdateGroupCertificateConfigurationInput {

    static func write(value: UpdateGroupCertificateConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateExpiryInMilliseconds"].write(value.certificateExpiryInMilliseconds)
    }
}

public struct UpdateGroupCertificateConfigurationInput {
    /// The amount of time remaining before the certificate expires, in milliseconds.
    public var certificateExpiryInMilliseconds: Swift.String?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        certificateExpiryInMilliseconds: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.certificateExpiryInMilliseconds = certificateExpiryInMilliseconds
        self.groupId = groupId
    }
}

extension UpdateGroupCertificateConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateGroupCertificateConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGroupCertificateConfigurationOutput()
        value.certificateAuthorityExpiryInMilliseconds = try reader["CertificateAuthorityExpiryInMilliseconds"].readIfPresent()
        value.certificateExpiryInMilliseconds = try reader["CertificateExpiryInMilliseconds"].readIfPresent()
        value.groupId = try reader["GroupId"].readIfPresent()
        return value
    }
}

public struct UpdateGroupCertificateConfigurationOutput {
    /// The amount of time remaining before the certificate authority expires, in milliseconds.
    public var certificateAuthorityExpiryInMilliseconds: Swift.String?
    /// The amount of time remaining before the certificate expires, in milliseconds.
    public var certificateExpiryInMilliseconds: Swift.String?
    /// The ID of the group certificate configuration.
    public var groupId: Swift.String?

    public init(
        certificateAuthorityExpiryInMilliseconds: Swift.String? = nil,
        certificateExpiryInMilliseconds: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.certificateAuthorityExpiryInMilliseconds = certificateAuthorityExpiryInMilliseconds
        self.certificateExpiryInMilliseconds = certificateExpiryInMilliseconds
        self.groupId = groupId
    }
}

enum UpdateGroupCertificateConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateGroupInput {

    static func urlPathProvider(_ value: UpdateGroupInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())"
    }
}

extension UpdateGroupInput {

    static func write(value: UpdateGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

public struct UpdateGroupInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.name = name
    }
}

extension UpdateGroupOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateGroupOutput {
        return UpdateGroupOutput()
    }
}

public struct UpdateGroupOutput {

    public init() { }
}

enum UpdateGroupOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateLoggerDefinitionInput {

    static func urlPathProvider(_ value: UpdateLoggerDefinitionInput) -> Swift.String? {
        guard let loggerDefinitionId = value.loggerDefinitionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())"
    }
}

extension UpdateLoggerDefinitionInput {

    static func write(value: UpdateLoggerDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

public struct UpdateLoggerDefinitionInput {
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        loggerDefinitionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
        self.name = name
    }
}

extension UpdateLoggerDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateLoggerDefinitionOutput {
        return UpdateLoggerDefinitionOutput()
    }
}

public struct UpdateLoggerDefinitionOutput {

    public init() { }
}

enum UpdateLoggerDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateResourceDefinitionInput {

    static func urlPathProvider(_ value: UpdateResourceDefinitionInput) -> Swift.String? {
        guard let resourceDefinitionId = value.resourceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())"
    }
}

extension UpdateResourceDefinitionInput {

    static func write(value: UpdateResourceDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

public struct UpdateResourceDefinitionInput {
    /// The name of the definition.
    public var name: Swift.String?
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?

    public init(
        name: Swift.String? = nil,
        resourceDefinitionId: Swift.String? = nil
    )
    {
        self.name = name
        self.resourceDefinitionId = resourceDefinitionId
    }
}

extension UpdateResourceDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateResourceDefinitionOutput {
        return UpdateResourceDefinitionOutput()
    }
}

public struct UpdateResourceDefinitionOutput {

    public init() { }
}

enum UpdateResourceDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateSubscriptionDefinitionInput {

    static func urlPathProvider(_ value: UpdateSubscriptionDefinitionInput) -> Swift.String? {
        guard let subscriptionDefinitionId = value.subscriptionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())"
    }
}

extension UpdateSubscriptionDefinitionInput {

    static func write(value: UpdateSubscriptionDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

public struct UpdateSubscriptionDefinitionInput {
    /// The name of the definition.
    public var name: Swift.String?
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?

    public init(
        name: Swift.String? = nil,
        subscriptionDefinitionId: Swift.String? = nil
    )
    {
        self.name = name
        self.subscriptionDefinitionId = subscriptionDefinitionId
    }
}

extension UpdateSubscriptionDefinitionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateSubscriptionDefinitionOutput {
        return UpdateSubscriptionDefinitionOutput()
    }
}

public struct UpdateSubscriptionDefinitionOutput {

    public init() { }
}

enum UpdateSubscriptionDefinitionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GreengrassClientTypes {

    /// The architecture of the cores which are the targets of an update.
    public enum UpdateTargetsArchitecture: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aarch64
        case armv6l
        case armv7l
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateTargetsArchitecture] {
            return [
                .aarch64,
                .armv6l,
                .armv7l,
                .x8664,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aarch64: return "aarch64"
            case .armv6l: return "armv6l"
            case .armv7l: return "armv7l"
            case .x8664: return "x86_64"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes {

    /// The operating system of the cores which are the targets of an update.
    public enum UpdateTargetsOperatingSystem: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonLinux
        case openwrt
        case raspbian
        case ubuntu
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateTargetsOperatingSystem] {
            return [
                .amazonLinux,
                .openwrt,
                .raspbian,
                .ubuntu,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonLinux: return "amazon_linux"
            case .openwrt: return "openwrt"
            case .raspbian: return "raspbian"
            case .ubuntu: return "ubuntu"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension UpdateThingRuntimeConfigurationInput {

    static func urlPathProvider(_ value: UpdateThingRuntimeConfigurationInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/greengrass/things/\(thingName.urlPercentEncoding())/runtimeconfig"
    }
}

extension UpdateThingRuntimeConfigurationInput {

    static func write(value: UpdateThingRuntimeConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TelemetryConfiguration"].write(value.telemetryConfiguration, with: GreengrassClientTypes.TelemetryConfigurationUpdate.write(value:to:))
    }
}

public struct UpdateThingRuntimeConfigurationInput {
    /// Configuration for telemetry service.
    public var telemetryConfiguration: GreengrassClientTypes.TelemetryConfigurationUpdate?
    /// The thing name.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        telemetryConfiguration: GreengrassClientTypes.TelemetryConfigurationUpdate? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.telemetryConfiguration = telemetryConfiguration
        self.thingName = thingName
    }
}

extension UpdateThingRuntimeConfigurationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateThingRuntimeConfigurationOutput {
        return UpdateThingRuntimeConfigurationOutput()
    }
}

public struct UpdateThingRuntimeConfigurationOutput {

    public init() { }
}

enum UpdateThingRuntimeConfigurationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GreengrassClientTypes.VersionInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.VersionInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.VersionInformation()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes {
    /// Information about a version.
    public struct VersionInformation {
        /// The ARN of the version.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the version was created.
        public var creationTimestamp: Swift.String?
        /// The ID of the parent definition that the version is associated with.
        public var id: Swift.String?
        /// The ID of the version.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTimestamp: Swift.String? = nil,
            id: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.version = version
        }
    }

}
