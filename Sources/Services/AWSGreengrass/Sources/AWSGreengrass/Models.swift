//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceOutput {

    public init() { }
}

extension GreengrassClientTypes {
    /// Information about a Greengrass core's connectivity.
    public struct ConnectivityInfo {
        /// The endpoint for the Greengrass core. Can be an IP address or DNS.
        public var hostAddress: Swift.String?
        /// The ID of the connectivity information.
        public var id: Swift.String?
        /// Metadata for this endpoint.
        public var metadata: Swift.String?
        /// The port of the Greengrass core. Usually 8883.
        public var portNumber: Swift.Int?

        public init(
            hostAddress: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: Swift.String? = nil,
            portNumber: Swift.Int? = nil
        )
        {
            self.hostAddress = hostAddress
            self.id = id
            self.metadata = metadata
            self.portNumber = portNumber
        }
    }

}

extension GreengrassClientTypes {
    /// Information about a connector. Connectors run on the Greengrass core and contain built-in integration with local infrastructure, device protocols, AWS, and other cloud services.
    public struct Connector {
        /// The ARN of the connector.
        /// This member is required.
        public var connectorArn: Swift.String?
        /// A descriptive or arbitrary ID for the connector. This value must be unique within the connector definition version. Max length is 128 characters with pattern [a-zA-Z0-9:_-]+.
        /// This member is required.
        public var id: Swift.String?
        /// The parameters or configuration that the connector uses.
        public var parameters: [Swift.String: Swift.String]?

        public init(
            connectorArn: Swift.String? = nil,
            id: Swift.String? = nil,
            parameters: [Swift.String: Swift.String]? = nil
        )
        {
            self.connectorArn = connectorArn
            self.id = id
            self.parameters = parameters
        }
    }

}

extension GreengrassClientTypes {
    /// Information about a core.
    public struct Core {
        /// The ARN of the certificate associated with the core.
        /// This member is required.
        public var certificateArn: Swift.String?
        /// A descriptive or arbitrary ID for the core. This value must be unique within the core definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        /// This member is required.
        public var id: Swift.String?
        /// If true, the core's local shadow is automatically synced with the cloud.
        public var syncShadow: Swift.Bool?
        /// The ARN of the thing which is the core.
        /// This member is required.
        public var thingArn: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            id: Swift.String? = nil,
            syncShadow: Swift.Bool? = nil,
            thingArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.id = id
            self.syncShadow = syncShadow
            self.thingArn = thingArn
        }
    }

}

extension GreengrassClientTypes {
    /// Information about a definition.
    public struct DefinitionInformation {
        /// The ARN of the definition.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the definition was created.
        public var creationTimestamp: Swift.String?
        /// The ID of the definition.
        public var id: Swift.String?
        /// The time, in milliseconds since the epoch, when the definition was last updated.
        public var lastUpdatedTimestamp: Swift.String?
        /// The ID of the latest version associated with the definition.
        public var latestVersion: Swift.String?
        /// The ARN of the latest version associated with the definition.
        public var latestVersionArn: Swift.String?
        /// The name of the definition.
        public var name: Swift.String?
        /// Tag(s) attached to the resource arn.
        public var tags: [Swift.String: Swift.String]?

        public init(
            arn: Swift.String? = nil,
            creationTimestamp: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedTimestamp: Swift.String? = nil,
            latestVersion: Swift.String? = nil,
            latestVersionArn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String: Swift.String]? = nil
        )
        {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
            self.tags = tags
        }
    }

}

extension GreengrassClientTypes {
    /// Information about a device.
    public struct Device {
        /// The ARN of the certificate associated with the device.
        /// This member is required.
        public var certificateArn: Swift.String?
        /// A descriptive or arbitrary ID for the device. This value must be unique within the device definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        /// This member is required.
        public var id: Swift.String?
        /// If true, the device's local shadow will be automatically synced with the cloud.
        public var syncShadow: Swift.Bool?
        /// The thing ARN of the device.
        /// This member is required.
        public var thingArn: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            id: Swift.String? = nil,
            syncShadow: Swift.Bool? = nil,
            thingArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.id = id
            self.syncShadow = syncShadow
            self.thingArn = thingArn
        }
    }

}

extension GreengrassClientTypes {

    public enum EncodingType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case binary
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [EncodingType] {
            return [
                .binary,
                .json
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .binary: return "binary"
            case .json: return "json"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes {

    /// Specifies whether the Lambda function runs in a Greengrass container (default) or without containerization. Unless your scenario requires that you run without containerization, we recommend that you run in a Greengrass container. Omit this value to run the Lambda function with the default containerization for the group.
    public enum FunctionIsolationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case greengrasscontainer
        case nocontainer
        case sdkUnknown(Swift.String)

        public static var allCases: [FunctionIsolationMode] {
            return [
                .greengrasscontainer,
                .nocontainer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .greengrasscontainer: return "GreengrassContainer"
            case .nocontainer: return "NoContainer"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes {
    /// Specifies the user and group whose permissions are used when running the Lambda function. You can specify one or both values to override the default values. We recommend that you avoid running as root unless absolutely necessary to minimize the risk of unintended changes or malicious attacks. To run as root, you must set ''IsolationMode'' to ''NoContainer'' and update config.json in ''greengrass-root/config'' to set ''allowFunctionsToRunAsRoot'' to ''yes''.
    public struct FunctionRunAsConfig {
        /// The group ID whose permissions are used to run a Lambda function.
        public var gid: Swift.Int?
        /// The user ID whose permissions are used to run a Lambda function.
        public var uid: Swift.Int?

        public init(
            gid: Swift.Int? = nil,
            uid: Swift.Int? = nil
        )
        {
            self.gid = gid
            self.uid = uid
        }
    }

}

extension GreengrassClientTypes {
    /// Configuration information that specifies how a Lambda function runs.
    public struct FunctionExecutionConfig {
        /// Specifies whether the Lambda function runs in a Greengrass container (default) or without containerization. Unless your scenario requires that you run without containerization, we recommend that you run in a Greengrass container. Omit this value to run the Lambda function with the default containerization for the group.
        public var isolationMode: GreengrassClientTypes.FunctionIsolationMode?
        /// Specifies the user and group whose permissions are used when running the Lambda function. You can specify one or both values to override the default values. We recommend that you avoid running as root unless absolutely necessary to minimize the risk of unintended changes or malicious attacks. To run as root, you must set ''IsolationMode'' to ''NoContainer'' and update config.json in ''greengrass-root/config'' to set ''allowFunctionsToRunAsRoot'' to ''yes''.
        public var runAs: GreengrassClientTypes.FunctionRunAsConfig?

        public init(
            isolationMode: GreengrassClientTypes.FunctionIsolationMode? = nil,
            runAs: GreengrassClientTypes.FunctionRunAsConfig? = nil
        )
        {
            self.isolationMode = isolationMode
            self.runAs = runAs
        }
    }

}

extension GreengrassClientTypes {

    /// The type of permission a function has to access a resource.
    public enum Permission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ro
        case rw
        case sdkUnknown(Swift.String)

        public static var allCases: [Permission] {
            return [
                .ro,
                .rw
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ro: return "ro"
            case .rw: return "rw"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes {
    /// A policy used by the function to access a resource.
    public struct ResourceAccessPolicy {
        /// The permissions that the Lambda function has to the resource. Can be one of ''rw'' (read/write) or ''ro'' (read-only).
        public var permission: GreengrassClientTypes.Permission?
        /// The ID of the resource. (This ID is assigned to the resource when you create the resource definiton.)
        /// This member is required.
        public var resourceId: Swift.String?

        public init(
            permission: GreengrassClientTypes.Permission? = nil,
            resourceId: Swift.String? = nil
        )
        {
            self.permission = permission
            self.resourceId = resourceId
        }
    }

}

extension GreengrassClientTypes {
    /// The environment configuration of the function.
    public struct FunctionConfigurationEnvironment {
        /// If true, the Lambda function is allowed to access the host's /sys folder. Use this when the Lambda function needs to read device information from /sys. This setting applies only when you run the Lambda function in a Greengrass container.
        public var accessSysfs: Swift.Bool?
        /// Configuration related to executing the Lambda function
        public var execution: GreengrassClientTypes.FunctionExecutionConfig?
        /// A list of the resources, with their permissions, to which the Lambda function will be granted access. A Lambda function can have at most 10 resources. ResourceAccessPolicies apply only when you run the Lambda function in a Greengrass container.
        public var resourceAccessPolicies: [GreengrassClientTypes.ResourceAccessPolicy]?
        /// Environment variables for the Lambda function's configuration.
        public var variables: [Swift.String: Swift.String]?

        public init(
            accessSysfs: Swift.Bool? = nil,
            execution: GreengrassClientTypes.FunctionExecutionConfig? = nil,
            resourceAccessPolicies: [GreengrassClientTypes.ResourceAccessPolicy]? = nil,
            variables: [Swift.String: Swift.String]? = nil
        )
        {
            self.accessSysfs = accessSysfs
            self.execution = execution
            self.resourceAccessPolicies = resourceAccessPolicies
            self.variables = variables
        }
    }

}

extension GreengrassClientTypes {
    /// The configuration of the Lambda function.
    public struct FunctionConfiguration {
        /// The expected encoding type of the input payload for the function. The default is ''json''.
        public var encodingType: GreengrassClientTypes.EncodingType?
        /// The environment configuration of the function.
        public var environment: GreengrassClientTypes.FunctionConfigurationEnvironment?
        /// The execution arguments.
        public var execArgs: Swift.String?
        /// The name of the function executable.
        public var executable: Swift.String?
        /// The Lambda runtime supported by Greengrass which is to be used instead of the one specified in the Lambda function.
        public var functionRuntimeOverride: Swift.String?
        /// The memory size, in KB, which the function requires. This setting is not applicable and should be cleared when you run the Lambda function without containerization.
        public var memorySize: Swift.Int?
        /// True if the function is pinned. Pinned means the function is long-lived and starts when the core starts.
        public var pinned: Swift.Bool?
        /// The allowed function execution time, after which Lambda should terminate the function. This timeout still applies to pinned Lambda functions for each request.
        public var timeout: Swift.Int?

        public init(
            encodingType: GreengrassClientTypes.EncodingType? = nil,
            environment: GreengrassClientTypes.FunctionConfigurationEnvironment? = nil,
            execArgs: Swift.String? = nil,
            executable: Swift.String? = nil,
            functionRuntimeOverride: Swift.String? = nil,
            memorySize: Swift.Int? = nil,
            pinned: Swift.Bool? = nil,
            timeout: Swift.Int? = nil
        )
        {
            self.encodingType = encodingType
            self.environment = environment
            self.execArgs = execArgs
            self.executable = executable
            self.functionRuntimeOverride = functionRuntimeOverride
            self.memorySize = memorySize
            self.pinned = pinned
            self.timeout = timeout
        }
    }

}

extension GreengrassClientTypes {
    /// Information about a Lambda function.
    public struct Function {
        /// The ARN of the Lambda function.
        public var functionArn: Swift.String?
        /// The configuration of the Lambda function.
        public var functionConfiguration: GreengrassClientTypes.FunctionConfiguration?
        /// A descriptive or arbitrary ID for the function. This value must be unique within the function definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        /// This member is required.
        public var id: Swift.String?

        public init(
            functionArn: Swift.String? = nil,
            functionConfiguration: GreengrassClientTypes.FunctionConfiguration? = nil,
            id: Swift.String? = nil
        )
        {
            self.functionArn = functionArn
            self.functionConfiguration = functionConfiguration
            self.id = id
        }
    }

}

extension GreengrassClientTypes {
    /// Information about a certificate authority for a group.
    public struct GroupCertificateAuthorityProperties {
        /// The ARN of the certificate authority for the group.
        public var groupCertificateAuthorityArn: Swift.String?
        /// The ID of the certificate authority for the group.
        public var groupCertificateAuthorityId: Swift.String?

        public init(
            groupCertificateAuthorityArn: Swift.String? = nil,
            groupCertificateAuthorityId: Swift.String? = nil
        )
        {
            self.groupCertificateAuthorityArn = groupCertificateAuthorityArn
            self.groupCertificateAuthorityId = groupCertificateAuthorityId
        }
    }

}

extension GreengrassClientTypes {
    /// Information about a group.
    public struct GroupInformation {
        /// The ARN of the group.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the group was created.
        public var creationTimestamp: Swift.String?
        /// The ID of the group.
        public var id: Swift.String?
        /// The time, in milliseconds since the epoch, when the group was last updated.
        public var lastUpdatedTimestamp: Swift.String?
        /// The ID of the latest version associated with the group.
        public var latestVersion: Swift.String?
        /// The ARN of the latest version associated with the group.
        public var latestVersionArn: Swift.String?
        /// The name of the group.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTimestamp: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedTimestamp: Swift.String? = nil,
            latestVersion: Swift.String? = nil,
            latestVersionArn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.latestVersion = latestVersion
            self.latestVersionArn = latestVersionArn
            self.name = name
        }
    }

}

extension GreengrassClientTypes {

    public enum LoggerComponent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case greengrasssystem
        case lambda
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggerComponent] {
            return [
                .greengrasssystem,
                .lambda
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .greengrasssystem: return "GreengrassSystem"
            case .lambda: return "Lambda"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes {

    public enum LoggerLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case debug
        case error
        case fatal
        case info
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggerLevel] {
            return [
                .debug,
                .error,
                .fatal,
                .info,
                .warn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .error: return "ERROR"
            case .fatal: return "FATAL"
            case .info: return "INFO"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes {

    public enum LoggerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awscloudwatch
        case filesystem
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggerType] {
            return [
                .awscloudwatch,
                .filesystem
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awscloudwatch: return "AWSCloudWatch"
            case .filesystem: return "FileSystem"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes {
    /// Information about a logger
    public struct Logger {
        /// The component that will be subject to logging.
        /// This member is required.
        public var component: GreengrassClientTypes.LoggerComponent?
        /// A descriptive or arbitrary ID for the logger. This value must be unique within the logger definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        /// This member is required.
        public var id: Swift.String?
        /// The level of the logs.
        /// This member is required.
        public var level: GreengrassClientTypes.LoggerLevel?
        /// The amount of file space, in KB, to use if the local file system is used for logging purposes.
        public var space: Swift.Int?
        /// The type of log output which will be used.
        /// This member is required.
        public var type: GreengrassClientTypes.LoggerType?

        public init(
            component: GreengrassClientTypes.LoggerComponent? = nil,
            id: Swift.String? = nil,
            level: GreengrassClientTypes.LoggerLevel? = nil,
            space: Swift.Int? = nil,
            type: GreengrassClientTypes.LoggerType? = nil
        )
        {
            self.component = component
            self.id = id
            self.level = level
            self.space = space
            self.type = type
        }
    }

}

extension GreengrassClientTypes {
    /// Group owner related settings for local resources.
    public struct GroupOwnerSetting {
        /// If true, AWS IoT Greengrass automatically adds the specified Linux OS group owner of the resource to the Lambda process privileges. Thus the Lambda process will have the file access permissions of the added Linux group.
        public var autoAddGroupOwner: Swift.Bool?
        /// The name of the Linux OS group whose privileges will be added to the Lambda process. This field is optional.
        public var groupOwner: Swift.String?

        public init(
            autoAddGroupOwner: Swift.Bool? = nil,
            groupOwner: Swift.String? = nil
        )
        {
            self.autoAddGroupOwner = autoAddGroupOwner
            self.groupOwner = groupOwner
        }
    }

}

extension GreengrassClientTypes {
    /// Attributes that define a local device resource.
    public struct LocalDeviceResourceData {
        /// Group/owner related settings for local resources.
        public var groupOwnerSetting: GreengrassClientTypes.GroupOwnerSetting?
        /// The local absolute path of the device resource. The source path for a device resource can refer only to a character device or block device under ''/dev''.
        public var sourcePath: Swift.String?

        public init(
            groupOwnerSetting: GreengrassClientTypes.GroupOwnerSetting? = nil,
            sourcePath: Swift.String? = nil
        )
        {
            self.groupOwnerSetting = groupOwnerSetting
            self.sourcePath = sourcePath
        }
    }

}

extension GreengrassClientTypes {
    /// Attributes that define a local volume resource.
    public struct LocalVolumeResourceData {
        /// The absolute local path of the resource inside the Lambda environment.
        public var destinationPath: Swift.String?
        /// Allows you to configure additional group privileges for the Lambda process. This field is optional.
        public var groupOwnerSetting: GreengrassClientTypes.GroupOwnerSetting?
        /// The local absolute path of the volume resource on the host. The source path for a volume resource type cannot start with ''/sys''.
        public var sourcePath: Swift.String?

        public init(
            destinationPath: Swift.String? = nil,
            groupOwnerSetting: GreengrassClientTypes.GroupOwnerSetting? = nil,
            sourcePath: Swift.String? = nil
        )
        {
            self.destinationPath = destinationPath
            self.groupOwnerSetting = groupOwnerSetting
            self.sourcePath = sourcePath
        }
    }

}

extension GreengrassClientTypes {
    /// The owner setting for downloaded machine learning resources.
    public struct ResourceDownloadOwnerSetting {
        /// The group owner of the resource. This is the name of an existing Linux OS group on the system or a GID. The group's permissions are added to the Lambda process.
        /// This member is required.
        public var groupOwner: Swift.String?
        /// The permissions that the group owner has to the resource. Valid values are ''rw'' (read/write) or ''ro'' (read-only).
        /// This member is required.
        public var groupPermission: GreengrassClientTypes.Permission?

        public init(
            groupOwner: Swift.String? = nil,
            groupPermission: GreengrassClientTypes.Permission? = nil
        )
        {
            self.groupOwner = groupOwner
            self.groupPermission = groupPermission
        }
    }

}

extension GreengrassClientTypes {
    /// Attributes that define an Amazon S3 machine learning resource.
    public struct S3MachineLearningModelResourceData {
        /// The absolute local path of the resource inside the Lambda environment.
        public var destinationPath: Swift.String?
        /// The owner setting for downloaded machine learning resources.
        public var ownerSetting: GreengrassClientTypes.ResourceDownloadOwnerSetting?
        /// The URI of the source model in an S3 bucket. The model package must be in tar.gz or .zip format.
        public var s3Uri: Swift.String?

        public init(
            destinationPath: Swift.String? = nil,
            ownerSetting: GreengrassClientTypes.ResourceDownloadOwnerSetting? = nil,
            s3Uri: Swift.String? = nil
        )
        {
            self.destinationPath = destinationPath
            self.ownerSetting = ownerSetting
            self.s3Uri = s3Uri
        }
    }

}

extension GreengrassClientTypes {
    /// Attributes that define an Amazon SageMaker machine learning resource.
    public struct SageMakerMachineLearningModelResourceData {
        /// The absolute local path of the resource inside the Lambda environment.
        public var destinationPath: Swift.String?
        /// The owner setting for downloaded machine learning resources.
        public var ownerSetting: GreengrassClientTypes.ResourceDownloadOwnerSetting?
        /// The ARN of the Amazon SageMaker training job that represents the source model.
        public var sageMakerJobArn: Swift.String?

        public init(
            destinationPath: Swift.String? = nil,
            ownerSetting: GreengrassClientTypes.ResourceDownloadOwnerSetting? = nil,
            sageMakerJobArn: Swift.String? = nil
        )
        {
            self.destinationPath = destinationPath
            self.ownerSetting = ownerSetting
            self.sageMakerJobArn = sageMakerJobArn
        }
    }

}

extension GreengrassClientTypes {
    /// Attributes that define a secret resource, which references a secret from AWS Secrets Manager. AWS IoT Greengrass stores a local, encrypted copy of the secret on the Greengrass core, where it can be securely accessed by connectors and Lambda functions.
    public struct SecretsManagerSecretResourceData {
        /// Optional. The staging labels whose values you want to make available on the core, in addition to ''AWSCURRENT''.
        public var additionalStagingLabelsToDownload: [Swift.String]?
        /// The ARN of the Secrets Manager secret to make available on the core. The value of the secret's latest version (represented by the ''AWSCURRENT'' staging label) is included by default.
        public var arn: Swift.String?

        public init(
            additionalStagingLabelsToDownload: [Swift.String]? = nil,
            arn: Swift.String? = nil
        )
        {
            self.additionalStagingLabelsToDownload = additionalStagingLabelsToDownload
            self.arn = arn
        }
    }

}

extension GreengrassClientTypes {
    /// A container for resource data. The container takes only one of the following supported resource data types: ''LocalDeviceResourceData'', ''LocalVolumeResourceData'', ''SageMakerMachineLearningModelResourceData'', ''S3MachineLearningModelResourceData'', ''SecretsManagerSecretResourceData''.
    public struct ResourceDataContainer {
        /// Attributes that define the local device resource.
        public var localDeviceResourceData: GreengrassClientTypes.LocalDeviceResourceData?
        /// Attributes that define the local volume resource.
        public var localVolumeResourceData: GreengrassClientTypes.LocalVolumeResourceData?
        /// Attributes that define an Amazon S3 machine learning resource.
        public var s3MachineLearningModelResourceData: GreengrassClientTypes.S3MachineLearningModelResourceData?
        /// Attributes that define an Amazon SageMaker machine learning resource.
        public var sageMakerMachineLearningModelResourceData: GreengrassClientTypes.SageMakerMachineLearningModelResourceData?
        /// Attributes that define a secret resource, which references a secret from AWS Secrets Manager.
        public var secretsManagerSecretResourceData: GreengrassClientTypes.SecretsManagerSecretResourceData?

        public init(
            localDeviceResourceData: GreengrassClientTypes.LocalDeviceResourceData? = nil,
            localVolumeResourceData: GreengrassClientTypes.LocalVolumeResourceData? = nil,
            s3MachineLearningModelResourceData: GreengrassClientTypes.S3MachineLearningModelResourceData? = nil,
            sageMakerMachineLearningModelResourceData: GreengrassClientTypes.SageMakerMachineLearningModelResourceData? = nil,
            secretsManagerSecretResourceData: GreengrassClientTypes.SecretsManagerSecretResourceData? = nil
        )
        {
            self.localDeviceResourceData = localDeviceResourceData
            self.localVolumeResourceData = localVolumeResourceData
            self.s3MachineLearningModelResourceData = s3MachineLearningModelResourceData
            self.sageMakerMachineLearningModelResourceData = sageMakerMachineLearningModelResourceData
            self.secretsManagerSecretResourceData = secretsManagerSecretResourceData
        }
    }

}

extension GreengrassClientTypes {
    /// Information about a resource.
    public struct Resource {
        /// The resource ID, used to refer to a resource in the Lambda function configuration. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''. This must be unique within a Greengrass group.
        /// This member is required.
        public var id: Swift.String?
        /// The descriptive resource name, which is displayed on the AWS IoT Greengrass console. Max length 128 characters with pattern ''[a-zA-Z0-9:_-]+''. This must be unique within a Greengrass group.
        /// This member is required.
        public var name: Swift.String?
        /// A container of data for all resource types.
        /// This member is required.
        public var resourceDataContainer: GreengrassClientTypes.ResourceDataContainer?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            resourceDataContainer: GreengrassClientTypes.ResourceDataContainer? = nil
        )
        {
            self.id = id
            self.name = name
            self.resourceDataContainer = resourceDataContainer
        }
    }

}

extension GreengrassClientTypes {
    /// Information about a subscription.
    public struct Subscription {
        /// A descriptive or arbitrary ID for the subscription. This value must be unique within the subscription definition version. Max length is 128 characters with pattern ''[a-zA-Z0-9:_-]+''.
        /// This member is required.
        public var id: Swift.String?
        /// The source of the subscription. Can be a thing ARN, a Lambda function ARN, a connector ARN, 'cloud' (which represents the AWS IoT cloud), or 'GGShadowService'.
        /// This member is required.
        public var source: Swift.String?
        /// The MQTT topic used to route the message.
        /// This member is required.
        public var subject: Swift.String?
        /// Where the message is sent to. Can be a thing ARN, a Lambda function ARN, a connector ARN, 'cloud' (which represents the AWS IoT cloud), or 'GGShadowService'.
        /// This member is required.
        public var target: Swift.String?

        public init(
            id: Swift.String? = nil,
            source: Swift.String? = nil,
            subject: Swift.String? = nil,
            target: Swift.String? = nil
        )
        {
            self.id = id
            self.source = source
            self.subject = subject
            self.target = target
        }
    }

}

extension GreengrassClientTypes {
    /// Information about a version.
    public struct VersionInformation {
        /// The ARN of the version.
        public var arn: Swift.String?
        /// The time, in milliseconds since the epoch, when the version was created.
        public var creationTimestamp: Swift.String?
        /// The ID of the parent definition that the version is associated with.
        public var id: Swift.String?
        /// The ID of the version.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTimestamp: Swift.String? = nil,
            id: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTimestamp = creationTimestamp
            self.id = id
            self.version = version
        }
    }

}

extension GreengrassClientTypes {
    /// Details about the error.
    public struct ErrorDetail {
        /// A detailed error code.
        public var detailedErrorCode: Swift.String?
        /// A detailed error message.
        public var detailedErrorMessage: Swift.String?

        public init(
            detailedErrorCode: Swift.String? = nil,
            detailedErrorMessage: Swift.String? = nil
        )
        {
            self.detailedErrorCode = detailedErrorCode
            self.detailedErrorMessage = detailedErrorMessage
        }
    }

}

/// General error information.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Details about the error.
        public internal(set) var errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil
        /// A message containing information about the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorDetails = errorDetails
        self.properties.message = message
    }
}

/// General error information.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Details about the error.
        public internal(set) var errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil
        /// A message containing information about the error.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.errorDetails = errorDetails
        self.properties.message = message
    }
}

public struct AssociateRoleToGroupInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The ARN of the role you wish to associate with this group. The existence of the role is not validated.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.roleArn = roleArn
    }
}

public struct AssociateRoleToGroupOutput {
    /// The time, in milliseconds since the epoch, when the role ARN was associated with the group.
    public var associatedAt: Swift.String?

    public init(
        associatedAt: Swift.String? = nil
    )
    {
        self.associatedAt = associatedAt
    }
}

public struct AssociateServiceRoleToAccountInput {
    /// The ARN of the service role you wish to associate with your account.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        roleArn: Swift.String? = nil
    )
    {
        self.roleArn = roleArn
    }
}

public struct AssociateServiceRoleToAccountOutput {
    /// The time when the service role was associated with the account.
    public var associatedAt: Swift.String?

    public init(
        associatedAt: Swift.String? = nil
    )
    {
        self.associatedAt = associatedAt
    }
}

extension GreengrassClientTypes {
    /// Information about a bulk deployment. You cannot start a new bulk deployment while another one is still running or in a non-terminal state.
    public struct BulkDeployment {
        /// The ARN of the bulk deployment.
        public var bulkDeploymentArn: Swift.String?
        /// The ID of the bulk deployment.
        public var bulkDeploymentId: Swift.String?
        /// The time, in ISO format, when the deployment was created.
        public var createdAt: Swift.String?

        public init(
            bulkDeploymentArn: Swift.String? = nil,
            bulkDeploymentId: Swift.String? = nil,
            createdAt: Swift.String? = nil
        )
        {
            self.bulkDeploymentArn = bulkDeploymentArn
            self.bulkDeploymentId = bulkDeploymentId
            self.createdAt = createdAt
        }
    }

}

extension GreengrassClientTypes {
    /// Relevant metrics on input records processed during bulk deployment.
    public struct BulkDeploymentMetrics {
        /// The total number of records that returned a non-retryable error. For example, this can occur if a group record from the input file uses an invalid format or specifies a nonexistent group version, or if the execution role doesn't grant permission to deploy a group or group version.
        public var invalidInputRecords: Swift.Int?
        /// The total number of group records from the input file that have been processed so far, or attempted.
        public var recordsProcessed: Swift.Int?
        /// The total number of deployment attempts that returned a retryable error. For example, a retry is triggered if the attempt to deploy a group returns a throttling error. ''StartBulkDeployment'' retries a group deployment up to five times.
        public var retryAttempts: Swift.Int?

        public init(
            invalidInputRecords: Swift.Int? = nil,
            recordsProcessed: Swift.Int? = nil,
            retryAttempts: Swift.Int? = nil
        )
        {
            self.invalidInputRecords = invalidInputRecords
            self.recordsProcessed = recordsProcessed
            self.retryAttempts = retryAttempts
        }
    }

}

extension GreengrassClientTypes {

    /// The type of deployment. When used for ''CreateDeployment'', only ''NewDeployment'' and ''Redeployment'' are valid.
    public enum DeploymentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case forceresetdeployment
        case newdeployment
        case redeployment
        case resetdeployment
        case sdkUnknown(Swift.String)

        public static var allCases: [DeploymentType] {
            return [
                .forceresetdeployment,
                .newdeployment,
                .redeployment,
                .resetdeployment
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .forceresetdeployment: return "ForceResetDeployment"
            case .newdeployment: return "NewDeployment"
            case .redeployment: return "Redeployment"
            case .resetdeployment: return "ResetDeployment"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes {
    /// Information about an individual group deployment in a bulk deployment operation.
    public struct BulkDeploymentResult {
        /// The time, in ISO format, when the deployment was created.
        public var createdAt: Swift.String?
        /// The ARN of the group deployment.
        public var deploymentArn: Swift.String?
        /// The ID of the group deployment.
        public var deploymentId: Swift.String?
        /// The current status of the group deployment: ''InProgress'', ''Building'', ''Success'', or ''Failure''.
        public var deploymentStatus: Swift.String?
        /// The type of the deployment.
        public var deploymentType: GreengrassClientTypes.DeploymentType?
        /// Details about the error.
        public var errorDetails: [GreengrassClientTypes.ErrorDetail]?
        /// The error message for a failed deployment
        public var errorMessage: Swift.String?
        /// The ARN of the Greengrass group.
        public var groupArn: Swift.String?

        public init(
            createdAt: Swift.String? = nil,
            deploymentArn: Swift.String? = nil,
            deploymentId: Swift.String? = nil,
            deploymentStatus: Swift.String? = nil,
            deploymentType: GreengrassClientTypes.DeploymentType? = nil,
            errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil,
            errorMessage: Swift.String? = nil,
            groupArn: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.deploymentArn = deploymentArn
            self.deploymentId = deploymentId
            self.deploymentStatus = deploymentStatus
            self.deploymentType = deploymentType
            self.errorDetails = errorDetails
            self.errorMessage = errorMessage
            self.groupArn = groupArn
        }
    }

}

extension GreengrassClientTypes {

    /// The current status of the bulk deployment.
    public enum BulkDeploymentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case failed
        case initializing
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [BulkDeploymentStatus] {
            return [
                .completed,
                .failed,
                .initializing,
                .running,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "Completed"
            case .failed: return "Failed"
            case .initializing: return "Initializing"
            case .running: return "Running"
            case .stopped: return "Stopped"
            case .stopping: return "Stopping"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes {

    public enum ConfigurationSyncStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case insync
        case outofsync
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationSyncStatus] {
            return [
                .insync,
                .outofsync
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .insync: return "InSync"
            case .outofsync: return "OutOfSync"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes {
    /// Information about the connector definition version, which is a container for connectors.
    public struct ConnectorDefinitionVersion {
        /// A list of references to connectors in this version, with their corresponding configuration settings.
        public var connectors: [GreengrassClientTypes.Connector]?

        public init(
            connectors: [GreengrassClientTypes.Connector]? = nil
        )
        {
            self.connectors = connectors
        }
    }

}

extension GreengrassClientTypes {
    /// Information about a core definition version.
    public struct CoreDefinitionVersion {
        /// A list of cores in the core definition version.
        public var cores: [GreengrassClientTypes.Core]?

        public init(
            cores: [GreengrassClientTypes.Core]? = nil
        )
        {
            self.cores = cores
        }
    }

}

public struct CreateConnectorDefinitionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the connector definition.
    public var initialVersion: GreengrassClientTypes.ConnectorDefinitionVersion?
    /// The name of the connector definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.ConnectorDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

public struct CreateConnectorDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

public struct CreateConnectorDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?
    /// A list of references to connectors in this version, with their corresponding configuration settings.
    public var connectors: [GreengrassClientTypes.Connector]?

    public init(
        amznClientToken: Swift.String? = nil,
        connectorDefinitionId: Swift.String? = nil,
        connectors: [GreengrassClientTypes.Connector]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.connectorDefinitionId = connectorDefinitionId
        self.connectors = connectors
    }
}

public struct CreateConnectorDefinitionVersionOutput {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

/// Information needed to create a core definition.
public struct CreateCoreDefinitionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the core definition.
    public var initialVersion: GreengrassClientTypes.CoreDefinitionVersion?
    /// The name of the core definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.CoreDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

public struct CreateCoreDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

public struct CreateCoreDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?
    /// A list of cores in the core definition version.
    public var cores: [GreengrassClientTypes.Core]?

    public init(
        amznClientToken: Swift.String? = nil,
        coreDefinitionId: Swift.String? = nil,
        cores: [GreengrassClientTypes.Core]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.coreDefinitionId = coreDefinitionId
        self.cores = cores
    }
}

public struct CreateCoreDefinitionVersionOutput {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

public struct CreateDeploymentInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the deployment if you wish to redeploy a previous deployment.
    public var deploymentId: Swift.String?
    /// The type of deployment. When used for ''CreateDeployment'', only ''NewDeployment'' and ''Redeployment'' are valid.
    /// This member is required.
    public var deploymentType: GreengrassClientTypes.DeploymentType?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The ID of the group version to be deployed.
    public var groupVersionId: Swift.String?

    public init(
        amznClientToken: Swift.String? = nil,
        deploymentId: Swift.String? = nil,
        deploymentType: GreengrassClientTypes.DeploymentType? = nil,
        groupId: Swift.String? = nil,
        groupVersionId: Swift.String? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.deploymentId = deploymentId
        self.deploymentType = deploymentType
        self.groupId = groupId
        self.groupVersionId = groupVersionId
    }
}

public struct CreateDeploymentOutput {
    /// The ARN of the deployment.
    public var deploymentArn: Swift.String?
    /// The ID of the deployment.
    public var deploymentId: Swift.String?

    public init(
        deploymentArn: Swift.String? = nil,
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentArn = deploymentArn
        self.deploymentId = deploymentId
    }
}

extension GreengrassClientTypes {
    /// Information about a device definition version.
    public struct DeviceDefinitionVersion {
        /// A list of devices in the definition version.
        public var devices: [GreengrassClientTypes.Device]?

        public init(
            devices: [GreengrassClientTypes.Device]? = nil
        )
        {
            self.devices = devices
        }
    }

}

public struct CreateDeviceDefinitionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the device definition.
    public var initialVersion: GreengrassClientTypes.DeviceDefinitionVersion?
    /// The name of the device definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.DeviceDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

public struct CreateDeviceDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

public struct CreateDeviceDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?
    /// A list of devices in the definition version.
    public var devices: [GreengrassClientTypes.Device]?

    public init(
        amznClientToken: Swift.String? = nil,
        deviceDefinitionId: Swift.String? = nil,
        devices: [GreengrassClientTypes.Device]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.deviceDefinitionId = deviceDefinitionId
        self.devices = devices
    }
}

public struct CreateDeviceDefinitionVersionOutput {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

extension GreengrassClientTypes {
    /// Configuration information that specifies how a Lambda function runs.
    public struct FunctionDefaultExecutionConfig {
        /// Specifies whether the Lambda function runs in a Greengrass container (default) or without containerization. Unless your scenario requires that you run without containerization, we recommend that you run in a Greengrass container. Omit this value to run the Lambda function with the default containerization for the group.
        public var isolationMode: GreengrassClientTypes.FunctionIsolationMode?
        /// Specifies the user and group whose permissions are used when running the Lambda function. You can specify one or both values to override the default values. We recommend that you avoid running as root unless absolutely necessary to minimize the risk of unintended changes or malicious attacks. To run as root, you must set ''IsolationMode'' to ''NoContainer'' and update config.json in ''greengrass-root/config'' to set ''allowFunctionsToRunAsRoot'' to ''yes''.
        public var runAs: GreengrassClientTypes.FunctionRunAsConfig?

        public init(
            isolationMode: GreengrassClientTypes.FunctionIsolationMode? = nil,
            runAs: GreengrassClientTypes.FunctionRunAsConfig? = nil
        )
        {
            self.isolationMode = isolationMode
            self.runAs = runAs
        }
    }

}

extension GreengrassClientTypes {
    /// The default configuration that applies to all Lambda functions in the group. Individual Lambda functions can override these settings.
    public struct FunctionDefaultConfig {
        /// Configuration information that specifies how a Lambda function runs.
        public var execution: GreengrassClientTypes.FunctionDefaultExecutionConfig?

        public init(
            execution: GreengrassClientTypes.FunctionDefaultExecutionConfig? = nil
        )
        {
            self.execution = execution
        }
    }

}

extension GreengrassClientTypes {
    /// Information about a function definition version.
    public struct FunctionDefinitionVersion {
        /// The default configuration that applies to all Lambda functions in this function definition version. Individual Lambda functions can override these settings.
        public var defaultConfig: GreengrassClientTypes.FunctionDefaultConfig?
        /// A list of Lambda functions in this function definition version.
        public var functions: [GreengrassClientTypes.Function]?

        public init(
            defaultConfig: GreengrassClientTypes.FunctionDefaultConfig? = nil,
            functions: [GreengrassClientTypes.Function]? = nil
        )
        {
            self.defaultConfig = defaultConfig
            self.functions = functions
        }
    }

}

public struct CreateFunctionDefinitionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the function definition.
    public var initialVersion: GreengrassClientTypes.FunctionDefinitionVersion?
    /// The name of the function definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.FunctionDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

public struct CreateFunctionDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

/// Information needed to create a function definition version.
public struct CreateFunctionDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The default configuration that applies to all Lambda functions in this function definition version. Individual Lambda functions can override these settings.
    public var defaultConfig: GreengrassClientTypes.FunctionDefaultConfig?
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?
    /// A list of Lambda functions in this function definition version.
    public var functions: [GreengrassClientTypes.Function]?

    public init(
        amznClientToken: Swift.String? = nil,
        defaultConfig: GreengrassClientTypes.FunctionDefaultConfig? = nil,
        functionDefinitionId: Swift.String? = nil,
        functions: [GreengrassClientTypes.Function]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.defaultConfig = defaultConfig
        self.functionDefinitionId = functionDefinitionId
        self.functions = functions
    }
}

public struct CreateFunctionDefinitionVersionOutput {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

extension GreengrassClientTypes {
    /// Information about a group version.
    public struct GroupVersion {
        /// The ARN of the connector definition version for this group.
        public var connectorDefinitionVersionArn: Swift.String?
        /// The ARN of the core definition version for this group.
        public var coreDefinitionVersionArn: Swift.String?
        /// The ARN of the device definition version for this group.
        public var deviceDefinitionVersionArn: Swift.String?
        /// The ARN of the function definition version for this group.
        public var functionDefinitionVersionArn: Swift.String?
        /// The ARN of the logger definition version for this group.
        public var loggerDefinitionVersionArn: Swift.String?
        /// The ARN of the resource definition version for this group.
        public var resourceDefinitionVersionArn: Swift.String?
        /// The ARN of the subscription definition version for this group.
        public var subscriptionDefinitionVersionArn: Swift.String?

        public init(
            connectorDefinitionVersionArn: Swift.String? = nil,
            coreDefinitionVersionArn: Swift.String? = nil,
            deviceDefinitionVersionArn: Swift.String? = nil,
            functionDefinitionVersionArn: Swift.String? = nil,
            loggerDefinitionVersionArn: Swift.String? = nil,
            resourceDefinitionVersionArn: Swift.String? = nil,
            subscriptionDefinitionVersionArn: Swift.String? = nil
        )
        {
            self.connectorDefinitionVersionArn = connectorDefinitionVersionArn
            self.coreDefinitionVersionArn = coreDefinitionVersionArn
            self.deviceDefinitionVersionArn = deviceDefinitionVersionArn
            self.functionDefinitionVersionArn = functionDefinitionVersionArn
            self.loggerDefinitionVersionArn = loggerDefinitionVersionArn
            self.resourceDefinitionVersionArn = resourceDefinitionVersionArn
            self.subscriptionDefinitionVersionArn = subscriptionDefinitionVersionArn
        }
    }

}

public struct CreateGroupInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the group.
    public var initialVersion: GreengrassClientTypes.GroupVersion?
    /// The name of the group.
    /// This member is required.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.GroupVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

public struct CreateGroupOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

public struct CreateGroupCertificateAuthorityInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        amznClientToken: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.groupId = groupId
    }
}

public struct CreateGroupCertificateAuthorityOutput {
    /// The ARN of the group certificate authority.
    public var groupCertificateAuthorityArn: Swift.String?

    public init(
        groupCertificateAuthorityArn: Swift.String? = nil
    )
    {
        self.groupCertificateAuthorityArn = groupCertificateAuthorityArn
    }
}

public struct CreateGroupVersionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ARN of the connector definition version for this group.
    public var connectorDefinitionVersionArn: Swift.String?
    /// The ARN of the core definition version for this group.
    public var coreDefinitionVersionArn: Swift.String?
    /// The ARN of the device definition version for this group.
    public var deviceDefinitionVersionArn: Swift.String?
    /// The ARN of the function definition version for this group.
    public var functionDefinitionVersionArn: Swift.String?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The ARN of the logger definition version for this group.
    public var loggerDefinitionVersionArn: Swift.String?
    /// The ARN of the resource definition version for this group.
    public var resourceDefinitionVersionArn: Swift.String?
    /// The ARN of the subscription definition version for this group.
    public var subscriptionDefinitionVersionArn: Swift.String?

    public init(
        amznClientToken: Swift.String? = nil,
        connectorDefinitionVersionArn: Swift.String? = nil,
        coreDefinitionVersionArn: Swift.String? = nil,
        deviceDefinitionVersionArn: Swift.String? = nil,
        functionDefinitionVersionArn: Swift.String? = nil,
        groupId: Swift.String? = nil,
        loggerDefinitionVersionArn: Swift.String? = nil,
        resourceDefinitionVersionArn: Swift.String? = nil,
        subscriptionDefinitionVersionArn: Swift.String? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.connectorDefinitionVersionArn = connectorDefinitionVersionArn
        self.coreDefinitionVersionArn = coreDefinitionVersionArn
        self.deviceDefinitionVersionArn = deviceDefinitionVersionArn
        self.functionDefinitionVersionArn = functionDefinitionVersionArn
        self.groupId = groupId
        self.loggerDefinitionVersionArn = loggerDefinitionVersionArn
        self.resourceDefinitionVersionArn = resourceDefinitionVersionArn
        self.subscriptionDefinitionVersionArn = subscriptionDefinitionVersionArn
    }
}

public struct CreateGroupVersionOutput {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

extension GreengrassClientTypes {
    /// Information about a logger definition version.
    public struct LoggerDefinitionVersion {
        /// A list of loggers.
        public var loggers: [GreengrassClientTypes.Logger]?

        public init(
            loggers: [GreengrassClientTypes.Logger]? = nil
        )
        {
            self.loggers = loggers
        }
    }

}

public struct CreateLoggerDefinitionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the logger definition.
    public var initialVersion: GreengrassClientTypes.LoggerDefinitionVersion?
    /// The name of the logger definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.LoggerDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

public struct CreateLoggerDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

public struct CreateLoggerDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?
    /// A list of loggers.
    public var loggers: [GreengrassClientTypes.Logger]?

    public init(
        amznClientToken: Swift.String? = nil,
        loggerDefinitionId: Swift.String? = nil,
        loggers: [GreengrassClientTypes.Logger]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.loggerDefinitionId = loggerDefinitionId
        self.loggers = loggers
    }
}

public struct CreateLoggerDefinitionVersionOutput {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

extension GreengrassClientTypes {
    /// Information about a resource definition version.
    public struct ResourceDefinitionVersion {
        /// A list of resources.
        public var resources: [GreengrassClientTypes.Resource]?

        public init(
            resources: [GreengrassClientTypes.Resource]? = nil
        )
        {
            self.resources = resources
        }
    }

}

public struct CreateResourceDefinitionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the resource definition.
    public var initialVersion: GreengrassClientTypes.ResourceDefinitionVersion?
    /// The name of the resource definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.ResourceDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

public struct CreateResourceDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

public struct CreateResourceDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?
    /// A list of resources.
    public var resources: [GreengrassClientTypes.Resource]?

    public init(
        amznClientToken: Swift.String? = nil,
        resourceDefinitionId: Swift.String? = nil,
        resources: [GreengrassClientTypes.Resource]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.resourceDefinitionId = resourceDefinitionId
        self.resources = resources
    }
}

public struct CreateResourceDefinitionVersionOutput {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

extension GreengrassClientTypes {

    /// The piece of software on the Greengrass core that will be updated.
    public enum SoftwareToUpdate: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case core
        case otaAgent
        case sdkUnknown(Swift.String)

        public static var allCases: [SoftwareToUpdate] {
            return [
                .core,
                .otaAgent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .core: return "core"
            case .otaAgent: return "ota_agent"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes {

    /// The minimum level of log statements that should be logged by the OTA Agent during an update.
    public enum UpdateAgentLogLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case debug
        case error
        case fatal
        case info
        case `none`
        case trace
        case verbose
        case warn
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateAgentLogLevel] {
            return [
                .debug,
                .error,
                .fatal,
                .info,
                .none,
                .trace,
                .verbose,
                .warn
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .debug: return "DEBUG"
            case .error: return "ERROR"
            case .fatal: return "FATAL"
            case .info: return "INFO"
            case .none: return "NONE"
            case .trace: return "TRACE"
            case .verbose: return "VERBOSE"
            case .warn: return "WARN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes {

    /// The architecture of the cores which are the targets of an update.
    public enum UpdateTargetsArchitecture: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aarch64
        case armv6l
        case armv7l
        case x8664
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateTargetsArchitecture] {
            return [
                .aarch64,
                .armv6l,
                .armv7l,
                .x8664
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aarch64: return "aarch64"
            case .armv6l: return "armv6l"
            case .armv7l: return "armv7l"
            case .x8664: return "x86_64"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes {

    /// The operating system of the cores which are the targets of an update.
    public enum UpdateTargetsOperatingSystem: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonLinux
        case openwrt
        case raspbian
        case ubuntu
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateTargetsOperatingSystem] {
            return [
                .amazonLinux,
                .openwrt,
                .raspbian,
                .ubuntu
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonLinux: return "amazon_linux"
            case .openwrt: return "openwrt"
            case .raspbian: return "raspbian"
            case .ubuntu: return "ubuntu"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateSoftwareUpdateJobInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The IAM Role that Greengrass will use to create pre-signed URLs pointing towards the update artifact.
    /// This member is required.
    public var s3UrlSignerRole: Swift.String?
    /// The piece of software on the Greengrass core that will be updated.
    /// This member is required.
    public var softwareToUpdate: GreengrassClientTypes.SoftwareToUpdate?
    /// The minimum level of log statements that should be logged by the OTA Agent during an update.
    public var updateAgentLogLevel: GreengrassClientTypes.UpdateAgentLogLevel?
    /// The ARNs of the targets (IoT things or IoT thing groups) that this update will be applied to.
    /// This member is required.
    public var updateTargets: [Swift.String]?
    /// The architecture of the cores which are the targets of an update.
    /// This member is required.
    public var updateTargetsArchitecture: GreengrassClientTypes.UpdateTargetsArchitecture?
    /// The operating system of the cores which are the targets of an update.
    /// This member is required.
    public var updateTargetsOperatingSystem: GreengrassClientTypes.UpdateTargetsOperatingSystem?

    public init(
        amznClientToken: Swift.String? = nil,
        s3UrlSignerRole: Swift.String? = nil,
        softwareToUpdate: GreengrassClientTypes.SoftwareToUpdate? = nil,
        updateAgentLogLevel: GreengrassClientTypes.UpdateAgentLogLevel? = nil,
        updateTargets: [Swift.String]? = nil,
        updateTargetsArchitecture: GreengrassClientTypes.UpdateTargetsArchitecture? = nil,
        updateTargetsOperatingSystem: GreengrassClientTypes.UpdateTargetsOperatingSystem? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.s3UrlSignerRole = s3UrlSignerRole
        self.softwareToUpdate = softwareToUpdate
        self.updateAgentLogLevel = updateAgentLogLevel
        self.updateTargets = updateTargets
        self.updateTargetsArchitecture = updateTargetsArchitecture
        self.updateTargetsOperatingSystem = updateTargetsOperatingSystem
    }
}

public struct CreateSoftwareUpdateJobOutput {
    /// The IoT Job ARN corresponding to this update.
    public var iotJobArn: Swift.String?
    /// The IoT Job Id corresponding to this update.
    public var iotJobId: Swift.String?
    /// The software version installed on the device or devices after the update.
    public var platformSoftwareVersion: Swift.String?

    public init(
        iotJobArn: Swift.String? = nil,
        iotJobId: Swift.String? = nil,
        platformSoftwareVersion: Swift.String? = nil
    )
    {
        self.iotJobArn = iotJobArn
        self.iotJobId = iotJobId
        self.platformSoftwareVersion = platformSoftwareVersion
    }
}

extension GreengrassClientTypes {
    /// Information about a subscription definition version.
    public struct SubscriptionDefinitionVersion {
        /// A list of subscriptions.
        public var subscriptions: [GreengrassClientTypes.Subscription]?

        public init(
            subscriptions: [GreengrassClientTypes.Subscription]? = nil
        )
        {
            self.subscriptions = subscriptions
        }
    }

}

public struct CreateSubscriptionDefinitionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// Information about the initial version of the subscription definition.
    public var initialVersion: GreengrassClientTypes.SubscriptionDefinitionVersion?
    /// The name of the subscription definition.
    public var name: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        initialVersion: GreengrassClientTypes.SubscriptionDefinitionVersion? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.initialVersion = initialVersion
        self.name = name
        self.tags = tags
    }
}

public struct CreateSubscriptionDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
    }
}

public struct CreateSubscriptionDefinitionVersionInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?
    /// A list of subscriptions.
    public var subscriptions: [GreengrassClientTypes.Subscription]?

    public init(
        amznClientToken: Swift.String? = nil,
        subscriptionDefinitionId: Swift.String? = nil,
        subscriptions: [GreengrassClientTypes.Subscription]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.subscriptionDefinitionId = subscriptionDefinitionId
        self.subscriptions = subscriptions
    }
}

public struct CreateSubscriptionDefinitionVersionOutput {
    /// The ARN of the version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the version was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the parent definition that the version is associated with.
    public var id: Swift.String?
    /// The ID of the version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.version = version
    }
}

public struct DeleteConnectorDefinitionInput {
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?

    public init(
        connectorDefinitionId: Swift.String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
    }
}

public struct DeleteConnectorDefinitionOutput {

    public init() { }
}

public struct DeleteCoreDefinitionInput {
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?

    public init(
        coreDefinitionId: Swift.String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
    }
}

public struct DeleteCoreDefinitionOutput {

    public init() { }
}

public struct DeleteDeviceDefinitionInput {
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?

    public init(
        deviceDefinitionId: Swift.String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
    }
}

public struct DeleteDeviceDefinitionOutput {

    public init() { }
}

public struct DeleteFunctionDefinitionInput {
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?

    public init(
        functionDefinitionId: Swift.String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
    }
}

public struct DeleteFunctionDefinitionOutput {

    public init() { }
}

public struct DeleteGroupInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

public struct DeleteGroupOutput {

    public init() { }
}

public struct DeleteLoggerDefinitionInput {
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?

    public init(
        loggerDefinitionId: Swift.String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
    }
}

public struct DeleteLoggerDefinitionOutput {

    public init() { }
}

public struct DeleteResourceDefinitionInput {
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?

    public init(
        resourceDefinitionId: Swift.String? = nil
    )
    {
        self.resourceDefinitionId = resourceDefinitionId
    }
}

public struct DeleteResourceDefinitionOutput {

    public init() { }
}

public struct DeleteSubscriptionDefinitionInput {
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?

    public init(
        subscriptionDefinitionId: Swift.String? = nil
    )
    {
        self.subscriptionDefinitionId = subscriptionDefinitionId
    }
}

public struct DeleteSubscriptionDefinitionOutput {

    public init() { }
}

extension GreengrassClientTypes {
    /// Information about a deployment.
    public struct Deployment {
        /// The time, in milliseconds since the epoch, when the deployment was created.
        public var createdAt: Swift.String?
        /// The ARN of the deployment.
        public var deploymentArn: Swift.String?
        /// The ID of the deployment.
        public var deploymentId: Swift.String?
        /// The type of the deployment.
        public var deploymentType: GreengrassClientTypes.DeploymentType?
        /// The ARN of the group for this deployment.
        public var groupArn: Swift.String?

        public init(
            createdAt: Swift.String? = nil,
            deploymentArn: Swift.String? = nil,
            deploymentId: Swift.String? = nil,
            deploymentType: GreengrassClientTypes.DeploymentType? = nil,
            groupArn: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.deploymentArn = deploymentArn
            self.deploymentId = deploymentId
            self.deploymentType = deploymentType
            self.groupArn = groupArn
        }
    }

}

public struct DisassociateRoleFromGroupInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

public struct DisassociateRoleFromGroupOutput {
    /// The time, in milliseconds since the epoch, when the role was disassociated from the group.
    public var disassociatedAt: Swift.String?

    public init(
        disassociatedAt: Swift.String? = nil
    )
    {
        self.disassociatedAt = disassociatedAt
    }
}

public struct DisassociateServiceRoleFromAccountInput {

    public init() { }
}

public struct DisassociateServiceRoleFromAccountOutput {
    /// The time when the service role was disassociated from the account.
    public var disassociatedAt: Swift.String?

    public init(
        disassociatedAt: Swift.String? = nil
    )
    {
        self.disassociatedAt = disassociatedAt
    }
}

public struct GetAssociatedRoleInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

public struct GetAssociatedRoleOutput {
    /// The time when the role was associated with the group.
    public var associatedAt: Swift.String?
    /// The ARN of the role that is associated with the group.
    public var roleArn: Swift.String?

    public init(
        associatedAt: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.associatedAt = associatedAt
        self.roleArn = roleArn
    }
}

public struct GetBulkDeploymentStatusInput {
    /// The ID of the bulk deployment.
    /// This member is required.
    public var bulkDeploymentId: Swift.String?

    public init(
        bulkDeploymentId: Swift.String? = nil
    )
    {
        self.bulkDeploymentId = bulkDeploymentId
    }
}

public struct GetBulkDeploymentStatusOutput {
    /// Relevant metrics on input records processed during bulk deployment.
    public var bulkDeploymentMetrics: GreengrassClientTypes.BulkDeploymentMetrics?
    /// The status of the bulk deployment.
    public var bulkDeploymentStatus: GreengrassClientTypes.BulkDeploymentStatus?
    /// The time, in ISO format, when the deployment was created.
    public var createdAt: Swift.String?
    /// Error details
    public var errorDetails: [GreengrassClientTypes.ErrorDetail]?
    /// Error message
    public var errorMessage: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String: Swift.String]?

    public init(
        bulkDeploymentMetrics: GreengrassClientTypes.BulkDeploymentMetrics? = nil,
        bulkDeploymentStatus: GreengrassClientTypes.BulkDeploymentStatus? = nil,
        createdAt: Swift.String? = nil,
        errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil,
        errorMessage: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.bulkDeploymentMetrics = bulkDeploymentMetrics
        self.bulkDeploymentStatus = bulkDeploymentStatus
        self.createdAt = createdAt
        self.errorDetails = errorDetails
        self.errorMessage = errorMessage
        self.tags = tags
    }
}

public struct GetConnectivityInfoInput {
    /// The thing name.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        thingName: Swift.String? = nil
    )
    {
        self.thingName = thingName
    }
}

public struct GetConnectivityInfoOutput {
    /// Connectivity info list.
    public var connectivityInfo: [GreengrassClientTypes.ConnectivityInfo]?
    /// A message about the connectivity info request.
    public var message: Swift.String?

    public init(
        connectivityInfo: [GreengrassClientTypes.ConnectivityInfo]? = nil,
        message: Swift.String? = nil
    )
    {
        self.connectivityInfo = connectivityInfo
        self.message = message
    }
}

public struct GetConnectorDefinitionInput {
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?

    public init(
        connectorDefinitionId: Swift.String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
    }
}

public struct GetConnectorDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

public struct GetConnectorDefinitionVersionInput {
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?
    /// The ID of the connector definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListConnectorDefinitionVersions'' requests. If the version is the last one that was associated with a connector definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var connectorDefinitionVersionId: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        connectorDefinitionId: Swift.String? = nil,
        connectorDefinitionVersionId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
        self.connectorDefinitionVersionId = connectorDefinitionVersionId
        self.nextToken = nextToken
    }
}

public struct GetConnectorDefinitionVersionOutput {
    /// The ARN of the connector definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the connector definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the connector definition version.
    public var definition: GreengrassClientTypes.ConnectorDefinitionVersion?
    /// The ID of the connector definition version.
    public var id: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The version of the connector definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.ConnectorDefinitionVersion? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

public struct GetCoreDefinitionInput {
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?

    public init(
        coreDefinitionId: Swift.String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
    }
}

public struct GetCoreDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

public struct GetCoreDefinitionVersionInput {
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?
    /// The ID of the core definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListCoreDefinitionVersions'' requests. If the version is the last one that was associated with a core definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var coreDefinitionVersionId: Swift.String?

    public init(
        coreDefinitionId: Swift.String? = nil,
        coreDefinitionVersionId: Swift.String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
        self.coreDefinitionVersionId = coreDefinitionVersionId
    }
}

public struct GetCoreDefinitionVersionOutput {
    /// The ARN of the core definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the core definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the core definition version.
    public var definition: GreengrassClientTypes.CoreDefinitionVersion?
    /// The ID of the core definition version.
    public var id: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The version of the core definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.CoreDefinitionVersion? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

public struct GetDeploymentStatusInput {
    /// The ID of the deployment.
    /// This member is required.
    public var deploymentId: Swift.String?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        deploymentId: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.deploymentId = deploymentId
        self.groupId = groupId
    }
}

public struct GetDeploymentStatusOutput {
    /// The status of the deployment: ''InProgress'', ''Building'', ''Success'', or ''Failure''.
    public var deploymentStatus: Swift.String?
    /// The type of the deployment.
    public var deploymentType: GreengrassClientTypes.DeploymentType?
    /// Error details
    public var errorDetails: [GreengrassClientTypes.ErrorDetail]?
    /// Error message
    public var errorMessage: Swift.String?
    /// The time, in milliseconds since the epoch, when the deployment status was updated.
    public var updatedAt: Swift.String?

    public init(
        deploymentStatus: Swift.String? = nil,
        deploymentType: GreengrassClientTypes.DeploymentType? = nil,
        errorDetails: [GreengrassClientTypes.ErrorDetail]? = nil,
        errorMessage: Swift.String? = nil,
        updatedAt: Swift.String? = nil
    )
    {
        self.deploymentStatus = deploymentStatus
        self.deploymentType = deploymentType
        self.errorDetails = errorDetails
        self.errorMessage = errorMessage
        self.updatedAt = updatedAt
    }
}

public struct GetDeviceDefinitionInput {
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?

    public init(
        deviceDefinitionId: Swift.String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
    }
}

public struct GetDeviceDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

public struct GetDeviceDefinitionVersionInput {
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?
    /// The ID of the device definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListDeviceDefinitionVersions'' requests. If the version is the last one that was associated with a device definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var deviceDefinitionVersionId: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        deviceDefinitionId: Swift.String? = nil,
        deviceDefinitionVersionId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
        self.deviceDefinitionVersionId = deviceDefinitionVersionId
        self.nextToken = nextToken
    }
}

public struct GetDeviceDefinitionVersionOutput {
    /// The ARN of the device definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the device definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the device definition version.
    public var definition: GreengrassClientTypes.DeviceDefinitionVersion?
    /// The ID of the device definition version.
    public var id: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The version of the device definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.DeviceDefinitionVersion? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

public struct GetFunctionDefinitionInput {
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?

    public init(
        functionDefinitionId: Swift.String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
    }
}

public struct GetFunctionDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

public struct GetFunctionDefinitionVersionInput {
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?
    /// The ID of the function definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListFunctionDefinitionVersions'' requests. If the version is the last one that was associated with a function definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var functionDefinitionVersionId: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        functionDefinitionId: Swift.String? = nil,
        functionDefinitionVersionId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
        self.functionDefinitionVersionId = functionDefinitionVersionId
        self.nextToken = nextToken
    }
}

public struct GetFunctionDefinitionVersionOutput {
    /// The ARN of the function definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the function definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information on the definition.
    public var definition: GreengrassClientTypes.FunctionDefinitionVersion?
    /// The ID of the function definition version.
    public var id: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The version of the function definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.FunctionDefinitionVersion? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

public struct GetGroupInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

public struct GetGroupOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

public struct GetGroupCertificateAuthorityInput {
    /// The ID of the certificate authority.
    /// This member is required.
    public var certificateAuthorityId: Swift.String?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        certificateAuthorityId: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.certificateAuthorityId = certificateAuthorityId
        self.groupId = groupId
    }
}

public struct GetGroupCertificateAuthorityOutput {
    /// The ARN of the certificate authority for the group.
    public var groupCertificateAuthorityArn: Swift.String?
    /// The ID of the certificate authority for the group.
    public var groupCertificateAuthorityId: Swift.String?
    /// The PEM encoded certificate for the group.
    public var pemEncodedCertificate: Swift.String?

    public init(
        groupCertificateAuthorityArn: Swift.String? = nil,
        groupCertificateAuthorityId: Swift.String? = nil,
        pemEncodedCertificate: Swift.String? = nil
    )
    {
        self.groupCertificateAuthorityArn = groupCertificateAuthorityArn
        self.groupCertificateAuthorityId = groupCertificateAuthorityId
        self.pemEncodedCertificate = pemEncodedCertificate
    }
}

public struct GetGroupCertificateConfigurationInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

public struct GetGroupCertificateConfigurationOutput {
    /// The amount of time remaining before the certificate authority expires, in milliseconds.
    public var certificateAuthorityExpiryInMilliseconds: Swift.String?
    /// The amount of time remaining before the certificate expires, in milliseconds.
    public var certificateExpiryInMilliseconds: Swift.String?
    /// The ID of the group certificate configuration.
    public var groupId: Swift.String?

    public init(
        certificateAuthorityExpiryInMilliseconds: Swift.String? = nil,
        certificateExpiryInMilliseconds: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.certificateAuthorityExpiryInMilliseconds = certificateAuthorityExpiryInMilliseconds
        self.certificateExpiryInMilliseconds = certificateExpiryInMilliseconds
        self.groupId = groupId
    }
}

public struct GetGroupVersionInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The ID of the group version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListGroupVersions'' requests. If the version is the last one that was associated with a group, the value also maps to the ''LatestVersion'' property of the corresponding ''GroupInformation'' object.
    /// This member is required.
    public var groupVersionId: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        groupVersionId: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.groupVersionId = groupVersionId
    }
}

public struct GetGroupVersionOutput {
    /// The ARN of the group version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the group version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the group version definition.
    public var definition: GreengrassClientTypes.GroupVersion?
    /// The ID of the group that the version is associated with.
    public var id: Swift.String?
    /// The ID of the group version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.GroupVersion? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.version = version
    }
}

public struct GetLoggerDefinitionInput {
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?

    public init(
        loggerDefinitionId: Swift.String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
    }
}

public struct GetLoggerDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

public struct GetLoggerDefinitionVersionInput {
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?
    /// The ID of the logger definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListLoggerDefinitionVersions'' requests. If the version is the last one that was associated with a logger definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var loggerDefinitionVersionId: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        loggerDefinitionId: Swift.String? = nil,
        loggerDefinitionVersionId: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
        self.loggerDefinitionVersionId = loggerDefinitionVersionId
        self.nextToken = nextToken
    }
}

public struct GetLoggerDefinitionVersionOutput {
    /// The ARN of the logger definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the logger definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the logger definition version.
    public var definition: GreengrassClientTypes.LoggerDefinitionVersion?
    /// The ID of the logger definition version.
    public var id: Swift.String?
    /// The version of the logger definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.LoggerDefinitionVersion? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.version = version
    }
}

public struct GetResourceDefinitionInput {
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?

    public init(
        resourceDefinitionId: Swift.String? = nil
    )
    {
        self.resourceDefinitionId = resourceDefinitionId
    }
}

public struct GetResourceDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

public struct GetResourceDefinitionVersionInput {
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?
    /// The ID of the resource definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListResourceDefinitionVersions'' requests. If the version is the last one that was associated with a resource definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var resourceDefinitionVersionId: Swift.String?

    public init(
        resourceDefinitionId: Swift.String? = nil,
        resourceDefinitionVersionId: Swift.String? = nil
    )
    {
        self.resourceDefinitionId = resourceDefinitionId
        self.resourceDefinitionVersionId = resourceDefinitionVersionId
    }
}

public struct GetResourceDefinitionVersionOutput {
    /// Arn of the resource definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the resource definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the definition.
    public var definition: GreengrassClientTypes.ResourceDefinitionVersion?
    /// The ID of the resource definition version.
    public var id: Swift.String?
    /// The version of the resource definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.ResourceDefinitionVersion? = nil,
        id: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.version = version
    }
}

public struct GetServiceRoleForAccountInput {

    public init() { }
}

public struct GetServiceRoleForAccountOutput {
    /// The time when the service role was associated with the account.
    public var associatedAt: Swift.String?
    /// The ARN of the role which is associated with the account.
    public var roleArn: Swift.String?

    public init(
        associatedAt: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.associatedAt = associatedAt
        self.roleArn = roleArn
    }
}

public struct GetSubscriptionDefinitionInput {
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?

    public init(
        subscriptionDefinitionId: Swift.String? = nil
    )
    {
        self.subscriptionDefinitionId = subscriptionDefinitionId
    }
}

public struct GetSubscriptionDefinitionOutput {
    /// The ARN of the definition.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was created.
    public var creationTimestamp: Swift.String?
    /// The ID of the definition.
    public var id: Swift.String?
    /// The time, in milliseconds since the epoch, when the definition was last updated.
    public var lastUpdatedTimestamp: Swift.String?
    /// The ID of the latest version associated with the definition.
    public var latestVersion: Swift.String?
    /// The ARN of the latest version associated with the definition.
    public var latestVersionArn: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?
    /// Tag(s) attached to the resource arn.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedTimestamp: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        latestVersionArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.id = id
        self.lastUpdatedTimestamp = lastUpdatedTimestamp
        self.latestVersion = latestVersion
        self.latestVersionArn = latestVersionArn
        self.name = name
        self.tags = tags
    }
}

public struct GetSubscriptionDefinitionVersionInput {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?
    /// The ID of the subscription definition version. This value maps to the ''Version'' property of the corresponding ''VersionInformation'' object, which is returned by ''ListSubscriptionDefinitionVersions'' requests. If the version is the last one that was associated with a subscription definition, the value also maps to the ''LatestVersion'' property of the corresponding ''DefinitionInformation'' object.
    /// This member is required.
    public var subscriptionDefinitionVersionId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        subscriptionDefinitionId: Swift.String? = nil,
        subscriptionDefinitionVersionId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.subscriptionDefinitionId = subscriptionDefinitionId
        self.subscriptionDefinitionVersionId = subscriptionDefinitionVersionId
    }
}

public struct GetSubscriptionDefinitionVersionOutput {
    /// The ARN of the subscription definition version.
    public var arn: Swift.String?
    /// The time, in milliseconds since the epoch, when the subscription definition version was created.
    public var creationTimestamp: Swift.String?
    /// Information about the subscription definition version.
    public var definition: GreengrassClientTypes.SubscriptionDefinitionVersion?
    /// The ID of the subscription definition version.
    public var id: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The version of the subscription definition version.
    public var version: Swift.String?

    public init(
        arn: Swift.String? = nil,
        creationTimestamp: Swift.String? = nil,
        definition: GreengrassClientTypes.SubscriptionDefinitionVersion? = nil,
        id: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.arn = arn
        self.creationTimestamp = creationTimestamp
        self.definition = definition
        self.id = id
        self.nextToken = nextToken
        self.version = version
    }
}

public struct GetThingRuntimeConfigurationInput {
    /// The thing name.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        thingName: Swift.String? = nil
    )
    {
        self.thingName = thingName
    }
}

extension GreengrassClientTypes {

    public enum Telemetry: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case off
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [Telemetry] {
            return [
                .off,
                .on
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .off: return "Off"
            case .on: return "On"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GreengrassClientTypes {
    /// Configuration settings for running telemetry.
    public struct TelemetryConfiguration {
        /// Synchronization status of the device reported configuration with the desired configuration.
        public var configurationSyncStatus: GreengrassClientTypes.ConfigurationSyncStatus?
        /// Configure telemetry to be on or off.
        /// This member is required.
        public var telemetry: GreengrassClientTypes.Telemetry?

        public init(
            configurationSyncStatus: GreengrassClientTypes.ConfigurationSyncStatus? = nil,
            telemetry: GreengrassClientTypes.Telemetry? = nil
        )
        {
            self.configurationSyncStatus = configurationSyncStatus
            self.telemetry = telemetry
        }
    }

}

extension GreengrassClientTypes {
    /// Runtime configuration for a thing.
    public struct RuntimeConfiguration {
        /// Configuration for telemetry service.
        public var telemetryConfiguration: GreengrassClientTypes.TelemetryConfiguration?

        public init(
            telemetryConfiguration: GreengrassClientTypes.TelemetryConfiguration? = nil
        )
        {
            self.telemetryConfiguration = telemetryConfiguration
        }
    }

}

public struct GetThingRuntimeConfigurationOutput {
    /// Runtime configuration for a thing.
    public var runtimeConfiguration: GreengrassClientTypes.RuntimeConfiguration?

    public init(
        runtimeConfiguration: GreengrassClientTypes.RuntimeConfiguration? = nil
    )
    {
        self.runtimeConfiguration = runtimeConfiguration
    }
}

public struct ListBulkDeploymentDetailedReportsInput {
    /// The ID of the bulk deployment.
    /// This member is required.
    public var bulkDeploymentId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        bulkDeploymentId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.bulkDeploymentId = bulkDeploymentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListBulkDeploymentDetailedReportsOutput {
    /// A list of the individual group deployments in the bulk deployment operation.
    public var deployments: [GreengrassClientTypes.BulkDeploymentResult]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        deployments: [GreengrassClientTypes.BulkDeploymentResult]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deployments = deployments
        self.nextToken = nextToken
    }
}

public struct ListBulkDeploymentsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListBulkDeploymentsOutput {
    /// A list of bulk deployments.
    public var bulkDeployments: [GreengrassClientTypes.BulkDeployment]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        bulkDeployments: [GreengrassClientTypes.BulkDeployment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.bulkDeployments = bulkDeployments
        self.nextToken = nextToken
    }
}

public struct ListConnectorDefinitionsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListConnectorDefinitionsOutput {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

public struct ListConnectorDefinitionVersionsInput {
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        connectorDefinitionId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListConnectorDefinitionVersionsOutput {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

public struct ListCoreDefinitionsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCoreDefinitionsOutput {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

public struct ListCoreDefinitionVersionsInput {
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        coreDefinitionId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListCoreDefinitionVersionsOutput {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

public struct ListDeploymentsInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDeploymentsOutput {
    /// A list of deployments for the requested groups.
    public var deployments: [GreengrassClientTypes.Deployment]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        deployments: [GreengrassClientTypes.Deployment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deployments = deployments
        self.nextToken = nextToken
    }
}

public struct ListDeviceDefinitionsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDeviceDefinitionsOutput {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

public struct ListDeviceDefinitionVersionsInput {
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        deviceDefinitionId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDeviceDefinitionVersionsOutput {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

public struct ListFunctionDefinitionsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFunctionDefinitionsOutput {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

public struct ListFunctionDefinitionVersionsInput {
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        functionDefinitionId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListFunctionDefinitionVersionsOutput {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

public struct ListGroupCertificateAuthoritiesInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        groupId: Swift.String? = nil
    )
    {
        self.groupId = groupId
    }
}

public struct ListGroupCertificateAuthoritiesOutput {
    /// A list of certificate authorities associated with the group.
    public var groupCertificateAuthorities: [GreengrassClientTypes.GroupCertificateAuthorityProperties]?

    public init(
        groupCertificateAuthorities: [GreengrassClientTypes.GroupCertificateAuthorityProperties]? = nil
    )
    {
        self.groupCertificateAuthorities = groupCertificateAuthorities
    }
}

public struct ListGroupsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListGroupsOutput {
    /// Information about a group.
    public var groups: [GreengrassClientTypes.GroupInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        groups: [GreengrassClientTypes.GroupInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groups = groups
        self.nextToken = nextToken
    }
}

public struct ListGroupVersionsInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListGroupVersionsOutput {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

public struct ListLoggerDefinitionsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListLoggerDefinitionsOutput {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

public struct ListLoggerDefinitionVersionsInput {
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        loggerDefinitionId: Swift.String? = nil,
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListLoggerDefinitionVersionsOutput {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

public struct ListResourceDefinitionsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListResourceDefinitionsOutput {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

public struct ListResourceDefinitionVersionsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        resourceDefinitionId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceDefinitionId = resourceDefinitionId
    }
}

public struct ListResourceDefinitionVersionsOutput {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

public struct ListSubscriptionDefinitionsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListSubscriptionDefinitionsOutput {
    /// Information about a definition.
    public var definitions: [GreengrassClientTypes.DefinitionInformation]?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        definitions: [GreengrassClientTypes.DefinitionInformation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.definitions = definitions
        self.nextToken = nextToken
    }
}

public struct ListSubscriptionDefinitionVersionsInput {
    /// The maximum number of results to be returned per request.
    public var maxResults: Swift.String?
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?

    public init(
        maxResults: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        subscriptionDefinitionId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.subscriptionDefinitionId = subscriptionDefinitionId
    }
}

public struct ListSubscriptionDefinitionVersionsOutput {
    /// The token for the next set of results, or ''null'' if there are no additional results.
    public var nextToken: Swift.String?
    /// Information about a version.
    public var versions: [GreengrassClientTypes.VersionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        versions: [GreengrassClientTypes.VersionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.versions = versions
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The key-value pair for the resource tag.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

/// Information needed to reset deployments.
public struct ResetDeploymentsInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// If true, performs a best-effort only core reset.
    public var force: Swift.Bool?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        amznClientToken: Swift.String? = nil,
        force: Swift.Bool? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.force = force
        self.groupId = groupId
    }
}

public struct ResetDeploymentsOutput {
    /// The ARN of the deployment.
    public var deploymentArn: Swift.String?
    /// The ID of the deployment.
    public var deploymentId: Swift.String?

    public init(
        deploymentArn: Swift.String? = nil,
        deploymentId: Swift.String? = nil
    )
    {
        self.deploymentArn = deploymentArn
        self.deploymentId = deploymentId
    }
}

public struct StartBulkDeploymentInput {
    /// A client token used to correlate requests and responses.
    public var amznClientToken: Swift.String?
    /// The ARN of the execution role to associate with the bulk deployment operation. This IAM role must allow the ''greengrass:CreateDeployment'' action for all group versions that are listed in the input file. This IAM role must have access to the S3 bucket containing the input file.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The URI of the input file contained in the S3 bucket. The execution role must have ''getObject'' permissions on this bucket to access the input file. The input file is a JSON-serialized, line delimited file with UTF-8 encoding that provides a list of group and version IDs and the deployment type. This file must be less than 100 MB. Currently, AWS IoT Greengrass supports only ''NewDeployment'' deployment types.
    /// This member is required.
    public var inputFileUri: Swift.String?
    /// Tag(s) to add to the new resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        amznClientToken: Swift.String? = nil,
        executionRoleArn: Swift.String? = nil,
        inputFileUri: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.amznClientToken = amznClientToken
        self.executionRoleArn = executionRoleArn
        self.inputFileUri = inputFileUri
        self.tags = tags
    }
}

public struct StartBulkDeploymentOutput {
    /// The ARN of the bulk deployment.
    public var bulkDeploymentArn: Swift.String?
    /// The ID of the bulk deployment.
    public var bulkDeploymentId: Swift.String?

    public init(
        bulkDeploymentArn: Swift.String? = nil,
        bulkDeploymentId: Swift.String? = nil
    )
    {
        self.bulkDeploymentArn = bulkDeploymentArn
        self.bulkDeploymentId = bulkDeploymentId
    }
}

public struct StopBulkDeploymentInput {
    /// The ID of the bulk deployment.
    /// This member is required.
    public var bulkDeploymentId: Swift.String?

    public init(
        bulkDeploymentId: Swift.String? = nil
    )
    {
        self.bulkDeploymentId = bulkDeploymentId
    }
}

public struct StopBulkDeploymentOutput {

    public init() { }
}

/// A map of the key-value pairs for the resource tag.
public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value pair for the resource tag.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// An array of tag keys to delete
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

/// Connectivity information.
public struct UpdateConnectivityInfoInput {
    /// A list of connectivity info.
    public var connectivityInfo: [GreengrassClientTypes.ConnectivityInfo]?
    /// The thing name.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        connectivityInfo: [GreengrassClientTypes.ConnectivityInfo]? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.connectivityInfo = connectivityInfo
        self.thingName = thingName
    }
}

public struct UpdateConnectivityInfoOutput {
    /// A message about the connectivity info update request.
    public var message: Swift.String?
    /// The new version of the connectivity info.
    public var version: Swift.String?

    public init(
        message: Swift.String? = nil,
        version: Swift.String? = nil
    )
    {
        self.message = message
        self.version = version
    }
}

public struct UpdateConnectorDefinitionInput {
    /// The ID of the connector definition.
    /// This member is required.
    public var connectorDefinitionId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        connectorDefinitionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.connectorDefinitionId = connectorDefinitionId
        self.name = name
    }
}

public struct UpdateConnectorDefinitionOutput {

    public init() { }
}

public struct UpdateCoreDefinitionInput {
    /// The ID of the core definition.
    /// This member is required.
    public var coreDefinitionId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        coreDefinitionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.coreDefinitionId = coreDefinitionId
        self.name = name
    }
}

public struct UpdateCoreDefinitionOutput {

    public init() { }
}

public struct UpdateDeviceDefinitionInput {
    /// The ID of the device definition.
    /// This member is required.
    public var deviceDefinitionId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        deviceDefinitionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.deviceDefinitionId = deviceDefinitionId
        self.name = name
    }
}

public struct UpdateDeviceDefinitionOutput {

    public init() { }
}

public struct UpdateFunctionDefinitionInput {
    /// The ID of the Lambda function definition.
    /// This member is required.
    public var functionDefinitionId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        functionDefinitionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.functionDefinitionId = functionDefinitionId
        self.name = name
    }
}

public struct UpdateFunctionDefinitionOutput {

    public init() { }
}

public struct UpdateGroupInput {
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        groupId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.groupId = groupId
        self.name = name
    }
}

public struct UpdateGroupOutput {

    public init() { }
}

public struct UpdateGroupCertificateConfigurationInput {
    /// The amount of time remaining before the certificate expires, in milliseconds.
    public var certificateExpiryInMilliseconds: Swift.String?
    /// The ID of the Greengrass group.
    /// This member is required.
    public var groupId: Swift.String?

    public init(
        certificateExpiryInMilliseconds: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.certificateExpiryInMilliseconds = certificateExpiryInMilliseconds
        self.groupId = groupId
    }
}

public struct UpdateGroupCertificateConfigurationOutput {
    /// The amount of time remaining before the certificate authority expires, in milliseconds.
    public var certificateAuthorityExpiryInMilliseconds: Swift.String?
    /// The amount of time remaining before the certificate expires, in milliseconds.
    public var certificateExpiryInMilliseconds: Swift.String?
    /// The ID of the group certificate configuration.
    public var groupId: Swift.String?

    public init(
        certificateAuthorityExpiryInMilliseconds: Swift.String? = nil,
        certificateExpiryInMilliseconds: Swift.String? = nil,
        groupId: Swift.String? = nil
    )
    {
        self.certificateAuthorityExpiryInMilliseconds = certificateAuthorityExpiryInMilliseconds
        self.certificateExpiryInMilliseconds = certificateExpiryInMilliseconds
        self.groupId = groupId
    }
}

public struct UpdateLoggerDefinitionInput {
    /// The ID of the logger definition.
    /// This member is required.
    public var loggerDefinitionId: Swift.String?
    /// The name of the definition.
    public var name: Swift.String?

    public init(
        loggerDefinitionId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.loggerDefinitionId = loggerDefinitionId
        self.name = name
    }
}

public struct UpdateLoggerDefinitionOutput {

    public init() { }
}

public struct UpdateResourceDefinitionInput {
    /// The name of the definition.
    public var name: Swift.String?
    /// The ID of the resource definition.
    /// This member is required.
    public var resourceDefinitionId: Swift.String?

    public init(
        name: Swift.String? = nil,
        resourceDefinitionId: Swift.String? = nil
    )
    {
        self.name = name
        self.resourceDefinitionId = resourceDefinitionId
    }
}

public struct UpdateResourceDefinitionOutput {

    public init() { }
}

public struct UpdateSubscriptionDefinitionInput {
    /// The name of the definition.
    public var name: Swift.String?
    /// The ID of the subscription definition.
    /// This member is required.
    public var subscriptionDefinitionId: Swift.String?

    public init(
        name: Swift.String? = nil,
        subscriptionDefinitionId: Swift.String? = nil
    )
    {
        self.name = name
        self.subscriptionDefinitionId = subscriptionDefinitionId
    }
}

public struct UpdateSubscriptionDefinitionOutput {

    public init() { }
}

extension GreengrassClientTypes {
    /// Configuration settings for running telemetry.
    public struct TelemetryConfigurationUpdate {
        /// Configure telemetry to be on or off.
        /// This member is required.
        public var telemetry: GreengrassClientTypes.Telemetry?

        public init(
            telemetry: GreengrassClientTypes.Telemetry? = nil
        )
        {
            self.telemetry = telemetry
        }
    }

}

public struct UpdateThingRuntimeConfigurationInput {
    /// Configuration for telemetry service.
    public var telemetryConfiguration: GreengrassClientTypes.TelemetryConfigurationUpdate?
    /// The thing name.
    /// This member is required.
    public var thingName: Swift.String?

    public init(
        telemetryConfiguration: GreengrassClientTypes.TelemetryConfigurationUpdate? = nil,
        thingName: Swift.String? = nil
    )
    {
        self.telemetryConfiguration = telemetryConfiguration
        self.thingName = thingName
    }
}

public struct UpdateThingRuntimeConfigurationOutput {

    public init() { }
}

extension AssociateRoleToGroupInput {

    static func urlPathProvider(_ value: AssociateRoleToGroupInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/role"
    }
}

extension AssociateServiceRoleToAccountInput {

    static func urlPathProvider(_ value: AssociateServiceRoleToAccountInput) -> Swift.String? {
        return "/greengrass/servicerole"
    }
}

extension CreateConnectorDefinitionInput {

    static func urlPathProvider(_ value: CreateConnectorDefinitionInput) -> Swift.String? {
        return "/greengrass/definition/connectors"
    }
}

extension CreateConnectorDefinitionInput {

    static func headerProvider(_ value: CreateConnectorDefinitionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateConnectorDefinitionVersionInput {

    static func urlPathProvider(_ value: CreateConnectorDefinitionVersionInput) -> Swift.String? {
        guard let connectorDefinitionId = value.connectorDefinitionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())/versions"
    }
}

extension CreateConnectorDefinitionVersionInput {

    static func headerProvider(_ value: CreateConnectorDefinitionVersionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateCoreDefinitionInput {

    static func urlPathProvider(_ value: CreateCoreDefinitionInput) -> Swift.String? {
        return "/greengrass/definition/cores"
    }
}

extension CreateCoreDefinitionInput {

    static func headerProvider(_ value: CreateCoreDefinitionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateCoreDefinitionVersionInput {

    static func urlPathProvider(_ value: CreateCoreDefinitionVersionInput) -> Swift.String? {
        guard let coreDefinitionId = value.coreDefinitionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())/versions"
    }
}

extension CreateCoreDefinitionVersionInput {

    static func headerProvider(_ value: CreateCoreDefinitionVersionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateDeploymentInput {

    static func urlPathProvider(_ value: CreateDeploymentInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/deployments"
    }
}

extension CreateDeploymentInput {

    static func headerProvider(_ value: CreateDeploymentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateDeviceDefinitionInput {

    static func urlPathProvider(_ value: CreateDeviceDefinitionInput) -> Swift.String? {
        return "/greengrass/definition/devices"
    }
}

extension CreateDeviceDefinitionInput {

    static func headerProvider(_ value: CreateDeviceDefinitionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateDeviceDefinitionVersionInput {

    static func urlPathProvider(_ value: CreateDeviceDefinitionVersionInput) -> Swift.String? {
        guard let deviceDefinitionId = value.deviceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())/versions"
    }
}

extension CreateDeviceDefinitionVersionInput {

    static func headerProvider(_ value: CreateDeviceDefinitionVersionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateFunctionDefinitionInput {

    static func urlPathProvider(_ value: CreateFunctionDefinitionInput) -> Swift.String? {
        return "/greengrass/definition/functions"
    }
}

extension CreateFunctionDefinitionInput {

    static func headerProvider(_ value: CreateFunctionDefinitionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateFunctionDefinitionVersionInput {

    static func urlPathProvider(_ value: CreateFunctionDefinitionVersionInput) -> Swift.String? {
        guard let functionDefinitionId = value.functionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())/versions"
    }
}

extension CreateFunctionDefinitionVersionInput {

    static func headerProvider(_ value: CreateFunctionDefinitionVersionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateGroupInput {

    static func urlPathProvider(_ value: CreateGroupInput) -> Swift.String? {
        return "/greengrass/groups"
    }
}

extension CreateGroupInput {

    static func headerProvider(_ value: CreateGroupInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateGroupCertificateAuthorityInput {

    static func urlPathProvider(_ value: CreateGroupCertificateAuthorityInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/certificateauthorities"
    }
}

extension CreateGroupCertificateAuthorityInput {

    static func headerProvider(_ value: CreateGroupCertificateAuthorityInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateGroupVersionInput {

    static func urlPathProvider(_ value: CreateGroupVersionInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/versions"
    }
}

extension CreateGroupVersionInput {

    static func headerProvider(_ value: CreateGroupVersionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateLoggerDefinitionInput {

    static func urlPathProvider(_ value: CreateLoggerDefinitionInput) -> Swift.String? {
        return "/greengrass/definition/loggers"
    }
}

extension CreateLoggerDefinitionInput {

    static func headerProvider(_ value: CreateLoggerDefinitionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateLoggerDefinitionVersionInput {

    static func urlPathProvider(_ value: CreateLoggerDefinitionVersionInput) -> Swift.String? {
        guard let loggerDefinitionId = value.loggerDefinitionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())/versions"
    }
}

extension CreateLoggerDefinitionVersionInput {

    static func headerProvider(_ value: CreateLoggerDefinitionVersionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateResourceDefinitionInput {

    static func urlPathProvider(_ value: CreateResourceDefinitionInput) -> Swift.String? {
        return "/greengrass/definition/resources"
    }
}

extension CreateResourceDefinitionInput {

    static func headerProvider(_ value: CreateResourceDefinitionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateResourceDefinitionVersionInput {

    static func urlPathProvider(_ value: CreateResourceDefinitionVersionInput) -> Swift.String? {
        guard let resourceDefinitionId = value.resourceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())/versions"
    }
}

extension CreateResourceDefinitionVersionInput {

    static func headerProvider(_ value: CreateResourceDefinitionVersionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateSoftwareUpdateJobInput {

    static func urlPathProvider(_ value: CreateSoftwareUpdateJobInput) -> Swift.String? {
        return "/greengrass/updates"
    }
}

extension CreateSoftwareUpdateJobInput {

    static func headerProvider(_ value: CreateSoftwareUpdateJobInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateSubscriptionDefinitionInput {

    static func urlPathProvider(_ value: CreateSubscriptionDefinitionInput) -> Swift.String? {
        return "/greengrass/definition/subscriptions"
    }
}

extension CreateSubscriptionDefinitionInput {

    static func headerProvider(_ value: CreateSubscriptionDefinitionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension CreateSubscriptionDefinitionVersionInput {

    static func urlPathProvider(_ value: CreateSubscriptionDefinitionVersionInput) -> Swift.String? {
        guard let subscriptionDefinitionId = value.subscriptionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())/versions"
    }
}

extension CreateSubscriptionDefinitionVersionInput {

    static func headerProvider(_ value: CreateSubscriptionDefinitionVersionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension DeleteConnectorDefinitionInput {

    static func urlPathProvider(_ value: DeleteConnectorDefinitionInput) -> Swift.String? {
        guard let connectorDefinitionId = value.connectorDefinitionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())"
    }
}

extension DeleteCoreDefinitionInput {

    static func urlPathProvider(_ value: DeleteCoreDefinitionInput) -> Swift.String? {
        guard let coreDefinitionId = value.coreDefinitionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())"
    }
}

extension DeleteDeviceDefinitionInput {

    static func urlPathProvider(_ value: DeleteDeviceDefinitionInput) -> Swift.String? {
        guard let deviceDefinitionId = value.deviceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())"
    }
}

extension DeleteFunctionDefinitionInput {

    static func urlPathProvider(_ value: DeleteFunctionDefinitionInput) -> Swift.String? {
        guard let functionDefinitionId = value.functionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())"
    }
}

extension DeleteGroupInput {

    static func urlPathProvider(_ value: DeleteGroupInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())"
    }
}

extension DeleteLoggerDefinitionInput {

    static func urlPathProvider(_ value: DeleteLoggerDefinitionInput) -> Swift.String? {
        guard let loggerDefinitionId = value.loggerDefinitionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())"
    }
}

extension DeleteResourceDefinitionInput {

    static func urlPathProvider(_ value: DeleteResourceDefinitionInput) -> Swift.String? {
        guard let resourceDefinitionId = value.resourceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())"
    }
}

extension DeleteSubscriptionDefinitionInput {

    static func urlPathProvider(_ value: DeleteSubscriptionDefinitionInput) -> Swift.String? {
        guard let subscriptionDefinitionId = value.subscriptionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())"
    }
}

extension DisassociateRoleFromGroupInput {

    static func urlPathProvider(_ value: DisassociateRoleFromGroupInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/role"
    }
}

extension DisassociateServiceRoleFromAccountInput {

    static func urlPathProvider(_ value: DisassociateServiceRoleFromAccountInput) -> Swift.String? {
        return "/greengrass/servicerole"
    }
}

extension GetAssociatedRoleInput {

    static func urlPathProvider(_ value: GetAssociatedRoleInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/role"
    }
}

extension GetBulkDeploymentStatusInput {

    static func urlPathProvider(_ value: GetBulkDeploymentStatusInput) -> Swift.String? {
        guard let bulkDeploymentId = value.bulkDeploymentId else {
            return nil
        }
        return "/greengrass/bulk/deployments/\(bulkDeploymentId.urlPercentEncoding())/status"
    }
}

extension GetConnectivityInfoInput {

    static func urlPathProvider(_ value: GetConnectivityInfoInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/greengrass/things/\(thingName.urlPercentEncoding())/connectivityInfo"
    }
}

extension GetConnectorDefinitionInput {

    static func urlPathProvider(_ value: GetConnectorDefinitionInput) -> Swift.String? {
        guard let connectorDefinitionId = value.connectorDefinitionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())"
    }
}

extension GetConnectorDefinitionVersionInput {

    static func urlPathProvider(_ value: GetConnectorDefinitionVersionInput) -> Swift.String? {
        guard let connectorDefinitionId = value.connectorDefinitionId else {
            return nil
        }
        guard let connectorDefinitionVersionId = value.connectorDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())/versions/\(connectorDefinitionVersionId.urlPercentEncoding())"
    }
}

extension GetConnectorDefinitionVersionInput {

    static func queryItemProvider(_ value: GetConnectorDefinitionVersionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension GetCoreDefinitionInput {

    static func urlPathProvider(_ value: GetCoreDefinitionInput) -> Swift.String? {
        guard let coreDefinitionId = value.coreDefinitionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())"
    }
}

extension GetCoreDefinitionVersionInput {

    static func urlPathProvider(_ value: GetCoreDefinitionVersionInput) -> Swift.String? {
        guard let coreDefinitionId = value.coreDefinitionId else {
            return nil
        }
        guard let coreDefinitionVersionId = value.coreDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())/versions/\(coreDefinitionVersionId.urlPercentEncoding())"
    }
}

extension GetDeploymentStatusInput {

    static func urlPathProvider(_ value: GetDeploymentStatusInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        guard let deploymentId = value.deploymentId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/deployments/\(deploymentId.urlPercentEncoding())/status"
    }
}

extension GetDeviceDefinitionInput {

    static func urlPathProvider(_ value: GetDeviceDefinitionInput) -> Swift.String? {
        guard let deviceDefinitionId = value.deviceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())"
    }
}

extension GetDeviceDefinitionVersionInput {

    static func urlPathProvider(_ value: GetDeviceDefinitionVersionInput) -> Swift.String? {
        guard let deviceDefinitionId = value.deviceDefinitionId else {
            return nil
        }
        guard let deviceDefinitionVersionId = value.deviceDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())/versions/\(deviceDefinitionVersionId.urlPercentEncoding())"
    }
}

extension GetDeviceDefinitionVersionInput {

    static func queryItemProvider(_ value: GetDeviceDefinitionVersionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension GetFunctionDefinitionInput {

    static func urlPathProvider(_ value: GetFunctionDefinitionInput) -> Swift.String? {
        guard let functionDefinitionId = value.functionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())"
    }
}

extension GetFunctionDefinitionVersionInput {

    static func urlPathProvider(_ value: GetFunctionDefinitionVersionInput) -> Swift.String? {
        guard let functionDefinitionId = value.functionDefinitionId else {
            return nil
        }
        guard let functionDefinitionVersionId = value.functionDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())/versions/\(functionDefinitionVersionId.urlPercentEncoding())"
    }
}

extension GetFunctionDefinitionVersionInput {

    static func queryItemProvider(_ value: GetFunctionDefinitionVersionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension GetGroupInput {

    static func urlPathProvider(_ value: GetGroupInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())"
    }
}

extension GetGroupCertificateAuthorityInput {

    static func urlPathProvider(_ value: GetGroupCertificateAuthorityInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        guard let certificateAuthorityId = value.certificateAuthorityId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/certificateauthorities/\(certificateAuthorityId.urlPercentEncoding())"
    }
}

extension GetGroupCertificateConfigurationInput {

    static func urlPathProvider(_ value: GetGroupCertificateConfigurationInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/certificateauthorities/configuration/expiry"
    }
}

extension GetGroupVersionInput {

    static func urlPathProvider(_ value: GetGroupVersionInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        guard let groupVersionId = value.groupVersionId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/versions/\(groupVersionId.urlPercentEncoding())"
    }
}

extension GetLoggerDefinitionInput {

    static func urlPathProvider(_ value: GetLoggerDefinitionInput) -> Swift.String? {
        guard let loggerDefinitionId = value.loggerDefinitionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())"
    }
}

extension GetLoggerDefinitionVersionInput {

    static func urlPathProvider(_ value: GetLoggerDefinitionVersionInput) -> Swift.String? {
        guard let loggerDefinitionId = value.loggerDefinitionId else {
            return nil
        }
        guard let loggerDefinitionVersionId = value.loggerDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())/versions/\(loggerDefinitionVersionId.urlPercentEncoding())"
    }
}

extension GetLoggerDefinitionVersionInput {

    static func queryItemProvider(_ value: GetLoggerDefinitionVersionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension GetResourceDefinitionInput {

    static func urlPathProvider(_ value: GetResourceDefinitionInput) -> Swift.String? {
        guard let resourceDefinitionId = value.resourceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())"
    }
}

extension GetResourceDefinitionVersionInput {

    static func urlPathProvider(_ value: GetResourceDefinitionVersionInput) -> Swift.String? {
        guard let resourceDefinitionId = value.resourceDefinitionId else {
            return nil
        }
        guard let resourceDefinitionVersionId = value.resourceDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())/versions/\(resourceDefinitionVersionId.urlPercentEncoding())"
    }
}

extension GetServiceRoleForAccountInput {

    static func urlPathProvider(_ value: GetServiceRoleForAccountInput) -> Swift.String? {
        return "/greengrass/servicerole"
    }
}

extension GetSubscriptionDefinitionInput {

    static func urlPathProvider(_ value: GetSubscriptionDefinitionInput) -> Swift.String? {
        guard let subscriptionDefinitionId = value.subscriptionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())"
    }
}

extension GetSubscriptionDefinitionVersionInput {

    static func urlPathProvider(_ value: GetSubscriptionDefinitionVersionInput) -> Swift.String? {
        guard let subscriptionDefinitionId = value.subscriptionDefinitionId else {
            return nil
        }
        guard let subscriptionDefinitionVersionId = value.subscriptionDefinitionVersionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())/versions/\(subscriptionDefinitionVersionId.urlPercentEncoding())"
    }
}

extension GetSubscriptionDefinitionVersionInput {

    static func queryItemProvider(_ value: GetSubscriptionDefinitionVersionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension GetThingRuntimeConfigurationInput {

    static func urlPathProvider(_ value: GetThingRuntimeConfigurationInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/greengrass/things/\(thingName.urlPercentEncoding())/runtimeconfig"
    }
}

extension ListBulkDeploymentDetailedReportsInput {

    static func urlPathProvider(_ value: ListBulkDeploymentDetailedReportsInput) -> Swift.String? {
        guard let bulkDeploymentId = value.bulkDeploymentId else {
            return nil
        }
        return "/greengrass/bulk/deployments/\(bulkDeploymentId.urlPercentEncoding())/detailed-reports"
    }
}

extension ListBulkDeploymentDetailedReportsInput {

    static func queryItemProvider(_ value: ListBulkDeploymentDetailedReportsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListBulkDeploymentsInput {

    static func urlPathProvider(_ value: ListBulkDeploymentsInput) -> Swift.String? {
        return "/greengrass/bulk/deployments"
    }
}

extension ListBulkDeploymentsInput {

    static func queryItemProvider(_ value: ListBulkDeploymentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListConnectorDefinitionsInput {

    static func urlPathProvider(_ value: ListConnectorDefinitionsInput) -> Swift.String? {
        return "/greengrass/definition/connectors"
    }
}

extension ListConnectorDefinitionsInput {

    static func queryItemProvider(_ value: ListConnectorDefinitionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListConnectorDefinitionVersionsInput {

    static func urlPathProvider(_ value: ListConnectorDefinitionVersionsInput) -> Swift.String? {
        guard let connectorDefinitionId = value.connectorDefinitionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())/versions"
    }
}

extension ListConnectorDefinitionVersionsInput {

    static func queryItemProvider(_ value: ListConnectorDefinitionVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCoreDefinitionsInput {

    static func urlPathProvider(_ value: ListCoreDefinitionsInput) -> Swift.String? {
        return "/greengrass/definition/cores"
    }
}

extension ListCoreDefinitionsInput {

    static func queryItemProvider(_ value: ListCoreDefinitionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCoreDefinitionVersionsInput {

    static func urlPathProvider(_ value: ListCoreDefinitionVersionsInput) -> Swift.String? {
        guard let coreDefinitionId = value.coreDefinitionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())/versions"
    }
}

extension ListCoreDefinitionVersionsInput {

    static func queryItemProvider(_ value: ListCoreDefinitionVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDeploymentsInput {

    static func urlPathProvider(_ value: ListDeploymentsInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/deployments"
    }
}

extension ListDeploymentsInput {

    static func queryItemProvider(_ value: ListDeploymentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDeviceDefinitionsInput {

    static func urlPathProvider(_ value: ListDeviceDefinitionsInput) -> Swift.String? {
        return "/greengrass/definition/devices"
    }
}

extension ListDeviceDefinitionsInput {

    static func queryItemProvider(_ value: ListDeviceDefinitionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDeviceDefinitionVersionsInput {

    static func urlPathProvider(_ value: ListDeviceDefinitionVersionsInput) -> Swift.String? {
        guard let deviceDefinitionId = value.deviceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())/versions"
    }
}

extension ListDeviceDefinitionVersionsInput {

    static func queryItemProvider(_ value: ListDeviceDefinitionVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFunctionDefinitionsInput {

    static func urlPathProvider(_ value: ListFunctionDefinitionsInput) -> Swift.String? {
        return "/greengrass/definition/functions"
    }
}

extension ListFunctionDefinitionsInput {

    static func queryItemProvider(_ value: ListFunctionDefinitionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListFunctionDefinitionVersionsInput {

    static func urlPathProvider(_ value: ListFunctionDefinitionVersionsInput) -> Swift.String? {
        guard let functionDefinitionId = value.functionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())/versions"
    }
}

extension ListFunctionDefinitionVersionsInput {

    static func queryItemProvider(_ value: ListFunctionDefinitionVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListGroupCertificateAuthoritiesInput {

    static func urlPathProvider(_ value: ListGroupCertificateAuthoritiesInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/certificateauthorities"
    }
}

extension ListGroupsInput {

    static func urlPathProvider(_ value: ListGroupsInput) -> Swift.String? {
        return "/greengrass/groups"
    }
}

extension ListGroupsInput {

    static func queryItemProvider(_ value: ListGroupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListGroupVersionsInput {

    static func urlPathProvider(_ value: ListGroupVersionsInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/versions"
    }
}

extension ListGroupVersionsInput {

    static func queryItemProvider(_ value: ListGroupVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListLoggerDefinitionsInput {

    static func urlPathProvider(_ value: ListLoggerDefinitionsInput) -> Swift.String? {
        return "/greengrass/definition/loggers"
    }
}

extension ListLoggerDefinitionsInput {

    static func queryItemProvider(_ value: ListLoggerDefinitionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListLoggerDefinitionVersionsInput {

    static func urlPathProvider(_ value: ListLoggerDefinitionVersionsInput) -> Swift.String? {
        guard let loggerDefinitionId = value.loggerDefinitionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())/versions"
    }
}

extension ListLoggerDefinitionVersionsInput {

    static func queryItemProvider(_ value: ListLoggerDefinitionVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListResourceDefinitionsInput {

    static func urlPathProvider(_ value: ListResourceDefinitionsInput) -> Swift.String? {
        return "/greengrass/definition/resources"
    }
}

extension ListResourceDefinitionsInput {

    static func queryItemProvider(_ value: ListResourceDefinitionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListResourceDefinitionVersionsInput {

    static func urlPathProvider(_ value: ListResourceDefinitionVersionsInput) -> Swift.String? {
        guard let resourceDefinitionId = value.resourceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())/versions"
    }
}

extension ListResourceDefinitionVersionsInput {

    static func queryItemProvider(_ value: ListResourceDefinitionVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSubscriptionDefinitionsInput {

    static func urlPathProvider(_ value: ListSubscriptionDefinitionsInput) -> Swift.String? {
        return "/greengrass/definition/subscriptions"
    }
}

extension ListSubscriptionDefinitionsInput {

    static func queryItemProvider(_ value: ListSubscriptionDefinitionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSubscriptionDefinitionVersionsInput {

    static func urlPathProvider(_ value: ListSubscriptionDefinitionVersionsInput) -> Swift.String? {
        guard let subscriptionDefinitionId = value.subscriptionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())/versions"
    }
}

extension ListSubscriptionDefinitionVersionsInput {

    static func queryItemProvider(_ value: ListSubscriptionDefinitionVersionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension ResetDeploymentsInput {

    static func urlPathProvider(_ value: ResetDeploymentsInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/deployments/$reset"
    }
}

extension ResetDeploymentsInput {

    static func headerProvider(_ value: ResetDeploymentsInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension StartBulkDeploymentInput {

    static func urlPathProvider(_ value: StartBulkDeploymentInput) -> Swift.String? {
        return "/greengrass/bulk/deployments"
    }
}

extension StartBulkDeploymentInput {

    static func headerProvider(_ value: StartBulkDeploymentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let amznClientToken = value.amznClientToken {
            items.add(SmithyHTTPAPI.Header(name: "X-Amzn-Client-Token", value: Swift.String(amznClientToken)))
        }
        return items
    }
}

extension StopBulkDeploymentInput {

    static func urlPathProvider(_ value: StopBulkDeploymentInput) -> Swift.String? {
        guard let bulkDeploymentId = value.bulkDeploymentId else {
            return nil
        }
        return "/greengrass/bulk/deployments/\(bulkDeploymentId.urlPercentEncoding())/$stop"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateConnectivityInfoInput {

    static func urlPathProvider(_ value: UpdateConnectivityInfoInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/greengrass/things/\(thingName.urlPercentEncoding())/connectivityInfo"
    }
}

extension UpdateConnectorDefinitionInput {

    static func urlPathProvider(_ value: UpdateConnectorDefinitionInput) -> Swift.String? {
        guard let connectorDefinitionId = value.connectorDefinitionId else {
            return nil
        }
        return "/greengrass/definition/connectors/\(connectorDefinitionId.urlPercentEncoding())"
    }
}

extension UpdateCoreDefinitionInput {

    static func urlPathProvider(_ value: UpdateCoreDefinitionInput) -> Swift.String? {
        guard let coreDefinitionId = value.coreDefinitionId else {
            return nil
        }
        return "/greengrass/definition/cores/\(coreDefinitionId.urlPercentEncoding())"
    }
}

extension UpdateDeviceDefinitionInput {

    static func urlPathProvider(_ value: UpdateDeviceDefinitionInput) -> Swift.String? {
        guard let deviceDefinitionId = value.deviceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/devices/\(deviceDefinitionId.urlPercentEncoding())"
    }
}

extension UpdateFunctionDefinitionInput {

    static func urlPathProvider(_ value: UpdateFunctionDefinitionInput) -> Swift.String? {
        guard let functionDefinitionId = value.functionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/functions/\(functionDefinitionId.urlPercentEncoding())"
    }
}

extension UpdateGroupInput {

    static func urlPathProvider(_ value: UpdateGroupInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())"
    }
}

extension UpdateGroupCertificateConfigurationInput {

    static func urlPathProvider(_ value: UpdateGroupCertificateConfigurationInput) -> Swift.String? {
        guard let groupId = value.groupId else {
            return nil
        }
        return "/greengrass/groups/\(groupId.urlPercentEncoding())/certificateauthorities/configuration/expiry"
    }
}

extension UpdateLoggerDefinitionInput {

    static func urlPathProvider(_ value: UpdateLoggerDefinitionInput) -> Swift.String? {
        guard let loggerDefinitionId = value.loggerDefinitionId else {
            return nil
        }
        return "/greengrass/definition/loggers/\(loggerDefinitionId.urlPercentEncoding())"
    }
}

extension UpdateResourceDefinitionInput {

    static func urlPathProvider(_ value: UpdateResourceDefinitionInput) -> Swift.String? {
        guard let resourceDefinitionId = value.resourceDefinitionId else {
            return nil
        }
        return "/greengrass/definition/resources/\(resourceDefinitionId.urlPercentEncoding())"
    }
}

extension UpdateSubscriptionDefinitionInput {

    static func urlPathProvider(_ value: UpdateSubscriptionDefinitionInput) -> Swift.String? {
        guard let subscriptionDefinitionId = value.subscriptionDefinitionId else {
            return nil
        }
        return "/greengrass/definition/subscriptions/\(subscriptionDefinitionId.urlPercentEncoding())"
    }
}

extension UpdateThingRuntimeConfigurationInput {

    static func urlPathProvider(_ value: UpdateThingRuntimeConfigurationInput) -> Swift.String? {
        guard let thingName = value.thingName else {
            return nil
        }
        return "/greengrass/things/\(thingName.urlPercentEncoding())/runtimeconfig"
    }
}

extension AssociateRoleToGroupInput {

    static func write(value: AssociateRoleToGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoleArn"].write(value.roleArn)
    }
}

extension AssociateServiceRoleToAccountInput {

    static func write(value: AssociateServiceRoleToAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoleArn"].write(value.roleArn)
    }
}

extension CreateConnectorDefinitionInput {

    static func write(value: CreateConnectorDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialVersion"].write(value.initialVersion, with: GreengrassClientTypes.ConnectorDefinitionVersion.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateConnectorDefinitionVersionInput {

    static func write(value: CreateConnectorDefinitionVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Connectors"].writeList(value.connectors, memberWritingClosure: GreengrassClientTypes.Connector.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateCoreDefinitionInput {

    static func write(value: CreateCoreDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialVersion"].write(value.initialVersion, with: GreengrassClientTypes.CoreDefinitionVersion.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateCoreDefinitionVersionInput {

    static func write(value: CreateCoreDefinitionVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Cores"].writeList(value.cores, memberWritingClosure: GreengrassClientTypes.Core.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateDeploymentInput {

    static func write(value: CreateDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeploymentId"].write(value.deploymentId)
        try writer["DeploymentType"].write(value.deploymentType)
        try writer["GroupVersionId"].write(value.groupVersionId)
    }
}

extension CreateDeviceDefinitionInput {

    static func write(value: CreateDeviceDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialVersion"].write(value.initialVersion, with: GreengrassClientTypes.DeviceDefinitionVersion.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateDeviceDefinitionVersionInput {

    static func write(value: CreateDeviceDefinitionVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Devices"].writeList(value.devices, memberWritingClosure: GreengrassClientTypes.Device.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateFunctionDefinitionInput {

    static func write(value: CreateFunctionDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialVersion"].write(value.initialVersion, with: GreengrassClientTypes.FunctionDefinitionVersion.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateFunctionDefinitionVersionInput {

    static func write(value: CreateFunctionDefinitionVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultConfig"].write(value.defaultConfig, with: GreengrassClientTypes.FunctionDefaultConfig.write(value:to:))
        try writer["Functions"].writeList(value.functions, memberWritingClosure: GreengrassClientTypes.Function.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateGroupInput {

    static func write(value: CreateGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialVersion"].write(value.initialVersion, with: GreengrassClientTypes.GroupVersion.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateGroupVersionInput {

    static func write(value: CreateGroupVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectorDefinitionVersionArn"].write(value.connectorDefinitionVersionArn)
        try writer["CoreDefinitionVersionArn"].write(value.coreDefinitionVersionArn)
        try writer["DeviceDefinitionVersionArn"].write(value.deviceDefinitionVersionArn)
        try writer["FunctionDefinitionVersionArn"].write(value.functionDefinitionVersionArn)
        try writer["LoggerDefinitionVersionArn"].write(value.loggerDefinitionVersionArn)
        try writer["ResourceDefinitionVersionArn"].write(value.resourceDefinitionVersionArn)
        try writer["SubscriptionDefinitionVersionArn"].write(value.subscriptionDefinitionVersionArn)
    }
}

extension CreateLoggerDefinitionInput {

    static func write(value: CreateLoggerDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialVersion"].write(value.initialVersion, with: GreengrassClientTypes.LoggerDefinitionVersion.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateLoggerDefinitionVersionInput {

    static func write(value: CreateLoggerDefinitionVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Loggers"].writeList(value.loggers, memberWritingClosure: GreengrassClientTypes.Logger.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateResourceDefinitionInput {

    static func write(value: CreateResourceDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialVersion"].write(value.initialVersion, with: GreengrassClientTypes.ResourceDefinitionVersion.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateResourceDefinitionVersionInput {

    static func write(value: CreateResourceDefinitionVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Resources"].writeList(value.resources, memberWritingClosure: GreengrassClientTypes.Resource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateSoftwareUpdateJobInput {

    static func write(value: CreateSoftwareUpdateJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3UrlSignerRole"].write(value.s3UrlSignerRole)
        try writer["SoftwareToUpdate"].write(value.softwareToUpdate)
        try writer["UpdateAgentLogLevel"].write(value.updateAgentLogLevel)
        try writer["UpdateTargets"].writeList(value.updateTargets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UpdateTargetsArchitecture"].write(value.updateTargetsArchitecture)
        try writer["UpdateTargetsOperatingSystem"].write(value.updateTargetsOperatingSystem)
    }
}

extension CreateSubscriptionDefinitionInput {

    static func write(value: CreateSubscriptionDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InitialVersion"].write(value.initialVersion, with: GreengrassClientTypes.SubscriptionDefinitionVersion.write(value:to:))
        try writer["Name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateSubscriptionDefinitionVersionInput {

    static func write(value: CreateSubscriptionDefinitionVersionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Subscriptions"].writeList(value.subscriptions, memberWritingClosure: GreengrassClientTypes.Subscription.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ResetDeploymentsInput {

    static func write(value: ResetDeploymentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Force"].write(value.force)
    }
}

extension StartBulkDeploymentInput {

    static func write(value: StartBulkDeploymentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExecutionRoleArn"].write(value.executionRoleArn)
        try writer["InputFileUri"].write(value.inputFileUri)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateConnectivityInfoInput {

    static func write(value: UpdateConnectivityInfoInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectivityInfo"].writeList(value.connectivityInfo, memberWritingClosure: GreengrassClientTypes.ConnectivityInfo.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateConnectorDefinitionInput {

    static func write(value: UpdateConnectorDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension UpdateCoreDefinitionInput {

    static func write(value: UpdateCoreDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension UpdateDeviceDefinitionInput {

    static func write(value: UpdateDeviceDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension UpdateFunctionDefinitionInput {

    static func write(value: UpdateFunctionDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension UpdateGroupInput {

    static func write(value: UpdateGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension UpdateGroupCertificateConfigurationInput {

    static func write(value: UpdateGroupCertificateConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateExpiryInMilliseconds"].write(value.certificateExpiryInMilliseconds)
    }
}

extension UpdateLoggerDefinitionInput {

    static func write(value: UpdateLoggerDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension UpdateResourceDefinitionInput {

    static func write(value: UpdateResourceDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension UpdateSubscriptionDefinitionInput {

    static func write(value: UpdateSubscriptionDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
    }
}

extension UpdateThingRuntimeConfigurationInput {

    static func write(value: UpdateThingRuntimeConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TelemetryConfiguration"].write(value.telemetryConfiguration, with: GreengrassClientTypes.TelemetryConfigurationUpdate.write(value:to:))
    }
}

extension AssociateRoleToGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateRoleToGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateRoleToGroupOutput()
        value.associatedAt = try reader["AssociatedAt"].readIfPresent()
        return value
    }
}

extension AssociateServiceRoleToAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateServiceRoleToAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateServiceRoleToAccountOutput()
        value.associatedAt = try reader["AssociatedAt"].readIfPresent()
        return value
    }
}

extension CreateConnectorDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConnectorDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConnectorDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension CreateConnectorDefinitionVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConnectorDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConnectorDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension CreateCoreDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCoreDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCoreDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension CreateCoreDefinitionVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCoreDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCoreDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension CreateDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDeploymentOutput()
        value.deploymentArn = try reader["DeploymentArn"].readIfPresent()
        value.deploymentId = try reader["DeploymentId"].readIfPresent()
        return value
    }
}

extension CreateDeviceDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDeviceDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDeviceDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension CreateDeviceDefinitionVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDeviceDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDeviceDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension CreateFunctionDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFunctionDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFunctionDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension CreateFunctionDefinitionVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateFunctionDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateFunctionDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension CreateGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGroupOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension CreateGroupCertificateAuthorityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGroupCertificateAuthorityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGroupCertificateAuthorityOutput()
        value.groupCertificateAuthorityArn = try reader["GroupCertificateAuthorityArn"].readIfPresent()
        return value
    }
}

extension CreateGroupVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGroupVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGroupVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension CreateLoggerDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLoggerDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLoggerDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension CreateLoggerDefinitionVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLoggerDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLoggerDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension CreateResourceDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateResourceDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateResourceDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension CreateResourceDefinitionVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateResourceDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateResourceDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension CreateSoftwareUpdateJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSoftwareUpdateJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSoftwareUpdateJobOutput()
        value.iotJobArn = try reader["IotJobArn"].readIfPresent()
        value.iotJobId = try reader["IotJobId"].readIfPresent()
        value.platformSoftwareVersion = try reader["PlatformSoftwareVersion"].readIfPresent()
        return value
    }
}

extension CreateSubscriptionDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSubscriptionDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSubscriptionDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension CreateSubscriptionDefinitionVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSubscriptionDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSubscriptionDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension DeleteConnectorDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConnectorDefinitionOutput {
        return DeleteConnectorDefinitionOutput()
    }
}

extension DeleteCoreDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCoreDefinitionOutput {
        return DeleteCoreDefinitionOutput()
    }
}

extension DeleteDeviceDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDeviceDefinitionOutput {
        return DeleteDeviceDefinitionOutput()
    }
}

extension DeleteFunctionDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteFunctionDefinitionOutput {
        return DeleteFunctionDefinitionOutput()
    }
}

extension DeleteGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGroupOutput {
        return DeleteGroupOutput()
    }
}

extension DeleteLoggerDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLoggerDefinitionOutput {
        return DeleteLoggerDefinitionOutput()
    }
}

extension DeleteResourceDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourceDefinitionOutput {
        return DeleteResourceDefinitionOutput()
    }
}

extension DeleteSubscriptionDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSubscriptionDefinitionOutput {
        return DeleteSubscriptionDefinitionOutput()
    }
}

extension DisassociateRoleFromGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateRoleFromGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateRoleFromGroupOutput()
        value.disassociatedAt = try reader["DisassociatedAt"].readIfPresent()
        return value
    }
}

extension DisassociateServiceRoleFromAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateServiceRoleFromAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateServiceRoleFromAccountOutput()
        value.disassociatedAt = try reader["DisassociatedAt"].readIfPresent()
        return value
    }
}

extension GetAssociatedRoleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAssociatedRoleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssociatedRoleOutput()
        value.associatedAt = try reader["AssociatedAt"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        return value
    }
}

extension GetBulkDeploymentStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBulkDeploymentStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBulkDeploymentStatusOutput()
        value.bulkDeploymentMetrics = try reader["BulkDeploymentMetrics"].readIfPresent(with: GreengrassClientTypes.BulkDeploymentMetrics.read(from:))
        value.bulkDeploymentStatus = try reader["BulkDeploymentStatus"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readIfPresent()
        value.errorDetails = try reader["ErrorDetails"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.ErrorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetConnectivityInfoOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConnectivityInfoOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectivityInfoOutput()
        value.connectivityInfo = try reader["ConnectivityInfo"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.ConnectivityInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension GetConnectorDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConnectorDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectorDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetConnectorDefinitionVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConnectorDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectorDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.definition = try reader["Definition"].readIfPresent(with: GreengrassClientTypes.ConnectorDefinitionVersion.read(from:))
        value.id = try reader["Id"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension GetCoreDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCoreDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCoreDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetCoreDefinitionVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCoreDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCoreDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.definition = try reader["Definition"].readIfPresent(with: GreengrassClientTypes.CoreDefinitionVersion.read(from:))
        value.id = try reader["Id"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension GetDeploymentStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeploymentStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeploymentStatusOutput()
        value.deploymentStatus = try reader["DeploymentStatus"].readIfPresent()
        value.deploymentType = try reader["DeploymentType"].readIfPresent()
        value.errorDetails = try reader["ErrorDetails"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.ErrorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.updatedAt = try reader["UpdatedAt"].readIfPresent()
        return value
    }
}

extension GetDeviceDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeviceDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeviceDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetDeviceDefinitionVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeviceDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeviceDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.definition = try reader["Definition"].readIfPresent(with: GreengrassClientTypes.DeviceDefinitionVersion.read(from:))
        value.id = try reader["Id"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension GetFunctionDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFunctionDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFunctionDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetFunctionDefinitionVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetFunctionDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetFunctionDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.definition = try reader["Definition"].readIfPresent(with: GreengrassClientTypes.FunctionDefinitionVersion.read(from:))
        value.id = try reader["Id"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension GetGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGroupOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetGroupCertificateAuthorityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGroupCertificateAuthorityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGroupCertificateAuthorityOutput()
        value.groupCertificateAuthorityArn = try reader["GroupCertificateAuthorityArn"].readIfPresent()
        value.groupCertificateAuthorityId = try reader["GroupCertificateAuthorityId"].readIfPresent()
        value.pemEncodedCertificate = try reader["PemEncodedCertificate"].readIfPresent()
        return value
    }
}

extension GetGroupCertificateConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGroupCertificateConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGroupCertificateConfigurationOutput()
        value.certificateAuthorityExpiryInMilliseconds = try reader["CertificateAuthorityExpiryInMilliseconds"].readIfPresent()
        value.certificateExpiryInMilliseconds = try reader["CertificateExpiryInMilliseconds"].readIfPresent()
        value.groupId = try reader["GroupId"].readIfPresent()
        return value
    }
}

extension GetGroupVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetGroupVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetGroupVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.definition = try reader["Definition"].readIfPresent(with: GreengrassClientTypes.GroupVersion.read(from:))
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension GetLoggerDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLoggerDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLoggerDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetLoggerDefinitionVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLoggerDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLoggerDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.definition = try reader["Definition"].readIfPresent(with: GreengrassClientTypes.LoggerDefinitionVersion.read(from:))
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension GetResourceDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourceDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetResourceDefinitionVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourceDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.definition = try reader["Definition"].readIfPresent(with: GreengrassClientTypes.ResourceDefinitionVersion.read(from:))
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension GetServiceRoleForAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServiceRoleForAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServiceRoleForAccountOutput()
        value.associatedAt = try reader["AssociatedAt"].readIfPresent()
        value.roleArn = try reader["RoleArn"].readIfPresent()
        return value
    }
}

extension GetSubscriptionDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSubscriptionDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSubscriptionDefinitionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetSubscriptionDefinitionVersionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSubscriptionDefinitionVersionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSubscriptionDefinitionVersionOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.definition = try reader["Definition"].readIfPresent(with: GreengrassClientTypes.SubscriptionDefinitionVersion.read(from:))
        value.id = try reader["Id"].readIfPresent()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension GetThingRuntimeConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetThingRuntimeConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetThingRuntimeConfigurationOutput()
        value.runtimeConfiguration = try reader["RuntimeConfiguration"].readIfPresent(with: GreengrassClientTypes.RuntimeConfiguration.read(from:))
        return value
    }
}

extension ListBulkDeploymentDetailedReportsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBulkDeploymentDetailedReportsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBulkDeploymentDetailedReportsOutput()
        value.deployments = try reader["Deployments"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.BulkDeploymentResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListBulkDeploymentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBulkDeploymentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBulkDeploymentsOutput()
        value.bulkDeployments = try reader["BulkDeployments"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.BulkDeployment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListConnectorDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConnectorDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConnectorDefinitionsOutput()
        value.definitions = try reader["Definitions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.DefinitionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListConnectorDefinitionVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConnectorDefinitionVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConnectorDefinitionVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.VersionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListCoreDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCoreDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCoreDefinitionsOutput()
        value.definitions = try reader["Definitions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.DefinitionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCoreDefinitionVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCoreDefinitionVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCoreDefinitionVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.VersionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListDeploymentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDeploymentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDeploymentsOutput()
        value.deployments = try reader["Deployments"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.Deployment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDeviceDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDeviceDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDeviceDefinitionsOutput()
        value.definitions = try reader["Definitions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.DefinitionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListDeviceDefinitionVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDeviceDefinitionVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDeviceDefinitionVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.VersionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListFunctionDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFunctionDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFunctionDefinitionsOutput()
        value.definitions = try reader["Definitions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.DefinitionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListFunctionDefinitionVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFunctionDefinitionVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFunctionDefinitionVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.VersionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListGroupCertificateAuthoritiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGroupCertificateAuthoritiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGroupCertificateAuthoritiesOutput()
        value.groupCertificateAuthorities = try reader["GroupCertificateAuthorities"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.GroupCertificateAuthorityProperties.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGroupsOutput()
        value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.GroupInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListGroupVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGroupVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGroupVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.VersionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListLoggerDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLoggerDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLoggerDefinitionsOutput()
        value.definitions = try reader["Definitions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.DefinitionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLoggerDefinitionVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLoggerDefinitionVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLoggerDefinitionVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.VersionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListResourceDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourceDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourceDefinitionsOutput()
        value.definitions = try reader["Definitions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.DefinitionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListResourceDefinitionVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourceDefinitionVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourceDefinitionVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.VersionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSubscriptionDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSubscriptionDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSubscriptionDefinitionsOutput()
        value.definitions = try reader["Definitions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.DefinitionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListSubscriptionDefinitionVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSubscriptionDefinitionVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSubscriptionDefinitionVersionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.versions = try reader["Versions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.VersionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ResetDeploymentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ResetDeploymentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ResetDeploymentsOutput()
        value.deploymentArn = try reader["DeploymentArn"].readIfPresent()
        value.deploymentId = try reader["DeploymentId"].readIfPresent()
        return value
    }
}

extension StartBulkDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartBulkDeploymentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartBulkDeploymentOutput()
        value.bulkDeploymentArn = try reader["BulkDeploymentArn"].readIfPresent()
        value.bulkDeploymentId = try reader["BulkDeploymentId"].readIfPresent()
        return value
    }
}

extension StopBulkDeploymentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopBulkDeploymentOutput {
        return StopBulkDeploymentOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateConnectivityInfoOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConnectivityInfoOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConnectivityInfoOutput()
        value.message = try reader["message"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension UpdateConnectorDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConnectorDefinitionOutput {
        return UpdateConnectorDefinitionOutput()
    }
}

extension UpdateCoreDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCoreDefinitionOutput {
        return UpdateCoreDefinitionOutput()
    }
}

extension UpdateDeviceDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDeviceDefinitionOutput {
        return UpdateDeviceDefinitionOutput()
    }
}

extension UpdateFunctionDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateFunctionDefinitionOutput {
        return UpdateFunctionDefinitionOutput()
    }
}

extension UpdateGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGroupOutput {
        return UpdateGroupOutput()
    }
}

extension UpdateGroupCertificateConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGroupCertificateConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGroupCertificateConfigurationOutput()
        value.certificateAuthorityExpiryInMilliseconds = try reader["CertificateAuthorityExpiryInMilliseconds"].readIfPresent()
        value.certificateExpiryInMilliseconds = try reader["CertificateExpiryInMilliseconds"].readIfPresent()
        value.groupId = try reader["GroupId"].readIfPresent()
        return value
    }
}

extension UpdateLoggerDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLoggerDefinitionOutput {
        return UpdateLoggerDefinitionOutput()
    }
}

extension UpdateResourceDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateResourceDefinitionOutput {
        return UpdateResourceDefinitionOutput()
    }
}

extension UpdateSubscriptionDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSubscriptionDefinitionOutput {
        return UpdateSubscriptionDefinitionOutput()
    }
}

extension UpdateThingRuntimeConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateThingRuntimeConfigurationOutput {
        return UpdateThingRuntimeConfigurationOutput()
    }
}

enum AssociateRoleToGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateServiceRoleToAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConnectorDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConnectorDefinitionVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCoreDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCoreDefinitionVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDeviceDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDeviceDefinitionVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFunctionDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateFunctionDefinitionVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGroupCertificateAuthorityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGroupVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLoggerDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLoggerDefinitionVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateResourceDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateResourceDefinitionVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSoftwareUpdateJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSubscriptionDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSubscriptionDefinitionVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConnectorDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCoreDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDeviceDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteFunctionDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLoggerDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourceDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSubscriptionDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateRoleFromGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateServiceRoleFromAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAssociatedRoleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBulkDeploymentStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConnectivityInfoOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConnectorDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConnectorDefinitionVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCoreDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCoreDefinitionVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeploymentStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeviceDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeviceDefinitionVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFunctionDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetFunctionDefinitionVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGroupCertificateAuthorityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGroupCertificateConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetGroupVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLoggerDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLoggerDefinitionVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourceDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourceDefinitionVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServiceRoleForAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSubscriptionDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSubscriptionDefinitionVersionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetThingRuntimeConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBulkDeploymentDetailedReportsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBulkDeploymentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConnectorDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConnectorDefinitionVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCoreDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCoreDefinitionVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDeploymentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDeviceDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDeviceDefinitionVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFunctionDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFunctionDefinitionVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGroupCertificateAuthoritiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGroupVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLoggerDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLoggerDefinitionVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourceDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourceDefinitionVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSubscriptionDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSubscriptionDefinitionVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ResetDeploymentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartBulkDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopBulkDeploymentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConnectivityInfoOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConnectorDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCoreDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDeviceDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateFunctionDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGroupCertificateConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLoggerDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateResourceDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSubscriptionDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateThingRuntimeConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServerErrorException()
        value.properties.errorDetails = try reader["ErrorDetails"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.ErrorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.errorDetails = try reader["ErrorDetails"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.ErrorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension GreengrassClientTypes.BulkDeploymentMetrics {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.BulkDeploymentMetrics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.BulkDeploymentMetrics()
        value.invalidInputRecords = try reader["InvalidInputRecords"].readIfPresent()
        value.recordsProcessed = try reader["RecordsProcessed"].readIfPresent()
        value.retryAttempts = try reader["RetryAttempts"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes.ErrorDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.ErrorDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.ErrorDetail()
        value.detailedErrorCode = try reader["DetailedErrorCode"].readIfPresent()
        value.detailedErrorMessage = try reader["DetailedErrorMessage"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes.ConnectivityInfo {

    static func write(value: GreengrassClientTypes.ConnectivityInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HostAddress"].write(value.hostAddress)
        try writer["Id"].write(value.id)
        try writer["Metadata"].write(value.metadata)
        try writer["PortNumber"].write(value.portNumber)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.ConnectivityInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.ConnectivityInfo()
        value.hostAddress = try reader["HostAddress"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.metadata = try reader["Metadata"].readIfPresent()
        value.portNumber = try reader["PortNumber"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes.ConnectorDefinitionVersion {

    static func write(value: GreengrassClientTypes.ConnectorDefinitionVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Connectors"].writeList(value.connectors, memberWritingClosure: GreengrassClientTypes.Connector.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.ConnectorDefinitionVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.ConnectorDefinitionVersion()
        value.connectors = try reader["Connectors"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.Connector.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes.Connector {

    static func write(value: GreengrassClientTypes.Connector?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectorArn"].write(value.connectorArn)
        try writer["Id"].write(value.id)
        try writer["Parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.Connector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.Connector()
        value.connectorArn = try reader["ConnectorArn"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.parameters = try reader["Parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes.CoreDefinitionVersion {

    static func write(value: GreengrassClientTypes.CoreDefinitionVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Cores"].writeList(value.cores, memberWritingClosure: GreengrassClientTypes.Core.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.CoreDefinitionVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.CoreDefinitionVersion()
        value.cores = try reader["Cores"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.Core.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes.Core {

    static func write(value: GreengrassClientTypes.Core?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateArn"].write(value.certificateArn)
        try writer["Id"].write(value.id)
        try writer["SyncShadow"].write(value.syncShadow)
        try writer["ThingArn"].write(value.thingArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.Core {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.Core()
        value.certificateArn = try reader["CertificateArn"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.syncShadow = try reader["SyncShadow"].readIfPresent()
        value.thingArn = try reader["ThingArn"].readIfPresent() ?? ""
        return value
    }
}

extension GreengrassClientTypes.DeviceDefinitionVersion {

    static func write(value: GreengrassClientTypes.DeviceDefinitionVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Devices"].writeList(value.devices, memberWritingClosure: GreengrassClientTypes.Device.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.DeviceDefinitionVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.DeviceDefinitionVersion()
        value.devices = try reader["Devices"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.Device.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes.Device {

    static func write(value: GreengrassClientTypes.Device?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CertificateArn"].write(value.certificateArn)
        try writer["Id"].write(value.id)
        try writer["SyncShadow"].write(value.syncShadow)
        try writer["ThingArn"].write(value.thingArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.Device {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.Device()
        value.certificateArn = try reader["CertificateArn"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.syncShadow = try reader["SyncShadow"].readIfPresent()
        value.thingArn = try reader["ThingArn"].readIfPresent() ?? ""
        return value
    }
}

extension GreengrassClientTypes.FunctionDefinitionVersion {

    static func write(value: GreengrassClientTypes.FunctionDefinitionVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DefaultConfig"].write(value.defaultConfig, with: GreengrassClientTypes.FunctionDefaultConfig.write(value:to:))
        try writer["Functions"].writeList(value.functions, memberWritingClosure: GreengrassClientTypes.Function.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.FunctionDefinitionVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.FunctionDefinitionVersion()
        value.defaultConfig = try reader["DefaultConfig"].readIfPresent(with: GreengrassClientTypes.FunctionDefaultConfig.read(from:))
        value.functions = try reader["Functions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.Function.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes.Function {

    static func write(value: GreengrassClientTypes.Function?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["FunctionArn"].write(value.functionArn)
        try writer["FunctionConfiguration"].write(value.functionConfiguration, with: GreengrassClientTypes.FunctionConfiguration.write(value:to:))
        try writer["Id"].write(value.id)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.Function {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.Function()
        value.functionArn = try reader["FunctionArn"].readIfPresent()
        value.functionConfiguration = try reader["FunctionConfiguration"].readIfPresent(with: GreengrassClientTypes.FunctionConfiguration.read(from:))
        value.id = try reader["Id"].readIfPresent() ?? ""
        return value
    }
}

extension GreengrassClientTypes.FunctionConfiguration {

    static func write(value: GreengrassClientTypes.FunctionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EncodingType"].write(value.encodingType)
        try writer["Environment"].write(value.environment, with: GreengrassClientTypes.FunctionConfigurationEnvironment.write(value:to:))
        try writer["ExecArgs"].write(value.execArgs)
        try writer["Executable"].write(value.executable)
        try writer["FunctionRuntimeOverride"].write(value.functionRuntimeOverride)
        try writer["MemorySize"].write(value.memorySize)
        try writer["Pinned"].write(value.pinned)
        try writer["Timeout"].write(value.timeout)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.FunctionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.FunctionConfiguration()
        value.encodingType = try reader["EncodingType"].readIfPresent()
        value.environment = try reader["Environment"].readIfPresent(with: GreengrassClientTypes.FunctionConfigurationEnvironment.read(from:))
        value.execArgs = try reader["ExecArgs"].readIfPresent()
        value.executable = try reader["Executable"].readIfPresent()
        value.memorySize = try reader["MemorySize"].readIfPresent()
        value.pinned = try reader["Pinned"].readIfPresent()
        value.timeout = try reader["Timeout"].readIfPresent()
        value.functionRuntimeOverride = try reader["FunctionRuntimeOverride"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes.FunctionConfigurationEnvironment {

    static func write(value: GreengrassClientTypes.FunctionConfigurationEnvironment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessSysfs"].write(value.accessSysfs)
        try writer["Execution"].write(value.execution, with: GreengrassClientTypes.FunctionExecutionConfig.write(value:to:))
        try writer["ResourceAccessPolicies"].writeList(value.resourceAccessPolicies, memberWritingClosure: GreengrassClientTypes.ResourceAccessPolicy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Variables"].writeMap(value.variables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.FunctionConfigurationEnvironment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.FunctionConfigurationEnvironment()
        value.accessSysfs = try reader["AccessSysfs"].readIfPresent()
        value.execution = try reader["Execution"].readIfPresent(with: GreengrassClientTypes.FunctionExecutionConfig.read(from:))
        value.resourceAccessPolicies = try reader["ResourceAccessPolicies"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.ResourceAccessPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.variables = try reader["Variables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes.ResourceAccessPolicy {

    static func write(value: GreengrassClientTypes.ResourceAccessPolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Permission"].write(value.permission)
        try writer["ResourceId"].write(value.resourceId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.ResourceAccessPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.ResourceAccessPolicy()
        value.permission = try reader["Permission"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        return value
    }
}

extension GreengrassClientTypes.FunctionExecutionConfig {

    static func write(value: GreengrassClientTypes.FunctionExecutionConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IsolationMode"].write(value.isolationMode)
        try writer["RunAs"].write(value.runAs, with: GreengrassClientTypes.FunctionRunAsConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.FunctionExecutionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.FunctionExecutionConfig()
        value.isolationMode = try reader["IsolationMode"].readIfPresent()
        value.runAs = try reader["RunAs"].readIfPresent(with: GreengrassClientTypes.FunctionRunAsConfig.read(from:))
        return value
    }
}

extension GreengrassClientTypes.FunctionRunAsConfig {

    static func write(value: GreengrassClientTypes.FunctionRunAsConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Gid"].write(value.gid)
        try writer["Uid"].write(value.uid)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.FunctionRunAsConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.FunctionRunAsConfig()
        value.gid = try reader["Gid"].readIfPresent()
        value.uid = try reader["Uid"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes.FunctionDefaultConfig {

    static func write(value: GreengrassClientTypes.FunctionDefaultConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Execution"].write(value.execution, with: GreengrassClientTypes.FunctionDefaultExecutionConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.FunctionDefaultConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.FunctionDefaultConfig()
        value.execution = try reader["Execution"].readIfPresent(with: GreengrassClientTypes.FunctionDefaultExecutionConfig.read(from:))
        return value
    }
}

extension GreengrassClientTypes.FunctionDefaultExecutionConfig {

    static func write(value: GreengrassClientTypes.FunctionDefaultExecutionConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IsolationMode"].write(value.isolationMode)
        try writer["RunAs"].write(value.runAs, with: GreengrassClientTypes.FunctionRunAsConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.FunctionDefaultExecutionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.FunctionDefaultExecutionConfig()
        value.isolationMode = try reader["IsolationMode"].readIfPresent()
        value.runAs = try reader["RunAs"].readIfPresent(with: GreengrassClientTypes.FunctionRunAsConfig.read(from:))
        return value
    }
}

extension GreengrassClientTypes.GroupVersion {

    static func write(value: GreengrassClientTypes.GroupVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ConnectorDefinitionVersionArn"].write(value.connectorDefinitionVersionArn)
        try writer["CoreDefinitionVersionArn"].write(value.coreDefinitionVersionArn)
        try writer["DeviceDefinitionVersionArn"].write(value.deviceDefinitionVersionArn)
        try writer["FunctionDefinitionVersionArn"].write(value.functionDefinitionVersionArn)
        try writer["LoggerDefinitionVersionArn"].write(value.loggerDefinitionVersionArn)
        try writer["ResourceDefinitionVersionArn"].write(value.resourceDefinitionVersionArn)
        try writer["SubscriptionDefinitionVersionArn"].write(value.subscriptionDefinitionVersionArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.GroupVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.GroupVersion()
        value.connectorDefinitionVersionArn = try reader["ConnectorDefinitionVersionArn"].readIfPresent()
        value.coreDefinitionVersionArn = try reader["CoreDefinitionVersionArn"].readIfPresent()
        value.deviceDefinitionVersionArn = try reader["DeviceDefinitionVersionArn"].readIfPresent()
        value.functionDefinitionVersionArn = try reader["FunctionDefinitionVersionArn"].readIfPresent()
        value.loggerDefinitionVersionArn = try reader["LoggerDefinitionVersionArn"].readIfPresent()
        value.resourceDefinitionVersionArn = try reader["ResourceDefinitionVersionArn"].readIfPresent()
        value.subscriptionDefinitionVersionArn = try reader["SubscriptionDefinitionVersionArn"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes.LoggerDefinitionVersion {

    static func write(value: GreengrassClientTypes.LoggerDefinitionVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Loggers"].writeList(value.loggers, memberWritingClosure: GreengrassClientTypes.Logger.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.LoggerDefinitionVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.LoggerDefinitionVersion()
        value.loggers = try reader["Loggers"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.Logger.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes.Logger {

    static func write(value: GreengrassClientTypes.Logger?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Component"].write(value.component)
        try writer["Id"].write(value.id)
        try writer["Level"].write(value.level)
        try writer["Space"].write(value.space)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.Logger {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.Logger()
        value.component = try reader["Component"].readIfPresent() ?? .sdkUnknown("")
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.level = try reader["Level"].readIfPresent() ?? .sdkUnknown("")
        value.space = try reader["Space"].readIfPresent()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GreengrassClientTypes.ResourceDefinitionVersion {

    static func write(value: GreengrassClientTypes.ResourceDefinitionVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Resources"].writeList(value.resources, memberWritingClosure: GreengrassClientTypes.Resource.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.ResourceDefinitionVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.ResourceDefinitionVersion()
        value.resources = try reader["Resources"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.Resource.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes.Resource {

    static func write(value: GreengrassClientTypes.Resource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["Name"].write(value.name)
        try writer["ResourceDataContainer"].write(value.resourceDataContainer, with: GreengrassClientTypes.ResourceDataContainer.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.Resource()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.resourceDataContainer = try reader["ResourceDataContainer"].readIfPresent(with: GreengrassClientTypes.ResourceDataContainer.read(from:))
        return value
    }
}

extension GreengrassClientTypes.ResourceDataContainer {

    static func write(value: GreengrassClientTypes.ResourceDataContainer?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LocalDeviceResourceData"].write(value.localDeviceResourceData, with: GreengrassClientTypes.LocalDeviceResourceData.write(value:to:))
        try writer["LocalVolumeResourceData"].write(value.localVolumeResourceData, with: GreengrassClientTypes.LocalVolumeResourceData.write(value:to:))
        try writer["S3MachineLearningModelResourceData"].write(value.s3MachineLearningModelResourceData, with: GreengrassClientTypes.S3MachineLearningModelResourceData.write(value:to:))
        try writer["SageMakerMachineLearningModelResourceData"].write(value.sageMakerMachineLearningModelResourceData, with: GreengrassClientTypes.SageMakerMachineLearningModelResourceData.write(value:to:))
        try writer["SecretsManagerSecretResourceData"].write(value.secretsManagerSecretResourceData, with: GreengrassClientTypes.SecretsManagerSecretResourceData.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.ResourceDataContainer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.ResourceDataContainer()
        value.localDeviceResourceData = try reader["LocalDeviceResourceData"].readIfPresent(with: GreengrassClientTypes.LocalDeviceResourceData.read(from:))
        value.localVolumeResourceData = try reader["LocalVolumeResourceData"].readIfPresent(with: GreengrassClientTypes.LocalVolumeResourceData.read(from:))
        value.s3MachineLearningModelResourceData = try reader["S3MachineLearningModelResourceData"].readIfPresent(with: GreengrassClientTypes.S3MachineLearningModelResourceData.read(from:))
        value.sageMakerMachineLearningModelResourceData = try reader["SageMakerMachineLearningModelResourceData"].readIfPresent(with: GreengrassClientTypes.SageMakerMachineLearningModelResourceData.read(from:))
        value.secretsManagerSecretResourceData = try reader["SecretsManagerSecretResourceData"].readIfPresent(with: GreengrassClientTypes.SecretsManagerSecretResourceData.read(from:))
        return value
    }
}

extension GreengrassClientTypes.SecretsManagerSecretResourceData {

    static func write(value: GreengrassClientTypes.SecretsManagerSecretResourceData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ARN"].write(value.arn)
        try writer["AdditionalStagingLabelsToDownload"].writeList(value.additionalStagingLabelsToDownload, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.SecretsManagerSecretResourceData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.SecretsManagerSecretResourceData()
        value.arn = try reader["ARN"].readIfPresent()
        value.additionalStagingLabelsToDownload = try reader["AdditionalStagingLabelsToDownload"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes.SageMakerMachineLearningModelResourceData {

    static func write(value: GreengrassClientTypes.SageMakerMachineLearningModelResourceData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationPath"].write(value.destinationPath)
        try writer["OwnerSetting"].write(value.ownerSetting, with: GreengrassClientTypes.ResourceDownloadOwnerSetting.write(value:to:))
        try writer["SageMakerJobArn"].write(value.sageMakerJobArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.SageMakerMachineLearningModelResourceData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.SageMakerMachineLearningModelResourceData()
        value.destinationPath = try reader["DestinationPath"].readIfPresent()
        value.ownerSetting = try reader["OwnerSetting"].readIfPresent(with: GreengrassClientTypes.ResourceDownloadOwnerSetting.read(from:))
        value.sageMakerJobArn = try reader["SageMakerJobArn"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes.ResourceDownloadOwnerSetting {

    static func write(value: GreengrassClientTypes.ResourceDownloadOwnerSetting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupOwner"].write(value.groupOwner)
        try writer["GroupPermission"].write(value.groupPermission)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.ResourceDownloadOwnerSetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.ResourceDownloadOwnerSetting()
        value.groupOwner = try reader["GroupOwner"].readIfPresent() ?? ""
        value.groupPermission = try reader["GroupPermission"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GreengrassClientTypes.S3MachineLearningModelResourceData {

    static func write(value: GreengrassClientTypes.S3MachineLearningModelResourceData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationPath"].write(value.destinationPath)
        try writer["OwnerSetting"].write(value.ownerSetting, with: GreengrassClientTypes.ResourceDownloadOwnerSetting.write(value:to:))
        try writer["S3Uri"].write(value.s3Uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.S3MachineLearningModelResourceData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.S3MachineLearningModelResourceData()
        value.destinationPath = try reader["DestinationPath"].readIfPresent()
        value.ownerSetting = try reader["OwnerSetting"].readIfPresent(with: GreengrassClientTypes.ResourceDownloadOwnerSetting.read(from:))
        value.s3Uri = try reader["S3Uri"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes.LocalVolumeResourceData {

    static func write(value: GreengrassClientTypes.LocalVolumeResourceData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationPath"].write(value.destinationPath)
        try writer["GroupOwnerSetting"].write(value.groupOwnerSetting, with: GreengrassClientTypes.GroupOwnerSetting.write(value:to:))
        try writer["SourcePath"].write(value.sourcePath)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.LocalVolumeResourceData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.LocalVolumeResourceData()
        value.destinationPath = try reader["DestinationPath"].readIfPresent()
        value.groupOwnerSetting = try reader["GroupOwnerSetting"].readIfPresent(with: GreengrassClientTypes.GroupOwnerSetting.read(from:))
        value.sourcePath = try reader["SourcePath"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes.GroupOwnerSetting {

    static func write(value: GreengrassClientTypes.GroupOwnerSetting?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoAddGroupOwner"].write(value.autoAddGroupOwner)
        try writer["GroupOwner"].write(value.groupOwner)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.GroupOwnerSetting {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.GroupOwnerSetting()
        value.autoAddGroupOwner = try reader["AutoAddGroupOwner"].readIfPresent()
        value.groupOwner = try reader["GroupOwner"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes.LocalDeviceResourceData {

    static func write(value: GreengrassClientTypes.LocalDeviceResourceData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["GroupOwnerSetting"].write(value.groupOwnerSetting, with: GreengrassClientTypes.GroupOwnerSetting.write(value:to:))
        try writer["SourcePath"].write(value.sourcePath)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.LocalDeviceResourceData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.LocalDeviceResourceData()
        value.groupOwnerSetting = try reader["GroupOwnerSetting"].readIfPresent(with: GreengrassClientTypes.GroupOwnerSetting.read(from:))
        value.sourcePath = try reader["SourcePath"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes.SubscriptionDefinitionVersion {

    static func write(value: GreengrassClientTypes.SubscriptionDefinitionVersion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Subscriptions"].writeList(value.subscriptions, memberWritingClosure: GreengrassClientTypes.Subscription.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.SubscriptionDefinitionVersion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.SubscriptionDefinitionVersion()
        value.subscriptions = try reader["Subscriptions"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.Subscription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes.Subscription {

    static func write(value: GreengrassClientTypes.Subscription?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["Source"].write(value.source)
        try writer["Subject"].write(value.subject)
        try writer["Target"].write(value.target)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.Subscription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.Subscription()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.source = try reader["Source"].readIfPresent() ?? ""
        value.subject = try reader["Subject"].readIfPresent() ?? ""
        value.target = try reader["Target"].readIfPresent() ?? ""
        return value
    }
}

extension GreengrassClientTypes.RuntimeConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.RuntimeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.RuntimeConfiguration()
        value.telemetryConfiguration = try reader["TelemetryConfiguration"].readIfPresent(with: GreengrassClientTypes.TelemetryConfiguration.read(from:))
        return value
    }
}

extension GreengrassClientTypes.TelemetryConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.TelemetryConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.TelemetryConfiguration()
        value.configurationSyncStatus = try reader["ConfigurationSyncStatus"].readIfPresent()
        value.telemetry = try reader["Telemetry"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GreengrassClientTypes.BulkDeploymentResult {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.BulkDeploymentResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.BulkDeploymentResult()
        value.createdAt = try reader["CreatedAt"].readIfPresent()
        value.deploymentArn = try reader["DeploymentArn"].readIfPresent()
        value.deploymentId = try reader["DeploymentId"].readIfPresent()
        value.deploymentStatus = try reader["DeploymentStatus"].readIfPresent()
        value.deploymentType = try reader["DeploymentType"].readIfPresent()
        value.errorDetails = try reader["ErrorDetails"].readListIfPresent(memberReadingClosure: GreengrassClientTypes.ErrorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        value.groupArn = try reader["GroupArn"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes.BulkDeployment {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.BulkDeployment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.BulkDeployment()
        value.bulkDeploymentArn = try reader["BulkDeploymentArn"].readIfPresent()
        value.bulkDeploymentId = try reader["BulkDeploymentId"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes.DefinitionInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.DefinitionInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.DefinitionInformation()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GreengrassClientTypes.VersionInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.VersionInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.VersionInformation()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes.Deployment {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.Deployment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.Deployment()
        value.createdAt = try reader["CreatedAt"].readIfPresent()
        value.deploymentArn = try reader["DeploymentArn"].readIfPresent()
        value.deploymentId = try reader["DeploymentId"].readIfPresent()
        value.deploymentType = try reader["DeploymentType"].readIfPresent()
        value.groupArn = try reader["GroupArn"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes.GroupCertificateAuthorityProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.GroupCertificateAuthorityProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.GroupCertificateAuthorityProperties()
        value.groupCertificateAuthorityArn = try reader["GroupCertificateAuthorityArn"].readIfPresent()
        value.groupCertificateAuthorityId = try reader["GroupCertificateAuthorityId"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes.GroupInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> GreengrassClientTypes.GroupInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GreengrassClientTypes.GroupInformation()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationTimestamp = try reader["CreationTimestamp"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedTimestamp = try reader["LastUpdatedTimestamp"].readIfPresent()
        value.latestVersion = try reader["LatestVersion"].readIfPresent()
        value.latestVersionArn = try reader["LatestVersionArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        return value
    }
}

extension GreengrassClientTypes.TelemetryConfigurationUpdate {

    static func write(value: GreengrassClientTypes.TelemetryConfigurationUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Telemetry"].write(value.telemetry)
    }
}

public enum GreengrassClientTypes {}
