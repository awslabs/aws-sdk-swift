// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(FileBasedConfig) import AWSClientRuntime
import ClientRuntime
import Foundation
import Logging

public class EKSAuthClient {
    public static let clientName = "EKSAuthClient"
    let client: ClientRuntime.SdkHttpClient
    let config: EKSAuthClient.EKSAuthClientConfiguration
    let serviceName = "EKS Auth"
    let encoder: ClientRuntime.RequestEncoder
    let decoder: ClientRuntime.ResponseDecoder

    public init(config: EKSAuthClient.EKSAuthClientConfiguration) {
        client = ClientRuntime.SdkHttpClient(engine: config.httpClientEngine, config: config.httpClientConfiguration)
        let encoder = ClientRuntime.JSONEncoder()
        encoder.dateEncodingStrategy = .secondsSince1970
        encoder.nonConformingFloatEncodingStrategy = .convertToString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.encoder = config.encoder ?? encoder
        let decoder = ClientRuntime.JSONDecoder()
        decoder.dateDecodingStrategy = .secondsSince1970
        decoder.nonConformingFloatDecodingStrategy = .convertFromString(positiveInfinity: "Infinity", negativeInfinity: "-Infinity", nan: "NaN")
        self.decoder = config.decoder ?? decoder
        self.config = config
    }

    public convenience init(region: Swift.String) throws {
        let config = try EKSAuthClient.EKSAuthClientConfiguration(region: region)
        self.init(config: config)
    }

    public convenience init() async throws {
        let config = try await EKSAuthClient.EKSAuthClientConfiguration()
        self.init(config: config)
    }
}

extension EKSAuthClient {
    public typealias EKSAuthClientConfiguration = AWSClientConfiguration<ServiceSpecificConfiguration>

    public struct ServiceSpecificConfiguration: AWSServiceSpecificConfiguration {
        public typealias AWSServiceEndpointResolver = EndpointResolver

        public var serviceName: String { "EKS Auth" }
        public var clientName: String { "EKSAuthClient" }
        public var endpointResolver: EndpointResolver

        public init(endpointResolver: EndpointResolver? = nil) throws {
            self.endpointResolver = try endpointResolver ?? DefaultEndpointResolver()
        }
    }

    static func resolve(plugins: [any Plugin]) async throws -> EKSAuthClient.EKSAuthClientConfiguration {
        let clientConfiguration = try await EKSAuthClient.EKSAuthClientConfiguration()
        for plugin in plugins {
            try await plugin.configureClient(clientConfiguration: clientConfiguration)
        }
        return clientConfiguration
    }

    public class Builder {
        private var plugins: [Plugin]
        public init(defaultPlugins: [Plugin] = []) {
            self.plugins = defaultPlugins
        }
        public func withPlugin(plugin: any Plugin) {
            self.plugins.append(plugin)
        }
        public func build() async throws -> EKSAuthClient {
            let configuration = try await resolve(plugins: self.plugins)
            return EKSAuthClient(config: configuration)
        }
    }

    public static func builder() -> Builder {
        return Builder(defaultPlugins: [DefaultClientPlugin()])
    }
}

extension EKSAuthClient.EKSAuthClientConfiguration: AwsDefaultClientConfiguration & AwsRegionClientConfiguration & DefaultClientConfiguration & DefaultHttpClientConfiguration {
}

public struct EKSAuthClientLogHandlerFactory: ClientRuntime.SDKLogHandlerFactory {
    public var label = "EKSAuthClient"
    let logLevel: ClientRuntime.SDKLogLevel
    public func construct(label: String) -> LogHandler {
        var handler = StreamLogHandler.standardOutput(label: label)
        handler.logLevel = logLevel.toLoggerType()
        return handler
    }
    public init(logLevel: ClientRuntime.SDKLogLevel) {
        self.logLevel = logLevel
    }
}

extension EKSAuthClient: EKSAuthClientProtocol {
    /// Performs the `AssumeRoleForPodIdentity` operation on the `EKSAuthFrontend` service.
    ///
    /// The Amazon EKS Auth API and the AssumeRoleForPodIdentity action are only used by the EKS Pod Identity Agent. We recommend that applications use the Amazon Web Services SDKs to connect to Amazon Web Services services; if credentials from an EKS Pod Identity association are available in the pod, the latest versions of the SDKs use them automatically.
    ///
    /// - Parameter AssumeRoleForPodIdentityInput : [no documentation found]
    ///
    /// - Returns: `AssumeRoleForPodIdentityOutput` : [no documentation found]
    ///
    /// - Throws: One of the exceptions listed below __Possible Exceptions__.
    ///
    /// __Possible Exceptions:__
    /// - `AccessDeniedException` : You don't have permissions to perform the requested operation. The IAM principal making the request must have at least one IAM permissions policy attached that grants the required permissions. For more information, see [Access management](https://docs.aws.amazon.com/IAM/latest/UserGuide/access.html) in the IAM User Guide.
    /// - `ExpiredTokenException` : The specified Kubernetes service account token is expired.
    /// - `InternalServerException` : These errors are usually caused by a server-side issue.
    /// - `InvalidParameterException` : The specified parameter is invalid. Review the available parameters for the API request.
    /// - `InvalidRequestException` : This exception is thrown if the request contains a semantic error. The precise meaning will depend on the API, and will be documented in the error message.
    /// - `InvalidTokenException` : The specified Kubernetes service account token is invalid.
    /// - `ResourceNotFoundException` : The specified resource could not be found.
    /// - `ServiceUnavailableException` : The service is unavailable. Back off and retry the operation.
    /// - `ThrottlingException` : The request was denied because your request rate is too high. Reduce the frequency of requests.
    public func assumeRoleForPodIdentity(input: AssumeRoleForPodIdentityInput) async throws -> AssumeRoleForPodIdentityOutput
    {
        let context = ClientRuntime.HttpContextBuilder()
                      .withEncoder(value: encoder)
                      .withDecoder(value: decoder)
                      .withMethod(value: .post)
                      .withServiceName(value: serviceName)
                      .withOperation(value: "assumeRoleForPodIdentity")
                      .withIdempotencyTokenGenerator(value: config.idempotencyTokenGenerator)
                      .withLogger(value: config.logger)
                      .withPartitionID(value: config.partitionID)
                      .withCredentialsProvider(value: config.credentialsProvider)
                      .withRegion(value: config.region)
                      .withSigningName(value: "eks-auth")
                      .withSigningRegion(value: config.signingRegion)
                      .build()
        var operation = ClientRuntime.OperationStack<AssumeRoleForPodIdentityInput, AssumeRoleForPodIdentityOutput>(id: "assumeRoleForPodIdentity")
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLPathMiddleware<AssumeRoleForPodIdentityInput, AssumeRoleForPodIdentityOutput>())
        operation.initializeStep.intercept(position: .after, middleware: ClientRuntime.URLHostMiddleware<AssumeRoleForPodIdentityInput, AssumeRoleForPodIdentityOutput>())
        let endpointParams = EndpointParams(endpoint: config.endpoint, region: config.region, useFIPS: config.useFIPS ?? false)
        operation.buildStep.intercept(position: .before, middleware: EndpointResolverMiddleware<AssumeRoleForPodIdentityOutput>(endpointResolver: config.serviceSpecific.endpointResolver, endpointParams: endpointParams))
        operation.buildStep.intercept(position: .before, middleware: AWSClientRuntime.UserAgentMiddleware(metadata: AWSClientRuntime.AWSUserAgentMetadata.fromConfig(serviceID: serviceName, version: "1.0", config: config)))
        operation.serializeStep.intercept(position: .after, middleware: ContentTypeMiddleware<AssumeRoleForPodIdentityInput, AssumeRoleForPodIdentityOutput>(contentType: "application/json"))
        operation.serializeStep.intercept(position: .after, middleware: ClientRuntime.BodyMiddleware<AssumeRoleForPodIdentityInput, AssumeRoleForPodIdentityOutput, ClientRuntime.JSONWriter>(documentWritingClosure: ClientRuntime.JSONReadWrite.documentWritingClosure(encoder: encoder), inputWritingClosure: JSONReadWrite.writingClosure()))
        operation.finalizeStep.intercept(position: .before, middleware: ClientRuntime.ContentLengthMiddleware())
        operation.finalizeStep.intercept(position: .after, middleware: ClientRuntime.RetryMiddleware<ClientRuntime.DefaultRetryStrategy, AWSClientRuntime.AWSRetryErrorInfoProvider, AssumeRoleForPodIdentityOutput>(options: config.retryStrategyOptions))
        let sigv4Config = AWSClientRuntime.SigV4Config(unsignedBody: false, signingAlgorithm: .sigv4)
        operation.finalizeStep.intercept(position: .before, middleware: AWSClientRuntime.SigV4Middleware<AssumeRoleForPodIdentityOutput>(config: sigv4Config))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.DeserializeMiddleware<AssumeRoleForPodIdentityOutput>(responseClosure(decoder: decoder), responseErrorClosure(AssumeRoleForPodIdentityOutputError.self, decoder: decoder)))
        operation.deserializeStep.intercept(position: .after, middleware: ClientRuntime.LoggerMiddleware<AssumeRoleForPodIdentityOutput>(clientLogMode: config.clientLogMode))
        let result = try await operation.handleMiddleware(context: context, input: input, next: client.getHandler())
        return result
    }

}
