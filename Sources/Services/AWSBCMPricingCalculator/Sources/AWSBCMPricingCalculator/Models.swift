//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class ClientRuntime.Indirect
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedCode" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents an action to add a Reserved Instance to a bill scenario.
    public struct AddReservedInstanceAction: Swift.Sendable {
        /// The number of instances to add for this Reserved Instance offering.
        public var instanceCount: Swift.Int?
        /// The ID of the Reserved Instance offering to add. For more information, see [ DescribeReservedInstancesOfferings](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeReservedInstancesOfferings.html).
        public var reservedInstancesOfferingId: Swift.String?

        public init(
            instanceCount: Swift.Int? = nil,
            reservedInstancesOfferingId: Swift.String? = nil
        )
        {
            self.instanceCount = instanceCount
            self.reservedInstancesOfferingId = reservedInstancesOfferingId
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents an action to add a Savings Plan to a bill scenario.
    public struct AddSavingsPlanAction: Swift.Sendable {
        /// The hourly commitment, in the same currency of the savingsPlanOfferingId. This is a value between 0.001 and 1 million. You cannot specify more than five digits after the decimal point.
        public var commitment: Swift.Double?
        /// The ID of the Savings Plan offering to add. For more information, see [ DescribeSavingsPlansOfferings](https://docs.aws.amazon.com/savingsplans/latest/APIReference/API_DescribeSavingsPlansOfferings.html).
        public var savingsPlanOfferingId: Swift.String?

        public init(
            commitment: Swift.Double? = nil,
            savingsPlanOfferingId: Swift.String? = nil
        )
        {
            self.commitment = commitment
            self.savingsPlanOfferingId = savingsPlanOfferingId
        }
    }
}

/// The requested data is currently unavailable.
public struct DataUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DataUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that was not found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that was not found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundCode" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

public struct ListBillEstimateCommitmentsInput: Swift.Sendable {
    /// The unique identifier of the bill estimate to list commitments for.
    /// This member is required.
    public var billEstimateId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// A token to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        billEstimateId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billEstimateId = billEstimateId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum CurrencyCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case usd
        case sdkUnknown(Swift.String)

        public static var allCases: [CurrencyCode] {
            return [
                .usd
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .usd: return "USD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents a monetary amount with associated currency.
    public struct CostAmount: Swift.Sendable {
        /// The numeric value of the cost.
        public var amount: Swift.Double?
        /// The currency code for the cost amount.
        public var currency: BCMPricingCalculatorClientTypes.CurrencyCode?

        public init(
            amount: Swift.Double? = nil,
            currency: BCMPricingCalculatorClientTypes.CurrencyCode? = nil
        )
        {
            self.amount = amount
            self.currency = currency
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum PurchaseAgreementType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case reservedInstance
        case savingsPlans
        case sdkUnknown(Swift.String)

        public static var allCases: [PurchaseAgreementType] {
            return [
                .reservedInstance,
                .savingsPlans
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .reservedInstance: return "RESERVED_INSTANCE"
            case .savingsPlans: return "SAVINGS_PLANS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Provides a summary of commitment-related information for a bill estimate.
    public struct BillEstimateCommitmentSummary: Swift.Sendable {
        /// The unique identifier of the commitment.
        public var id: Swift.String?
        /// The monthly payment amount for this commitment, if applicable.
        public var monthlyPayment: BCMPricingCalculatorClientTypes.CostAmount?
        /// The identifier of the specific offering associated with this commitment.
        public var offeringId: Swift.String?
        /// The payment option chosen for this commitment (e.g., All Upfront, Partial Upfront, No Upfront).
        public var paymentOption: Swift.String?
        /// The type of purchase agreement (e.g., Reserved Instance, Savings Plan).
        public var purchaseAgreementType: BCMPricingCalculatorClientTypes.PurchaseAgreementType?
        /// The Amazon Web Services region associated with this commitment.
        public var region: Swift.String?
        /// The length of the commitment term.
        public var termLength: Swift.String?
        /// The upfront payment amount for this commitment, if applicable.
        public var upfrontPayment: BCMPricingCalculatorClientTypes.CostAmount?
        /// The Amazon Web Services account ID associated with this commitment.
        public var usageAccountId: Swift.String?

        public init(
            id: Swift.String? = nil,
            monthlyPayment: BCMPricingCalculatorClientTypes.CostAmount? = nil,
            offeringId: Swift.String? = nil,
            paymentOption: Swift.String? = nil,
            purchaseAgreementType: BCMPricingCalculatorClientTypes.PurchaseAgreementType? = nil,
            region: Swift.String? = nil,
            termLength: Swift.String? = nil,
            upfrontPayment: BCMPricingCalculatorClientTypes.CostAmount? = nil,
            usageAccountId: Swift.String? = nil
        )
        {
            self.id = id
            self.monthlyPayment = monthlyPayment
            self.offeringId = offeringId
            self.paymentOption = paymentOption
            self.purchaseAgreementType = purchaseAgreementType
            self.region = region
            self.termLength = termLength
            self.upfrontPayment = upfrontPayment
            self.usageAccountId = usageAccountId
        }
    }
}

public struct ListBillEstimateCommitmentsOutput: Swift.Sendable {
    /// The list of commitments associated with the bill estimate.
    public var items: [BCMPricingCalculatorClientTypes.BillEstimateCommitmentSummary]?
    /// A token to retrieve the next page of results, if any.
    public var nextToken: Swift.String?

    public init(
        items: [BCMPricingCalculatorClientTypes.BillEstimateCommitmentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents the difference between historical and estimated costs.
    public struct CostDifference: Swift.Sendable {
        /// The estimated cost amount.
        public var estimatedCost: BCMPricingCalculatorClientTypes.CostAmount?
        /// The historical cost amount.
        public var historicalCost: BCMPricingCalculatorClientTypes.CostAmount?

        public init(
            estimatedCost: BCMPricingCalculatorClientTypes.CostAmount? = nil,
            historicalCost: BCMPricingCalculatorClientTypes.CostAmount? = nil
        )
        {
            self.estimatedCost = estimatedCost
            self.historicalCost = historicalCost
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Provides a summary of cost-related information for a bill estimate.
    public struct BillEstimateCostSummary: Swift.Sendable {
        /// A breakdown of cost differences by Amazon Web Services service.
        public var serviceCostDifferences: [Swift.String: BCMPricingCalculatorClientTypes.CostDifference]?
        /// The total difference in cost between the estimated and historical costs.
        public var totalCostDifference: BCMPricingCalculatorClientTypes.CostDifference?

        public init(
            serviceCostDifferences: [Swift.String: BCMPricingCalculatorClientTypes.CostDifference]? = nil,
            totalCostDifference: BCMPricingCalculatorClientTypes.CostDifference? = nil
        )
        {
            self.serviceCostDifferences = serviceCostDifferences
            self.totalCostDifference = totalCostDifference
        }
    }
}

public struct ListBillEstimateInputCommitmentModificationsInput: Swift.Sendable {
    /// The unique identifier of the bill estimate to list input commitment modifications for.
    /// This member is required.
    public var billEstimateId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// A token to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        billEstimateId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billEstimateId = billEstimateId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents an action to remove a Reserved Instance from a bill scenario. This is the ID of an existing Reserved Instance in your account.
    public struct NegateReservedInstanceAction: Swift.Sendable {
        /// The ID of the Reserved Instance to remove.
        public var reservedInstancesId: Swift.String?

        public init(
            reservedInstancesId: Swift.String? = nil
        )
        {
            self.reservedInstancesId = reservedInstancesId
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents an action to remove a Savings Plan from a bill scenario. This is the ID of an existing Savings Plan in your account.
    public struct NegateSavingsPlanAction: Swift.Sendable {
        /// The ID of the Savings Plan to remove.
        public var savingsPlanId: Swift.String?

        public init(
            savingsPlanId: Swift.String? = nil
        )
        {
            self.savingsPlanId = savingsPlanId
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents an action to modify commitments in a bill scenario.
    public enum BillScenarioCommitmentModificationAction: Swift.Sendable {
        /// Action to add a Reserved Instance to the scenario.
        case addreservedinstanceaction(BCMPricingCalculatorClientTypes.AddReservedInstanceAction)
        /// Action to add a Savings Plan to the scenario.
        case addsavingsplanaction(BCMPricingCalculatorClientTypes.AddSavingsPlanAction)
        /// Action to remove a Reserved Instance from the scenario.
        case negatereservedinstanceaction(BCMPricingCalculatorClientTypes.NegateReservedInstanceAction)
        /// Action to remove a Savings Plan from the scenario.
        case negatesavingsplanaction(BCMPricingCalculatorClientTypes.NegateSavingsPlanAction)
        case sdkUnknown(Swift.String)
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Summarizes an input commitment modification for a bill estimate.
    public struct BillEstimateInputCommitmentModificationSummary: Swift.Sendable {
        /// The specific commitment action taken in this modification.
        public var commitmentAction: BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationAction?
        /// The group identifier for the commitment modification.
        public var group: Swift.String?
        /// The unique identifier of the commitment modification.
        public var id: Swift.String?
        /// The Amazon Web Services account ID associated with this commitment modification.
        public var usageAccountId: Swift.String?

        public init(
            commitmentAction: BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationAction? = nil,
            group: Swift.String? = nil,
            id: Swift.String? = nil,
            usageAccountId: Swift.String? = nil
        )
        {
            self.commitmentAction = commitmentAction
            self.group = group
            self.id = id
            self.usageAccountId = usageAccountId
        }
    }
}

public struct ListBillEstimateInputCommitmentModificationsOutput: Swift.Sendable {
    /// The list of input commitment modifications associated with the bill estimate.
    public var items: [BCMPricingCalculatorClientTypes.BillEstimateInputCommitmentModificationSummary]?
    /// A token to retrieve the next page of results, if any.
    public var nextToken: Swift.String?

    public init(
        items: [BCMPricingCalculatorClientTypes.BillEstimateInputCommitmentModificationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum MatchOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contains
        case equals
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [MatchOption] {
            return [
                .contains,
                .equals,
                .startsWith
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .equals: return "EQUALS"
            case .startsWith: return "STARTS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum ListUsageFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case historicalLocation
        case historicalOperation
        case historicalServiceCode
        case historicalUsageAccountId
        case historicalUsageType
        case location
        case operation
        case serviceCode
        case usageAccountId
        case usageGroup
        case usageType
        case sdkUnknown(Swift.String)

        public static var allCases: [ListUsageFilterName] {
            return [
                .historicalLocation,
                .historicalOperation,
                .historicalServiceCode,
                .historicalUsageAccountId,
                .historicalUsageType,
                .location,
                .operation,
                .serviceCode,
                .usageAccountId,
                .usageGroup,
                .usageType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .historicalLocation: return "HISTORICAL_LOCATION"
            case .historicalOperation: return "HISTORICAL_OPERATION"
            case .historicalServiceCode: return "HISTORICAL_SERVICE_CODE"
            case .historicalUsageAccountId: return "HISTORICAL_USAGE_ACCOUNT_ID"
            case .historicalUsageType: return "HISTORICAL_USAGE_TYPE"
            case .location: return "LOCATION"
            case .operation: return "OPERATION"
            case .serviceCode: return "SERVICE_CODE"
            case .usageAccountId: return "USAGE_ACCOUNT_ID"
            case .usageGroup: return "USAGE_GROUP"
            case .usageType: return "USAGE_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents a filter for listing usage data.
    public struct ListUsageFilter: Swift.Sendable {
        /// The match option for the filter (e.g., equals, contains).
        public var matchOption: BCMPricingCalculatorClientTypes.MatchOption?
        /// The name of the filter attribute.
        /// This member is required.
        public var name: BCMPricingCalculatorClientTypes.ListUsageFilterName?
        /// The values to filter by.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            matchOption: BCMPricingCalculatorClientTypes.MatchOption? = nil,
            name: BCMPricingCalculatorClientTypes.ListUsageFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.matchOption = matchOption
            self.name = name
            self.values = values
        }
    }
}

public struct ListBillEstimateInputUsageModificationsInput: Swift.Sendable {
    /// The unique identifier of the bill estimate to list input usage modifications for.
    /// This member is required.
    public var billEstimateId: Swift.String?
    /// Filters to apply to the list of input usage modifications.
    public var filters: [BCMPricingCalculatorClientTypes.ListUsageFilter]?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// A token to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        billEstimateId: Swift.String? = nil,
        filters: [BCMPricingCalculatorClientTypes.ListUsageFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billEstimateId = billEstimateId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents a time interval for a bill or estimate.
    public struct BillInterval: Swift.Sendable {
        /// The end date and time of the interval.
        public var end: Foundation.Date?
        /// The start date and time of the interval.
        public var start: Foundation.Date?

        public init(
            end: Foundation.Date? = nil,
            start: Foundation.Date? = nil
        )
        {
            self.end = end
            self.start = start
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents a filter used within an expression.
    public struct ExpressionFilter: Swift.Sendable {
        /// The key or attribute to filter on.
        public var key: Swift.String?
        /// The match options for the filter (e.g., equals, contains).
        public var matchOptions: [Swift.String]?
        /// The values to match against.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            matchOptions: [Swift.String]? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents a usage quantity with associated unit and time period.
    public struct UsageQuantity: Swift.Sendable {
        /// The numeric value of the usage quantity.
        public var amount: Swift.Double?
        /// The start hour of the usage period.
        public var startHour: Foundation.Date?
        /// The unit of measurement for the usage quantity.
        public var unit: Swift.String?

        public init(
            amount: Swift.Double? = nil,
            startHour: Foundation.Date? = nil,
            unit: Swift.String? = nil
        )
        {
            self.amount = amount
            self.startHour = startHour
            self.unit = unit
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum ListBillEstimateLineItemsFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lineItemType
        case location
        case operation
        case serviceCode
        case usageAccountId
        case usageType
        case sdkUnknown(Swift.String)

        public static var allCases: [ListBillEstimateLineItemsFilterName] {
            return [
                .lineItemType,
                .location,
                .operation,
                .serviceCode,
                .usageAccountId,
                .usageType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lineItemType: return "LINE_ITEM_TYPE"
            case .location: return "LOCATION"
            case .operation: return "OPERATION"
            case .serviceCode: return "SERVICE_CODE"
            case .usageAccountId: return "USAGE_ACCOUNT_ID"
            case .usageType: return "USAGE_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents a filter for listing bill estimate line items.
    public struct ListBillEstimateLineItemsFilter: Swift.Sendable {
        /// The match option for the filter (e.g., equals, contains).
        public var matchOption: BCMPricingCalculatorClientTypes.MatchOption?
        /// The name of the filter attribute.
        /// This member is required.
        public var name: BCMPricingCalculatorClientTypes.ListBillEstimateLineItemsFilterName?
        /// The values to filter by.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            matchOption: BCMPricingCalculatorClientTypes.MatchOption? = nil,
            name: BCMPricingCalculatorClientTypes.ListBillEstimateLineItemsFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.matchOption = matchOption
            self.name = name
            self.values = values
        }
    }
}

public struct ListBillEstimateLineItemsInput: Swift.Sendable {
    /// The unique identifier of the bill estimate to list line items for.
    /// This member is required.
    public var billEstimateId: Swift.String?
    /// Filters to apply to the list of line items.
    public var filters: [BCMPricingCalculatorClientTypes.ListBillEstimateLineItemsFilter]?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// A token to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        billEstimateId: Swift.String? = nil,
        filters: [BCMPricingCalculatorClientTypes.ListBillEstimateLineItemsFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billEstimateId = billEstimateId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents the result of a usage quantity calculation.
    public struct UsageQuantityResult: Swift.Sendable {
        /// The numeric value of the usage quantity result.
        public var amount: Swift.Double?
        /// The unit of measurement for the usage quantity result.
        public var unit: Swift.String?

        public init(
            amount: Swift.Double? = nil,
            unit: Swift.String? = nil
        )
        {
            self.amount = amount
            self.unit = unit
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Provides a summary of a line item in a bill estimate.
    public struct BillEstimateLineItemSummary: Swift.Sendable {
        /// The availability zone associated with this line item, if applicable.
        public var availabilityZone: Swift.String?
        /// The estimated cost for this line item.
        public var estimatedCost: BCMPricingCalculatorClientTypes.CostAmount?
        /// The estimated usage quantity for this line item.
        public var estimatedUsageQuantity: BCMPricingCalculatorClientTypes.UsageQuantityResult?
        /// The historical cost for this line item.
        public var historicalCost: BCMPricingCalculatorClientTypes.CostAmount?
        /// The historical usage quantity for this line item.
        public var historicalUsageQuantity: BCMPricingCalculatorClientTypes.UsageQuantityResult?
        /// The unique identifier of this line item.
        public var id: Swift.String?
        /// The line item identifier from the original bill.
        public var lineItemId: Swift.String?
        /// The type of this line item (e.g., Usage, Tax, Credit).
        public var lineItemType: Swift.String?
        /// The location associated with this line item.
        public var location: Swift.String?
        /// The specific operation associated with this line item.
        /// This member is required.
        public var operation: Swift.String?
        /// The Amazon Web Services account ID of the payer for this line item.
        public var payerAccountId: Swift.String?
        /// The Amazon Resource Names (ARNs) of any Savings Plans applied to this line item.
        public var savingsPlanArns: [Swift.String]?
        /// The Amazon Web Services service code associated with this line item.
        /// This member is required.
        public var serviceCode: Swift.String?
        /// The Amazon Web Services account ID associated with the usage for this line item.
        public var usageAccountId: Swift.String?
        /// The type of usage for this line item.
        /// This member is required.
        public var usageType: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            estimatedCost: BCMPricingCalculatorClientTypes.CostAmount? = nil,
            estimatedUsageQuantity: BCMPricingCalculatorClientTypes.UsageQuantityResult? = nil,
            historicalCost: BCMPricingCalculatorClientTypes.CostAmount? = nil,
            historicalUsageQuantity: BCMPricingCalculatorClientTypes.UsageQuantityResult? = nil,
            id: Swift.String? = nil,
            lineItemId: Swift.String? = nil,
            lineItemType: Swift.String? = nil,
            location: Swift.String? = nil,
            operation: Swift.String? = nil,
            payerAccountId: Swift.String? = nil,
            savingsPlanArns: [Swift.String]? = nil,
            serviceCode: Swift.String? = nil,
            usageAccountId: Swift.String? = nil,
            usageType: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.estimatedCost = estimatedCost
            self.estimatedUsageQuantity = estimatedUsageQuantity
            self.historicalCost = historicalCost
            self.historicalUsageQuantity = historicalUsageQuantity
            self.id = id
            self.lineItemId = lineItemId
            self.lineItemType = lineItemType
            self.location = location
            self.operation = operation
            self.payerAccountId = payerAccountId
            self.savingsPlanArns = savingsPlanArns
            self.serviceCode = serviceCode
            self.usageAccountId = usageAccountId
            self.usageType = usageType
        }
    }
}

public struct ListBillEstimateLineItemsOutput: Swift.Sendable {
    /// The list of line items associated with the bill estimate.
    public var items: [BCMPricingCalculatorClientTypes.BillEstimateLineItemSummary]?
    /// A token to retrieve the next page of results, if any.
    public var nextToken: Swift.String?

    public init(
        items: [BCMPricingCalculatorClientTypes.BillEstimateLineItemSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum BillEstimateStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [BillEstimateStatus] {
            return [
                .complete,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request could not be processed because of conflict in the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that was not found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that was not found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictCode" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

public struct CreateBillEstimateInput: Swift.Sendable {
    /// The ID of the Bill Scenario for which you want to create a Bill estimate.
    /// This member is required.
    public var billScenarioId: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The name of the Bill estimate that will be created. Names must be unique for an account.
    /// This member is required.
    public var name: Swift.String?
    /// An optional list of tags to associate with the specified BillEstimate. You can use resource tags to control access to your BillEstimate using IAM policies. Each tag consists of a key and a value, and each key must be unique for the resource. The following restrictions apply to resource tags:
    ///
    /// * Although the maximum number of array members is 200, you can assign a maximum of 50 user-tags to one resource. The remaining are reserved for Amazon Web Services.
    ///
    /// * The maximum length of a key is 128 characters.
    ///
    /// * The maximum length of a value is 256 characters.
    ///
    /// * Keys and values can only contain alphanumeric characters, spaces, and any of the following: _.:/=+@-.
    ///
    /// * Keys and values are case sensitive.
    ///
    /// * Keys and values are trimmed for any leading or trailing whitespaces.
    ///
    /// * Don't use aws: as a prefix for your keys. This prefix is reserved for Amazon Web Services.
    public var tags: [Swift.String: Swift.String]?

    public init(
        billScenarioId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.billScenarioId = billScenarioId
        self.clientToken = clientToken
        self.name = name
        self.tags = tags
    }
}

public struct CreateBillEstimateOutput: Swift.Sendable {
    /// The bill month start and end timestamp that was used to create the Bill estimate. This is set to the last complete anniversary bill month start and end timestamp.
    public var billInterval: BCMPricingCalculatorClientTypes.BillInterval?
    /// Returns summary-level cost information once a Bill estimate is successfully generated. This summary includes: 1) the total cost difference, showing the pre-tax cost change for the consolidated billing family between the completed anniversary bill and the estimated bill, and 2) total cost differences per service, detailing the pre-tax cost of each service, comparing the completed anniversary bill to the estimated bill on a per-service basis.
    public var costSummary: BCMPricingCalculatorClientTypes.BillEstimateCostSummary?
    /// The timestamp of when the Bill estimate create process was started (not when it successfully completed or failed).
    public var createdAt: Foundation.Date?
    /// The timestamp of when the Bill estimate will expire. A Bill estimate becomes inaccessible after expiration.
    public var expiresAt: Foundation.Date?
    /// This attribute provides the reason if a Bill estimate result generation fails.
    public var failureMessage: Swift.String?
    /// The unique identifier of your newly created Bill estimate.
    /// This member is required.
    public var id: Swift.String?
    /// The name of your newly created Bill estimate.
    public var name: Swift.String?
    /// The status of your newly created Bill estimate. Bill estimate creation can take anywhere between 8 to 12 hours. The status will allow you to identify when the Bill estimate is complete or has failed.
    public var status: BCMPricingCalculatorClientTypes.BillEstimateStatus?

    public init(
        billInterval: BCMPricingCalculatorClientTypes.BillInterval? = nil,
        costSummary: BCMPricingCalculatorClientTypes.BillEstimateCostSummary? = nil,
        createdAt: Foundation.Date? = nil,
        expiresAt: Foundation.Date? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: BCMPricingCalculatorClientTypes.BillEstimateStatus? = nil
    )
    {
        self.billInterval = billInterval
        self.costSummary = costSummary
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.failureMessage = failureMessage
        self.id = id
        self.name = name
        self.status = status
    }
}

public struct DeleteBillEstimateInput: Swift.Sendable {
    /// The unique identifier of the bill estimate to delete.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct DeleteBillEstimateOutput: Swift.Sendable {

    public init() { }
}

public struct GetBillEstimateInput: Swift.Sendable {
    /// The unique identifier of the bill estimate to retrieve.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct GetBillEstimateOutput: Swift.Sendable {
    /// The time period covered by the bill estimate.
    public var billInterval: BCMPricingCalculatorClientTypes.BillInterval?
    /// A summary of the estimated costs.
    public var costSummary: BCMPricingCalculatorClientTypes.BillEstimateCostSummary?
    /// The timestamp when the bill estimate was created.
    public var createdAt: Foundation.Date?
    /// The timestamp when the bill estimate will expire.
    public var expiresAt: Foundation.Date?
    /// An error message if the bill estimate retrieval failed.
    public var failureMessage: Swift.String?
    /// The unique identifier of the retrieved bill estimate.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the retrieved bill estimate.
    public var name: Swift.String?
    /// The current status of the bill estimate.
    public var status: BCMPricingCalculatorClientTypes.BillEstimateStatus?

    public init(
        billInterval: BCMPricingCalculatorClientTypes.BillInterval? = nil,
        costSummary: BCMPricingCalculatorClientTypes.BillEstimateCostSummary? = nil,
        createdAt: Foundation.Date? = nil,
        expiresAt: Foundation.Date? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: BCMPricingCalculatorClientTypes.BillEstimateStatus? = nil
    )
    {
        self.billInterval = billInterval
        self.costSummary = costSummary
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.failureMessage = failureMessage
        self.id = id
        self.name = name
        self.status = status
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents a time-based filter.
    public struct FilterTimestamp: Swift.Sendable {
        /// Include results after this timestamp.
        public var afterTimestamp: Foundation.Date?
        /// Include results before this timestamp.
        public var beforeTimestamp: Foundation.Date?

        public init(
            afterTimestamp: Foundation.Date? = nil,
            beforeTimestamp: Foundation.Date? = nil
        )
        {
            self.afterTimestamp = afterTimestamp
            self.beforeTimestamp = beforeTimestamp
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum ListBillEstimatesFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case name
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [ListBillEstimatesFilterName] {
            return [
                .name,
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .name: return "NAME"
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents a filter for listing bill estimates.
    public struct ListBillEstimatesFilter: Swift.Sendable {
        /// The match option for the filter (e.g., equals, contains).
        public var matchOption: BCMPricingCalculatorClientTypes.MatchOption?
        /// The name of the filter attribute.
        /// This member is required.
        public var name: BCMPricingCalculatorClientTypes.ListBillEstimatesFilterName?
        /// The values to filter by.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            matchOption: BCMPricingCalculatorClientTypes.MatchOption? = nil,
            name: BCMPricingCalculatorClientTypes.ListBillEstimatesFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.matchOption = matchOption
            self.name = name
            self.values = values
        }
    }
}

public struct ListBillEstimatesInput: Swift.Sendable {
    /// Filter bill estimates based on their creation date.
    public var createdAtFilter: BCMPricingCalculatorClientTypes.FilterTimestamp?
    /// Filter bill estimates based on their expiration date.
    public var expiresAtFilter: BCMPricingCalculatorClientTypes.FilterTimestamp?
    /// Filters to apply to the list of bill estimates.
    public var filters: [BCMPricingCalculatorClientTypes.ListBillEstimatesFilter]?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// A token to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        createdAtFilter: BCMPricingCalculatorClientTypes.FilterTimestamp? = nil,
        expiresAtFilter: BCMPricingCalculatorClientTypes.FilterTimestamp? = nil,
        filters: [BCMPricingCalculatorClientTypes.ListBillEstimatesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.createdAtFilter = createdAtFilter
        self.expiresAtFilter = expiresAtFilter
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Provides a summary of a bill estimate.
    public struct BillEstimateSummary: Swift.Sendable {
        /// The time period covered by the bill estimate.
        public var billInterval: BCMPricingCalculatorClientTypes.BillInterval?
        /// The timestamp when the bill estimate was created.
        public var createdAt: Foundation.Date?
        /// The timestamp when the bill estimate will expire.
        public var expiresAt: Foundation.Date?
        /// The unique identifier of the bill estimate.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the bill estimate.
        public var name: Swift.String?
        /// The current status of the bill estimate.
        public var status: BCMPricingCalculatorClientTypes.BillEstimateStatus?

        public init(
            billInterval: BCMPricingCalculatorClientTypes.BillInterval? = nil,
            createdAt: Foundation.Date? = nil,
            expiresAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: BCMPricingCalculatorClientTypes.BillEstimateStatus? = nil
        )
        {
            self.billInterval = billInterval
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.id = id
            self.name = name
            self.status = status
        }
    }
}

public struct ListBillEstimatesOutput: Swift.Sendable {
    /// The list of bill estimates for the account.
    public var items: [BCMPricingCalculatorClientTypes.BillEstimateSummary]?
    /// A token to retrieve the next page of results, if any.
    public var nextToken: Swift.String?

    public init(
        items: [BCMPricingCalculatorClientTypes.BillEstimateSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UpdateBillEstimateInput: Swift.Sendable {
    /// The new expiration date for the bill estimate.
    public var expiresAt: Foundation.Date?
    /// The unique identifier of the bill estimate to update.
    /// This member is required.
    public var identifier: Swift.String?
    /// The new name for the bill estimate.
    public var name: Swift.String?

    public init(
        expiresAt: Foundation.Date? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.expiresAt = expiresAt
        self.identifier = identifier
        self.name = name
    }
}

public struct UpdateBillEstimateOutput: Swift.Sendable {
    /// The time period covered by the updated bill estimate.
    public var billInterval: BCMPricingCalculatorClientTypes.BillInterval?
    /// A summary of the updated estimated costs.
    public var costSummary: BCMPricingCalculatorClientTypes.BillEstimateCostSummary?
    /// The timestamp when the bill estimate was originally created.
    public var createdAt: Foundation.Date?
    /// The updated expiration timestamp for the bill estimate.
    public var expiresAt: Foundation.Date?
    /// An error message if the bill estimate update failed.
    public var failureMessage: Swift.String?
    /// The unique identifier of the updated bill estimate.
    /// This member is required.
    public var id: Swift.String?
    /// The updated name of the bill estimate.
    public var name: Swift.String?
    /// The current status of the updated bill estimate.
    public var status: BCMPricingCalculatorClientTypes.BillEstimateStatus?

    public init(
        billInterval: BCMPricingCalculatorClientTypes.BillInterval? = nil,
        costSummary: BCMPricingCalculatorClientTypes.BillEstimateCostSummary? = nil,
        createdAt: Foundation.Date? = nil,
        expiresAt: Foundation.Date? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: BCMPricingCalculatorClientTypes.BillEstimateStatus? = nil
    )
    {
        self.billInterval = billInterval
        self.costSummary = costSummary
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.failureMessage = failureMessage
        self.id = id
        self.name = name
        self.status = status
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents an entry object in the batch operation to create bill scenario commitment modifications.
    public struct BatchCreateBillScenarioCommitmentModificationEntry: Swift.Sendable {
        /// The specific commitment action to be taken (e.g., adding a Reserved Instance or Savings Plan).
        /// This member is required.
        public var commitmentAction: BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationAction?
        /// An optional group identifier for the commitment modification.
        public var group: Swift.String?
        /// A unique identifier for this entry in the batch operation. This can be any valid string. This key is useful to identify errors associated with any commitment entry as any error is returned with this key.
        /// This member is required.
        public var key: Swift.String?
        /// The Amazon Web Services account ID to which this commitment will be applied to.
        /// This member is required.
        public var usageAccountId: Swift.String?

        public init(
            commitmentAction: BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationAction? = nil,
            group: Swift.String? = nil,
            key: Swift.String? = nil,
            usageAccountId: Swift.String? = nil
        )
        {
            self.commitmentAction = commitmentAction
            self.group = group
            self.key = key
            self.usageAccountId = usageAccountId
        }
    }
}

public struct BatchCreateBillScenarioCommitmentModificationInput: Swift.Sendable {
    /// The ID of the Bill Scenario for which you want to create the modeled commitment.
    /// This member is required.
    public var billScenarioId: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// List of commitments that you want to model in the Bill Scenario.
    /// This member is required.
    public var commitmentModifications: [BCMPricingCalculatorClientTypes.BatchCreateBillScenarioCommitmentModificationEntry]?

    public init(
        billScenarioId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        commitmentModifications: [BCMPricingCalculatorClientTypes.BatchCreateBillScenarioCommitmentModificationEntry]? = nil
    )
    {
        self.billScenarioId = billScenarioId
        self.clientToken = clientToken
        self.commitmentModifications = commitmentModifications
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum BatchCreateBillScenarioCommitmentModificationErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case conflict
        case internalServerError
        case invalidAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchCreateBillScenarioCommitmentModificationErrorCode] {
            return [
                .conflict,
                .internalServerError,
                .invalidAccount
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .conflict: return "CONFLICT"
            case .internalServerError: return "INTERNAL_SERVER_ERROR"
            case .invalidAccount: return "INVALID_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents an error that occurred during a batch create operation for bill scenario commitment modifications.
    public struct BatchCreateBillScenarioCommitmentModificationError: Swift.Sendable {
        /// The error code associated with the failed operation.
        public var errorCode: BCMPricingCalculatorClientTypes.BatchCreateBillScenarioCommitmentModificationErrorCode?
        /// A descriptive message for the error that occurred.
        public var errorMessage: Swift.String?
        /// The key of the entry that caused the error.
        public var key: Swift.String?

        public init(
            errorCode: BCMPricingCalculatorClientTypes.BatchCreateBillScenarioCommitmentModificationErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.key = key
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents a successfully created item in a batch operation for bill scenario commitment modifications.
    public struct BatchCreateBillScenarioCommitmentModificationItem: Swift.Sendable {
        /// The specific commitment action that was taken.
        public var commitmentAction: BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationAction?
        /// The group identifier for the created commitment modification.
        public var group: Swift.String?
        /// The unique identifier assigned to the created commitment modification.
        public var id: Swift.String?
        /// The key of the successfully created entry. This can be any valid string. This key is useful to identify errors associated with any commitment entry as any error is returned with this key.
        public var key: Swift.String?
        /// The Amazon Web Services account ID associated with the created commitment modification.
        public var usageAccountId: Swift.String?

        public init(
            commitmentAction: BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationAction? = nil,
            group: Swift.String? = nil,
            id: Swift.String? = nil,
            key: Swift.String? = nil,
            usageAccountId: Swift.String? = nil
        )
        {
            self.commitmentAction = commitmentAction
            self.group = group
            self.id = id
            self.key = key
            self.usageAccountId = usageAccountId
        }
    }
}

public struct BatchCreateBillScenarioCommitmentModificationOutput: Swift.Sendable {
    /// Returns the list of errors reason and the commitment item keys that cannot be created in the Bill Scenario.
    public var errors: [BCMPricingCalculatorClientTypes.BatchCreateBillScenarioCommitmentModificationError]?
    /// Returns the list of successful commitment line items that were created for the Bill Scenario.
    public var items: [BCMPricingCalculatorClientTypes.BatchCreateBillScenarioCommitmentModificationItem]?

    public init(
        errors: [BCMPricingCalculatorClientTypes.BatchCreateBillScenarioCommitmentModificationError]? = nil,
        items: [BCMPricingCalculatorClientTypes.BatchCreateBillScenarioCommitmentModificationItem]? = nil
    )
    {
        self.errors = errors
        self.items = items
    }
}

public struct BatchDeleteBillScenarioCommitmentModificationInput: Swift.Sendable {
    /// The ID of the Bill Scenario for which you want to delete the modeled commitment.
    /// This member is required.
    public var billScenarioId: Swift.String?
    /// List of commitments that you want to delete from the Bill Scenario.
    /// This member is required.
    public var ids: [Swift.String]?

    public init(
        billScenarioId: Swift.String? = nil,
        ids: [Swift.String]? = nil
    )
    {
        self.billScenarioId = billScenarioId
        self.ids = ids
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum BatchDeleteBillScenarioCommitmentModificationErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case badRequest
        case conflict
        case internalServerError
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchDeleteBillScenarioCommitmentModificationErrorCode] {
            return [
                .badRequest,
                .conflict,
                .internalServerError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .badRequest: return "BAD_REQUEST"
            case .conflict: return "CONFLICT"
            case .internalServerError: return "INTERNAL_SERVER_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents an error that occurred when deleting a commitment in a Bill Scenario.
    public struct BatchDeleteBillScenarioCommitmentModificationError: Swift.Sendable {
        /// The code associated with the error.
        public var errorCode: BCMPricingCalculatorClientTypes.BatchDeleteBillScenarioCommitmentModificationErrorCode?
        /// The message that describes the error.
        public var errorMessage: Swift.String?
        /// The ID of the error.
        public var id: Swift.String?

        public init(
            errorCode: BCMPricingCalculatorClientTypes.BatchDeleteBillScenarioCommitmentModificationErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }
    }
}

public struct BatchDeleteBillScenarioCommitmentModificationOutput: Swift.Sendable {
    /// Returns the list of errors reason and the commitment item keys that cannot be deleted from the Bill Scenario.
    public var errors: [BCMPricingCalculatorClientTypes.BatchDeleteBillScenarioCommitmentModificationError]?

    public init(
        errors: [BCMPricingCalculatorClientTypes.BatchDeleteBillScenarioCommitmentModificationError]? = nil
    )
    {
        self.errors = errors
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents an entry in a batch operation to update bill scenario commitment modifications.
    public struct BatchUpdateBillScenarioCommitmentModificationEntry: Swift.Sendable {
        /// The updated group identifier for the commitment modification.
        public var group: Swift.String?
        /// The unique identifier of the commitment modification to update.
        /// This member is required.
        public var id: Swift.String?

        public init(
            group: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.group = group
            self.id = id
        }
    }
}

public struct BatchUpdateBillScenarioCommitmentModificationInput: Swift.Sendable {
    /// The ID of the Bill Scenario for which you want to modify the commitment group of a modeled commitment.
    /// This member is required.
    public var billScenarioId: Swift.String?
    /// List of commitments that you want to update in a Bill Scenario.
    /// This member is required.
    public var commitmentModifications: [BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioCommitmentModificationEntry]?

    public init(
        billScenarioId: Swift.String? = nil,
        commitmentModifications: [BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioCommitmentModificationEntry]? = nil
    )
    {
        self.billScenarioId = billScenarioId
        self.commitmentModifications = commitmentModifications
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum BatchUpdateBillScenarioCommitmentModificationErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case badRequest
        case conflict
        case internalServerError
        case notFound
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchUpdateBillScenarioCommitmentModificationErrorCode] {
            return [
                .badRequest,
                .conflict,
                .internalServerError,
                .notFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .badRequest: return "BAD_REQUEST"
            case .conflict: return "CONFLICT"
            case .internalServerError: return "INTERNAL_SERVER_ERROR"
            case .notFound: return "NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents an error that occurred when updating a commitment in a Bill Scenario.
    public struct BatchUpdateBillScenarioCommitmentModificationError: Swift.Sendable {
        /// The code associated with the error.
        public var errorCode: BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioCommitmentModificationErrorCode?
        /// The message that describes the error.
        public var errorMessage: Swift.String?
        /// The ID of the error.
        public var id: Swift.String?

        public init(
            errorCode: BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioCommitmentModificationErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents a commitment modification item in a bill scenario.
    public struct BillScenarioCommitmentModificationItem: Swift.Sendable {
        /// The specific commitment action taken in this modification.
        public var commitmentAction: BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationAction?
        /// The group identifier for the commitment modification.
        public var group: Swift.String?
        /// The unique identifier of the commitment modification.
        public var id: Swift.String?
        /// The Amazon Web Services account ID associated with this commitment modification.
        public var usageAccountId: Swift.String?

        public init(
            commitmentAction: BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationAction? = nil,
            group: Swift.String? = nil,
            id: Swift.String? = nil,
            usageAccountId: Swift.String? = nil
        )
        {
            self.commitmentAction = commitmentAction
            self.group = group
            self.id = id
            self.usageAccountId = usageAccountId
        }
    }
}

public struct BatchUpdateBillScenarioCommitmentModificationOutput: Swift.Sendable {
    /// Returns the list of error reasons and commitment line item IDs that could not be updated for the Bill Scenario.
    public var errors: [BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioCommitmentModificationError]?
    /// Returns the list of successful commitment line items that were updated for a Bill Scenario.
    public var items: [BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationItem]?

    public init(
        errors: [BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioCommitmentModificationError]? = nil,
        items: [BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationItem]? = nil
    )
    {
        self.errors = errors
        self.items = items
    }
}

public struct ListBillScenarioCommitmentModificationsInput: Swift.Sendable {
    /// The unique identifier of the bill scenario to list commitment modifications for.
    /// This member is required.
    public var billScenarioId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// A token to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        billScenarioId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billScenarioId = billScenarioId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListBillScenarioCommitmentModificationsOutput: Swift.Sendable {
    /// The list of commitment modifications associated with the bill scenario.
    public var items: [BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationItem]?
    /// A token to retrieve the next page of results, if any.
    public var nextToken: Swift.String?

    public init(
        items: [BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum BillScenarioStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case locked
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [BillScenarioStatus] {
            return [
                .failed,
                .locked,
                .ready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .locked: return "LOCKED"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request would cause you to exceed your service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota code that was exceeded.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The identifier of the resource that exceeded quota.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that exceeded quota.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// The service code that exceeded quota.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaCode" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents a usage amount for a specific time period.
    public struct UsageAmount: Swift.Sendable {
        /// The usage amount for the period.
        /// This member is required.
        public var amount: Swift.Double?
        /// The start hour of the usage period.
        /// This member is required.
        public var startHour: Foundation.Date?

        public init(
            amount: Swift.Double? = nil,
            startHour: Foundation.Date? = nil
        )
        {
            self.amount = amount
            self.startHour = startHour
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum BatchCreateBillScenarioUsageModificationErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case badRequest
        case conflict
        case internalServerError
        case notFound
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchCreateBillScenarioUsageModificationErrorCode] {
            return [
                .badRequest,
                .conflict,
                .internalServerError,
                .notFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .badRequest: return "BAD_REQUEST"
            case .conflict: return "CONFLICT"
            case .internalServerError: return "INTERNAL_SERVER_ERROR"
            case .notFound: return "NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents an error that occurred during a batch create operation for bill scenario usage modifications.
    public struct BatchCreateBillScenarioUsageModificationError: Swift.Sendable {
        /// The error code associated with the failed operation.
        public var errorCode: BCMPricingCalculatorClientTypes.BatchCreateBillScenarioUsageModificationErrorCode?
        /// A descriptive message for the error that occurred.
        public var errorMessage: Swift.String?
        /// The key of the entry that caused the error.
        public var key: Swift.String?

        public init(
            errorCode: BCMPricingCalculatorClientTypes.BatchCreateBillScenarioUsageModificationErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.key = key
        }
    }
}

public struct BatchDeleteBillScenarioUsageModificationInput: Swift.Sendable {
    /// The ID of the Bill Scenario for which you want to delete the modeled usage.
    /// This member is required.
    public var billScenarioId: Swift.String?
    /// List of usage that you want to delete from the Bill Scenario.
    /// This member is required.
    public var ids: [Swift.String]?

    public init(
        billScenarioId: Swift.String? = nil,
        ids: [Swift.String]? = nil
    )
    {
        self.billScenarioId = billScenarioId
        self.ids = ids
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum BatchDeleteBillScenarioUsageModificationErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case badRequest
        case conflict
        case internalServerError
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchDeleteBillScenarioUsageModificationErrorCode] {
            return [
                .badRequest,
                .conflict,
                .internalServerError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .badRequest: return "BAD_REQUEST"
            case .conflict: return "CONFLICT"
            case .internalServerError: return "INTERNAL_SERVER_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents an error that occurred when deleting usage in a Bill Scenario.
    public struct BatchDeleteBillScenarioUsageModificationError: Swift.Sendable {
        /// The code associated with the error.
        public var errorCode: BCMPricingCalculatorClientTypes.BatchDeleteBillScenarioUsageModificationErrorCode?
        /// The message that describes the error.
        public var errorMessage: Swift.String?
        /// The ID of the error.
        public var id: Swift.String?

        public init(
            errorCode: BCMPricingCalculatorClientTypes.BatchDeleteBillScenarioUsageModificationErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }
    }
}

public struct BatchDeleteBillScenarioUsageModificationOutput: Swift.Sendable {
    /// Returns the list of errors reason and the usage item keys that cannot be deleted from the Bill Scenario.
    public var errors: [BCMPricingCalculatorClientTypes.BatchDeleteBillScenarioUsageModificationError]?

    public init(
        errors: [BCMPricingCalculatorClientTypes.BatchDeleteBillScenarioUsageModificationError]? = nil
    )
    {
        self.errors = errors
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents an entry in a batch operation to update bill scenario usage modifications.
    public struct BatchUpdateBillScenarioUsageModificationEntry: Swift.Sendable {
        /// The updated usage amounts for the modification.
        public var amounts: [BCMPricingCalculatorClientTypes.UsageAmount]?
        /// The updated group identifier for the usage modification.
        public var group: Swift.String?
        /// The unique identifier of the usage modification to update.
        /// This member is required.
        public var id: Swift.String?

        public init(
            amounts: [BCMPricingCalculatorClientTypes.UsageAmount]? = nil,
            group: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.amounts = amounts
            self.group = group
            self.id = id
        }
    }
}

public struct BatchUpdateBillScenarioUsageModificationInput: Swift.Sendable {
    /// The ID of the Bill Scenario for which you want to modify the usage lines.
    /// This member is required.
    public var billScenarioId: Swift.String?
    /// List of usage lines that you want to update in a Bill Scenario identified by the usage ID.
    /// This member is required.
    public var usageModifications: [BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioUsageModificationEntry]?

    public init(
        billScenarioId: Swift.String? = nil,
        usageModifications: [BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioUsageModificationEntry]? = nil
    )
    {
        self.billScenarioId = billScenarioId
        self.usageModifications = usageModifications
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum BatchUpdateBillScenarioUsageModificationErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case badRequest
        case conflict
        case internalServerError
        case notFound
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchUpdateBillScenarioUsageModificationErrorCode] {
            return [
                .badRequest,
                .conflict,
                .internalServerError,
                .notFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .badRequest: return "BAD_REQUEST"
            case .conflict: return "CONFLICT"
            case .internalServerError: return "INTERNAL_SERVER_ERROR"
            case .notFound: return "NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents an error that occurred when updating usage in a Bill Scenario.
    public struct BatchUpdateBillScenarioUsageModificationError: Swift.Sendable {
        /// The code associated with the error.
        public var errorCode: BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioUsageModificationErrorCode?
        /// The message that describes the error.
        public var errorMessage: Swift.String?
        /// The ID of the error.
        public var id: Swift.String?

        public init(
            errorCode: BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioUsageModificationErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }
    }
}

public struct ListBillScenarioUsageModificationsInput: Swift.Sendable {
    /// The unique identifier of the bill scenario to list usage modifications for.
    /// This member is required.
    public var billScenarioId: Swift.String?
    /// Filters to apply to the list of usage modifications.
    public var filters: [BCMPricingCalculatorClientTypes.ListUsageFilter]?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// A token to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        billScenarioId: Swift.String? = nil,
        filters: [BCMPricingCalculatorClientTypes.ListUsageFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.billScenarioId = billScenarioId
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct CreateBillScenarioInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A descriptive name for the bill scenario.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to apply to the bill scenario.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.tags = tags
    }
}

public struct CreateBillScenarioOutput: Swift.Sendable {
    /// The time period covered by the bill scenario.
    public var billInterval: BCMPricingCalculatorClientTypes.BillInterval?
    /// The timestamp when the bill scenario was created.
    public var createdAt: Foundation.Date?
    /// The timestamp when the bill scenario will expire.
    public var expiresAt: Foundation.Date?
    /// An error message if the bill scenario creation failed.
    public var failureMessage: Swift.String?
    /// The unique identifier for the created bill scenario.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the created bill scenario.
    public var name: Swift.String?
    /// The current status of the bill scenario.
    public var status: BCMPricingCalculatorClientTypes.BillScenarioStatus?

    public init(
        billInterval: BCMPricingCalculatorClientTypes.BillInterval? = nil,
        createdAt: Foundation.Date? = nil,
        expiresAt: Foundation.Date? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: BCMPricingCalculatorClientTypes.BillScenarioStatus? = nil
    )
    {
        self.billInterval = billInterval
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.failureMessage = failureMessage
        self.id = id
        self.name = name
        self.status = status
    }
}

public struct DeleteBillScenarioInput: Swift.Sendable {
    /// The unique identifier of the bill scenario to delete.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct DeleteBillScenarioOutput: Swift.Sendable {

    public init() { }
}

public struct GetBillScenarioInput: Swift.Sendable {
    /// The unique identifier of the bill scenario to retrieve.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct GetBillScenarioOutput: Swift.Sendable {
    /// The time period covered by the bill scenario.
    public var billInterval: BCMPricingCalculatorClientTypes.BillInterval?
    /// The timestamp when the bill scenario was created.
    public var createdAt: Foundation.Date?
    /// The timestamp when the bill scenario will expire.
    public var expiresAt: Foundation.Date?
    /// An error message if the bill scenario retrieval failed.
    public var failureMessage: Swift.String?
    /// The unique identifier of the retrieved bill scenario.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the retrieved bill scenario.
    public var name: Swift.String?
    /// The current status of the bill scenario.
    public var status: BCMPricingCalculatorClientTypes.BillScenarioStatus?

    public init(
        billInterval: BCMPricingCalculatorClientTypes.BillInterval? = nil,
        createdAt: Foundation.Date? = nil,
        expiresAt: Foundation.Date? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: BCMPricingCalculatorClientTypes.BillScenarioStatus? = nil
    )
    {
        self.billInterval = billInterval
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.failureMessage = failureMessage
        self.id = id
        self.name = name
        self.status = status
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum ListBillScenariosFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case name
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [ListBillScenariosFilterName] {
            return [
                .name,
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .name: return "NAME"
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents a filter for listing bill scenarios.
    public struct ListBillScenariosFilter: Swift.Sendable {
        /// The match option for the filter (e.g., equals, contains).
        public var matchOption: BCMPricingCalculatorClientTypes.MatchOption?
        /// The name of the filter attribute.
        /// This member is required.
        public var name: BCMPricingCalculatorClientTypes.ListBillScenariosFilterName?
        /// The values to filter by.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            matchOption: BCMPricingCalculatorClientTypes.MatchOption? = nil,
            name: BCMPricingCalculatorClientTypes.ListBillScenariosFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.matchOption = matchOption
            self.name = name
            self.values = values
        }
    }
}

public struct ListBillScenariosInput: Swift.Sendable {
    /// Filter bill scenarios based on their creation date.
    public var createdAtFilter: BCMPricingCalculatorClientTypes.FilterTimestamp?
    /// Filter bill scenarios based on their expiration date.
    public var expiresAtFilter: BCMPricingCalculatorClientTypes.FilterTimestamp?
    /// Filters to apply to the list of bill scenarios.
    public var filters: [BCMPricingCalculatorClientTypes.ListBillScenariosFilter]?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// A token to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        createdAtFilter: BCMPricingCalculatorClientTypes.FilterTimestamp? = nil,
        expiresAtFilter: BCMPricingCalculatorClientTypes.FilterTimestamp? = nil,
        filters: [BCMPricingCalculatorClientTypes.ListBillScenariosFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.createdAtFilter = createdAtFilter
        self.expiresAtFilter = expiresAtFilter
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Provides a summary of a bill scenario.
    public struct BillScenarioSummary: Swift.Sendable {
        /// The time period covered by the bill scenario.
        public var billInterval: BCMPricingCalculatorClientTypes.BillInterval?
        /// The timestamp when the bill scenario was created.
        public var createdAt: Foundation.Date?
        /// The timestamp when the bill scenario will expire.
        public var expiresAt: Foundation.Date?
        /// An error message if the bill scenario creation or processing failed.
        public var failureMessage: Swift.String?
        /// The unique identifier of the bill scenario.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the bill scenario.
        public var name: Swift.String?
        /// The current status of the bill scenario.
        public var status: BCMPricingCalculatorClientTypes.BillScenarioStatus?

        public init(
            billInterval: BCMPricingCalculatorClientTypes.BillInterval? = nil,
            createdAt: Foundation.Date? = nil,
            expiresAt: Foundation.Date? = nil,
            failureMessage: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: BCMPricingCalculatorClientTypes.BillScenarioStatus? = nil
        )
        {
            self.billInterval = billInterval
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.failureMessage = failureMessage
            self.id = id
            self.name = name
            self.status = status
        }
    }
}

public struct ListBillScenariosOutput: Swift.Sendable {
    /// The list of bill scenarios for the account.
    public var items: [BCMPricingCalculatorClientTypes.BillScenarioSummary]?
    /// A token to retrieve the next page of results, if any.
    public var nextToken: Swift.String?

    public init(
        items: [BCMPricingCalculatorClientTypes.BillScenarioSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UpdateBillScenarioInput: Swift.Sendable {
    /// The new expiration date for the bill scenario.
    public var expiresAt: Foundation.Date?
    /// The unique identifier of the bill scenario to update.
    /// This member is required.
    public var identifier: Swift.String?
    /// The new name for the bill scenario.
    public var name: Swift.String?

    public init(
        expiresAt: Foundation.Date? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.expiresAt = expiresAt
        self.identifier = identifier
        self.name = name
    }
}

public struct UpdateBillScenarioOutput: Swift.Sendable {
    /// The time period covered by the updated bill scenario.
    public var billInterval: BCMPricingCalculatorClientTypes.BillInterval?
    /// The timestamp when the bill scenario was originally created.
    public var createdAt: Foundation.Date?
    /// The updated expiration timestamp for the bill scenario.
    public var expiresAt: Foundation.Date?
    /// An error message if the bill scenario update failed.
    public var failureMessage: Swift.String?
    /// The unique identifier of the updated bill scenario.
    /// This member is required.
    public var id: Swift.String?
    /// The updated name of the bill scenario.
    public var name: Swift.String?
    /// The current status of the updated bill scenario.
    public var status: BCMPricingCalculatorClientTypes.BillScenarioStatus?

    public init(
        billInterval: BCMPricingCalculatorClientTypes.BillInterval? = nil,
        createdAt: Foundation.Date? = nil,
        expiresAt: Foundation.Date? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        status: BCMPricingCalculatorClientTypes.BillScenarioStatus? = nil
    )
    {
        self.billInterval = billInterval
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.failureMessage = failureMessage
        self.id = id
        self.name = name
        self.status = status
    }
}

public struct GetPreferencesInput: Swift.Sendable {

    public init() { }
}

extension BCMPricingCalculatorClientTypes {

    public enum RateType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case afterDiscounts
        case beforeDiscounts
        case sdkUnknown(Swift.String)

        public static var allCases: [RateType] {
            return [
                .afterDiscounts,
                .beforeDiscounts
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .afterDiscounts: return "AFTER_DISCOUNTS"
            case .beforeDiscounts: return "BEFORE_DISCOUNTS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetPreferencesOutput: Swift.Sendable {
    /// The preferred rate types for the management account.
    public var managementAccountRateTypeSelections: [BCMPricingCalculatorClientTypes.RateType]?
    /// The preferred rate types for member accounts.
    public var memberAccountRateTypeSelections: [BCMPricingCalculatorClientTypes.RateType]?

    public init(
        managementAccountRateTypeSelections: [BCMPricingCalculatorClientTypes.RateType]? = nil,
        memberAccountRateTypeSelections: [BCMPricingCalculatorClientTypes.RateType]? = nil
    )
    {
        self.managementAccountRateTypeSelections = managementAccountRateTypeSelections
        self.memberAccountRateTypeSelections = memberAccountRateTypeSelections
    }
}

/// An internal error has occurred. Retry your request, but if the problem persists, contact Amazon Web Services support.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// An internal error has occurred. Retry your request, but if the problem persists, contact Amazon Web Services support.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to list tags for.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The list of tags associated with the specified resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to add tags to.
    /// This member is required.
    public var arn: Swift.String?
    /// The tags to add to the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota code that exceeded the throttling limit.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The service code that exceeded the throttling limit. Retry your request, but if the problem persists, contact Amazon Web Services support.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The service code that exceeded the throttling limit.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingCode" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to remove tags from.
    /// This member is required.
    public var arn: Swift.String?
    /// The keys of the tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.arn = arn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdatePreferencesInput: Swift.Sendable {
    /// The updated preferred rate types for the management account.
    public var managementAccountRateTypeSelections: [BCMPricingCalculatorClientTypes.RateType]?
    /// The updated preferred rate types for member accounts.
    public var memberAccountRateTypeSelections: [BCMPricingCalculatorClientTypes.RateType]?

    public init(
        managementAccountRateTypeSelections: [BCMPricingCalculatorClientTypes.RateType]? = nil,
        memberAccountRateTypeSelections: [BCMPricingCalculatorClientTypes.RateType]? = nil
    )
    {
        self.managementAccountRateTypeSelections = managementAccountRateTypeSelections
        self.memberAccountRateTypeSelections = memberAccountRateTypeSelections
    }
}

public struct UpdatePreferencesOutput: Swift.Sendable {
    /// The updated preferred rate types for the management account.
    public var managementAccountRateTypeSelections: [BCMPricingCalculatorClientTypes.RateType]?
    /// The updated preferred rate types for member accounts.
    public var memberAccountRateTypeSelections: [BCMPricingCalculatorClientTypes.RateType]?

    public init(
        managementAccountRateTypeSelections: [BCMPricingCalculatorClientTypes.RateType]? = nil,
        memberAccountRateTypeSelections: [BCMPricingCalculatorClientTypes.RateType]? = nil
    )
    {
        self.managementAccountRateTypeSelections = managementAccountRateTypeSelections
        self.memberAccountRateTypeSelections = memberAccountRateTypeSelections
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents a field that failed validation in a request.
    public struct ValidationExceptionField: Swift.Sendable {
        /// The error message describing why the field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case disallowedRate
        case fieldValidationFailed
        case invalidRequestFromMember
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .disallowedRate,
                .fieldValidationFailed,
                .invalidRequestFromMember,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .disallowedRate: return "disallowedRate"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .invalidRequestFromMember: return "invalidRequestFromMember"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input provided fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The list of fields that are invalid.
        public internal(set) var fieldList: [BCMPricingCalculatorClientTypes.ValidationExceptionField]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the validation exception.
        public internal(set) var reason: BCMPricingCalculatorClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [BCMPricingCalculatorClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: BCMPricingCalculatorClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum WorkloadEstimateRateType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case afterDiscounts
        case beforeDiscounts
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadEstimateRateType] {
            return [
                .afterDiscounts,
                .beforeDiscounts
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .afterDiscounts: return "AFTER_DISCOUNTS"
            case .beforeDiscounts: return "BEFORE_DISCOUNTS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateWorkloadEstimateInput: Swift.Sendable {
    /// A unique, case-sensitive identifier to ensure idempotency of the request.
    public var clientToken: Swift.String?
    /// A descriptive name for the workload estimate.
    /// This member is required.
    public var name: Swift.String?
    /// The type of pricing rates to use for the estimate.
    public var rateType: BCMPricingCalculatorClientTypes.WorkloadEstimateRateType?
    /// The tags to apply to the workload estimate.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        rateType: BCMPricingCalculatorClientTypes.WorkloadEstimateRateType? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.rateType = rateType
        self.tags = tags
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum WorkloadEstimateStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actionNeeded
        case invalid
        case updating
        case valid
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadEstimateStatus] {
            return [
                .actionNeeded,
                .invalid,
                .updating,
                .valid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actionNeeded: return "ACTION_NEEDED"
            case .invalid: return "INVALID"
            case .updating: return "UPDATING"
            case .valid: return "VALID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Mixin for common fields returned by CRUD APIs
public struct CreateWorkloadEstimateOutput: Swift.Sendable {
    /// The currency of the estimated cost.
    public var costCurrency: BCMPricingCalculatorClientTypes.CurrencyCode?
    /// The timestamp when the workload estimate was created.
    public var createdAt: Foundation.Date?
    /// The timestamp when the workload estimate will expire.
    public var expiresAt: Foundation.Date?
    /// An error message if the workload estimate creation failed.
    public var failureMessage: Swift.String?
    /// The unique identifier for the created workload estimate.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the created workload estimate.
    public var name: Swift.String?
    /// The timestamp of the pricing rates used for the estimate.
    public var rateTimestamp: Foundation.Date?
    /// The type of pricing rates used for the estimate.
    public var rateType: BCMPricingCalculatorClientTypes.WorkloadEstimateRateType?
    /// The current status of the workload estimate.
    public var status: BCMPricingCalculatorClientTypes.WorkloadEstimateStatus?
    /// The total estimated cost for the workload.
    public var totalCost: Swift.Double?

    public init(
        costCurrency: BCMPricingCalculatorClientTypes.CurrencyCode? = nil,
        createdAt: Foundation.Date? = nil,
        expiresAt: Foundation.Date? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        rateTimestamp: Foundation.Date? = nil,
        rateType: BCMPricingCalculatorClientTypes.WorkloadEstimateRateType? = nil,
        status: BCMPricingCalculatorClientTypes.WorkloadEstimateStatus? = nil,
        totalCost: Swift.Double? = nil
    )
    {
        self.costCurrency = costCurrency
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.failureMessage = failureMessage
        self.id = id
        self.name = name
        self.rateTimestamp = rateTimestamp
        self.rateType = rateType
        self.status = status
        self.totalCost = totalCost
    }
}

public struct DeleteWorkloadEstimateInput: Swift.Sendable {
    /// The unique identifier of the workload estimate to delete.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

public struct DeleteWorkloadEstimateOutput: Swift.Sendable {

    public init() { }
}

public struct GetWorkloadEstimateInput: Swift.Sendable {
    /// The unique identifier of the workload estimate to retrieve.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    )
    {
        self.identifier = identifier
    }
}

/// Mixin for common fields returned by CRUD APIs
public struct GetWorkloadEstimateOutput: Swift.Sendable {
    /// The currency of the estimated cost.
    public var costCurrency: BCMPricingCalculatorClientTypes.CurrencyCode?
    /// The timestamp when the workload estimate was created.
    public var createdAt: Foundation.Date?
    /// The timestamp when the workload estimate will expire.
    public var expiresAt: Foundation.Date?
    /// An error message if the workload estimate retrieval failed.
    public var failureMessage: Swift.String?
    /// The unique identifier of the retrieved workload estimate.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the retrieved workload estimate.
    public var name: Swift.String?
    /// The timestamp of the pricing rates used for the estimate.
    public var rateTimestamp: Foundation.Date?
    /// The type of pricing rates used for the estimate.
    public var rateType: BCMPricingCalculatorClientTypes.WorkloadEstimateRateType?
    /// The current status of the workload estimate.
    public var status: BCMPricingCalculatorClientTypes.WorkloadEstimateStatus?
    /// The total estimated cost for the workload.
    public var totalCost: Swift.Double?

    public init(
        costCurrency: BCMPricingCalculatorClientTypes.CurrencyCode? = nil,
        createdAt: Foundation.Date? = nil,
        expiresAt: Foundation.Date? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        rateTimestamp: Foundation.Date? = nil,
        rateType: BCMPricingCalculatorClientTypes.WorkloadEstimateRateType? = nil,
        status: BCMPricingCalculatorClientTypes.WorkloadEstimateStatus? = nil,
        totalCost: Swift.Double? = nil
    )
    {
        self.costCurrency = costCurrency
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.failureMessage = failureMessage
        self.id = id
        self.name = name
        self.rateTimestamp = rateTimestamp
        self.rateType = rateType
        self.status = status
        self.totalCost = totalCost
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum ListWorkloadEstimatesFilterName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case name
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [ListWorkloadEstimatesFilterName] {
            return [
                .name,
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .name: return "NAME"
            case .status: return "STATUS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents a filter for listing workload estimates.
    public struct ListWorkloadEstimatesFilter: Swift.Sendable {
        /// The match option for the filter (e.g., equals, contains).
        public var matchOption: BCMPricingCalculatorClientTypes.MatchOption?
        /// The name of the filter attribute.
        /// This member is required.
        public var name: BCMPricingCalculatorClientTypes.ListWorkloadEstimatesFilterName?
        /// The values to filter by.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            matchOption: BCMPricingCalculatorClientTypes.MatchOption? = nil,
            name: BCMPricingCalculatorClientTypes.ListWorkloadEstimatesFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.matchOption = matchOption
            self.name = name
            self.values = values
        }
    }
}

public struct ListWorkloadEstimatesInput: Swift.Sendable {
    /// Filter workload estimates based on their creation date.
    public var createdAtFilter: BCMPricingCalculatorClientTypes.FilterTimestamp?
    /// Filter workload estimates based on their expiration date.
    public var expiresAtFilter: BCMPricingCalculatorClientTypes.FilterTimestamp?
    /// Filters to apply to the list of workload estimates.
    public var filters: [BCMPricingCalculatorClientTypes.ListWorkloadEstimatesFilter]?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// A token to retrieve the next page of results.
    public var nextToken: Swift.String?

    public init(
        createdAtFilter: BCMPricingCalculatorClientTypes.FilterTimestamp? = nil,
        expiresAtFilter: BCMPricingCalculatorClientTypes.FilterTimestamp? = nil,
        filters: [BCMPricingCalculatorClientTypes.ListWorkloadEstimatesFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.createdAtFilter = createdAtFilter
        self.expiresAtFilter = expiresAtFilter
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Provides a summary of a workload estimate.
    public struct WorkloadEstimateSummary: Swift.Sendable {
        /// The currency of the estimated cost.
        public var costCurrency: BCMPricingCalculatorClientTypes.CurrencyCode?
        /// The timestamp when the workload estimate was created.
        public var createdAt: Foundation.Date?
        /// The timestamp when the workload estimate will expire.
        public var expiresAt: Foundation.Date?
        /// An error message if the workload estimate creation or processing failed.
        public var failureMessage: Swift.String?
        /// The unique identifier of the workload estimate.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the workload estimate.
        public var name: Swift.String?
        /// The timestamp of the pricing rates used for the estimate.
        public var rateTimestamp: Foundation.Date?
        /// The type of pricing rates used for the estimate.
        public var rateType: BCMPricingCalculatorClientTypes.WorkloadEstimateRateType?
        /// The current status of the workload estimate.
        public var status: BCMPricingCalculatorClientTypes.WorkloadEstimateStatus?
        /// The total estimated cost for the workload.
        public var totalCost: Swift.Double?

        public init(
            costCurrency: BCMPricingCalculatorClientTypes.CurrencyCode? = nil,
            createdAt: Foundation.Date? = nil,
            expiresAt: Foundation.Date? = nil,
            failureMessage: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            rateTimestamp: Foundation.Date? = nil,
            rateType: BCMPricingCalculatorClientTypes.WorkloadEstimateRateType? = nil,
            status: BCMPricingCalculatorClientTypes.WorkloadEstimateStatus? = nil,
            totalCost: Swift.Double? = nil
        )
        {
            self.costCurrency = costCurrency
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.failureMessage = failureMessage
            self.id = id
            self.name = name
            self.rateTimestamp = rateTimestamp
            self.rateType = rateType
            self.status = status
            self.totalCost = totalCost
        }
    }
}

public struct ListWorkloadEstimatesOutput: Swift.Sendable {
    /// The list of workload estimates for the account.
    public var items: [BCMPricingCalculatorClientTypes.WorkloadEstimateSummary]?
    /// A token to retrieve the next page of results, if any.
    public var nextToken: Swift.String?

    public init(
        items: [BCMPricingCalculatorClientTypes.WorkloadEstimateSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UpdateWorkloadEstimateInput: Swift.Sendable {
    /// The new expiration date for the workload estimate.
    public var expiresAt: Foundation.Date?
    /// The unique identifier of the workload estimate to update.
    /// This member is required.
    public var identifier: Swift.String?
    /// The new name for the workload estimate.
    public var name: Swift.String?

    public init(
        expiresAt: Foundation.Date? = nil,
        identifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.expiresAt = expiresAt
        self.identifier = identifier
        self.name = name
    }
}

/// Mixin for common fields returned by CRUD APIs
public struct UpdateWorkloadEstimateOutput: Swift.Sendable {
    /// The currency of the updated estimated cost.
    public var costCurrency: BCMPricingCalculatorClientTypes.CurrencyCode?
    /// The timestamp when the workload estimate was originally created.
    public var createdAt: Foundation.Date?
    /// The updated expiration timestamp for the workload estimate.
    public var expiresAt: Foundation.Date?
    /// An error message if the workload estimate update failed.
    public var failureMessage: Swift.String?
    /// The unique identifier of the updated workload estimate.
    /// This member is required.
    public var id: Swift.String?
    /// The updated name of the workload estimate.
    public var name: Swift.String?
    /// The timestamp of the pricing rates used for the updated estimate.
    public var rateTimestamp: Foundation.Date?
    /// The type of pricing rates used for the updated estimate.
    public var rateType: BCMPricingCalculatorClientTypes.WorkloadEstimateRateType?
    /// The current status of the updated workload estimate.
    public var status: BCMPricingCalculatorClientTypes.WorkloadEstimateStatus?
    /// The updated total estimated cost for the workload.
    public var totalCost: Swift.Double?

    public init(
        costCurrency: BCMPricingCalculatorClientTypes.CurrencyCode? = nil,
        createdAt: Foundation.Date? = nil,
        expiresAt: Foundation.Date? = nil,
        failureMessage: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        rateTimestamp: Foundation.Date? = nil,
        rateType: BCMPricingCalculatorClientTypes.WorkloadEstimateRateType? = nil,
        status: BCMPricingCalculatorClientTypes.WorkloadEstimateStatus? = nil,
        totalCost: Swift.Double? = nil
    )
    {
        self.costCurrency = costCurrency
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.failureMessage = failureMessage
        self.id = id
        self.name = name
        self.rateTimestamp = rateTimestamp
        self.rateType = rateType
        self.status = status
        self.totalCost = totalCost
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum BatchCreateWorkloadEstimateUsageCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case badRequest
        case conflict
        case internalServerError
        case notFound
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchCreateWorkloadEstimateUsageCode] {
            return [
                .badRequest,
                .conflict,
                .internalServerError,
                .notFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .badRequest: return "BAD_REQUEST"
            case .conflict: return "CONFLICT"
            case .internalServerError: return "INTERNAL_SERVER_ERROR"
            case .notFound: return "NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents an error that occurred during a batch create operation for workload estimate usage.
    public struct BatchCreateWorkloadEstimateUsageError: Swift.Sendable {
        /// The error code associated with the failed operation.
        public var errorCode: BCMPricingCalculatorClientTypes.BatchCreateWorkloadEstimateUsageCode?
        /// A descriptive message for the error that occurred.
        public var errorMessage: Swift.String?
        /// The key of the entry that caused the error.
        public var key: Swift.String?

        public init(
            errorCode: BCMPricingCalculatorClientTypes.BatchCreateWorkloadEstimateUsageCode? = nil,
            errorMessage: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.key = key
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents a usage quantity for a workload estimate.
    public struct WorkloadEstimateUsageQuantity: Swift.Sendable {
        /// The numeric value of the usage quantity.
        public var amount: Swift.Double?
        /// The unit of measurement for the usage quantity.
        public var unit: Swift.String?

        public init(
            amount: Swift.Double? = nil,
            unit: Swift.String? = nil
        )
        {
            self.amount = amount
            self.unit = unit
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum WorkloadEstimateCostStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case invalid
        case stale
        case valid
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadEstimateCostStatus] {
            return [
                .invalid,
                .stale,
                .valid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .invalid: return "INVALID"
            case .stale: return "STALE"
            case .valid: return "VALID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct BatchDeleteWorkloadEstimateUsageInput: Swift.Sendable {
    /// List of usage that you want to delete from the Workload estimate.
    /// This member is required.
    public var ids: [Swift.String]?
    /// The ID of the Workload estimate for which you want to delete the modeled usage.
    /// This member is required.
    public var workloadEstimateId: Swift.String?

    public init(
        ids: [Swift.String]? = nil,
        workloadEstimateId: Swift.String? = nil
    )
    {
        self.ids = ids
        self.workloadEstimateId = workloadEstimateId
    }
}

extension BCMPricingCalculatorClientTypes {

    public enum WorkloadEstimateUpdateUsageErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case badRequest
        case conflict
        case internalServerError
        case notFound
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkloadEstimateUpdateUsageErrorCode] {
            return [
                .badRequest,
                .conflict,
                .internalServerError,
                .notFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .badRequest: return "BAD_REQUEST"
            case .conflict: return "CONFLICT"
            case .internalServerError: return "INTERNAL_SERVER_ERROR"
            case .notFound: return "NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents an error that occurred when deleting usage in a workload estimate.
    public struct BatchDeleteWorkloadEstimateUsageError: Swift.Sendable {
        /// The code associated with the error.
        public var errorCode: BCMPricingCalculatorClientTypes.WorkloadEstimateUpdateUsageErrorCode?
        /// The message that describes the error.
        public var errorMessage: Swift.String?
        /// The ID of the error.
        public var id: Swift.String?

        public init(
            errorCode: BCMPricingCalculatorClientTypes.WorkloadEstimateUpdateUsageErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }
    }
}

public struct BatchDeleteWorkloadEstimateUsageOutput: Swift.Sendable {
    /// Returns the list of errors reason and the usage item keys that cannot be deleted from the Workload estimate.
    public var errors: [BCMPricingCalculatorClientTypes.BatchDeleteWorkloadEstimateUsageError]?

    public init(
        errors: [BCMPricingCalculatorClientTypes.BatchDeleteWorkloadEstimateUsageError]? = nil
    )
    {
        self.errors = errors
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents an entry in a batch operation to update workload estimate usage.
    public struct BatchUpdateWorkloadEstimateUsageEntry: Swift.Sendable {
        /// The updated estimated usage amount.
        public var amount: Swift.Double?
        /// The updated group identifier for the usage estimate.
        public var group: Swift.String?
        /// The unique identifier of the usage estimate to update.
        /// This member is required.
        public var id: Swift.String?

        public init(
            amount: Swift.Double? = nil,
            group: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.amount = amount
            self.group = group
            self.id = id
        }
    }
}

public struct BatchUpdateWorkloadEstimateUsageInput: Swift.Sendable {
    /// List of usage line amounts and usage group that you want to update in a Workload estimate identified by the usage ID.
    /// This member is required.
    public var usage: [BCMPricingCalculatorClientTypes.BatchUpdateWorkloadEstimateUsageEntry]?
    /// The ID of the Workload estimate for which you want to modify the usage lines.
    /// This member is required.
    public var workloadEstimateId: Swift.String?

    public init(
        usage: [BCMPricingCalculatorClientTypes.BatchUpdateWorkloadEstimateUsageEntry]? = nil,
        workloadEstimateId: Swift.String? = nil
    )
    {
        self.usage = usage
        self.workloadEstimateId = workloadEstimateId
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents an error that occurred when updating usage in a workload estimate.
    public struct BatchUpdateWorkloadEstimateUsageError: Swift.Sendable {
        /// The code associated with the error.
        public var errorCode: BCMPricingCalculatorClientTypes.WorkloadEstimateUpdateUsageErrorCode?
        /// The message that describes the error.
        public var errorMessage: Swift.String?
        /// The ID of the error.
        public var id: Swift.String?

        public init(
            errorCode: BCMPricingCalculatorClientTypes.WorkloadEstimateUpdateUsageErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.id = id
        }
    }
}

public struct ListWorkloadEstimateUsageInput: Swift.Sendable {
    /// Filters to apply to the list of usage items.
    public var filters: [BCMPricingCalculatorClientTypes.ListUsageFilter]?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// A token to retrieve the next page of results.
    public var nextToken: Swift.String?
    /// The unique identifier of the workload estimate to list usage for.
    /// This member is required.
    public var workloadEstimateId: Swift.String?

    public init(
        filters: [BCMPricingCalculatorClientTypes.ListUsageFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workloadEstimateId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workloadEstimateId = workloadEstimateId
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents a complex filtering expression for cost and usage data.
    public struct Expression: Swift.Sendable {
        /// A list of expressions to be combined with AND logic.
        public var and: [BCMPricingCalculatorClientTypes.Expression]?
        /// Filters based on cost categories.
        public var costCategories: BCMPricingCalculatorClientTypes.ExpressionFilter?
        /// Filters based on dimensions (e.g., service, operation).
        public var dimensions: BCMPricingCalculatorClientTypes.ExpressionFilter?
        /// An expression to be negated.
        @Indirect public var not: BCMPricingCalculatorClientTypes.Expression?
        /// A list of expressions to be combined with OR logic.
        public var or: [BCMPricingCalculatorClientTypes.Expression]?
        /// Filters based on resource tags.
        public var tags: BCMPricingCalculatorClientTypes.ExpressionFilter?

        public init(
            and: [BCMPricingCalculatorClientTypes.Expression]? = nil,
            costCategories: BCMPricingCalculatorClientTypes.ExpressionFilter? = nil,
            dimensions: BCMPricingCalculatorClientTypes.ExpressionFilter? = nil,
            not: BCMPricingCalculatorClientTypes.Expression? = nil,
            or: [BCMPricingCalculatorClientTypes.Expression]? = nil,
            tags: BCMPricingCalculatorClientTypes.ExpressionFilter? = nil
        )
        {
            self.and = and
            self.costCategories = costCategories
            self.dimensions = dimensions
            self.not = not
            self.or = or
            self.tags = tags
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents historical usage data for a specific entity.
    public struct HistoricalUsageEntity: Swift.Sendable {
        /// The time interval for the historical usage data.
        /// This member is required.
        public var billInterval: BCMPricingCalculatorClientTypes.BillInterval?
        /// An optional filter expression to apply to the historical usage data.
        /// This member is required.
        public var filterExpression: BCMPricingCalculatorClientTypes.Expression?
        /// The location associated with the usage.
        public var location: Swift.String?
        /// The specific operation associated with the usage.
        /// This member is required.
        public var operation: Swift.String?
        /// The Amazon Web Services service code associated with the usage.
        /// This member is required.
        public var serviceCode: Swift.String?
        /// The Amazon Web Services account ID associated with the usage.
        /// This member is required.
        public var usageAccountId: Swift.String?
        /// The type of usage.
        /// This member is required.
        public var usageType: Swift.String?

        public init(
            billInterval: BCMPricingCalculatorClientTypes.BillInterval? = nil,
            filterExpression: BCMPricingCalculatorClientTypes.Expression? = nil,
            location: Swift.String? = nil,
            operation: Swift.String? = nil,
            serviceCode: Swift.String? = nil,
            usageAccountId: Swift.String? = nil,
            usageType: Swift.String? = nil
        )
        {
            self.billInterval = billInterval
            self.filterExpression = filterExpression
            self.location = location
            self.operation = operation
            self.serviceCode = serviceCode
            self.usageAccountId = usageAccountId
            self.usageType = usageType
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents an entry in a batch operation to create bill scenario usage modifications.
    public struct BatchCreateBillScenarioUsageModificationEntry: Swift.Sendable {
        /// The amount of usage you want to create for the service use you are modeling.
        public var amounts: [BCMPricingCalculatorClientTypes.UsageAmount]?
        /// The Availability Zone that this usage line uses.
        public var availabilityZone: Swift.String?
        /// An optional group identifier for the usage modification.
        public var group: Swift.String?
        /// Historical usage data associated with this modification, if available.
        public var historicalUsage: BCMPricingCalculatorClientTypes.HistoricalUsageEntity?
        /// A unique identifier for this entry in the batch operation. This can be any valid string. This key is useful to identify errors associated with any usage entry as any error is returned with this key.
        /// This member is required.
        public var key: Swift.String?
        /// The specific operation associated with this usage modification. Describes the specific Amazon Web Services operation that this usage line models. For example, RunInstances indicates the operation of an Amazon EC2 instance.
        /// This member is required.
        public var operation: Swift.String?
        /// The Amazon Web Services service code for this usage modification. This identifies the specific Amazon Web Services service to the customer as a unique short abbreviation. For example, AmazonEC2 and AWSKMS.
        /// This member is required.
        public var serviceCode: Swift.String?
        /// The Amazon Web Services account ID to which this usage will be applied to.
        /// This member is required.
        public var usageAccountId: Swift.String?
        /// Describes the usage details of the usage line item.
        /// This member is required.
        public var usageType: Swift.String?

        public init(
            amounts: [BCMPricingCalculatorClientTypes.UsageAmount]? = nil,
            availabilityZone: Swift.String? = nil,
            group: Swift.String? = nil,
            historicalUsage: BCMPricingCalculatorClientTypes.HistoricalUsageEntity? = nil,
            key: Swift.String? = nil,
            operation: Swift.String? = nil,
            serviceCode: Swift.String? = nil,
            usageAccountId: Swift.String? = nil,
            usageType: Swift.String? = nil
        )
        {
            self.amounts = amounts
            self.availabilityZone = availabilityZone
            self.group = group
            self.historicalUsage = historicalUsage
            self.key = key
            self.operation = operation
            self.serviceCode = serviceCode
            self.usageAccountId = usageAccountId
            self.usageType = usageType
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents a successfully created item in a batch operation for bill scenario usage modifications.
    public struct BatchCreateBillScenarioUsageModificationItem: Swift.Sendable {
        /// The availability zone associated with this usage modification, if applicable.
        public var availabilityZone: Swift.String?
        /// The group identifier for the created usage modification.
        public var group: Swift.String?
        /// Historical usage data associated with this modification, if available.
        public var historicalUsage: BCMPricingCalculatorClientTypes.HistoricalUsageEntity?
        /// The unique identifier assigned to the created usage modification.
        public var id: Swift.String?
        /// The key of the successfully created entry.
        public var key: Swift.String?
        /// The location associated with this usage modification.
        public var location: Swift.String?
        /// The specific operation associated with this usage modification.
        /// This member is required.
        public var operation: Swift.String?
        /// The modified usage quantities.
        public var quantities: [BCMPricingCalculatorClientTypes.UsageQuantity]?
        /// The Amazon Web Services service code for this usage modification.
        /// This member is required.
        public var serviceCode: Swift.String?
        /// The Amazon Web Services account ID associated with the created usage modification.
        public var usageAccountId: Swift.String?
        /// The type of usage that was modified.
        /// This member is required.
        public var usageType: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            group: Swift.String? = nil,
            historicalUsage: BCMPricingCalculatorClientTypes.HistoricalUsageEntity? = nil,
            id: Swift.String? = nil,
            key: Swift.String? = nil,
            location: Swift.String? = nil,
            operation: Swift.String? = nil,
            quantities: [BCMPricingCalculatorClientTypes.UsageQuantity]? = nil,
            serviceCode: Swift.String? = nil,
            usageAccountId: Swift.String? = nil,
            usageType: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.group = group
            self.historicalUsage = historicalUsage
            self.id = id
            self.key = key
            self.location = location
            self.operation = operation
            self.quantities = quantities
            self.serviceCode = serviceCode
            self.usageAccountId = usageAccountId
            self.usageType = usageType
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents an entry in a batch operation to create workload estimate usage.
    public struct BatchCreateWorkloadEstimateUsageEntry: Swift.Sendable {
        /// The estimated usage amount.
        /// This member is required.
        public var amount: Swift.Double?
        /// An optional group identifier for the usage estimate.
        public var group: Swift.String?
        /// Historical usage data associated with this estimate, if available.
        public var historicalUsage: BCMPricingCalculatorClientTypes.HistoricalUsageEntity?
        /// A unique identifier for this entry in the batch operation.
        /// This member is required.
        public var key: Swift.String?
        /// The specific operation associated with this usage estimate.
        /// This member is required.
        public var operation: Swift.String?
        /// The Amazon Web Services service code for this usage estimate.
        /// This member is required.
        public var serviceCode: Swift.String?
        /// The Amazon Web Services account ID associated with this usage estimate.
        /// This member is required.
        public var usageAccountId: Swift.String?
        /// The type of usage being estimated.
        /// This member is required.
        public var usageType: Swift.String?

        public init(
            amount: Swift.Double? = nil,
            group: Swift.String? = nil,
            historicalUsage: BCMPricingCalculatorClientTypes.HistoricalUsageEntity? = nil,
            key: Swift.String? = nil,
            operation: Swift.String? = nil,
            serviceCode: Swift.String? = nil,
            usageAccountId: Swift.String? = nil,
            usageType: Swift.String? = nil
        )
        {
            self.amount = amount
            self.group = group
            self.historicalUsage = historicalUsage
            self.key = key
            self.operation = operation
            self.serviceCode = serviceCode
            self.usageAccountId = usageAccountId
            self.usageType = usageType
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents a successfully created item in a batch operation for workload estimate usage.
    public struct BatchCreateWorkloadEstimateUsageItem: Swift.Sendable {
        /// The estimated cost associated with this usage.
        public var cost: Swift.Double?
        /// The currency of the estimated cost.
        public var currency: BCMPricingCalculatorClientTypes.CurrencyCode?
        /// The group identifier for the created usage estimate.
        public var group: Swift.String?
        /// Historical usage data associated with this estimate, if available.
        public var historicalUsage: BCMPricingCalculatorClientTypes.HistoricalUsageEntity?
        /// The unique identifier assigned to the created usage estimate.
        public var id: Swift.String?
        /// The key of the successfully created entry.
        public var key: Swift.String?
        /// The location associated with this usage estimate.
        public var location: Swift.String?
        /// The specific operation associated with this usage estimate.
        /// This member is required.
        public var operation: Swift.String?
        /// The estimated usage quantity.
        public var quantity: BCMPricingCalculatorClientTypes.WorkloadEstimateUsageQuantity?
        /// The Amazon Web Services service code for this usage estimate.
        /// This member is required.
        public var serviceCode: Swift.String?
        /// The current status of the created usage estimate.
        public var status: BCMPricingCalculatorClientTypes.WorkloadEstimateCostStatus?
        /// The Amazon Web Services account ID associated with the created usage estimate.
        public var usageAccountId: Swift.String?
        /// The type of usage that was estimated.
        /// This member is required.
        public var usageType: Swift.String?

        public init(
            cost: Swift.Double? = nil,
            currency: BCMPricingCalculatorClientTypes.CurrencyCode? = nil,
            group: Swift.String? = nil,
            historicalUsage: BCMPricingCalculatorClientTypes.HistoricalUsageEntity? = nil,
            id: Swift.String? = nil,
            key: Swift.String? = nil,
            location: Swift.String? = nil,
            operation: Swift.String? = nil,
            quantity: BCMPricingCalculatorClientTypes.WorkloadEstimateUsageQuantity? = nil,
            serviceCode: Swift.String? = nil,
            status: BCMPricingCalculatorClientTypes.WorkloadEstimateCostStatus? = nil,
            usageAccountId: Swift.String? = nil,
            usageType: Swift.String? = nil
        )
        {
            self.cost = cost
            self.currency = currency
            self.group = group
            self.historicalUsage = historicalUsage
            self.id = id
            self.key = key
            self.location = location
            self.operation = operation
            self.quantity = quantity
            self.serviceCode = serviceCode
            self.status = status
            self.usageAccountId = usageAccountId
            self.usageType = usageType
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Summarizes an input usage modification for a bill estimate.
    public struct BillEstimateInputUsageModificationSummary: Swift.Sendable {
        /// The availability zone associated with this usage modification, if applicable.
        public var availabilityZone: Swift.String?
        /// The group identifier for the usage modification.
        public var group: Swift.String?
        /// Historical usage data associated with this modification, if available.
        public var historicalUsage: BCMPricingCalculatorClientTypes.HistoricalUsageEntity?
        /// The unique identifier of the usage modification.
        public var id: Swift.String?
        /// The location associated with this usage modification.
        public var location: Swift.String?
        /// The specific operation associated with this usage modification.
        /// This member is required.
        public var operation: Swift.String?
        /// The modified usage quantities.
        public var quantities: [BCMPricingCalculatorClientTypes.UsageQuantity]?
        /// The Amazon Web Services service code for this usage modification.
        /// This member is required.
        public var serviceCode: Swift.String?
        /// The Amazon Web Services account ID associated with this usage modification.
        public var usageAccountId: Swift.String?
        /// The type of usage being modified.
        /// This member is required.
        public var usageType: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            group: Swift.String? = nil,
            historicalUsage: BCMPricingCalculatorClientTypes.HistoricalUsageEntity? = nil,
            id: Swift.String? = nil,
            location: Swift.String? = nil,
            operation: Swift.String? = nil,
            quantities: [BCMPricingCalculatorClientTypes.UsageQuantity]? = nil,
            serviceCode: Swift.String? = nil,
            usageAccountId: Swift.String? = nil,
            usageType: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.group = group
            self.historicalUsage = historicalUsage
            self.id = id
            self.location = location
            self.operation = operation
            self.quantities = quantities
            self.serviceCode = serviceCode
            self.usageAccountId = usageAccountId
            self.usageType = usageType
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents a usage modification item in a bill scenario.
    public struct BillScenarioUsageModificationItem: Swift.Sendable {
        /// The availability zone associated with this usage modification, if applicable.
        public var availabilityZone: Swift.String?
        /// The group identifier for the usage modification.
        public var group: Swift.String?
        /// Historical usage data associated with this modification, if available.
        public var historicalUsage: BCMPricingCalculatorClientTypes.HistoricalUsageEntity?
        /// The unique identifier of the usage modification.
        public var id: Swift.String?
        /// The location associated with this usage modification.
        public var location: Swift.String?
        /// The specific operation associated with this usage modification.
        /// This member is required.
        public var operation: Swift.String?
        /// The modified usage quantities.
        public var quantities: [BCMPricingCalculatorClientTypes.UsageQuantity]?
        /// The Amazon Web Services service code for this usage modification.
        /// This member is required.
        public var serviceCode: Swift.String?
        /// The Amazon Web Services account ID associated with this usage modification.
        public var usageAccountId: Swift.String?
        /// The type of usage being modified.
        /// This member is required.
        public var usageType: Swift.String?

        public init(
            availabilityZone: Swift.String? = nil,
            group: Swift.String? = nil,
            historicalUsage: BCMPricingCalculatorClientTypes.HistoricalUsageEntity? = nil,
            id: Swift.String? = nil,
            location: Swift.String? = nil,
            operation: Swift.String? = nil,
            quantities: [BCMPricingCalculatorClientTypes.UsageQuantity]? = nil,
            serviceCode: Swift.String? = nil,
            usageAccountId: Swift.String? = nil,
            usageType: Swift.String? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.group = group
            self.historicalUsage = historicalUsage
            self.id = id
            self.location = location
            self.operation = operation
            self.quantities = quantities
            self.serviceCode = serviceCode
            self.usageAccountId = usageAccountId
            self.usageType = usageType
        }
    }
}

extension BCMPricingCalculatorClientTypes {

    /// Represents a usage item in a workload estimate.
    public struct WorkloadEstimateUsageItem: Swift.Sendable {
        /// The estimated cost for this usage item.
        public var cost: Swift.Double?
        /// The currency of the estimated cost.
        public var currency: BCMPricingCalculatorClientTypes.CurrencyCode?
        /// The group identifier for this usage item.
        public var group: Swift.String?
        /// Historical usage data associated with this item, if available.
        public var historicalUsage: BCMPricingCalculatorClientTypes.HistoricalUsageEntity?
        /// The unique identifier of this usage item.
        public var id: Swift.String?
        /// The location associated with this usage item.
        public var location: Swift.String?
        /// The specific operation associated with this usage item.
        /// This member is required.
        public var operation: Swift.String?
        /// The estimated usage quantity for this item.
        public var quantity: BCMPricingCalculatorClientTypes.WorkloadEstimateUsageQuantity?
        /// The Amazon Web Services service code associated with this usage item.
        /// This member is required.
        public var serviceCode: Swift.String?
        /// The current status of this usage item.
        public var status: BCMPricingCalculatorClientTypes.WorkloadEstimateCostStatus?
        /// The Amazon Web Services account ID associated with this usage item.
        public var usageAccountId: Swift.String?
        /// The type of usage for this item.
        /// This member is required.
        public var usageType: Swift.String?

        public init(
            cost: Swift.Double? = nil,
            currency: BCMPricingCalculatorClientTypes.CurrencyCode? = nil,
            group: Swift.String? = nil,
            historicalUsage: BCMPricingCalculatorClientTypes.HistoricalUsageEntity? = nil,
            id: Swift.String? = nil,
            location: Swift.String? = nil,
            operation: Swift.String? = nil,
            quantity: BCMPricingCalculatorClientTypes.WorkloadEstimateUsageQuantity? = nil,
            serviceCode: Swift.String? = nil,
            status: BCMPricingCalculatorClientTypes.WorkloadEstimateCostStatus? = nil,
            usageAccountId: Swift.String? = nil,
            usageType: Swift.String? = nil
        )
        {
            self.cost = cost
            self.currency = currency
            self.group = group
            self.historicalUsage = historicalUsage
            self.id = id
            self.location = location
            self.operation = operation
            self.quantity = quantity
            self.serviceCode = serviceCode
            self.status = status
            self.usageAccountId = usageAccountId
            self.usageType = usageType
        }
    }
}

public struct BatchCreateBillScenarioUsageModificationInput: Swift.Sendable {
    /// The ID of the Bill Scenario for which you want to create the modeled usage.
    /// This member is required.
    public var billScenarioId: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// List of usage that you want to model in the Bill Scenario.
    /// This member is required.
    public var usageModifications: [BCMPricingCalculatorClientTypes.BatchCreateBillScenarioUsageModificationEntry]?

    public init(
        billScenarioId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        usageModifications: [BCMPricingCalculatorClientTypes.BatchCreateBillScenarioUsageModificationEntry]? = nil
    )
    {
        self.billScenarioId = billScenarioId
        self.clientToken = clientToken
        self.usageModifications = usageModifications
    }
}

public struct BatchCreateBillScenarioUsageModificationOutput: Swift.Sendable {
    /// Returns the list of errors reason and the usage item keys that cannot be created in the Bill Scenario.
    public var errors: [BCMPricingCalculatorClientTypes.BatchCreateBillScenarioUsageModificationError]?
    /// Returns the list of successful usage line items that were created for the Bill Scenario.
    public var items: [BCMPricingCalculatorClientTypes.BatchCreateBillScenarioUsageModificationItem]?

    public init(
        errors: [BCMPricingCalculatorClientTypes.BatchCreateBillScenarioUsageModificationError]? = nil,
        items: [BCMPricingCalculatorClientTypes.BatchCreateBillScenarioUsageModificationItem]? = nil
    )
    {
        self.errors = errors
        self.items = items
    }
}

public struct BatchCreateWorkloadEstimateUsageInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// List of usage that you want to model in the Workload estimate.
    /// This member is required.
    public var usage: [BCMPricingCalculatorClientTypes.BatchCreateWorkloadEstimateUsageEntry]?
    /// The ID of the Workload estimate for which you want to create the modeled usage.
    /// This member is required.
    public var workloadEstimateId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        usage: [BCMPricingCalculatorClientTypes.BatchCreateWorkloadEstimateUsageEntry]? = nil,
        workloadEstimateId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.usage = usage
        self.workloadEstimateId = workloadEstimateId
    }
}

public struct BatchCreateWorkloadEstimateUsageOutput: Swift.Sendable {
    /// Returns the list of errors reason and the usage item keys that cannot be created in the Workload estimate.
    public var errors: [BCMPricingCalculatorClientTypes.BatchCreateWorkloadEstimateUsageError]?
    /// Returns the list of successful usage line items that were created for the Workload estimate.
    public var items: [BCMPricingCalculatorClientTypes.BatchCreateWorkloadEstimateUsageItem]?

    public init(
        errors: [BCMPricingCalculatorClientTypes.BatchCreateWorkloadEstimateUsageError]? = nil,
        items: [BCMPricingCalculatorClientTypes.BatchCreateWorkloadEstimateUsageItem]? = nil
    )
    {
        self.errors = errors
        self.items = items
    }
}

public struct BatchUpdateBillScenarioUsageModificationOutput: Swift.Sendable {
    /// Returns the list of error reasons and usage line item IDs that could not be updated for the Bill Scenario.
    public var errors: [BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioUsageModificationError]?
    /// Returns the list of successful usage line items that were updated for a Bill Scenario.
    public var items: [BCMPricingCalculatorClientTypes.BillScenarioUsageModificationItem]?

    public init(
        errors: [BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioUsageModificationError]? = nil,
        items: [BCMPricingCalculatorClientTypes.BillScenarioUsageModificationItem]? = nil
    )
    {
        self.errors = errors
        self.items = items
    }
}

public struct BatchUpdateWorkloadEstimateUsageOutput: Swift.Sendable {
    /// Returns the list of error reasons and usage line item IDs that could not be updated for the Workload estimate.
    public var errors: [BCMPricingCalculatorClientTypes.BatchUpdateWorkloadEstimateUsageError]?
    /// Returns the list of successful usage line items that were updated for a Workload estimate.
    public var items: [BCMPricingCalculatorClientTypes.WorkloadEstimateUsageItem]?

    public init(
        errors: [BCMPricingCalculatorClientTypes.BatchUpdateWorkloadEstimateUsageError]? = nil,
        items: [BCMPricingCalculatorClientTypes.WorkloadEstimateUsageItem]? = nil
    )
    {
        self.errors = errors
        self.items = items
    }
}

public struct ListBillEstimateInputUsageModificationsOutput: Swift.Sendable {
    /// The list of input usage modifications associated with the bill estimate.
    public var items: [BCMPricingCalculatorClientTypes.BillEstimateInputUsageModificationSummary]?
    /// A token to retrieve the next page of results, if any.
    public var nextToken: Swift.String?

    public init(
        items: [BCMPricingCalculatorClientTypes.BillEstimateInputUsageModificationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListBillScenarioUsageModificationsOutput: Swift.Sendable {
    /// The list of usage modifications associated with the bill scenario.
    public var items: [BCMPricingCalculatorClientTypes.BillScenarioUsageModificationItem]?
    /// A token to retrieve the next page of results, if any.
    public var nextToken: Swift.String?

    public init(
        items: [BCMPricingCalculatorClientTypes.BillScenarioUsageModificationItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListWorkloadEstimateUsageOutput: Swift.Sendable {
    /// The list of usage items associated with the workload estimate.
    public var items: [BCMPricingCalculatorClientTypes.WorkloadEstimateUsageItem]?
    /// A token to retrieve the next page of results, if any.
    public var nextToken: Swift.String?

    public init(
        items: [BCMPricingCalculatorClientTypes.WorkloadEstimateUsageItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

extension BatchCreateBillScenarioCommitmentModificationInput {

    static func urlPathProvider(_ value: BatchCreateBillScenarioCommitmentModificationInput) -> Swift.String? {
        return "/"
    }
}

extension BatchCreateBillScenarioUsageModificationInput {

    static func urlPathProvider(_ value: BatchCreateBillScenarioUsageModificationInput) -> Swift.String? {
        return "/"
    }
}

extension BatchCreateWorkloadEstimateUsageInput {

    static func urlPathProvider(_ value: BatchCreateWorkloadEstimateUsageInput) -> Swift.String? {
        return "/"
    }
}

extension BatchDeleteBillScenarioCommitmentModificationInput {

    static func urlPathProvider(_ value: BatchDeleteBillScenarioCommitmentModificationInput) -> Swift.String? {
        return "/"
    }
}

extension BatchDeleteBillScenarioUsageModificationInput {

    static func urlPathProvider(_ value: BatchDeleteBillScenarioUsageModificationInput) -> Swift.String? {
        return "/"
    }
}

extension BatchDeleteWorkloadEstimateUsageInput {

    static func urlPathProvider(_ value: BatchDeleteWorkloadEstimateUsageInput) -> Swift.String? {
        return "/"
    }
}

extension BatchUpdateBillScenarioCommitmentModificationInput {

    static func urlPathProvider(_ value: BatchUpdateBillScenarioCommitmentModificationInput) -> Swift.String? {
        return "/"
    }
}

extension BatchUpdateBillScenarioUsageModificationInput {

    static func urlPathProvider(_ value: BatchUpdateBillScenarioUsageModificationInput) -> Swift.String? {
        return "/"
    }
}

extension BatchUpdateWorkloadEstimateUsageInput {

    static func urlPathProvider(_ value: BatchUpdateWorkloadEstimateUsageInput) -> Swift.String? {
        return "/"
    }
}

extension CreateBillEstimateInput {

    static func urlPathProvider(_ value: CreateBillEstimateInput) -> Swift.String? {
        return "/"
    }
}

extension CreateBillScenarioInput {

    static func urlPathProvider(_ value: CreateBillScenarioInput) -> Swift.String? {
        return "/"
    }
}

extension CreateWorkloadEstimateInput {

    static func urlPathProvider(_ value: CreateWorkloadEstimateInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteBillEstimateInput {

    static func urlPathProvider(_ value: DeleteBillEstimateInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteBillScenarioInput {

    static func urlPathProvider(_ value: DeleteBillScenarioInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteWorkloadEstimateInput {

    static func urlPathProvider(_ value: DeleteWorkloadEstimateInput) -> Swift.String? {
        return "/"
    }
}

extension GetBillEstimateInput {

    static func urlPathProvider(_ value: GetBillEstimateInput) -> Swift.String? {
        return "/"
    }
}

extension GetBillScenarioInput {

    static func urlPathProvider(_ value: GetBillScenarioInput) -> Swift.String? {
        return "/"
    }
}

extension GetPreferencesInput {

    static func urlPathProvider(_ value: GetPreferencesInput) -> Swift.String? {
        return "/"
    }
}

extension GetWorkloadEstimateInput {

    static func urlPathProvider(_ value: GetWorkloadEstimateInput) -> Swift.String? {
        return "/"
    }
}

extension ListBillEstimateCommitmentsInput {

    static func urlPathProvider(_ value: ListBillEstimateCommitmentsInput) -> Swift.String? {
        return "/"
    }
}

extension ListBillEstimateInputCommitmentModificationsInput {

    static func urlPathProvider(_ value: ListBillEstimateInputCommitmentModificationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListBillEstimateInputUsageModificationsInput {

    static func urlPathProvider(_ value: ListBillEstimateInputUsageModificationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListBillEstimateLineItemsInput {

    static func urlPathProvider(_ value: ListBillEstimateLineItemsInput) -> Swift.String? {
        return "/"
    }
}

extension ListBillEstimatesInput {

    static func urlPathProvider(_ value: ListBillEstimatesInput) -> Swift.String? {
        return "/"
    }
}

extension ListBillScenarioCommitmentModificationsInput {

    static func urlPathProvider(_ value: ListBillScenarioCommitmentModificationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListBillScenariosInput {

    static func urlPathProvider(_ value: ListBillScenariosInput) -> Swift.String? {
        return "/"
    }
}

extension ListBillScenarioUsageModificationsInput {

    static func urlPathProvider(_ value: ListBillScenarioUsageModificationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListWorkloadEstimatesInput {

    static func urlPathProvider(_ value: ListWorkloadEstimatesInput) -> Swift.String? {
        return "/"
    }
}

extension ListWorkloadEstimateUsageInput {

    static func urlPathProvider(_ value: ListWorkloadEstimateUsageInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateBillEstimateInput {

    static func urlPathProvider(_ value: UpdateBillEstimateInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateBillScenarioInput {

    static func urlPathProvider(_ value: UpdateBillScenarioInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePreferencesInput {

    static func urlPathProvider(_ value: UpdatePreferencesInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateWorkloadEstimateInput {

    static func urlPathProvider(_ value: UpdateWorkloadEstimateInput) -> Swift.String? {
        return "/"
    }
}

extension BatchCreateBillScenarioCommitmentModificationInput {

    static func write(value: BatchCreateBillScenarioCommitmentModificationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["billScenarioId"].write(value.billScenarioId)
        try writer["commitmentModifications"].writeList(value.commitmentModifications, memberWritingClosure: BCMPricingCalculatorClientTypes.BatchCreateBillScenarioCommitmentModificationEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchCreateBillScenarioUsageModificationInput {

    static func write(value: BatchCreateBillScenarioUsageModificationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["billScenarioId"].write(value.billScenarioId)
        try writer["usageModifications"].writeList(value.usageModifications, memberWritingClosure: BCMPricingCalculatorClientTypes.BatchCreateBillScenarioUsageModificationEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchCreateWorkloadEstimateUsageInput {

    static func write(value: BatchCreateWorkloadEstimateUsageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["usage"].writeList(value.usage, memberWritingClosure: BCMPricingCalculatorClientTypes.BatchCreateWorkloadEstimateUsageEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["workloadEstimateId"].write(value.workloadEstimateId)
    }
}

extension BatchDeleteBillScenarioCommitmentModificationInput {

    static func write(value: BatchDeleteBillScenarioCommitmentModificationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["billScenarioId"].write(value.billScenarioId)
        try writer["ids"].writeList(value.ids, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDeleteBillScenarioUsageModificationInput {

    static func write(value: BatchDeleteBillScenarioUsageModificationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["billScenarioId"].write(value.billScenarioId)
        try writer["ids"].writeList(value.ids, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchDeleteWorkloadEstimateUsageInput {

    static func write(value: BatchDeleteWorkloadEstimateUsageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ids"].writeList(value.ids, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["workloadEstimateId"].write(value.workloadEstimateId)
    }
}

extension BatchUpdateBillScenarioCommitmentModificationInput {

    static func write(value: BatchUpdateBillScenarioCommitmentModificationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["billScenarioId"].write(value.billScenarioId)
        try writer["commitmentModifications"].writeList(value.commitmentModifications, memberWritingClosure: BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioCommitmentModificationEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchUpdateBillScenarioUsageModificationInput {

    static func write(value: BatchUpdateBillScenarioUsageModificationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["billScenarioId"].write(value.billScenarioId)
        try writer["usageModifications"].writeList(value.usageModifications, memberWritingClosure: BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioUsageModificationEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchUpdateWorkloadEstimateUsageInput {

    static func write(value: BatchUpdateWorkloadEstimateUsageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["usage"].writeList(value.usage, memberWritingClosure: BCMPricingCalculatorClientTypes.BatchUpdateWorkloadEstimateUsageEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["workloadEstimateId"].write(value.workloadEstimateId)
    }
}

extension CreateBillEstimateInput {

    static func write(value: CreateBillEstimateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["billScenarioId"].write(value.billScenarioId)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateBillScenarioInput {

    static func write(value: CreateBillScenarioInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateWorkloadEstimateInput {

    static func write(value: CreateWorkloadEstimateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["rateType"].write(value.rateType)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension DeleteBillEstimateInput {

    static func write(value: DeleteBillEstimateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
    }
}

extension DeleteBillScenarioInput {

    static func write(value: DeleteBillScenarioInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
    }
}

extension DeleteWorkloadEstimateInput {

    static func write(value: DeleteWorkloadEstimateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
    }
}

extension GetBillEstimateInput {

    static func write(value: GetBillEstimateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
    }
}

extension GetBillScenarioInput {

    static func write(value: GetBillScenarioInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
    }
}

extension GetPreferencesInput {

    static func write(value: GetPreferencesInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension GetWorkloadEstimateInput {

    static func write(value: GetWorkloadEstimateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["identifier"].write(value.identifier)
    }
}

extension ListBillEstimateCommitmentsInput {

    static func write(value: ListBillEstimateCommitmentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["billEstimateId"].write(value.billEstimateId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListBillEstimateInputCommitmentModificationsInput {

    static func write(value: ListBillEstimateInputCommitmentModificationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["billEstimateId"].write(value.billEstimateId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListBillEstimateInputUsageModificationsInput {

    static func write(value: ListBillEstimateInputUsageModificationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["billEstimateId"].write(value.billEstimateId)
        try writer["filters"].writeList(value.filters, memberWritingClosure: BCMPricingCalculatorClientTypes.ListUsageFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListBillEstimateLineItemsInput {

    static func write(value: ListBillEstimateLineItemsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["billEstimateId"].write(value.billEstimateId)
        try writer["filters"].writeList(value.filters, memberWritingClosure: BCMPricingCalculatorClientTypes.ListBillEstimateLineItemsFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListBillEstimatesInput {

    static func write(value: ListBillEstimatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["createdAtFilter"].write(value.createdAtFilter, with: BCMPricingCalculatorClientTypes.FilterTimestamp.write(value:to:))
        try writer["expiresAtFilter"].write(value.expiresAtFilter, with: BCMPricingCalculatorClientTypes.FilterTimestamp.write(value:to:))
        try writer["filters"].writeList(value.filters, memberWritingClosure: BCMPricingCalculatorClientTypes.ListBillEstimatesFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListBillScenarioCommitmentModificationsInput {

    static func write(value: ListBillScenarioCommitmentModificationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["billScenarioId"].write(value.billScenarioId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListBillScenariosInput {

    static func write(value: ListBillScenariosInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["createdAtFilter"].write(value.createdAtFilter, with: BCMPricingCalculatorClientTypes.FilterTimestamp.write(value:to:))
        try writer["expiresAtFilter"].write(value.expiresAtFilter, with: BCMPricingCalculatorClientTypes.FilterTimestamp.write(value:to:))
        try writer["filters"].writeList(value.filters, memberWritingClosure: BCMPricingCalculatorClientTypes.ListBillScenariosFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListBillScenarioUsageModificationsInput {

    static func write(value: ListBillScenarioUsageModificationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["billScenarioId"].write(value.billScenarioId)
        try writer["filters"].writeList(value.filters, memberWritingClosure: BCMPricingCalculatorClientTypes.ListUsageFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension ListWorkloadEstimatesInput {

    static func write(value: ListWorkloadEstimatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["createdAtFilter"].write(value.createdAtFilter, with: BCMPricingCalculatorClientTypes.FilterTimestamp.write(value:to:))
        try writer["expiresAtFilter"].write(value.expiresAtFilter, with: BCMPricingCalculatorClientTypes.FilterTimestamp.write(value:to:))
        try writer["filters"].writeList(value.filters, memberWritingClosure: BCMPricingCalculatorClientTypes.ListWorkloadEstimatesFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListWorkloadEstimateUsageInput {

    static func write(value: ListWorkloadEstimateUsageInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filters"].writeList(value.filters, memberWritingClosure: BCMPricingCalculatorClientTypes.ListUsageFilter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["workloadEstimateId"].write(value.workloadEstimateId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateBillEstimateInput {

    static func write(value: UpdateBillEstimateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["expiresAt"].writeTimestamp(value.expiresAt, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["identifier"].write(value.identifier)
        try writer["name"].write(value.name)
    }
}

extension UpdateBillScenarioInput {

    static func write(value: UpdateBillScenarioInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["expiresAt"].writeTimestamp(value.expiresAt, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["identifier"].write(value.identifier)
        try writer["name"].write(value.name)
    }
}

extension UpdatePreferencesInput {

    static func write(value: UpdatePreferencesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["managementAccountRateTypeSelections"].writeList(value.managementAccountRateTypeSelections, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BCMPricingCalculatorClientTypes.RateType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["memberAccountRateTypeSelections"].writeList(value.memberAccountRateTypeSelections, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BCMPricingCalculatorClientTypes.RateType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateWorkloadEstimateInput {

    static func write(value: UpdateWorkloadEstimateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["expiresAt"].writeTimestamp(value.expiresAt, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["identifier"].write(value.identifier)
        try writer["name"].write(value.name)
    }
}

extension BatchCreateBillScenarioCommitmentModificationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchCreateBillScenarioCommitmentModificationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchCreateBillScenarioCommitmentModificationOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BatchCreateBillScenarioCommitmentModificationError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BatchCreateBillScenarioCommitmentModificationItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchCreateBillScenarioUsageModificationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchCreateBillScenarioUsageModificationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchCreateBillScenarioUsageModificationOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BatchCreateBillScenarioUsageModificationError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BatchCreateBillScenarioUsageModificationItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchCreateWorkloadEstimateUsageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchCreateWorkloadEstimateUsageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchCreateWorkloadEstimateUsageOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BatchCreateWorkloadEstimateUsageError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BatchCreateWorkloadEstimateUsageItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDeleteBillScenarioCommitmentModificationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteBillScenarioCommitmentModificationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteBillScenarioCommitmentModificationOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BatchDeleteBillScenarioCommitmentModificationError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDeleteBillScenarioUsageModificationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteBillScenarioUsageModificationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteBillScenarioUsageModificationOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BatchDeleteBillScenarioUsageModificationError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDeleteWorkloadEstimateUsageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDeleteWorkloadEstimateUsageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDeleteWorkloadEstimateUsageOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BatchDeleteWorkloadEstimateUsageError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchUpdateBillScenarioCommitmentModificationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUpdateBillScenarioCommitmentModificationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdateBillScenarioCommitmentModificationOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioCommitmentModificationError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchUpdateBillScenarioUsageModificationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUpdateBillScenarioUsageModificationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdateBillScenarioUsageModificationOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioUsageModificationError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BillScenarioUsageModificationItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchUpdateWorkloadEstimateUsageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchUpdateWorkloadEstimateUsageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdateWorkloadEstimateUsageOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BatchUpdateWorkloadEstimateUsageError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.WorkloadEstimateUsageItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateBillEstimateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBillEstimateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBillEstimateOutput()
        value.billInterval = try reader["billInterval"].readIfPresent(with: BCMPricingCalculatorClientTypes.BillInterval.read(from:))
        value.costSummary = try reader["costSummary"].readIfPresent(with: BCMPricingCalculatorClientTypes.BillEstimateCostSummary.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.expiresAt = try reader["expiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateBillScenarioOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBillScenarioOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBillScenarioOutput()
        value.billInterval = try reader["billInterval"].readIfPresent(with: BCMPricingCalculatorClientTypes.BillInterval.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.expiresAt = try reader["expiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension CreateWorkloadEstimateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkloadEstimateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkloadEstimateOutput()
        value.costCurrency = try reader["costCurrency"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.expiresAt = try reader["expiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.rateTimestamp = try reader["rateTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.rateType = try reader["rateType"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.totalCost = try reader["totalCost"].readIfPresent()
        return value
    }
}

extension DeleteBillEstimateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBillEstimateOutput {
        return DeleteBillEstimateOutput()
    }
}

extension DeleteBillScenarioOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBillScenarioOutput {
        return DeleteBillScenarioOutput()
    }
}

extension DeleteWorkloadEstimateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkloadEstimateOutput {
        return DeleteWorkloadEstimateOutput()
    }
}

extension GetBillEstimateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBillEstimateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBillEstimateOutput()
        value.billInterval = try reader["billInterval"].readIfPresent(with: BCMPricingCalculatorClientTypes.BillInterval.read(from:))
        value.costSummary = try reader["costSummary"].readIfPresent(with: BCMPricingCalculatorClientTypes.BillEstimateCostSummary.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.expiresAt = try reader["expiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetBillScenarioOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBillScenarioOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBillScenarioOutput()
        value.billInterval = try reader["billInterval"].readIfPresent(with: BCMPricingCalculatorClientTypes.BillInterval.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.expiresAt = try reader["expiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension GetPreferencesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPreferencesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPreferencesOutput()
        value.managementAccountRateTypeSelections = try reader["managementAccountRateTypeSelections"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BCMPricingCalculatorClientTypes.RateType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.memberAccountRateTypeSelections = try reader["memberAccountRateTypeSelections"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BCMPricingCalculatorClientTypes.RateType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetWorkloadEstimateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkloadEstimateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkloadEstimateOutput()
        value.costCurrency = try reader["costCurrency"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.expiresAt = try reader["expiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.rateTimestamp = try reader["rateTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.rateType = try reader["rateType"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.totalCost = try reader["totalCost"].readIfPresent()
        return value
    }
}

extension ListBillEstimateCommitmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBillEstimateCommitmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBillEstimateCommitmentsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BillEstimateCommitmentSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListBillEstimateInputCommitmentModificationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBillEstimateInputCommitmentModificationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBillEstimateInputCommitmentModificationsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BillEstimateInputCommitmentModificationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListBillEstimateInputUsageModificationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBillEstimateInputUsageModificationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBillEstimateInputUsageModificationsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BillEstimateInputUsageModificationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListBillEstimateLineItemsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBillEstimateLineItemsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBillEstimateLineItemsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BillEstimateLineItemSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListBillEstimatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBillEstimatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBillEstimatesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BillEstimateSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListBillScenarioCommitmentModificationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBillScenarioCommitmentModificationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBillScenarioCommitmentModificationsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListBillScenariosOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBillScenariosOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBillScenariosOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BillScenarioSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListBillScenarioUsageModificationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBillScenarioUsageModificationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBillScenarioUsageModificationsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.BillScenarioUsageModificationItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListWorkloadEstimatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkloadEstimatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkloadEstimatesOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.WorkloadEstimateSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListWorkloadEstimateUsageOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkloadEstimateUsageOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkloadEstimateUsageOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.WorkloadEstimateUsageItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateBillEstimateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBillEstimateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBillEstimateOutput()
        value.billInterval = try reader["billInterval"].readIfPresent(with: BCMPricingCalculatorClientTypes.BillInterval.read(from:))
        value.costSummary = try reader["costSummary"].readIfPresent(with: BCMPricingCalculatorClientTypes.BillEstimateCostSummary.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.expiresAt = try reader["expiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension UpdateBillScenarioOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBillScenarioOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBillScenarioOutput()
        value.billInterval = try reader["billInterval"].readIfPresent(with: BCMPricingCalculatorClientTypes.BillInterval.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.expiresAt = try reader["expiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        return value
    }
}

extension UpdatePreferencesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePreferencesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePreferencesOutput()
        value.managementAccountRateTypeSelections = try reader["managementAccountRateTypeSelections"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BCMPricingCalculatorClientTypes.RateType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.memberAccountRateTypeSelections = try reader["memberAccountRateTypeSelections"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BCMPricingCalculatorClientTypes.RateType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateWorkloadEstimateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateWorkloadEstimateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateWorkloadEstimateOutput()
        value.costCurrency = try reader["costCurrency"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.expiresAt = try reader["expiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.rateTimestamp = try reader["rateTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.rateType = try reader["rateType"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.totalCost = try reader["totalCost"].readIfPresent()
        return value
    }
}

func httpServiceError(baseError: AWSClientRuntime.AWSJSONError) throws -> Swift.Error? {
    switch baseError.code {
        case "AccessDeniedCode": return try AccessDeniedException.makeError(baseError: baseError)
        case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
        case "ThrottlingCode": return try ThrottlingException.makeError(baseError: baseError)
        case "ValidationException": return try ValidationException.makeError(baseError: baseError)
        default: return nil
    }
}

enum BatchCreateBillScenarioCommitmentModificationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictCode": return try ConflictException.makeError(baseError: baseError)
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchCreateBillScenarioUsageModificationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictCode": return try ConflictException.makeError(baseError: baseError)
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaCode": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchCreateWorkloadEstimateUsageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictCode": return try ConflictException.makeError(baseError: baseError)
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaCode": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeleteBillScenarioCommitmentModificationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeleteBillScenarioUsageModificationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaCode": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDeleteWorkloadEstimateUsageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaCode": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchUpdateBillScenarioCommitmentModificationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchUpdateBillScenarioUsageModificationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaCode": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchUpdateWorkloadEstimateUsageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaCode": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBillEstimateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictCode": return try ConflictException.makeError(baseError: baseError)
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBillScenarioOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictCode": return try ConflictException.makeError(baseError: baseError)
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ServiceQuotaCode": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkloadEstimateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictCode": return try ConflictException.makeError(baseError: baseError)
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ServiceQuotaCode": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBillEstimateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBillScenarioOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkloadEstimateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBillEstimateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBillScenarioOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPreferencesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkloadEstimateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBillEstimateCommitmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBillEstimateInputCommitmentModificationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBillEstimateInputUsageModificationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBillEstimateLineItemsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBillEstimatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBillScenarioCommitmentModificationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBillScenariosOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBillScenarioUsageModificationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkloadEstimatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkloadEstimateUsageOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaCode": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBillEstimateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictCode": return try ConflictException.makeError(baseError: baseError)
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBillScenarioOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictCode": return try ConflictException.makeError(baseError: baseError)
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePreferencesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ServiceQuotaCode": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateWorkloadEstimateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        if let error = try httpServiceError(baseError: baseError) { return error }
        switch baseError.code {
            case "ConflictCode": return try ConflictException.makeError(baseError: baseError)
            case "DataUnavailableException": return try DataUnavailableException.makeError(baseError: baseError)
            case "ResourceNotFoundCode": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DataUnavailableException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DataUnavailableException {
        let reader = baseError.errorBodyReader
        var value = DataUnavailableException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BatchCreateBillScenarioCommitmentModificationItem {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BatchCreateBillScenarioCommitmentModificationItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BatchCreateBillScenarioCommitmentModificationItem()
        value.key = try reader["key"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.group = try reader["group"].readIfPresent()
        value.usageAccountId = try reader["usageAccountId"].readIfPresent()
        value.commitmentAction = try reader["commitmentAction"].readIfPresent(with: BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationAction.read(from:))
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationAction {

    static func write(value: BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .addreservedinstanceaction(addreservedinstanceaction):
                try writer["addReservedInstanceAction"].write(addreservedinstanceaction, with: BCMPricingCalculatorClientTypes.AddReservedInstanceAction.write(value:to:))
            case let .addsavingsplanaction(addsavingsplanaction):
                try writer["addSavingsPlanAction"].write(addsavingsplanaction, with: BCMPricingCalculatorClientTypes.AddSavingsPlanAction.write(value:to:))
            case let .negatereservedinstanceaction(negatereservedinstanceaction):
                try writer["negateReservedInstanceAction"].write(negatereservedinstanceaction, with: BCMPricingCalculatorClientTypes.NegateReservedInstanceAction.write(value:to:))
            case let .negatesavingsplanaction(negatesavingsplanaction):
                try writer["negateSavingsPlanAction"].write(negatesavingsplanaction, with: BCMPricingCalculatorClientTypes.NegateSavingsPlanAction.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "addReservedInstanceAction":
                return .addreservedinstanceaction(try reader["addReservedInstanceAction"].read(with: BCMPricingCalculatorClientTypes.AddReservedInstanceAction.read(from:)))
            case "addSavingsPlanAction":
                return .addsavingsplanaction(try reader["addSavingsPlanAction"].read(with: BCMPricingCalculatorClientTypes.AddSavingsPlanAction.read(from:)))
            case "negateReservedInstanceAction":
                return .negatereservedinstanceaction(try reader["negateReservedInstanceAction"].read(with: BCMPricingCalculatorClientTypes.NegateReservedInstanceAction.read(from:)))
            case "negateSavingsPlanAction":
                return .negatesavingsplanaction(try reader["negateSavingsPlanAction"].read(with: BCMPricingCalculatorClientTypes.NegateSavingsPlanAction.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BCMPricingCalculatorClientTypes.NegateSavingsPlanAction {

    static func write(value: BCMPricingCalculatorClientTypes.NegateSavingsPlanAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["savingsPlanId"].write(value.savingsPlanId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.NegateSavingsPlanAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.NegateSavingsPlanAction()
        value.savingsPlanId = try reader["savingsPlanId"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.NegateReservedInstanceAction {

    static func write(value: BCMPricingCalculatorClientTypes.NegateReservedInstanceAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["reservedInstancesId"].write(value.reservedInstancesId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.NegateReservedInstanceAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.NegateReservedInstanceAction()
        value.reservedInstancesId = try reader["reservedInstancesId"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.AddSavingsPlanAction {

    static func write(value: BCMPricingCalculatorClientTypes.AddSavingsPlanAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["commitment"].write(value.commitment)
        try writer["savingsPlanOfferingId"].write(value.savingsPlanOfferingId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.AddSavingsPlanAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.AddSavingsPlanAction()
        value.savingsPlanOfferingId = try reader["savingsPlanOfferingId"].readIfPresent()
        value.commitment = try reader["commitment"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.AddReservedInstanceAction {

    static func write(value: BCMPricingCalculatorClientTypes.AddReservedInstanceAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["instanceCount"].write(value.instanceCount)
        try writer["reservedInstancesOfferingId"].write(value.reservedInstancesOfferingId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.AddReservedInstanceAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.AddReservedInstanceAction()
        value.reservedInstancesOfferingId = try reader["reservedInstancesOfferingId"].readIfPresent()
        value.instanceCount = try reader["instanceCount"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BatchCreateBillScenarioCommitmentModificationError {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BatchCreateBillScenarioCommitmentModificationError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BatchCreateBillScenarioCommitmentModificationError()
        value.key = try reader["key"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BatchCreateBillScenarioUsageModificationItem {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BatchCreateBillScenarioUsageModificationItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BatchCreateBillScenarioUsageModificationItem()
        value.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.usageType = try reader["usageType"].readIfPresent() ?? ""
        value.operation = try reader["operation"].readIfPresent() ?? ""
        value.location = try reader["location"].readIfPresent()
        value.availabilityZone = try reader["availabilityZone"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.group = try reader["group"].readIfPresent()
        value.usageAccountId = try reader["usageAccountId"].readIfPresent()
        value.quantities = try reader["quantities"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.UsageQuantity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.historicalUsage = try reader["historicalUsage"].readIfPresent(with: BCMPricingCalculatorClientTypes.HistoricalUsageEntity.read(from:))
        value.key = try reader["key"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.HistoricalUsageEntity {

    static func write(value: BCMPricingCalculatorClientTypes.HistoricalUsageEntity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["billInterval"].write(value.billInterval, with: BCMPricingCalculatorClientTypes.BillInterval.write(value:to:))
        try writer["filterExpression"].write(value.filterExpression, with: BCMPricingCalculatorClientTypes.Expression.write(value:to:))
        try writer["location"].write(value.location)
        try writer["operation"].write(value.operation)
        try writer["serviceCode"].write(value.serviceCode)
        try writer["usageAccountId"].write(value.usageAccountId)
        try writer["usageType"].write(value.usageType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.HistoricalUsageEntity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.HistoricalUsageEntity()
        value.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.usageType = try reader["usageType"].readIfPresent() ?? ""
        value.operation = try reader["operation"].readIfPresent() ?? ""
        value.location = try reader["location"].readIfPresent()
        value.usageAccountId = try reader["usageAccountId"].readIfPresent() ?? ""
        value.billInterval = try reader["billInterval"].readIfPresent(with: BCMPricingCalculatorClientTypes.BillInterval.read(from:))
        value.filterExpression = try reader["filterExpression"].readIfPresent(with: BCMPricingCalculatorClientTypes.Expression.read(from:))
        return value
    }
}

extension BCMPricingCalculatorClientTypes.Expression {

    static func write(value: BCMPricingCalculatorClientTypes.Expression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["and"].writeList(value.and, memberWritingClosure: BCMPricingCalculatorClientTypes.Expression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["costCategories"].write(value.costCategories, with: BCMPricingCalculatorClientTypes.ExpressionFilter.write(value:to:))
        try writer["dimensions"].write(value.dimensions, with: BCMPricingCalculatorClientTypes.ExpressionFilter.write(value:to:))
        try writer["not"].write(value.not, with: BCMPricingCalculatorClientTypes.Expression.write(value:to:))
        try writer["or"].writeList(value.or, memberWritingClosure: BCMPricingCalculatorClientTypes.Expression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].write(value.tags, with: BCMPricingCalculatorClientTypes.ExpressionFilter.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.Expression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.Expression()
        value.and = try reader["and"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.Expression.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.or = try reader["or"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.Expression.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.not = try reader["not"].readIfPresent(with: BCMPricingCalculatorClientTypes.Expression.read(from:))
        value.costCategories = try reader["costCategories"].readIfPresent(with: BCMPricingCalculatorClientTypes.ExpressionFilter.read(from:))
        value.dimensions = try reader["dimensions"].readIfPresent(with: BCMPricingCalculatorClientTypes.ExpressionFilter.read(from:))
        value.tags = try reader["tags"].readIfPresent(with: BCMPricingCalculatorClientTypes.ExpressionFilter.read(from:))
        return value
    }
}

extension BCMPricingCalculatorClientTypes.ExpressionFilter {

    static func write(value: BCMPricingCalculatorClientTypes.ExpressionFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["matchOptions"].writeList(value.matchOptions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.ExpressionFilter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.ExpressionFilter()
        value.key = try reader["key"].readIfPresent()
        value.matchOptions = try reader["matchOptions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BillInterval {

    static func write(value: BCMPricingCalculatorClientTypes.BillInterval?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["end"].writeTimestamp(value.end, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["start"].writeTimestamp(value.start, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BillInterval {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BillInterval()
        value.start = try reader["start"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.end = try reader["end"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension BCMPricingCalculatorClientTypes.UsageQuantity {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.UsageQuantity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.UsageQuantity()
        value.startHour = try reader["startHour"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.unit = try reader["unit"].readIfPresent()
        value.amount = try reader["amount"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BatchCreateBillScenarioUsageModificationError {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BatchCreateBillScenarioUsageModificationError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BatchCreateBillScenarioUsageModificationError()
        value.key = try reader["key"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BatchCreateWorkloadEstimateUsageItem {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BatchCreateWorkloadEstimateUsageItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BatchCreateWorkloadEstimateUsageItem()
        value.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.usageType = try reader["usageType"].readIfPresent() ?? ""
        value.operation = try reader["operation"].readIfPresent() ?? ""
        value.location = try reader["location"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.usageAccountId = try reader["usageAccountId"].readIfPresent()
        value.group = try reader["group"].readIfPresent()
        value.quantity = try reader["quantity"].readIfPresent(with: BCMPricingCalculatorClientTypes.WorkloadEstimateUsageQuantity.read(from:))
        value.cost = try reader["cost"].readIfPresent()
        value.currency = try reader["currency"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.historicalUsage = try reader["historicalUsage"].readIfPresent(with: BCMPricingCalculatorClientTypes.HistoricalUsageEntity.read(from:))
        value.key = try reader["key"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.WorkloadEstimateUsageQuantity {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.WorkloadEstimateUsageQuantity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.WorkloadEstimateUsageQuantity()
        value.unit = try reader["unit"].readIfPresent()
        value.amount = try reader["amount"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BatchCreateWorkloadEstimateUsageError {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BatchCreateWorkloadEstimateUsageError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BatchCreateWorkloadEstimateUsageError()
        value.key = try reader["key"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BatchDeleteBillScenarioCommitmentModificationError {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BatchDeleteBillScenarioCommitmentModificationError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BatchDeleteBillScenarioCommitmentModificationError()
        value.id = try reader["id"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BatchDeleteBillScenarioUsageModificationError {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BatchDeleteBillScenarioUsageModificationError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BatchDeleteBillScenarioUsageModificationError()
        value.id = try reader["id"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BatchDeleteWorkloadEstimateUsageError {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BatchDeleteWorkloadEstimateUsageError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BatchDeleteWorkloadEstimateUsageError()
        value.id = try reader["id"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationItem {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationItem()
        value.id = try reader["id"].readIfPresent()
        value.usageAccountId = try reader["usageAccountId"].readIfPresent()
        value.group = try reader["group"].readIfPresent()
        value.commitmentAction = try reader["commitmentAction"].readIfPresent(with: BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationAction.read(from:))
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioCommitmentModificationError {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioCommitmentModificationError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioCommitmentModificationError()
        value.id = try reader["id"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BillScenarioUsageModificationItem {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BillScenarioUsageModificationItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BillScenarioUsageModificationItem()
        value.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.usageType = try reader["usageType"].readIfPresent() ?? ""
        value.operation = try reader["operation"].readIfPresent() ?? ""
        value.location = try reader["location"].readIfPresent()
        value.availabilityZone = try reader["availabilityZone"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.group = try reader["group"].readIfPresent()
        value.usageAccountId = try reader["usageAccountId"].readIfPresent()
        value.quantities = try reader["quantities"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.UsageQuantity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.historicalUsage = try reader["historicalUsage"].readIfPresent(with: BCMPricingCalculatorClientTypes.HistoricalUsageEntity.read(from:))
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioUsageModificationError {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioUsageModificationError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioUsageModificationError()
        value.id = try reader["id"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.WorkloadEstimateUsageItem {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.WorkloadEstimateUsageItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.WorkloadEstimateUsageItem()
        value.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.usageType = try reader["usageType"].readIfPresent() ?? ""
        value.operation = try reader["operation"].readIfPresent() ?? ""
        value.location = try reader["location"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.usageAccountId = try reader["usageAccountId"].readIfPresent()
        value.group = try reader["group"].readIfPresent()
        value.quantity = try reader["quantity"].readIfPresent(with: BCMPricingCalculatorClientTypes.WorkloadEstimateUsageQuantity.read(from:))
        value.cost = try reader["cost"].readIfPresent()
        value.currency = try reader["currency"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.historicalUsage = try reader["historicalUsage"].readIfPresent(with: BCMPricingCalculatorClientTypes.HistoricalUsageEntity.read(from:))
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BatchUpdateWorkloadEstimateUsageError {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BatchUpdateWorkloadEstimateUsageError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BatchUpdateWorkloadEstimateUsageError()
        value.id = try reader["id"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BillEstimateCostSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BillEstimateCostSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BillEstimateCostSummary()
        value.totalCostDifference = try reader["totalCostDifference"].readIfPresent(with: BCMPricingCalculatorClientTypes.CostDifference.read(from:))
        value.serviceCostDifferences = try reader["serviceCostDifferences"].readMapIfPresent(valueReadingClosure: BCMPricingCalculatorClientTypes.CostDifference.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension BCMPricingCalculatorClientTypes.CostDifference {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.CostDifference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.CostDifference()
        value.historicalCost = try reader["historicalCost"].readIfPresent(with: BCMPricingCalculatorClientTypes.CostAmount.read(from:))
        value.estimatedCost = try reader["estimatedCost"].readIfPresent(with: BCMPricingCalculatorClientTypes.CostAmount.read(from:))
        return value
    }
}

extension BCMPricingCalculatorClientTypes.CostAmount {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.CostAmount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.CostAmount()
        value.amount = try reader["amount"].readIfPresent()
        value.currency = try reader["currency"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BillEstimateCommitmentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BillEstimateCommitmentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BillEstimateCommitmentSummary()
        value.id = try reader["id"].readIfPresent()
        value.purchaseAgreementType = try reader["purchaseAgreementType"].readIfPresent()
        value.offeringId = try reader["offeringId"].readIfPresent()
        value.usageAccountId = try reader["usageAccountId"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        value.termLength = try reader["termLength"].readIfPresent()
        value.paymentOption = try reader["paymentOption"].readIfPresent()
        value.upfrontPayment = try reader["upfrontPayment"].readIfPresent(with: BCMPricingCalculatorClientTypes.CostAmount.read(from:))
        value.monthlyPayment = try reader["monthlyPayment"].readIfPresent(with: BCMPricingCalculatorClientTypes.CostAmount.read(from:))
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BillEstimateInputCommitmentModificationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BillEstimateInputCommitmentModificationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BillEstimateInputCommitmentModificationSummary()
        value.id = try reader["id"].readIfPresent()
        value.group = try reader["group"].readIfPresent()
        value.usageAccountId = try reader["usageAccountId"].readIfPresent()
        value.commitmentAction = try reader["commitmentAction"].readIfPresent(with: BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationAction.read(from:))
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BillEstimateInputUsageModificationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BillEstimateInputUsageModificationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BillEstimateInputUsageModificationSummary()
        value.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.usageType = try reader["usageType"].readIfPresent() ?? ""
        value.operation = try reader["operation"].readIfPresent() ?? ""
        value.location = try reader["location"].readIfPresent()
        value.availabilityZone = try reader["availabilityZone"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.group = try reader["group"].readIfPresent()
        value.usageAccountId = try reader["usageAccountId"].readIfPresent()
        value.quantities = try reader["quantities"].readListIfPresent(memberReadingClosure: BCMPricingCalculatorClientTypes.UsageQuantity.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.historicalUsage = try reader["historicalUsage"].readIfPresent(with: BCMPricingCalculatorClientTypes.HistoricalUsageEntity.read(from:))
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BillEstimateLineItemSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BillEstimateLineItemSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BillEstimateLineItemSummary()
        value.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.usageType = try reader["usageType"].readIfPresent() ?? ""
        value.operation = try reader["operation"].readIfPresent() ?? ""
        value.location = try reader["location"].readIfPresent()
        value.availabilityZone = try reader["availabilityZone"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        value.lineItemId = try reader["lineItemId"].readIfPresent()
        value.lineItemType = try reader["lineItemType"].readIfPresent()
        value.payerAccountId = try reader["payerAccountId"].readIfPresent()
        value.usageAccountId = try reader["usageAccountId"].readIfPresent()
        value.estimatedUsageQuantity = try reader["estimatedUsageQuantity"].readIfPresent(with: BCMPricingCalculatorClientTypes.UsageQuantityResult.read(from:))
        value.estimatedCost = try reader["estimatedCost"].readIfPresent(with: BCMPricingCalculatorClientTypes.CostAmount.read(from:))
        value.historicalUsageQuantity = try reader["historicalUsageQuantity"].readIfPresent(with: BCMPricingCalculatorClientTypes.UsageQuantityResult.read(from:))
        value.historicalCost = try reader["historicalCost"].readIfPresent(with: BCMPricingCalculatorClientTypes.CostAmount.read(from:))
        value.savingsPlanArns = try reader["savingsPlanArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BCMPricingCalculatorClientTypes.UsageQuantityResult {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.UsageQuantityResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.UsageQuantityResult()
        value.amount = try reader["amount"].readIfPresent()
        value.unit = try reader["unit"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BillEstimateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BillEstimateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BillEstimateSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.billInterval = try reader["billInterval"].readIfPresent(with: BCMPricingCalculatorClientTypes.BillInterval.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.expiresAt = try reader["expiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BillScenarioSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.BillScenarioSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.BillScenarioSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.billInterval = try reader["billInterval"].readIfPresent(with: BCMPricingCalculatorClientTypes.BillInterval.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.expiresAt = try reader["expiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.WorkloadEstimateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.WorkloadEstimateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.WorkloadEstimateSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.expiresAt = try reader["expiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.rateType = try reader["rateType"].readIfPresent()
        value.rateTimestamp = try reader["rateTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.totalCost = try reader["totalCost"].readIfPresent()
        value.costCurrency = try reader["costCurrency"].readIfPresent()
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        return value
    }
}

extension BCMPricingCalculatorClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMPricingCalculatorClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMPricingCalculatorClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension BCMPricingCalculatorClientTypes.BatchCreateBillScenarioCommitmentModificationEntry {

    static func write(value: BCMPricingCalculatorClientTypes.BatchCreateBillScenarioCommitmentModificationEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["commitmentAction"].write(value.commitmentAction, with: BCMPricingCalculatorClientTypes.BillScenarioCommitmentModificationAction.write(value:to:))
        try writer["group"].write(value.group)
        try writer["key"].write(value.key)
        try writer["usageAccountId"].write(value.usageAccountId)
    }
}

extension BCMPricingCalculatorClientTypes.BatchCreateBillScenarioUsageModificationEntry {

    static func write(value: BCMPricingCalculatorClientTypes.BatchCreateBillScenarioUsageModificationEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["amounts"].writeList(value.amounts, memberWritingClosure: BCMPricingCalculatorClientTypes.UsageAmount.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["availabilityZone"].write(value.availabilityZone)
        try writer["group"].write(value.group)
        try writer["historicalUsage"].write(value.historicalUsage, with: BCMPricingCalculatorClientTypes.HistoricalUsageEntity.write(value:to:))
        try writer["key"].write(value.key)
        try writer["operation"].write(value.operation)
        try writer["serviceCode"].write(value.serviceCode)
        try writer["usageAccountId"].write(value.usageAccountId)
        try writer["usageType"].write(value.usageType)
    }
}

extension BCMPricingCalculatorClientTypes.UsageAmount {

    static func write(value: BCMPricingCalculatorClientTypes.UsageAmount?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["amount"].write(value.amount)
        try writer["startHour"].writeTimestamp(value.startHour, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension BCMPricingCalculatorClientTypes.BatchCreateWorkloadEstimateUsageEntry {

    static func write(value: BCMPricingCalculatorClientTypes.BatchCreateWorkloadEstimateUsageEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["amount"].write(value.amount)
        try writer["group"].write(value.group)
        try writer["historicalUsage"].write(value.historicalUsage, with: BCMPricingCalculatorClientTypes.HistoricalUsageEntity.write(value:to:))
        try writer["key"].write(value.key)
        try writer["operation"].write(value.operation)
        try writer["serviceCode"].write(value.serviceCode)
        try writer["usageAccountId"].write(value.usageAccountId)
        try writer["usageType"].write(value.usageType)
    }
}

extension BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioCommitmentModificationEntry {

    static func write(value: BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioCommitmentModificationEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["group"].write(value.group)
        try writer["id"].write(value.id)
    }
}

extension BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioUsageModificationEntry {

    static func write(value: BCMPricingCalculatorClientTypes.BatchUpdateBillScenarioUsageModificationEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["amounts"].writeList(value.amounts, memberWritingClosure: BCMPricingCalculatorClientTypes.UsageAmount.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["group"].write(value.group)
        try writer["id"].write(value.id)
    }
}

extension BCMPricingCalculatorClientTypes.BatchUpdateWorkloadEstimateUsageEntry {

    static func write(value: BCMPricingCalculatorClientTypes.BatchUpdateWorkloadEstimateUsageEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["amount"].write(value.amount)
        try writer["group"].write(value.group)
        try writer["id"].write(value.id)
    }
}

extension BCMPricingCalculatorClientTypes.ListUsageFilter {

    static func write(value: BCMPricingCalculatorClientTypes.ListUsageFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["matchOption"].write(value.matchOption)
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BCMPricingCalculatorClientTypes.ListBillEstimateLineItemsFilter {

    static func write(value: BCMPricingCalculatorClientTypes.ListBillEstimateLineItemsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["matchOption"].write(value.matchOption)
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BCMPricingCalculatorClientTypes.ListBillEstimatesFilter {

    static func write(value: BCMPricingCalculatorClientTypes.ListBillEstimatesFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["matchOption"].write(value.matchOption)
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BCMPricingCalculatorClientTypes.FilterTimestamp {

    static func write(value: BCMPricingCalculatorClientTypes.FilterTimestamp?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["afterTimestamp"].writeTimestamp(value.afterTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["beforeTimestamp"].writeTimestamp(value.beforeTimestamp, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension BCMPricingCalculatorClientTypes.ListBillScenariosFilter {

    static func write(value: BCMPricingCalculatorClientTypes.ListBillScenariosFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["matchOption"].write(value.matchOption)
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BCMPricingCalculatorClientTypes.ListWorkloadEstimatesFilter {

    static func write(value: BCMPricingCalculatorClientTypes.ListWorkloadEstimatesFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["matchOption"].write(value.matchOption)
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum BCMPricingCalculatorClientTypes {}
