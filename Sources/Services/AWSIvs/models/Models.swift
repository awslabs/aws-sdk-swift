// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// User does not have sufficient access to perform this action.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IvsClientTypes.AudioConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels
        case codec
        case sampleRate
        case targetBitrate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if channels != 0 {
            try encodeContainer.encode(channels, forKey: .channels)
        }
        if let codec = self.codec {
            try encodeContainer.encode(codec, forKey: .codec)
        }
        if sampleRate != 0 {
            try encodeContainer.encode(sampleRate, forKey: .sampleRate)
        }
        if targetBitrate != 0 {
            try encodeContainer.encode(targetBitrate, forKey: .targetBitrate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codec)
        codec = codecDecoded
        let targetBitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetBitrate) ?? 0
        targetBitrate = targetBitrateDecoded
        let sampleRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sampleRate) ?? 0
        sampleRate = sampleRateDecoded
        let channelsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .channels) ?? 0
        channels = channelsDecoded
    }
}

extension IvsClientTypes {
    /// Object specifying a streamâ€™s audio configuration, as set up by the broadcaster (usually in an encoder). This is part of the [IngestConfiguration] object and used for monitoring stream health.
    public struct AudioConfiguration: Swift.Equatable {
        /// Number of audio channels.
        public var channels: Swift.Int
        /// Codec used for the audio encoding.
        public var codec: Swift.String?
        /// Number of audio samples recorded per second.
        public var sampleRate: Swift.Int
        /// The expected ingest bitrate (bits per second). This is configured in the encoder.
        public var targetBitrate: Swift.Int

        public init(
            channels: Swift.Int = 0,
            codec: Swift.String? = nil,
            sampleRate: Swift.Int = 0,
            targetBitrate: Swift.Int = 0
        )
        {
            self.channels = channels
            self.codec = codec
            self.sampleRate = sampleRate
            self.targetBitrate = targetBitrate
        }
    }

}

extension IvsClientTypes.BatchError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IvsClientTypes {
    /// Error related to a specific channel, specified by its ARN.
    public struct BatchError: Swift.Equatable {
        /// Channel ARN.
        public var arn: Swift.String?
        /// Error code.
        public var code: Swift.String?
        /// Error message, determined by the application.
        public var message: Swift.String?

        public init(
            arn: Swift.String? = nil,
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.arn = arn
            self.code = code
            self.message = message
        }
    }

}

extension BatchGetChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for channelarn0 in arns {
                try arnsContainer.encode(channelarn0)
            }
        }
    }
}

extension BatchGetChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/BatchGetChannel"
    }
}

public struct BatchGetChannelInput: Swift.Equatable {
    /// Array of ARNs, one per channel.
    /// This member is required.
    public var arns: [Swift.String]?

    public init(
        arns: [Swift.String]? = nil
    )
    {
        self.arns = arns
    }
}

struct BatchGetChannelInputBody: Swift.Equatable {
    let arns: [Swift.String]?
}

extension BatchGetChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
    }
}

extension BatchGetChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.errors = output.errors
        } else {
            self.channels = nil
            self.errors = nil
        }
    }
}

public struct BatchGetChannelOutput: Swift.Equatable {
    ///
    public var channels: [IvsClientTypes.Channel]?
    /// Each error object is related to a specific ARN in the request.
    public var errors: [IvsClientTypes.BatchError]?

    public init(
        channels: [IvsClientTypes.Channel]? = nil,
        errors: [IvsClientTypes.BatchError]? = nil
    )
    {
        self.channels = channels
        self.errors = errors
    }
}

struct BatchGetChannelOutputBody: Swift.Equatable {
    let channels: [IvsClientTypes.Channel]?
    let errors: [IvsClientTypes.BatchError]?
}

extension BatchGetChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([IvsClientTypes.Channel?].self, forKey: .channels)
        var channelsDecoded0:[IvsClientTypes.Channel]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [IvsClientTypes.Channel]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([IvsClientTypes.BatchError?].self, forKey: .errors)
        var errorsDecoded0:[IvsClientTypes.BatchError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IvsClientTypes.BatchError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchGetChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchGetStreamKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for streamkeyarn0 in arns {
                try arnsContainer.encode(streamkeyarn0)
            }
        }
    }
}

extension BatchGetStreamKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/BatchGetStreamKey"
    }
}

public struct BatchGetStreamKeyInput: Swift.Equatable {
    /// Array of ARNs, one per stream key.
    /// This member is required.
    public var arns: [Swift.String]?

    public init(
        arns: [Swift.String]? = nil
    )
    {
        self.arns = arns
    }
}

struct BatchGetStreamKeyInputBody: Swift.Equatable {
    let arns: [Swift.String]?
}

extension BatchGetStreamKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
    }
}

extension BatchGetStreamKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetStreamKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.streamKeys = output.streamKeys
        } else {
            self.errors = nil
            self.streamKeys = nil
        }
    }
}

public struct BatchGetStreamKeyOutput: Swift.Equatable {
    ///
    public var errors: [IvsClientTypes.BatchError]?
    ///
    public var streamKeys: [IvsClientTypes.StreamKey]?

    public init(
        errors: [IvsClientTypes.BatchError]? = nil,
        streamKeys: [IvsClientTypes.StreamKey]? = nil
    )
    {
        self.errors = errors
        self.streamKeys = streamKeys
    }
}

struct BatchGetStreamKeyOutputBody: Swift.Equatable {
    let streamKeys: [IvsClientTypes.StreamKey]?
    let errors: [IvsClientTypes.BatchError]?
}

extension BatchGetStreamKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case streamKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamKeysContainer = try containerValues.decodeIfPresent([IvsClientTypes.StreamKey?].self, forKey: .streamKeys)
        var streamKeysDecoded0:[IvsClientTypes.StreamKey]? = nil
        if let streamKeysContainer = streamKeysContainer {
            streamKeysDecoded0 = [IvsClientTypes.StreamKey]()
            for structure0 in streamKeysContainer {
                if let structure0 = structure0 {
                    streamKeysDecoded0?.append(structure0)
                }
            }
        }
        streamKeys = streamKeysDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([IvsClientTypes.BatchError?].self, forKey: .errors)
        var errorsDecoded0:[IvsClientTypes.BatchError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IvsClientTypes.BatchError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchGetStreamKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IvsClientTypes.BatchStartViewerSessionRevocationError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case code
        case message
        case viewerId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let viewerId = self.viewerId {
            try encodeContainer.encode(viewerId, forKey: .viewerId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let viewerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .viewerId)
        viewerId = viewerIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IvsClientTypes {
    /// Error for a request in the batch for BatchStartViewerSessionRevocation. Each error is related to a specific channel-ARN and viewer-ID pair.
    public struct BatchStartViewerSessionRevocationError: Swift.Equatable {
        /// Channel ARN.
        /// This member is required.
        public var channelArn: Swift.String?
        /// Error code.
        public var code: Swift.String?
        /// Error message, determined by the application.
        public var message: Swift.String?
        /// The ID of the viewer session to revoke.
        /// This member is required.
        public var viewerId: Swift.String?

        public init(
            channelArn: Swift.String? = nil,
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            viewerId: Swift.String? = nil
        )
        {
            self.channelArn = channelArn
            self.code = code
            self.message = message
            self.viewerId = viewerId
        }
    }

}

extension BatchStartViewerSessionRevocationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case viewerSessions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let viewerSessions = viewerSessions {
            var viewerSessionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .viewerSessions)
            for batchstartviewersessionrevocationviewersession0 in viewerSessions {
                try viewerSessionsContainer.encode(batchstartviewersessionrevocationviewersession0)
            }
        }
    }
}

extension BatchStartViewerSessionRevocationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/BatchStartViewerSessionRevocation"
    }
}

public struct BatchStartViewerSessionRevocationInput: Swift.Equatable {
    /// Array of viewer sessions, one per channel-ARN and viewer-ID pair.
    /// This member is required.
    public var viewerSessions: [IvsClientTypes.BatchStartViewerSessionRevocationViewerSession]?

    public init(
        viewerSessions: [IvsClientTypes.BatchStartViewerSessionRevocationViewerSession]? = nil
    )
    {
        self.viewerSessions = viewerSessions
    }
}

struct BatchStartViewerSessionRevocationInputBody: Swift.Equatable {
    let viewerSessions: [IvsClientTypes.BatchStartViewerSessionRevocationViewerSession]?
}

extension BatchStartViewerSessionRevocationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case viewerSessions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let viewerSessionsContainer = try containerValues.decodeIfPresent([IvsClientTypes.BatchStartViewerSessionRevocationViewerSession?].self, forKey: .viewerSessions)
        var viewerSessionsDecoded0:[IvsClientTypes.BatchStartViewerSessionRevocationViewerSession]? = nil
        if let viewerSessionsContainer = viewerSessionsContainer {
            viewerSessionsDecoded0 = [IvsClientTypes.BatchStartViewerSessionRevocationViewerSession]()
            for structure0 in viewerSessionsContainer {
                if let structure0 = structure0 {
                    viewerSessionsDecoded0?.append(structure0)
                }
            }
        }
        viewerSessions = viewerSessionsDecoded0
    }
}

extension BatchStartViewerSessionRevocationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchStartViewerSessionRevocationOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchStartViewerSessionRevocationOutput: Swift.Equatable {
    /// Each error object is related to a specific channelArn and viewerId pair in the request.
    public var errors: [IvsClientTypes.BatchStartViewerSessionRevocationError]?

    public init(
        errors: [IvsClientTypes.BatchStartViewerSessionRevocationError]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchStartViewerSessionRevocationOutputBody: Swift.Equatable {
    let errors: [IvsClientTypes.BatchStartViewerSessionRevocationError]?
}

extension BatchStartViewerSessionRevocationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([IvsClientTypes.BatchStartViewerSessionRevocationError?].self, forKey: .errors)
        var errorsDecoded0:[IvsClientTypes.BatchStartViewerSessionRevocationError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IvsClientTypes.BatchStartViewerSessionRevocationError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchStartViewerSessionRevocationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IvsClientTypes.BatchStartViewerSessionRevocationViewerSession: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case viewerId
        case viewerSessionVersionsLessThanOrEqualTo
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let viewerId = self.viewerId {
            try encodeContainer.encode(viewerId, forKey: .viewerId)
        }
        if viewerSessionVersionsLessThanOrEqualTo != 0 {
            try encodeContainer.encode(viewerSessionVersionsLessThanOrEqualTo, forKey: .viewerSessionVersionsLessThanOrEqualTo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let viewerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .viewerId)
        viewerId = viewerIdDecoded
        let viewerSessionVersionsLessThanOrEqualToDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .viewerSessionVersionsLessThanOrEqualTo) ?? 0
        viewerSessionVersionsLessThanOrEqualTo = viewerSessionVersionsLessThanOrEqualToDecoded
    }
}

extension IvsClientTypes {
    /// A viewer session to revoke in the call to [BatchStartViewerSessionRevocation].
    public struct BatchStartViewerSessionRevocationViewerSession: Swift.Equatable {
        /// The ARN of the channel associated with the viewer session to revoke.
        /// This member is required.
        public var channelArn: Swift.String?
        /// The ID of the viewer associated with the viewer session to revoke. Do not use this field for personally identifying, confidential, or sensitive information.
        /// This member is required.
        public var viewerId: Swift.String?
        /// An optional filter on which versions of the viewer session to revoke. All versions less than or equal to the specified version will be revoked. Default: 0.
        public var viewerSessionVersionsLessThanOrEqualTo: Swift.Int

        public init(
            channelArn: Swift.String? = nil,
            viewerId: Swift.String? = nil,
            viewerSessionVersionsLessThanOrEqualTo: Swift.Int = 0
        )
        {
            self.channelArn = channelArn
            self.viewerId = viewerId
            self.viewerSessionVersionsLessThanOrEqualTo = viewerSessionVersionsLessThanOrEqualTo
        }
    }

}

extension IvsClientTypes.Channel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authorized
        case ingestEndpoint
        case insecureIngest
        case latencyMode
        case name
        case playbackUrl
        case preset
        case recordingConfigurationArn
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if authorized != false {
            try encodeContainer.encode(authorized, forKey: .authorized)
        }
        if let ingestEndpoint = self.ingestEndpoint {
            try encodeContainer.encode(ingestEndpoint, forKey: .ingestEndpoint)
        }
        if insecureIngest != false {
            try encodeContainer.encode(insecureIngest, forKey: .insecureIngest)
        }
        if let latencyMode = self.latencyMode {
            try encodeContainer.encode(latencyMode.rawValue, forKey: .latencyMode)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let playbackUrl = self.playbackUrl {
            try encodeContainer.encode(playbackUrl, forKey: .playbackUrl)
        }
        if let preset = self.preset {
            try encodeContainer.encode(preset.rawValue, forKey: .preset)
        }
        if let recordingConfigurationArn = self.recordingConfigurationArn {
            try encodeContainer.encode(recordingConfigurationArn, forKey: .recordingConfigurationArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let latencyModeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelLatencyMode.self, forKey: .latencyMode)
        latencyMode = latencyModeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelType.self, forKey: .type)
        type = typeDecoded
        let recordingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordingConfigurationArn)
        recordingConfigurationArn = recordingConfigurationArnDecoded
        let ingestEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestEndpoint)
        ingestEndpoint = ingestEndpointDecoded
        let playbackUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackUrl)
        playbackUrl = playbackUrlDecoded
        let authorizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .authorized) ?? false
        authorized = authorizedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let insecureIngestDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .insecureIngest) ?? false
        insecureIngest = insecureIngestDecoded
        let presetDecoded = try containerValues.decodeIfPresent(IvsClientTypes.TranscodePreset.self, forKey: .preset)
        preset = presetDecoded
    }
}

extension IvsClientTypes {
    /// Object specifying a channel.
    public struct Channel: Swift.Equatable {
        /// Channel ARN.
        public var arn: Swift.String?
        /// Whether the channel is private (enabled for playback authorization). Default: false.
        public var authorized: Swift.Bool
        /// Channel ingest endpoint, part of the definition of an ingest server, used when you set up streaming software.
        public var ingestEndpoint: Swift.String?
        /// Whether the channel allows insecure RTMP ingest. Default: false.
        public var insecureIngest: Swift.Bool
        /// Channel latency mode. Use NORMAL to broadcast and deliver live video up to Full HD. Use LOW for near-real-time interaction with viewers. Default: LOW. (Note: In the Amazon IVS console, LOW and NORMAL correspond to Ultra-low and Standard, respectively.)
        public var latencyMode: IvsClientTypes.ChannelLatencyMode?
        /// Channel name.
        public var name: Swift.String?
        /// Channel playback URL.
        public var playbackUrl: Swift.String?
        /// Optional transcode preset for the channel. This is selectable only for ADVANCED_HD and ADVANCED_SD channel types. For those channel types, the default preset is HIGHER_BANDWIDTH_DELIVERY. For other channel types (BASIC and STANDARD), preset is the empty string ("").
        public var preset: IvsClientTypes.TranscodePreset?
        /// Recording-configuration ARN. A value other than an empty string indicates that recording is enabled. Default: "" (empty string, recording is disabled).
        public var recordingConfigurationArn: Swift.String?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?
        /// Channel type, which determines the allowable resolution and bitrate. If you exceed the allowable input resolution or bitrate, the stream probably will disconnect immediately. Default: STANDARD. For details, see [Channel Types](https://docs.aws.amazon.com/ivs/latest/LowLatencyAPIReference/channel-types.html).
        public var type: IvsClientTypes.ChannelType?

        public init(
            arn: Swift.String? = nil,
            authorized: Swift.Bool = false,
            ingestEndpoint: Swift.String? = nil,
            insecureIngest: Swift.Bool = false,
            latencyMode: IvsClientTypes.ChannelLatencyMode? = nil,
            name: Swift.String? = nil,
            playbackUrl: Swift.String? = nil,
            preset: IvsClientTypes.TranscodePreset? = nil,
            recordingConfigurationArn: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: IvsClientTypes.ChannelType? = nil
        )
        {
            self.arn = arn
            self.authorized = authorized
            self.ingestEndpoint = ingestEndpoint
            self.insecureIngest = insecureIngest
            self.latencyMode = latencyMode
            self.name = name
            self.playbackUrl = playbackUrl
            self.preset = preset
            self.recordingConfigurationArn = recordingConfigurationArn
            self.tags = tags
            self.type = type
        }
    }

}

extension IvsClientTypes {
    public enum ChannelLatencyMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lowlatency
        case normallatency
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelLatencyMode] {
            return [
                .lowlatency,
                .normallatency,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lowlatency: return "LOW"
            case .normallatency: return "NORMAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelLatencyMode(rawValue: rawValue) ?? ChannelLatencyMode.sdkUnknown(rawValue)
        }
    }
}

extension ChannelNotBroadcasting {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ChannelNotBroadcastingBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ChannelNotBroadcasting: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The stream is offline for the given channel ARN.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ChannelNotBroadcasting" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct ChannelNotBroadcastingBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension ChannelNotBroadcastingBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IvsClientTypes.ChannelSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authorized
        case insecureIngest
        case latencyMode
        case name
        case preset
        case recordingConfigurationArn
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if authorized != false {
            try encodeContainer.encode(authorized, forKey: .authorized)
        }
        if insecureIngest != false {
            try encodeContainer.encode(insecureIngest, forKey: .insecureIngest)
        }
        if let latencyMode = self.latencyMode {
            try encodeContainer.encode(latencyMode.rawValue, forKey: .latencyMode)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let preset = self.preset {
            try encodeContainer.encode(preset.rawValue, forKey: .preset)
        }
        if let recordingConfigurationArn = self.recordingConfigurationArn {
            try encodeContainer.encode(recordingConfigurationArn, forKey: .recordingConfigurationArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let latencyModeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelLatencyMode.self, forKey: .latencyMode)
        latencyMode = latencyModeDecoded
        let authorizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .authorized) ?? false
        authorized = authorizedDecoded
        let recordingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordingConfigurationArn)
        recordingConfigurationArn = recordingConfigurationArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let insecureIngestDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .insecureIngest) ?? false
        insecureIngest = insecureIngestDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelType.self, forKey: .type)
        type = typeDecoded
        let presetDecoded = try containerValues.decodeIfPresent(IvsClientTypes.TranscodePreset.self, forKey: .preset)
        preset = presetDecoded
    }
}

extension IvsClientTypes {
    /// Summary information about a channel.
    public struct ChannelSummary: Swift.Equatable {
        /// Channel ARN.
        public var arn: Swift.String?
        /// Whether the channel is private (enabled for playback authorization). Default: false.
        public var authorized: Swift.Bool
        /// Whether the channel allows insecure RTMP ingest. Default: false.
        public var insecureIngest: Swift.Bool
        /// Channel latency mode. Use NORMAL to broadcast and deliver live video up to Full HD. Use LOW for near-real-time interaction with viewers. Default: LOW. (Note: In the Amazon IVS console, LOW and NORMAL correspond to Ultra-low and Standard, respectively.)
        public var latencyMode: IvsClientTypes.ChannelLatencyMode?
        /// Channel name.
        public var name: Swift.String?
        /// Optional transcode preset for the channel. This is selectable only for ADVANCED_HD and ADVANCED_SD channel types. For those channel types, the default preset is HIGHER_BANDWIDTH_DELIVERY. For other channel types (BASIC and STANDARD), preset is the empty string ("").
        public var preset: IvsClientTypes.TranscodePreset?
        /// Recording-configuration ARN. A value other than an empty string indicates that recording is enabled. Default: "" (empty string, recording is disabled).
        public var recordingConfigurationArn: Swift.String?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?
        /// Channel type, which determines the allowable resolution and bitrate. If you exceed the allowable input resolution or bitrate, the stream probably will disconnect immediately. Default: STANDARD. For details, see [Channel Types](https://docs.aws.amazon.com/ivs/latest/LowLatencyAPIReference/channel-types.html).
        public var type: IvsClientTypes.ChannelType?

        public init(
            arn: Swift.String? = nil,
            authorized: Swift.Bool = false,
            insecureIngest: Swift.Bool = false,
            latencyMode: IvsClientTypes.ChannelLatencyMode? = nil,
            name: Swift.String? = nil,
            preset: IvsClientTypes.TranscodePreset? = nil,
            recordingConfigurationArn: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: IvsClientTypes.ChannelType? = nil
        )
        {
            self.arn = arn
            self.authorized = authorized
            self.insecureIngest = insecureIngest
            self.latencyMode = latencyMode
            self.name = name
            self.preset = preset
            self.recordingConfigurationArn = recordingConfigurationArn
            self.tags = tags
            self.type = type
        }
    }

}

extension IvsClientTypes {
    public enum ChannelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case advancedhdchanneltype
        case advancedsdchanneltype
        case basicchanneltype
        case standardchanneltype
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelType] {
            return [
                .advancedhdchanneltype,
                .advancedsdchanneltype,
                .basicchanneltype,
                .standardchanneltype,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .advancedhdchanneltype: return "ADVANCED_HD"
            case .advancedsdchanneltype: return "ADVANCED_SD"
            case .basicchanneltype: return "BASIC"
            case .standardchanneltype: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelType(rawValue: rawValue) ?? ChannelType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Updating or deleting a resource can cause an inconsistent state.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension CreateChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorized
        case insecureIngest
        case latencyMode
        case name
        case preset
        case recordingConfigurationArn
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if authorized != false {
            try encodeContainer.encode(authorized, forKey: .authorized)
        }
        if insecureIngest != false {
            try encodeContainer.encode(insecureIngest, forKey: .insecureIngest)
        }
        if let latencyMode = self.latencyMode {
            try encodeContainer.encode(latencyMode.rawValue, forKey: .latencyMode)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let preset = self.preset {
            try encodeContainer.encode(preset.rawValue, forKey: .preset)
        }
        if let recordingConfigurationArn = self.recordingConfigurationArn {
            try encodeContainer.encode(recordingConfigurationArn, forKey: .recordingConfigurationArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateChannel"
    }
}

public struct CreateChannelInput: Swift.Equatable {
    /// Whether the channel is private (enabled for playback authorization). Default: false.
    public var authorized: Swift.Bool
    /// Whether the channel allows insecure RTMP ingest. Default: false.
    public var insecureIngest: Swift.Bool
    /// Channel latency mode. Use NORMAL to broadcast and deliver live video up to Full HD. Use LOW for near-real-time interaction with viewers. (Note: In the Amazon IVS console, LOW and NORMAL correspond to Ultra-low and Standard, respectively.) Default: LOW.
    public var latencyMode: IvsClientTypes.ChannelLatencyMode?
    /// Channel name.
    public var name: Swift.String?
    /// Optional transcode preset for the channel. This is selectable only for ADVANCED_HD and ADVANCED_SD channel types. For those channel types, the default preset is HIGHER_BANDWIDTH_DELIVERY. For other channel types (BASIC and STANDARD), preset is the empty string ("").
    public var preset: IvsClientTypes.TranscodePreset?
    /// Recording-configuration ARN. Default: "" (empty string, recording is disabled).
    public var recordingConfigurationArn: Swift.String?
    /// Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?
    /// Channel type, which determines the allowable resolution and bitrate. If you exceed the allowable input resolution or bitrate, the stream probably will disconnect immediately. Default: STANDARD. For details, see [Channel Types](https://docs.aws.amazon.com/ivs/latest/LowLatencyAPIReference/channel-types.html).
    public var type: IvsClientTypes.ChannelType?

    public init(
        authorized: Swift.Bool = false,
        insecureIngest: Swift.Bool = false,
        latencyMode: IvsClientTypes.ChannelLatencyMode? = nil,
        name: Swift.String? = nil,
        preset: IvsClientTypes.TranscodePreset? = nil,
        recordingConfigurationArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: IvsClientTypes.ChannelType? = nil
    )
    {
        self.authorized = authorized
        self.insecureIngest = insecureIngest
        self.latencyMode = latencyMode
        self.name = name
        self.preset = preset
        self.recordingConfigurationArn = recordingConfigurationArn
        self.tags = tags
        self.type = type
    }
}

struct CreateChannelInputBody: Swift.Equatable {
    let name: Swift.String?
    let latencyMode: IvsClientTypes.ChannelLatencyMode?
    let type: IvsClientTypes.ChannelType?
    let authorized: Swift.Bool
    let recordingConfigurationArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let insecureIngest: Swift.Bool
    let preset: IvsClientTypes.TranscodePreset?
}

extension CreateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorized
        case insecureIngest
        case latencyMode
        case name
        case preset
        case recordingConfigurationArn
        case tags
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let latencyModeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelLatencyMode.self, forKey: .latencyMode)
        latencyMode = latencyModeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelType.self, forKey: .type)
        type = typeDecoded
        let authorizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .authorized) ?? false
        authorized = authorizedDecoded
        let recordingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordingConfigurationArn)
        recordingConfigurationArn = recordingConfigurationArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let insecureIngestDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .insecureIngest) ?? false
        insecureIngest = insecureIngestDecoded
        let presetDecoded = try containerValues.decodeIfPresent(IvsClientTypes.TranscodePreset.self, forKey: .preset)
        preset = presetDecoded
    }
}

extension CreateChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
            self.streamKey = output.streamKey
        } else {
            self.channel = nil
            self.streamKey = nil
        }
    }
}

public struct CreateChannelOutput: Swift.Equatable {
    ///
    public var channel: IvsClientTypes.Channel?
    ///
    public var streamKey: IvsClientTypes.StreamKey?

    public init(
        channel: IvsClientTypes.Channel? = nil,
        streamKey: IvsClientTypes.StreamKey? = nil
    )
    {
        self.channel = channel
        self.streamKey = streamKey
    }
}

struct CreateChannelOutputBody: Swift.Equatable {
    let channel: IvsClientTypes.Channel?
    let streamKey: IvsClientTypes.StreamKey?
}

extension CreateChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel
        case streamKey
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(IvsClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
        let streamKeyDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamKey.self, forKey: .streamKey)
        streamKey = streamKeyDecoded
    }
}

enum CreateChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRecordingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfiguration
        case name
        case recordingReconnectWindowSeconds
        case renditionConfiguration
        case tags
        case thumbnailConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfiguration = self.destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if recordingReconnectWindowSeconds != 0 {
            try encodeContainer.encode(recordingReconnectWindowSeconds, forKey: .recordingReconnectWindowSeconds)
        }
        if let renditionConfiguration = self.renditionConfiguration {
            try encodeContainer.encode(renditionConfiguration, forKey: .renditionConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let thumbnailConfiguration = self.thumbnailConfiguration {
            try encodeContainer.encode(thumbnailConfiguration, forKey: .thumbnailConfiguration)
        }
    }
}

extension CreateRecordingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateRecordingConfiguration"
    }
}

public struct CreateRecordingConfigurationInput: Swift.Equatable {
    /// A complex type that contains a destination configuration for where recorded video will be stored.
    /// This member is required.
    public var destinationConfiguration: IvsClientTypes.DestinationConfiguration?
    /// Recording-configuration name. The value does not need to be unique.
    public var name: Swift.String?
    /// If a broadcast disconnects and then reconnects within the specified interval, the multiple streams will be considered a single broadcast and merged together. Default: 0.
    public var recordingReconnectWindowSeconds: Swift.Int
    /// Object that describes which renditions should be recorded for a stream.
    public var renditionConfiguration: IvsClientTypes.RenditionConfiguration?
    /// Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?
    /// A complex type that allows you to enable/disable the recording of thumbnails for a live session and modify the interval at which thumbnails are generated for the live session.
    public var thumbnailConfiguration: IvsClientTypes.ThumbnailConfiguration?

    public init(
        destinationConfiguration: IvsClientTypes.DestinationConfiguration? = nil,
        name: Swift.String? = nil,
        recordingReconnectWindowSeconds: Swift.Int = 0,
        renditionConfiguration: IvsClientTypes.RenditionConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        thumbnailConfiguration: IvsClientTypes.ThumbnailConfiguration? = nil
    )
    {
        self.destinationConfiguration = destinationConfiguration
        self.name = name
        self.recordingReconnectWindowSeconds = recordingReconnectWindowSeconds
        self.renditionConfiguration = renditionConfiguration
        self.tags = tags
        self.thumbnailConfiguration = thumbnailConfiguration
    }
}

struct CreateRecordingConfigurationInputBody: Swift.Equatable {
    let name: Swift.String?
    let destinationConfiguration: IvsClientTypes.DestinationConfiguration?
    let tags: [Swift.String:Swift.String]?
    let thumbnailConfiguration: IvsClientTypes.ThumbnailConfiguration?
    let recordingReconnectWindowSeconds: Swift.Int
    let renditionConfiguration: IvsClientTypes.RenditionConfiguration?
}

extension CreateRecordingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfiguration
        case name
        case recordingReconnectWindowSeconds
        case renditionConfiguration
        case tags
        case thumbnailConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let thumbnailConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ThumbnailConfiguration.self, forKey: .thumbnailConfiguration)
        thumbnailConfiguration = thumbnailConfigurationDecoded
        let recordingReconnectWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordingReconnectWindowSeconds) ?? 0
        recordingReconnectWindowSeconds = recordingReconnectWindowSecondsDecoded
        let renditionConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.RenditionConfiguration.self, forKey: .renditionConfiguration)
        renditionConfiguration = renditionConfigurationDecoded
    }
}

extension CreateRecordingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRecordingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.recordingConfiguration = output.recordingConfiguration
        } else {
            self.recordingConfiguration = nil
        }
    }
}

public struct CreateRecordingConfigurationOutput: Swift.Equatable {
    ///
    public var recordingConfiguration: IvsClientTypes.RecordingConfiguration?

    public init(
        recordingConfiguration: IvsClientTypes.RecordingConfiguration? = nil
    )
    {
        self.recordingConfiguration = recordingConfiguration
    }
}

struct CreateRecordingConfigurationOutputBody: Swift.Equatable {
    let recordingConfiguration: IvsClientTypes.RecordingConfiguration?
}

extension CreateRecordingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordingConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordingConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.RecordingConfiguration.self, forKey: .recordingConfiguration)
        recordingConfiguration = recordingConfigurationDecoded
    }
}

enum CreateRecordingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateStreamKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateStreamKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateStreamKey"
    }
}

public struct CreateStreamKeyInput: Swift.Equatable {
    /// ARN of the channel for which to create the stream key.
    /// This member is required.
    public var channelArn: Swift.String?
    /// Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?

    public init(
        channelArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.channelArn = channelArn
        self.tags = tags
    }
}

struct CreateStreamKeyInputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateStreamKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStreamKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateStreamKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.streamKey = output.streamKey
        } else {
            self.streamKey = nil
        }
    }
}

public struct CreateStreamKeyOutput: Swift.Equatable {
    /// Stream key used to authenticate an RTMPS stream for ingestion.
    public var streamKey: IvsClientTypes.StreamKey?

    public init(
        streamKey: IvsClientTypes.StreamKey? = nil
    )
    {
        self.streamKey = streamKey
    }
}

struct CreateStreamKeyOutputBody: Swift.Equatable {
    let streamKey: IvsClientTypes.StreamKey?
}

extension CreateStreamKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamKey
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamKeyDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamKey.self, forKey: .streamKey)
        streamKey = streamKeyDecoded
    }
}

enum CreateStreamKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteChannel"
    }
}

public struct DeleteChannelInput: Swift.Equatable {
    /// ARN of the channel to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteChannelInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteChannelOutput: Swift.Equatable {

    public init() { }
}

enum DeleteChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePlaybackKeyPairInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeletePlaybackKeyPairInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeletePlaybackKeyPair"
    }
}

public struct DeletePlaybackKeyPairInput: Swift.Equatable {
    /// ARN of the key pair to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeletePlaybackKeyPairInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeletePlaybackKeyPairInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeletePlaybackKeyPairOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePlaybackKeyPairOutput: Swift.Equatable {

    public init() { }
}

enum DeletePlaybackKeyPairOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRecordingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteRecordingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteRecordingConfiguration"
    }
}

public struct DeleteRecordingConfigurationInput: Swift.Equatable {
    /// ARN of the recording configuration to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteRecordingConfigurationInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteRecordingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteRecordingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRecordingConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRecordingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteStreamKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteStreamKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteStreamKey"
    }
}

public struct DeleteStreamKeyInput: Swift.Equatable {
    /// ARN of the stream key to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteStreamKeyInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteStreamKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteStreamKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteStreamKeyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStreamKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IvsClientTypes.DestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(IvsClientTypes.S3DestinationConfiguration.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension IvsClientTypes {
    /// A complex type that describes a location where recorded videos will be stored. Each member represents a type of destination configuration. For recording, you define one and only one type of destination configuration.
    public struct DestinationConfiguration: Swift.Equatable {
        /// An S3 destination configuration where recorded videos will be stored.
        public var s3: IvsClientTypes.S3DestinationConfiguration?

        public init(
            s3: IvsClientTypes.S3DestinationConfiguration? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension GetChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetChannel"
    }
}

public struct GetChannelInput: Swift.Equatable {
    /// ARN of the channel for which the configuration is to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetChannelInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
        } else {
            self.channel = nil
        }
    }
}

public struct GetChannelOutput: Swift.Equatable {
    ///
    public var channel: IvsClientTypes.Channel?

    public init(
        channel: IvsClientTypes.Channel? = nil
    )
    {
        self.channel = channel
    }
}

struct GetChannelOutputBody: Swift.Equatable {
    let channel: IvsClientTypes.Channel?
}

extension GetChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(IvsClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

enum GetChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPlaybackKeyPairInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetPlaybackKeyPairInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetPlaybackKeyPair"
    }
}

public struct GetPlaybackKeyPairInput: Swift.Equatable {
    /// ARN of the key pair to be returned.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetPlaybackKeyPairInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetPlaybackKeyPairInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetPlaybackKeyPairOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPlaybackKeyPairOutputBody = try responseDecoder.decode(responseBody: data)
            self.keyPair = output.keyPair
        } else {
            self.keyPair = nil
        }
    }
}

public struct GetPlaybackKeyPairOutput: Swift.Equatable {
    ///
    public var keyPair: IvsClientTypes.PlaybackKeyPair?

    public init(
        keyPair: IvsClientTypes.PlaybackKeyPair? = nil
    )
    {
        self.keyPair = keyPair
    }
}

struct GetPlaybackKeyPairOutputBody: Swift.Equatable {
    let keyPair: IvsClientTypes.PlaybackKeyPair?
}

extension GetPlaybackKeyPairOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyPair
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPairDecoded = try containerValues.decodeIfPresent(IvsClientTypes.PlaybackKeyPair.self, forKey: .keyPair)
        keyPair = keyPairDecoded
    }
}

enum GetPlaybackKeyPairOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRecordingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetRecordingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetRecordingConfiguration"
    }
}

public struct GetRecordingConfigurationInput: Swift.Equatable {
    /// ARN of the recording configuration to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetRecordingConfigurationInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetRecordingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetRecordingConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRecordingConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.recordingConfiguration = output.recordingConfiguration
        } else {
            self.recordingConfiguration = nil
        }
    }
}

public struct GetRecordingConfigurationOutput: Swift.Equatable {
    ///
    public var recordingConfiguration: IvsClientTypes.RecordingConfiguration?

    public init(
        recordingConfiguration: IvsClientTypes.RecordingConfiguration? = nil
    )
    {
        self.recordingConfiguration = recordingConfiguration
    }
}

struct GetRecordingConfigurationOutputBody: Swift.Equatable {
    let recordingConfiguration: IvsClientTypes.RecordingConfiguration?
}

extension GetRecordingConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordingConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordingConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.RecordingConfiguration.self, forKey: .recordingConfiguration)
        recordingConfiguration = recordingConfigurationDecoded
    }
}

enum GetRecordingConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
    }
}

extension GetStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetStream"
    }
}

public struct GetStreamInput: Swift.Equatable {
    /// Channel ARN for stream to be accessed.
    /// This member is required.
    public var channelArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct GetStreamInputBody: Swift.Equatable {
    let channelArn: Swift.String?
}

extension GetStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

extension GetStreamKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetStreamKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetStreamKey"
    }
}

public struct GetStreamKeyInput: Swift.Equatable {
    /// ARN for the stream key to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetStreamKeyInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetStreamKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetStreamKeyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStreamKeyOutputBody = try responseDecoder.decode(responseBody: data)
            self.streamKey = output.streamKey
        } else {
            self.streamKey = nil
        }
    }
}

public struct GetStreamKeyOutput: Swift.Equatable {
    ///
    public var streamKey: IvsClientTypes.StreamKey?

    public init(
        streamKey: IvsClientTypes.StreamKey? = nil
    )
    {
        self.streamKey = streamKey
    }
}

struct GetStreamKeyOutputBody: Swift.Equatable {
    let streamKey: IvsClientTypes.StreamKey?
}

extension GetStreamKeyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamKey
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamKeyDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamKey.self, forKey: .streamKey)
        streamKey = streamKeyDecoded
    }
}

enum GetStreamKeyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStreamOutputBody = try responseDecoder.decode(responseBody: data)
            self.stream = output.stream
        } else {
            self.stream = nil
        }
    }
}

public struct GetStreamOutput: Swift.Equatable {
    ///
    public var stream: IvsClientTypes.Stream?

    public init(
        stream: IvsClientTypes.Stream? = nil
    )
    {
        self.stream = stream
    }
}

struct GetStreamOutputBody: Swift.Equatable {
    let stream: IvsClientTypes.Stream?
}

extension GetStreamOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stream
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDecoded = try containerValues.decodeIfPresent(IvsClientTypes.Stream.self, forKey: .stream)
        stream = streamDecoded
    }
}

enum GetStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ChannelNotBroadcasting": return try await ChannelNotBroadcasting(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetStreamSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case streamId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
    }
}

extension GetStreamSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetStreamSession"
    }
}

public struct GetStreamSessionInput: Swift.Equatable {
    /// ARN of the channel resource
    /// This member is required.
    public var channelArn: Swift.String?
    /// Unique identifier for a live or previously live stream in the specified channel. If no streamId is provided, this returns the most recent stream session for the channel, if it exists.
    public var streamId: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        streamId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.streamId = streamId
    }
}

struct GetStreamSessionInputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let streamId: Swift.String?
}

extension GetStreamSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case streamId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
    }
}

extension GetStreamSessionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetStreamSessionOutputBody = try responseDecoder.decode(responseBody: data)
            self.streamSession = output.streamSession
        } else {
            self.streamSession = nil
        }
    }
}

public struct GetStreamSessionOutput: Swift.Equatable {
    /// List of stream details.
    public var streamSession: IvsClientTypes.StreamSession?

    public init(
        streamSession: IvsClientTypes.StreamSession? = nil
    )
    {
        self.streamSession = streamSession
    }
}

struct GetStreamSessionOutputBody: Swift.Equatable {
    let streamSession: IvsClientTypes.StreamSession?
}

extension GetStreamSessionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamSession
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamSessionDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamSession.self, forKey: .streamSession)
        streamSession = streamSessionDecoded
    }
}

enum GetStreamSessionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImportPlaybackKeyPairInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case publicKeyMaterial
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let publicKeyMaterial = self.publicKeyMaterial {
            try encodeContainer.encode(publicKeyMaterial, forKey: .publicKeyMaterial)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension ImportPlaybackKeyPairInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ImportPlaybackKeyPair"
    }
}

public struct ImportPlaybackKeyPairInput: Swift.Equatable {
    /// Playback-key-pair name. The value does not need to be unique.
    public var name: Swift.String?
    /// The public portion of a customer-generated key pair.
    /// This member is required.
    public var publicKeyMaterial: Swift.String?
    /// Any tags provided with the request are added to the playback key pair tags. See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?

    public init(
        name: Swift.String? = nil,
        publicKeyMaterial: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.name = name
        self.publicKeyMaterial = publicKeyMaterial
        self.tags = tags
    }
}

struct ImportPlaybackKeyPairInputBody: Swift.Equatable {
    let publicKeyMaterial: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension ImportPlaybackKeyPairInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case publicKeyMaterial
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyMaterialDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicKeyMaterial)
        publicKeyMaterial = publicKeyMaterialDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImportPlaybackKeyPairOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImportPlaybackKeyPairOutputBody = try responseDecoder.decode(responseBody: data)
            self.keyPair = output.keyPair
        } else {
            self.keyPair = nil
        }
    }
}

public struct ImportPlaybackKeyPairOutput: Swift.Equatable {
    ///
    public var keyPair: IvsClientTypes.PlaybackKeyPair?

    public init(
        keyPair: IvsClientTypes.PlaybackKeyPair? = nil
    )
    {
        self.keyPair = keyPair
    }
}

struct ImportPlaybackKeyPairOutputBody: Swift.Equatable {
    let keyPair: IvsClientTypes.PlaybackKeyPair?
}

extension ImportPlaybackKeyPairOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyPair
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPairDecoded = try containerValues.decodeIfPresent(IvsClientTypes.PlaybackKeyPair.self, forKey: .keyPair)
        keyPair = keyPairDecoded
    }
}

enum ImportPlaybackKeyPairOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IvsClientTypes.IngestConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audio
        case video
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audio = self.audio {
            try encodeContainer.encode(audio, forKey: .audio)
        }
        if let video = self.video {
            try encodeContainer.encode(video, forKey: .video)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let videoDecoded = try containerValues.decodeIfPresent(IvsClientTypes.VideoConfiguration.self, forKey: .video)
        video = videoDecoded
        let audioDecoded = try containerValues.decodeIfPresent(IvsClientTypes.AudioConfiguration.self, forKey: .audio)
        audio = audioDecoded
    }
}

extension IvsClientTypes {
    /// Object specifying the ingest configuration set up by the broadcaster, usually in an encoder.
    public struct IngestConfiguration: Swift.Equatable {
        /// Encoder settings for audio.
        public var audio: IvsClientTypes.AudioConfiguration?
        /// Encoder settings for video.
        public var video: IvsClientTypes.VideoConfiguration?

        public init(
            audio: IvsClientTypes.AudioConfiguration? = nil,
            video: IvsClientTypes.VideoConfiguration? = nil
        )
        {
            self.audio = audio
            self.video = video
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Unexpected error during processing of request.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension ListChannelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterByName
        case filterByRecordingConfigurationArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterByName = self.filterByName {
            try encodeContainer.encode(filterByName, forKey: .filterByName)
        }
        if let filterByRecordingConfigurationArn = self.filterByRecordingConfigurationArn {
            try encodeContainer.encode(filterByRecordingConfigurationArn, forKey: .filterByRecordingConfigurationArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListChannels"
    }
}

public struct ListChannelsInput: Swift.Equatable {
    /// Filters the channel list to match the specified name.
    public var filterByName: Swift.String?
    /// Filters the channel list to match the specified recording-configuration ARN.
    public var filterByRecordingConfigurationArn: Swift.String?
    /// Maximum number of channels to return. Default: 100.
    public var maxResults: Swift.Int
    /// The first channel to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        filterByName: Swift.String? = nil,
        filterByRecordingConfigurationArn: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filterByName = filterByName
        self.filterByRecordingConfigurationArn = filterByRecordingConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsInputBody: Swift.Equatable {
    let filterByName: Swift.String?
    let filterByRecordingConfigurationArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListChannelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterByName
        case filterByRecordingConfigurationArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterByNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterByName)
        filterByName = filterByNameDecoded
        let filterByRecordingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterByRecordingConfigurationArn)
        filterByRecordingConfigurationArn = filterByRecordingConfigurationArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension ListChannelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListChannelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutput: Swift.Equatable {
    /// List of the matching channels.
    /// This member is required.
    public var channels: [IvsClientTypes.ChannelSummary]?
    /// If there are more channels than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?

    public init(
        channels: [IvsClientTypes.ChannelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputBody: Swift.Equatable {
    let channels: [IvsClientTypes.ChannelSummary]?
    let nextToken: Swift.String?
}

extension ListChannelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([IvsClientTypes.ChannelSummary?].self, forKey: .channels)
        var channelsDecoded0:[IvsClientTypes.ChannelSummary]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [IvsClientTypes.ChannelSummary]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListChannelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPlaybackKeyPairsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPlaybackKeyPairsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListPlaybackKeyPairs"
    }
}

public struct ListPlaybackKeyPairsInput: Swift.Equatable {
    /// Maximum number of key pairs to return. Default: your service quota or 100, whichever is smaller.
    public var maxResults: Swift.Int
    /// The first key pair to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPlaybackKeyPairsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListPlaybackKeyPairsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension ListPlaybackKeyPairsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPlaybackKeyPairsOutputBody = try responseDecoder.decode(responseBody: data)
            self.keyPairs = output.keyPairs
            self.nextToken = output.nextToken
        } else {
            self.keyPairs = nil
            self.nextToken = nil
        }
    }
}

public struct ListPlaybackKeyPairsOutput: Swift.Equatable {
    /// List of key pairs.
    /// This member is required.
    public var keyPairs: [IvsClientTypes.PlaybackKeyPairSummary]?
    /// If there are more key pairs than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?

    public init(
        keyPairs: [IvsClientTypes.PlaybackKeyPairSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.keyPairs = keyPairs
        self.nextToken = nextToken
    }
}

struct ListPlaybackKeyPairsOutputBody: Swift.Equatable {
    let keyPairs: [IvsClientTypes.PlaybackKeyPairSummary]?
    let nextToken: Swift.String?
}

extension ListPlaybackKeyPairsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyPairs
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPairsContainer = try containerValues.decodeIfPresent([IvsClientTypes.PlaybackKeyPairSummary?].self, forKey: .keyPairs)
        var keyPairsDecoded0:[IvsClientTypes.PlaybackKeyPairSummary]? = nil
        if let keyPairsContainer = keyPairsContainer {
            keyPairsDecoded0 = [IvsClientTypes.PlaybackKeyPairSummary]()
            for structure0 in keyPairsContainer {
                if let structure0 = structure0 {
                    keyPairsDecoded0?.append(structure0)
                }
            }
        }
        keyPairs = keyPairsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPlaybackKeyPairsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRecordingConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRecordingConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListRecordingConfigurations"
    }
}

public struct ListRecordingConfigurationsInput: Swift.Equatable {
    /// Maximum number of recording configurations to return. Default: your service quota or 100, whichever is smaller.
    public var maxResults: Swift.Int
    /// The first recording configuration to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRecordingConfigurationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListRecordingConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension ListRecordingConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRecordingConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recordingConfigurations = output.recordingConfigurations
        } else {
            self.nextToken = nil
            self.recordingConfigurations = nil
        }
    }
}

public struct ListRecordingConfigurationsOutput: Swift.Equatable {
    /// If there are more recording configurations than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching recording configurations.
    /// This member is required.
    public var recordingConfigurations: [IvsClientTypes.RecordingConfigurationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        recordingConfigurations: [IvsClientTypes.RecordingConfigurationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recordingConfigurations = recordingConfigurations
    }
}

struct ListRecordingConfigurationsOutputBody: Swift.Equatable {
    let recordingConfigurations: [IvsClientTypes.RecordingConfigurationSummary]?
    let nextToken: Swift.String?
}

extension ListRecordingConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case recordingConfigurations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordingConfigurationsContainer = try containerValues.decodeIfPresent([IvsClientTypes.RecordingConfigurationSummary?].self, forKey: .recordingConfigurations)
        var recordingConfigurationsDecoded0:[IvsClientTypes.RecordingConfigurationSummary]? = nil
        if let recordingConfigurationsContainer = recordingConfigurationsContainer {
            recordingConfigurationsDecoded0 = [IvsClientTypes.RecordingConfigurationSummary]()
            for structure0 in recordingConfigurationsContainer {
                if let structure0 = structure0 {
                    recordingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        recordingConfigurations = recordingConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRecordingConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStreamKeysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListStreamKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListStreamKeys"
    }
}

public struct ListStreamKeysInput: Swift.Equatable {
    /// Channel ARN used to filter the list.
    /// This member is required.
    public var channelArn: Swift.String?
    /// Maximum number of streamKeys to return. Default: 1.
    public var maxResults: Swift.Int
    /// The first stream key to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStreamKeysInputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListStreamKeysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension ListStreamKeysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStreamKeysOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.streamKeys = output.streamKeys
        } else {
            self.nextToken = nil
            self.streamKeys = nil
        }
    }
}

public struct ListStreamKeysOutput: Swift.Equatable {
    /// If there are more stream keys than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of stream keys.
    /// This member is required.
    public var streamKeys: [IvsClientTypes.StreamKeySummary]?

    public init(
        nextToken: Swift.String? = nil,
        streamKeys: [IvsClientTypes.StreamKeySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.streamKeys = streamKeys
    }
}

struct ListStreamKeysOutputBody: Swift.Equatable {
    let streamKeys: [IvsClientTypes.StreamKeySummary]?
    let nextToken: Swift.String?
}

extension ListStreamKeysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case streamKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamKeysContainer = try containerValues.decodeIfPresent([IvsClientTypes.StreamKeySummary?].self, forKey: .streamKeys)
        var streamKeysDecoded0:[IvsClientTypes.StreamKeySummary]? = nil
        if let streamKeysContainer = streamKeysContainer {
            streamKeysDecoded0 = [IvsClientTypes.StreamKeySummary]()
            for structure0 in streamKeysContainer {
                if let structure0 = structure0 {
                    streamKeysDecoded0?.append(structure0)
                }
            }
        }
        streamKeys = streamKeysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListStreamKeysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStreamSessionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListStreamSessionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListStreamSessions"
    }
}

public struct ListStreamSessionsInput: Swift.Equatable {
    /// Channel ARN used to filter the list.
    /// This member is required.
    public var channelArn: Swift.String?
    /// Maximum number of streams to return. Default: 100.
    public var maxResults: Swift.Int
    /// The first stream to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStreamSessionsInputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListStreamSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension ListStreamSessionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStreamSessionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.streamSessions = output.streamSessions
        } else {
            self.nextToken = nil
            self.streamSessions = nil
        }
    }
}

public struct ListStreamSessionsOutput: Swift.Equatable {
    /// If there are more streams than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of stream sessions.
    /// This member is required.
    public var streamSessions: [IvsClientTypes.StreamSessionSummary]?

    public init(
        nextToken: Swift.String? = nil,
        streamSessions: [IvsClientTypes.StreamSessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.streamSessions = streamSessions
    }
}

struct ListStreamSessionsOutputBody: Swift.Equatable {
    let streamSessions: [IvsClientTypes.StreamSessionSummary]?
    let nextToken: Swift.String?
}

extension ListStreamSessionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case streamSessions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamSessionsContainer = try containerValues.decodeIfPresent([IvsClientTypes.StreamSessionSummary?].self, forKey: .streamSessions)
        var streamSessionsDecoded0:[IvsClientTypes.StreamSessionSummary]? = nil
        if let streamSessionsContainer = streamSessionsContainer {
            streamSessionsDecoded0 = [IvsClientTypes.StreamSessionSummary]()
            for structure0 in streamSessionsContainer {
                if let structure0 = structure0 {
                    streamSessionsDecoded0?.append(structure0)
                }
            }
        }
        streamSessions = streamSessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListStreamSessionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStreamsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterBy
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterBy = self.filterBy {
            try encodeContainer.encode(filterBy, forKey: .filterBy)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListStreamsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListStreams"
    }
}

public struct ListStreamsInput: Swift.Equatable {
    /// Filters the stream list to match the specified criterion.
    public var filterBy: IvsClientTypes.StreamFilters?
    /// Maximum number of streams to return. Default: 100.
    public var maxResults: Swift.Int
    /// The first stream to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init(
        filterBy: IvsClientTypes.StreamFilters? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filterBy = filterBy
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStreamsInputBody: Swift.Equatable {
    let filterBy: IvsClientTypes.StreamFilters?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListStreamsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterBy
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterByDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamFilters.self, forKey: .filterBy)
        filterBy = filterByDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension ListStreamsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStreamsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.streams = output.streams
        } else {
            self.nextToken = nil
            self.streams = nil
        }
    }
}

public struct ListStreamsOutput: Swift.Equatable {
    /// If there are more streams than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of streams.
    /// This member is required.
    public var streams: [IvsClientTypes.StreamSummary]?

    public init(
        nextToken: Swift.String? = nil,
        streams: [IvsClientTypes.StreamSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.streams = streams
    }
}

struct ListStreamsOutputBody: Swift.Equatable {
    let streams: [IvsClientTypes.StreamSummary]?
    let nextToken: Swift.String?
}

extension ListStreamsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case streams
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamsContainer = try containerValues.decodeIfPresent([IvsClientTypes.StreamSummary?].self, forKey: .streams)
        var streamsDecoded0:[IvsClientTypes.StreamSummary]? = nil
        if let streamsContainer = streamsContainer {
            streamsDecoded0 = [IvsClientTypes.StreamSummary]()
            for structure0 in streamsContainer {
                if let structure0 = structure0 {
                    streamsDecoded0?.append(structure0)
                }
            }
        }
        streams = streamsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListStreamsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource to be retrieved. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PendingVerification {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PendingVerificationBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct PendingVerification: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Your account is pending verification.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PendingVerification" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct PendingVerificationBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension PendingVerificationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IvsClientTypes.PlaybackKeyPair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case fingerprint
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let fingerprint = self.fingerprint {
            try encodeContainer.encode(fingerprint, forKey: .fingerprint)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fingerprint)
        fingerprint = fingerprintDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvsClientTypes {
    /// A key pair used to sign and validate a playback authorization token.
    public struct PlaybackKeyPair: Swift.Equatable {
        /// Key-pair ARN.
        public var arn: Swift.String?
        /// Key-pair identifier.
        public var fingerprint: Swift.String?
        /// Playback-key-pair name. The value does not need to be unique.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            fingerprint: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.fingerprint = fingerprint
            self.name = name
            self.tags = tags
        }
    }

}

extension IvsClientTypes.PlaybackKeyPairSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvsClientTypes {
    /// Summary information about a playback key pair.
    public struct PlaybackKeyPairSummary: Swift.Equatable {
        /// Key-pair ARN.
        public var arn: Swift.String?
        /// Playback-key-pair name. The value does not need to be unique.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.tags = tags
        }
    }

}

extension PutMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutMetadataInput(channelArn: \(Swift.String(describing: channelArn)), metadata: \"CONTENT_REDACTED\")"}
}

extension PutMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case metadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
    }
}

extension PutMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/PutMetadata"
    }
}

public struct PutMetadataInput: Swift.Equatable {
    /// ARN of the channel into which metadata is inserted. This channel must have an active stream.
    /// This member is required.
    public var channelArn: Swift.String?
    /// Metadata to insert into the stream. Maximum: 1 KB per request.
    /// This member is required.
    public var metadata: Swift.String?

    public init(
        channelArn: Swift.String? = nil,
        metadata: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.metadata = metadata
    }
}

struct PutMetadataInputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let metadata: Swift.String?
}

extension PutMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case metadata
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension PutMetadataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutMetadataOutput: Swift.Equatable {

    public init() { }
}

enum PutMetadataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ChannelNotBroadcasting": return try await ChannelNotBroadcasting(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IvsClientTypes.RecordingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case destinationConfiguration
        case name
        case recordingReconnectWindowSeconds
        case renditionConfiguration
        case state
        case tags
        case thumbnailConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let destinationConfiguration = self.destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if recordingReconnectWindowSeconds != 0 {
            try encodeContainer.encode(recordingReconnectWindowSeconds, forKey: .recordingReconnectWindowSeconds)
        }
        if let renditionConfiguration = self.renditionConfiguration {
            try encodeContainer.encode(renditionConfiguration, forKey: .renditionConfiguration)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let thumbnailConfiguration = self.thumbnailConfiguration {
            try encodeContainer.encode(thumbnailConfiguration, forKey: .thumbnailConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IvsClientTypes.RecordingConfigurationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let thumbnailConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ThumbnailConfiguration.self, forKey: .thumbnailConfiguration)
        thumbnailConfiguration = thumbnailConfigurationDecoded
        let recordingReconnectWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordingReconnectWindowSeconds) ?? 0
        recordingReconnectWindowSeconds = recordingReconnectWindowSecondsDecoded
        let renditionConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.RenditionConfiguration.self, forKey: .renditionConfiguration)
        renditionConfiguration = renditionConfigurationDecoded
    }
}

extension IvsClientTypes {
    /// An object representing a configuration to record a channel stream.
    public struct RecordingConfiguration: Swift.Equatable {
        /// Recording-configuration ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// A complex type that contains information about where recorded video will be stored.
        /// This member is required.
        public var destinationConfiguration: IvsClientTypes.DestinationConfiguration?
        /// Recording-configuration name. The value does not need to be unique.
        public var name: Swift.String?
        /// If a broadcast disconnects and then reconnects within the specified interval, the multiple streams will be considered a single broadcast and merged together. Default: 0.
        public var recordingReconnectWindowSeconds: Swift.Int
        /// Object that describes which renditions should be recorded for a stream.
        public var renditionConfiguration: IvsClientTypes.RenditionConfiguration?
        /// Indicates the current state of the recording configuration. When the state is ACTIVE, the configuration is ready for recording a channel stream.
        /// This member is required.
        public var state: IvsClientTypes.RecordingConfigurationState?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?
        /// A complex type that allows you to enable/disable the recording of thumbnails for a live session and modify the interval at which thumbnails are generated for the live session.
        public var thumbnailConfiguration: IvsClientTypes.ThumbnailConfiguration?

        public init(
            arn: Swift.String? = nil,
            destinationConfiguration: IvsClientTypes.DestinationConfiguration? = nil,
            name: Swift.String? = nil,
            recordingReconnectWindowSeconds: Swift.Int = 0,
            renditionConfiguration: IvsClientTypes.RenditionConfiguration? = nil,
            state: IvsClientTypes.RecordingConfigurationState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            thumbnailConfiguration: IvsClientTypes.ThumbnailConfiguration? = nil
        )
        {
            self.arn = arn
            self.destinationConfiguration = destinationConfiguration
            self.name = name
            self.recordingReconnectWindowSeconds = recordingReconnectWindowSeconds
            self.renditionConfiguration = renditionConfiguration
            self.state = state
            self.tags = tags
            self.thumbnailConfiguration = thumbnailConfiguration
        }
    }

}

extension IvsClientTypes {
    public enum RecordingConfigurationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createfailed
        case creating
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordingConfigurationState] {
            return [
                .active,
                .createfailed,
                .creating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createfailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecordingConfigurationState(rawValue: rawValue) ?? RecordingConfigurationState.sdkUnknown(rawValue)
        }
    }
}

extension IvsClientTypes.RecordingConfigurationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case destinationConfiguration
        case name
        case state
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let destinationConfiguration = self.destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IvsClientTypes.RecordingConfigurationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvsClientTypes {
    /// Summary information about a RecordingConfiguration.
    public struct RecordingConfigurationSummary: Swift.Equatable {
        /// Recording-configuration ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// A complex type that contains information about where recorded video will be stored.
        /// This member is required.
        public var destinationConfiguration: IvsClientTypes.DestinationConfiguration?
        /// Recording-configuration name. The value does not need to be unique.
        public var name: Swift.String?
        /// Indicates the current state of the recording configuration. When the state is ACTIVE, the configuration is ready for recording a channel stream.
        /// This member is required.
        public var state: IvsClientTypes.RecordingConfigurationState?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            destinationConfiguration: IvsClientTypes.DestinationConfiguration? = nil,
            name: Swift.String? = nil,
            state: IvsClientTypes.RecordingConfigurationState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.destinationConfiguration = destinationConfiguration
            self.name = name
            self.state = state
            self.tags = tags
        }
    }

}

extension IvsClientTypes {
    public enum RecordingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case interval
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordingMode] {
            return [
                .disabled,
                .interval,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .interval: return "INTERVAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecordingMode(rawValue: rawValue) ?? RecordingMode.sdkUnknown(rawValue)
        }
    }
}

extension IvsClientTypes.RenditionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case renditionSelection
        case renditions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let renditionSelection = self.renditionSelection {
            try encodeContainer.encode(renditionSelection.rawValue, forKey: .renditionSelection)
        }
        if let renditions = renditions {
            var renditionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .renditions)
            for renditionconfigurationrendition0 in renditions {
                try renditionsContainer.encode(renditionconfigurationrendition0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let renditionSelectionDecoded = try containerValues.decodeIfPresent(IvsClientTypes.RenditionConfigurationRenditionSelection.self, forKey: .renditionSelection)
        renditionSelection = renditionSelectionDecoded
        let renditionsContainer = try containerValues.decodeIfPresent([IvsClientTypes.RenditionConfigurationRendition?].self, forKey: .renditions)
        var renditionsDecoded0:[IvsClientTypes.RenditionConfigurationRendition]? = nil
        if let renditionsContainer = renditionsContainer {
            renditionsDecoded0 = [IvsClientTypes.RenditionConfigurationRendition]()
            for string0 in renditionsContainer {
                if let string0 = string0 {
                    renditionsDecoded0?.append(string0)
                }
            }
        }
        renditions = renditionsDecoded0
    }
}

extension IvsClientTypes {
    /// Object that describes which renditions should be recorded for a stream.
    public struct RenditionConfiguration: Swift.Equatable {
        /// Indicates which set of renditions are recorded for a stream. For BASIC channels, the CUSTOM value has no effect. If CUSTOM is specified, a set of renditions must be specified in the renditions field. Default: ALL.
        public var renditionSelection: IvsClientTypes.RenditionConfigurationRenditionSelection?
        /// Indicates which renditions are recorded for a stream, if renditionSelection is CUSTOM; otherwise, this field is irrelevant. The selected renditions are recorded if they are available during the stream. If a selected rendition is unavailable, the best available rendition is recorded. For details on the resolution dimensions of each rendition, see [Auto-Record to Amazon S3](https://docs.aws.amazon.com/ivs/latest/userguide/record-to-s3.html).
        public var renditions: [IvsClientTypes.RenditionConfigurationRendition]?

        public init(
            renditionSelection: IvsClientTypes.RenditionConfigurationRenditionSelection? = nil,
            renditions: [IvsClientTypes.RenditionConfigurationRendition]? = nil
        )
        {
            self.renditionSelection = renditionSelection
            self.renditions = renditions
        }
    }

}

extension IvsClientTypes {
    public enum RenditionConfigurationRendition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullHd
        case hd
        case lowestResolution
        case sd
        case sdkUnknown(Swift.String)

        public static var allCases: [RenditionConfigurationRendition] {
            return [
                .fullHd,
                .hd,
                .lowestResolution,
                .sd,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullHd: return "FULL_HD"
            case .hd: return "HD"
            case .lowestResolution: return "LOWEST_RESOLUTION"
            case .sd: return "SD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RenditionConfigurationRendition(rawValue: rawValue) ?? RenditionConfigurationRendition.sdkUnknown(rawValue)
        }
    }
}

extension IvsClientTypes {
    public enum RenditionConfigurationRenditionSelection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case custom
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [RenditionConfigurationRenditionSelection] {
            return [
                .all,
                .custom,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .custom: return "CUSTOM"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RenditionConfigurationRenditionSelection(rawValue: rawValue) ?? RenditionConfigurationRenditionSelection.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Request references a resource which does not exist.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IvsClientTypes.S3DestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension IvsClientTypes {
    /// A complex type that describes an S3 location where recorded videos will be stored.
    public struct S3DestinationConfiguration: Swift.Equatable {
        /// Location (S3 bucket name) where recorded videos will be stored.
        /// This member is required.
        public var bucketName: Swift.String?

        public init(
            bucketName: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Request would cause a service quota to be exceeded.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension StartViewerSessionRevocationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case viewerId
        case viewerSessionVersionsLessThanOrEqualTo
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let viewerId = self.viewerId {
            try encodeContainer.encode(viewerId, forKey: .viewerId)
        }
        if viewerSessionVersionsLessThanOrEqualTo != 0 {
            try encodeContainer.encode(viewerSessionVersionsLessThanOrEqualTo, forKey: .viewerSessionVersionsLessThanOrEqualTo)
        }
    }
}

extension StartViewerSessionRevocationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StartViewerSessionRevocation"
    }
}

public struct StartViewerSessionRevocationInput: Swift.Equatable {
    /// The ARN of the channel associated with the viewer session to revoke.
    /// This member is required.
    public var channelArn: Swift.String?
    /// The ID of the viewer associated with the viewer session to revoke. Do not use this field for personally identifying, confidential, or sensitive information.
    /// This member is required.
    public var viewerId: Swift.String?
    /// An optional filter on which versions of the viewer session to revoke. All versions less than or equal to the specified version will be revoked. Default: 0.
    public var viewerSessionVersionsLessThanOrEqualTo: Swift.Int

    public init(
        channelArn: Swift.String? = nil,
        viewerId: Swift.String? = nil,
        viewerSessionVersionsLessThanOrEqualTo: Swift.Int = 0
    )
    {
        self.channelArn = channelArn
        self.viewerId = viewerId
        self.viewerSessionVersionsLessThanOrEqualTo = viewerSessionVersionsLessThanOrEqualTo
    }
}

struct StartViewerSessionRevocationInputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let viewerId: Swift.String?
    let viewerSessionVersionsLessThanOrEqualTo: Swift.Int
}

extension StartViewerSessionRevocationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case viewerId
        case viewerSessionVersionsLessThanOrEqualTo
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let viewerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .viewerId)
        viewerId = viewerIdDecoded
        let viewerSessionVersionsLessThanOrEqualToDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .viewerSessionVersionsLessThanOrEqualTo) ?? 0
        viewerSessionVersionsLessThanOrEqualTo = viewerSessionVersionsLessThanOrEqualToDecoded
    }
}

extension StartViewerSessionRevocationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartViewerSessionRevocationOutput: Swift.Equatable {

    public init() { }
}

enum StartViewerSessionRevocationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
    }
}

extension StopStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StopStream"
    }
}

public struct StopStreamInput: Swift.Equatable {
    /// ARN of the channel for which the stream is to be stopped.
    /// This member is required.
    public var channelArn: Swift.String?

    public init(
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct StopStreamInputBody: Swift.Equatable {
    let channelArn: Swift.String?
}

extension StopStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

extension StopStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopStreamOutput: Swift.Equatable {

    public init() { }
}

enum StopStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ChannelNotBroadcasting": return try await ChannelNotBroadcasting(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StreamUnavailable": return try await StreamUnavailable(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IvsClientTypes.Stream: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case health
        case playbackUrl
        case startTime
        case state
        case streamId
        case viewerCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let health = self.health {
            try encodeContainer.encode(health.rawValue, forKey: .health)
        }
        if let playbackUrl = self.playbackUrl {
            try encodeContainer.encode(playbackUrl, forKey: .playbackUrl)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if viewerCount != 0 {
            try encodeContainer.encode(viewerCount, forKey: .viewerCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let playbackUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackUrl)
        playbackUrl = playbackUrlDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamState.self, forKey: .state)
        state = stateDecoded
        let healthDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamHealth.self, forKey: .health)
        health = healthDecoded
        let viewerCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .viewerCount) ?? 0
        viewerCount = viewerCountDecoded
    }
}

extension IvsClientTypes {
    /// Specifies a live video stream that has been ingested and distributed.
    public struct Stream: Swift.Equatable {
        /// Channel ARN for the stream.
        public var channelArn: Swift.String?
        /// The streamâ€™s health.
        public var health: IvsClientTypes.StreamHealth?
        /// URL of the master playlist, required by the video player to play the HLS stream.
        public var playbackUrl: Swift.String?
        /// Time of the streamâ€™s start. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: ClientRuntime.Date?
        /// The streamâ€™s state. Do not rely on the OFFLINE state, as the API may not return it; instead, a "NotBroadcasting" error will indicate that the stream is not live.
        public var state: IvsClientTypes.StreamState?
        /// Unique identifier for a live or previously live stream in the specified channel.
        public var streamId: Swift.String?
        /// A count of concurrent views of the stream. Typically, a new view appears in viewerCount within 15 seconds of when video playback starts and a view is removed from viewerCount within 1 minute of when video playback ends. A value of -1 indicates that the request timed out; in this case, retry.
        public var viewerCount: Swift.Int

        public init(
            channelArn: Swift.String? = nil,
            health: IvsClientTypes.StreamHealth? = nil,
            playbackUrl: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: IvsClientTypes.StreamState? = nil,
            streamId: Swift.String? = nil,
            viewerCount: Swift.Int = 0
        )
        {
            self.channelArn = channelArn
            self.health = health
            self.playbackUrl = playbackUrl
            self.startTime = startTime
            self.state = state
            self.streamId = streamId
            self.viewerCount = viewerCount
        }
    }

}

extension IvsClientTypes.StreamEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTime
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTime = self.eventTime {
            try encodeContainer.encodeTimestamp(eventTime, format: .dateTime, forKey: .eventTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let eventTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .eventTime)
        eventTime = eventTimeDecoded
    }
}

extension IvsClientTypes {
    /// Object specifying a streamâ€™s events. For a list of events, see [Using Amazon EventBridge with Amazon IVS](https://docs.aws.amazon.com/ivs/latest/userguide/eventbridge.html).
    public struct StreamEvent: Swift.Equatable {
        /// Time when the event occurred. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var eventTime: ClientRuntime.Date?
        /// Name that identifies the stream event within a type.
        public var name: Swift.String?
        /// Logical group for certain events.
        public var type: Swift.String?

        public init(
            eventTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.eventTime = eventTime
            self.name = name
            self.type = type
        }
    }

}

extension IvsClientTypes.StreamFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case health
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let health = self.health {
            try encodeContainer.encode(health.rawValue, forKey: .health)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let healthDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamHealth.self, forKey: .health)
        health = healthDecoded
    }
}

extension IvsClientTypes {
    /// Object specifying the stream attribute on which to filter.
    public struct StreamFilters: Swift.Equatable {
        /// The streamâ€™s health.
        public var health: IvsClientTypes.StreamHealth?

        public init(
            health: IvsClientTypes.StreamHealth? = nil
        )
        {
            self.health = health
        }
    }

}

extension IvsClientTypes {
    public enum StreamHealth: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case starving
        case streamhealthy
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamHealth] {
            return [
                .starving,
                .streamhealthy,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .starving: return "STARVING"
            case .streamhealthy: return "HEALTHY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamHealth(rawValue: rawValue) ?? StreamHealth.sdkUnknown(rawValue)
        }
    }
}

extension IvsClientTypes.StreamKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case channelArn
        case tags
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvsClientTypes.StreamKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamKey(arn: \(Swift.String(describing: arn)), channelArn: \(Swift.String(describing: channelArn)), tags: \(Swift.String(describing: tags)), value: \"CONTENT_REDACTED\")"}
}

extension IvsClientTypes {
    /// Object specifying a stream key.
    public struct StreamKey: Swift.Equatable {
        /// Stream-key ARN.
        public var arn: Swift.String?
        /// Channel ARN for the stream.
        public var channelArn: Swift.String?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?
        /// Stream-key value.
        public var value: Swift.String?

        public init(
            arn: Swift.String? = nil,
            channelArn: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            value: Swift.String? = nil
        )
        {
            self.arn = arn
            self.channelArn = channelArn
            self.tags = tags
            self.value = value
        }
    }

}

extension IvsClientTypes.StreamKeySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case channelArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvsClientTypes {
    /// Summary information about a stream key.
    public struct StreamKeySummary: Swift.Equatable {
        /// Stream-key ARN.
        public var arn: Swift.String?
        /// Channel ARN for the stream.
        public var channelArn: Swift.String?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            channelArn: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.channelArn = channelArn
            self.tags = tags
        }
    }

}

extension IvsClientTypes.StreamSession: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel
        case endTime
        case ingestConfiguration
        case recordingConfiguration
        case startTime
        case streamId
        case truncatedEvents
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = self.channel {
            try encodeContainer.encode(channel, forKey: .channel)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let ingestConfiguration = self.ingestConfiguration {
            try encodeContainer.encode(ingestConfiguration, forKey: .ingestConfiguration)
        }
        if let recordingConfiguration = self.recordingConfiguration {
            try encodeContainer.encode(recordingConfiguration, forKey: .recordingConfiguration)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let truncatedEvents = truncatedEvents {
            var truncatedEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .truncatedEvents)
            for streamevent0 in truncatedEvents {
                try truncatedEventsContainer.encode(streamevent0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let channelDecoded = try containerValues.decodeIfPresent(IvsClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
        let ingestConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.IngestConfiguration.self, forKey: .ingestConfiguration)
        ingestConfiguration = ingestConfigurationDecoded
        let recordingConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.RecordingConfiguration.self, forKey: .recordingConfiguration)
        recordingConfiguration = recordingConfigurationDecoded
        let truncatedEventsContainer = try containerValues.decodeIfPresent([IvsClientTypes.StreamEvent?].self, forKey: .truncatedEvents)
        var truncatedEventsDecoded0:[IvsClientTypes.StreamEvent]? = nil
        if let truncatedEventsContainer = truncatedEventsContainer {
            truncatedEventsDecoded0 = [IvsClientTypes.StreamEvent]()
            for structure0 in truncatedEventsContainer {
                if let structure0 = structure0 {
                    truncatedEventsDecoded0?.append(structure0)
                }
            }
        }
        truncatedEvents = truncatedEventsDecoded0
    }
}

extension IvsClientTypes {
    /// Object that captures the Amazon IVS configuration that the customer provisioned, the ingest configurations that the broadcaster used, and the most recent Amazon IVS stream events it encountered.
    public struct StreamSession: Swift.Equatable {
        /// The properties of the channel at the time of going live.
        public var channel: IvsClientTypes.Channel?
        /// Time when the channel went offline. This is an ISO 8601 timestamp; note that this is returned as a string. For live streams, this is NULL.
        public var endTime: ClientRuntime.Date?
        /// The properties of the incoming RTMP stream for the stream.
        public var ingestConfiguration: IvsClientTypes.IngestConfiguration?
        /// The properties of recording the live stream.
        public var recordingConfiguration: IvsClientTypes.RecordingConfiguration?
        /// Time when the channel went live. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: ClientRuntime.Date?
        /// Unique identifier for a live or previously live stream in the specified channel.
        public var streamId: Swift.String?
        /// List of Amazon IVS events that the stream encountered. The list is sorted by most recent events and contains up to 500 events. For Amazon IVS events, see [Using Amazon EventBridge with Amazon IVS](https://docs.aws.amazon.com/ivs/latest/userguide/eventbridge.html).
        public var truncatedEvents: [IvsClientTypes.StreamEvent]?

        public init(
            channel: IvsClientTypes.Channel? = nil,
            endTime: ClientRuntime.Date? = nil,
            ingestConfiguration: IvsClientTypes.IngestConfiguration? = nil,
            recordingConfiguration: IvsClientTypes.RecordingConfiguration? = nil,
            startTime: ClientRuntime.Date? = nil,
            streamId: Swift.String? = nil,
            truncatedEvents: [IvsClientTypes.StreamEvent]? = nil
        )
        {
            self.channel = channel
            self.endTime = endTime
            self.ingestConfiguration = ingestConfiguration
            self.recordingConfiguration = recordingConfiguration
            self.startTime = startTime
            self.streamId = streamId
            self.truncatedEvents = truncatedEvents
        }
    }

}

extension IvsClientTypes.StreamSessionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case hasErrorEvent
        case startTime
        case streamId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if hasErrorEvent != false {
            try encodeContainer.encode(hasErrorEvent, forKey: .hasErrorEvent)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let hasErrorEventDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasErrorEvent) ?? false
        hasErrorEvent = hasErrorEventDecoded
    }
}

extension IvsClientTypes {
    /// Summary information about a stream session.
    public struct StreamSessionSummary: Swift.Equatable {
        /// Time when the channel went offline. This is an ISO 8601 timestamp; note that this is returned as a string. For live streams, this is NULL.
        public var endTime: ClientRuntime.Date?
        /// If true, this stream encountered a quota breach or failure.
        public var hasErrorEvent: Swift.Bool
        /// Time when the channel went live. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: ClientRuntime.Date?
        /// Unique identifier for a live or previously live stream in the specified channel.
        public var streamId: Swift.String?

        public init(
            endTime: ClientRuntime.Date? = nil,
            hasErrorEvent: Swift.Bool = false,
            startTime: ClientRuntime.Date? = nil,
            streamId: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.hasErrorEvent = hasErrorEvent
            self.startTime = startTime
            self.streamId = streamId
        }
    }

}

extension IvsClientTypes {
    public enum StreamState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case streamlive
        case streamoffline
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamState] {
            return [
                .streamlive,
                .streamoffline,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .streamlive: return "LIVE"
            case .streamoffline: return "OFFLINE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamState(rawValue: rawValue) ?? StreamState.sdkUnknown(rawValue)
        }
    }
}

extension IvsClientTypes.StreamSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case health
        case startTime
        case state
        case streamId
        case viewerCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let health = self.health {
            try encodeContainer.encode(health.rawValue, forKey: .health)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if viewerCount != 0 {
            try encodeContainer.encode(viewerCount, forKey: .viewerCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamState.self, forKey: .state)
        state = stateDecoded
        let healthDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamHealth.self, forKey: .health)
        health = healthDecoded
        let viewerCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .viewerCount) ?? 0
        viewerCount = viewerCountDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension IvsClientTypes {
    /// Summary information about a stream.
    public struct StreamSummary: Swift.Equatable {
        /// Channel ARN for the stream.
        public var channelArn: Swift.String?
        /// The streamâ€™s health.
        public var health: IvsClientTypes.StreamHealth?
        /// Time of the streamâ€™s start. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: ClientRuntime.Date?
        /// The streamâ€™s state. Do not rely on the OFFLINE state, as the API may not return it; instead, a "NotBroadcasting" error will indicate that the stream is not live.
        public var state: IvsClientTypes.StreamState?
        /// Unique identifier for a live or previously live stream in the specified channel.
        public var streamId: Swift.String?
        /// A count of concurrent views of the stream. Typically, a new view appears in viewerCount within 15 seconds of when video playback starts and a view is removed from viewerCount within 1 minute of when video playback ends. A value of -1 indicates that the request timed out; in this case, retry.
        public var viewerCount: Swift.Int

        public init(
            channelArn: Swift.String? = nil,
            health: IvsClientTypes.StreamHealth? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: IvsClientTypes.StreamState? = nil,
            streamId: Swift.String? = nil,
            viewerCount: Swift.Int = 0
        )
        {
            self.channelArn = channelArn
            self.health = health
            self.startTime = startTime
            self.state = state
            self.streamId = streamId
            self.viewerCount = viewerCount
        }
    }

}

extension StreamUnavailable {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StreamUnavailableBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct StreamUnavailable: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The stream is temporarily unavailable.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StreamUnavailable" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct StreamUnavailableBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension StreamUnavailableBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// ARN of the resource for which tags are to be added or updated. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be added or updated. Array of maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Request was denied due to request throttling.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IvsClientTypes.ThumbnailConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordingMode
        case resolution
        case storage
        case targetIntervalSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordingMode = self.recordingMode {
            try encodeContainer.encode(recordingMode.rawValue, forKey: .recordingMode)
        }
        if let resolution = self.resolution {
            try encodeContainer.encode(resolution.rawValue, forKey: .resolution)
        }
        if let storage = storage {
            var storageContainer = encodeContainer.nestedUnkeyedContainer(forKey: .storage)
            for thumbnailconfigurationstorage0 in storage {
                try storageContainer.encode(thumbnailconfigurationstorage0.rawValue)
            }
        }
        if targetIntervalSeconds != 0 {
            try encodeContainer.encode(targetIntervalSeconds, forKey: .targetIntervalSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordingModeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.RecordingMode.self, forKey: .recordingMode)
        recordingMode = recordingModeDecoded
        let targetIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetIntervalSeconds) ?? 0
        targetIntervalSeconds = targetIntervalSecondsDecoded
        let resolutionDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ThumbnailConfigurationResolution.self, forKey: .resolution)
        resolution = resolutionDecoded
        let storageContainer = try containerValues.decodeIfPresent([IvsClientTypes.ThumbnailConfigurationStorage?].self, forKey: .storage)
        var storageDecoded0:[IvsClientTypes.ThumbnailConfigurationStorage]? = nil
        if let storageContainer = storageContainer {
            storageDecoded0 = [IvsClientTypes.ThumbnailConfigurationStorage]()
            for string0 in storageContainer {
                if let string0 = string0 {
                    storageDecoded0?.append(string0)
                }
            }
        }
        storage = storageDecoded0
    }
}

extension IvsClientTypes {
    /// An object representing a configuration of thumbnails for recorded video.
    public struct ThumbnailConfiguration: Swift.Equatable {
        /// Thumbnail recording mode. Default: INTERVAL.
        public var recordingMode: IvsClientTypes.RecordingMode?
        /// Indicates the desired resolution of recorded thumbnails. Thumbnails are recorded at the selected resolution if the corresponding rendition is available during the stream; otherwise, they are recorded at source resolution. For more information about resolution values and their corresponding height and width dimensions, see [Auto-Record to Amazon S3](https://docs.aws.amazon.com/ivs/latest/userguide/record-to-s3.html). Default: Null (source resolution is returned).
        public var resolution: IvsClientTypes.ThumbnailConfigurationResolution?
        /// Indicates the format in which thumbnails are recorded. SEQUENTIAL records all generated thumbnails in a serial manner, to the media/thumbnails directory. LATEST saves the latest thumbnail in media/latest_thumbnail/thumb.jpg and overwrites it at the interval specified by targetIntervalSeconds. You can enable both SEQUENTIAL and LATEST. Default: SEQUENTIAL.
        public var storage: [IvsClientTypes.ThumbnailConfigurationStorage]?
        /// The targeted thumbnail-generation interval in seconds. This is configurable (and required) only if recordingMode is INTERVAL. Default: 60. Important: For the BASIC channel type, setting a value for targetIntervalSeconds does not guarantee that thumbnails are generated at the specified interval. For thumbnails to be generated at the targetIntervalSeconds interval, the IDR/Keyframe value for the input video must be less than the targetIntervalSeconds value. See [ Amazon IVS Streaming Configuration](https://docs.aws.amazon.com/ivs/latest/userguide/streaming-config.html) for information on setting IDR/Keyframe to the recommended value in video-encoder settings.
        public var targetIntervalSeconds: Swift.Int

        public init(
            recordingMode: IvsClientTypes.RecordingMode? = nil,
            resolution: IvsClientTypes.ThumbnailConfigurationResolution? = nil,
            storage: [IvsClientTypes.ThumbnailConfigurationStorage]? = nil,
            targetIntervalSeconds: Swift.Int = 0
        )
        {
            self.recordingMode = recordingMode
            self.resolution = resolution
            self.storage = storage
            self.targetIntervalSeconds = targetIntervalSeconds
        }
    }

}

extension IvsClientTypes {
    public enum ThumbnailConfigurationResolution: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullHd
        case hd
        case lowestResolution
        case sd
        case sdkUnknown(Swift.String)

        public static var allCases: [ThumbnailConfigurationResolution] {
            return [
                .fullHd,
                .hd,
                .lowestResolution,
                .sd,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullHd: return "FULL_HD"
            case .hd: return "HD"
            case .lowestResolution: return "LOWEST_RESOLUTION"
            case .sd: return "SD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThumbnailConfigurationResolution(rawValue: rawValue) ?? ThumbnailConfigurationResolution.sdkUnknown(rawValue)
        }
    }
}

extension IvsClientTypes {
    public enum ThumbnailConfigurationStorage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case latest
        case sequential
        case sdkUnknown(Swift.String)

        public static var allCases: [ThumbnailConfigurationStorage] {
            return [
                .latest,
                .sequential,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .latest: return "LATEST"
            case .sequential: return "SEQUENTIAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThumbnailConfigurationStorage(rawValue: rawValue) ?? ThumbnailConfigurationStorage.sdkUnknown(rawValue)
        }
    }
}

extension IvsClientTypes {
    public enum TranscodePreset: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case constrainedbandwidthtranscodepreset
        case higherbandwidthtranscodepreset
        case sdkUnknown(Swift.String)

        public static var allCases: [TranscodePreset] {
            return [
                .constrainedbandwidthtranscodepreset,
                .higherbandwidthtranscodepreset,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .constrainedbandwidthtranscodepreset: return "CONSTRAINED_BANDWIDTH_DELIVERY"
            case .higherbandwidthtranscodepreset: return "HIGHER_BANDWIDTH_DELIVERY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TranscodePreset(rawValue: rawValue) ?? TranscodePreset.sdkUnknown(rawValue)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// ARN of the resource for which tags are to be removed. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be removed. Array of maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authorized
        case insecureIngest
        case latencyMode
        case name
        case preset
        case recordingConfigurationArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if authorized != false {
            try encodeContainer.encode(authorized, forKey: .authorized)
        }
        if insecureIngest != false {
            try encodeContainer.encode(insecureIngest, forKey: .insecureIngest)
        }
        if let latencyMode = self.latencyMode {
            try encodeContainer.encode(latencyMode.rawValue, forKey: .latencyMode)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let preset = self.preset {
            try encodeContainer.encode(preset.rawValue, forKey: .preset)
        }
        if let recordingConfigurationArn = self.recordingConfigurationArn {
            try encodeContainer.encode(recordingConfigurationArn, forKey: .recordingConfigurationArn)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateChannel"
    }
}

public struct UpdateChannelInput: Swift.Equatable {
    /// ARN of the channel to be updated.
    /// This member is required.
    public var arn: Swift.String?
    /// Whether the channel is private (enabled for playback authorization).
    public var authorized: Swift.Bool
    /// Whether the channel allows insecure RTMP ingest. Default: false.
    public var insecureIngest: Swift.Bool
    /// Channel latency mode. Use NORMAL to broadcast and deliver live video up to Full HD. Use LOW for near-real-time interaction with viewers. (Note: In the Amazon IVS console, LOW and NORMAL correspond to Ultra-low and Standard, respectively.)
    public var latencyMode: IvsClientTypes.ChannelLatencyMode?
    /// Channel name.
    public var name: Swift.String?
    /// Optional transcode preset for the channel. This is selectable only for ADVANCED_HD and ADVANCED_SD channel types. For those channel types, the default preset is HIGHER_BANDWIDTH_DELIVERY. For other channel types (BASIC and STANDARD), preset is the empty string ("").
    public var preset: IvsClientTypes.TranscodePreset?
    /// Recording-configuration ARN. If this is set to an empty string, recording is disabled. A value other than an empty string indicates that recording is enabled
    public var recordingConfigurationArn: Swift.String?
    /// Channel type, which determines the allowable resolution and bitrate. If you exceed the allowable input resolution or bitrate, the stream probably will disconnect immediately. Default: STANDARD. For details, see [Channel Types](https://docs.aws.amazon.com/ivs/latest/LowLatencyAPIReference/channel-types.html).
    public var type: IvsClientTypes.ChannelType?

    public init(
        arn: Swift.String? = nil,
        authorized: Swift.Bool = false,
        insecureIngest: Swift.Bool = false,
        latencyMode: IvsClientTypes.ChannelLatencyMode? = nil,
        name: Swift.String? = nil,
        preset: IvsClientTypes.TranscodePreset? = nil,
        recordingConfigurationArn: Swift.String? = nil,
        type: IvsClientTypes.ChannelType? = nil
    )
    {
        self.arn = arn
        self.authorized = authorized
        self.insecureIngest = insecureIngest
        self.latencyMode = latencyMode
        self.name = name
        self.preset = preset
        self.recordingConfigurationArn = recordingConfigurationArn
        self.type = type
    }
}

struct UpdateChannelInputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let latencyMode: IvsClientTypes.ChannelLatencyMode?
    let type: IvsClientTypes.ChannelType?
    let authorized: Swift.Bool
    let recordingConfigurationArn: Swift.String?
    let insecureIngest: Swift.Bool
    let preset: IvsClientTypes.TranscodePreset?
}

extension UpdateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authorized
        case insecureIngest
        case latencyMode
        case name
        case preset
        case recordingConfigurationArn
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let latencyModeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelLatencyMode.self, forKey: .latencyMode)
        latencyMode = latencyModeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelType.self, forKey: .type)
        type = typeDecoded
        let authorizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .authorized) ?? false
        authorized = authorizedDecoded
        let recordingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordingConfigurationArn)
        recordingConfigurationArn = recordingConfigurationArnDecoded
        let insecureIngestDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .insecureIngest) ?? false
        insecureIngest = insecureIngestDecoded
        let presetDecoded = try containerValues.decodeIfPresent(IvsClientTypes.TranscodePreset.self, forKey: .preset)
        preset = presetDecoded
    }
}

extension UpdateChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
        } else {
            self.channel = nil
        }
    }
}

public struct UpdateChannelOutput: Swift.Equatable {
    /// Object specifying a channel.
    public var channel: IvsClientTypes.Channel?

    public init(
        channel: IvsClientTypes.Channel? = nil
    )
    {
        self.channel = channel
    }
}

struct UpdateChannelOutputBody: Swift.Equatable {
    let channel: IvsClientTypes.Channel?
}

extension UpdateChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(IvsClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

enum UpdateChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PendingVerification": return try await PendingVerification(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.exceptionMessage = output.exceptionMessage
        } else {
            self.properties.exceptionMessage = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

///
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
        public internal(set) var exceptionMessage: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        exceptionMessage: Swift.String? = nil
    )
    {
        self.properties.exceptionMessage = exceptionMessage
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IvsClientTypes.VideoConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case avcLevel
        case avcProfile
        case codec
        case encoder
        case targetBitrate
        case targetFramerate
        case videoHeight
        case videoWidth
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let avcLevel = self.avcLevel {
            try encodeContainer.encode(avcLevel, forKey: .avcLevel)
        }
        if let avcProfile = self.avcProfile {
            try encodeContainer.encode(avcProfile, forKey: .avcProfile)
        }
        if let codec = self.codec {
            try encodeContainer.encode(codec, forKey: .codec)
        }
        if let encoder = self.encoder {
            try encodeContainer.encode(encoder, forKey: .encoder)
        }
        if targetBitrate != 0 {
            try encodeContainer.encode(targetBitrate, forKey: .targetBitrate)
        }
        if targetFramerate != 0 {
            try encodeContainer.encode(targetFramerate, forKey: .targetFramerate)
        }
        if videoHeight != 0 {
            try encodeContainer.encode(videoHeight, forKey: .videoHeight)
        }
        if videoWidth != 0 {
            try encodeContainer.encode(videoWidth, forKey: .videoWidth)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let avcProfileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .avcProfile)
        avcProfile = avcProfileDecoded
        let avcLevelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .avcLevel)
        avcLevel = avcLevelDecoded
        let codecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codec)
        codec = codecDecoded
        let encoderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encoder)
        encoder = encoderDecoded
        let targetBitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetBitrate) ?? 0
        targetBitrate = targetBitrateDecoded
        let targetFramerateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetFramerate) ?? 0
        targetFramerate = targetFramerateDecoded
        let videoHeightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .videoHeight) ?? 0
        videoHeight = videoHeightDecoded
        let videoWidthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .videoWidth) ?? 0
        videoWidth = videoWidthDecoded
    }
}

extension IvsClientTypes {
    /// Object specifying a streamâ€™s video configuration, as set up by the broadcaster (usually in an encoder). This is part of the [IngestConfiguration] object and used for monitoring stream health.
    public struct VideoConfiguration: Swift.Equatable {
        /// Indicates the degree of required decoder performance for a profile. Normally this is set automatically by the encoder. For details, see the H.264 specification.
        public var avcLevel: Swift.String?
        /// Indicates to the decoder the requirements for decoding the stream. For definitions of the valid values, see the H.264 specification.
        public var avcProfile: Swift.String?
        /// Codec used for the video encoding.
        public var codec: Swift.String?
        /// Software or hardware used to encode the video.
        public var encoder: Swift.String?
        /// The expected ingest bitrate (bits per second). This is configured in the encoder.
        public var targetBitrate: Swift.Int
        /// The expected ingest framerate. This is configured in the encoder.
        public var targetFramerate: Swift.Int
        /// Video-resolution height in pixels.
        public var videoHeight: Swift.Int
        /// Video-resolution width in pixels.
        public var videoWidth: Swift.Int

        public init(
            avcLevel: Swift.String? = nil,
            avcProfile: Swift.String? = nil,
            codec: Swift.String? = nil,
            encoder: Swift.String? = nil,
            targetBitrate: Swift.Int = 0,
            targetFramerate: Swift.Int = 0,
            videoHeight: Swift.Int = 0,
            videoWidth: Swift.Int = 0
        )
        {
            self.avcLevel = avcLevel
            self.avcProfile = avcProfile
            self.codec = codec
            self.encoder = encoder
            self.targetBitrate = targetBitrate
            self.targetFramerate = targetFramerate
            self.videoHeight = videoHeight
            self.videoWidth = videoWidth
        }
    }

}
