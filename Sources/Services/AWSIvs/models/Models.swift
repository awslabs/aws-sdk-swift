// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// User does not have sufficient access to perform this action.
    public var exceptionMessage: Swift.String?

    public init (
        exceptionMessage: Swift.String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IvsClientTypes.AudioConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels
        case codec
        case sampleRate
        case targetBitrate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if channels != 0 {
            try encodeContainer.encode(channels, forKey: .channels)
        }
        if let codec = self.codec {
            try encodeContainer.encode(codec, forKey: .codec)
        }
        if sampleRate != 0 {
            try encodeContainer.encode(sampleRate, forKey: .sampleRate)
        }
        if targetBitrate != 0 {
            try encodeContainer.encode(targetBitrate, forKey: .targetBitrate)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codec)
        codec = codecDecoded
        let targetBitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetBitrate) ?? 0
        targetBitrate = targetBitrateDecoded
        let sampleRateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .sampleRate) ?? 0
        sampleRate = sampleRateDecoded
        let channelsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .channels) ?? 0
        channels = channelsDecoded
    }
}

extension IvsClientTypes {
    /// Object specifying a streamâ€™s audio configuration, as set up by the broadcaster (usually in an encoder). This is part of the [IngestConfiguration] object and used for monitoring stream health.
    public struct AudioConfiguration: Swift.Equatable {
        /// Number of audio channels.
        public var channels: Swift.Int
        /// Codec used for the audio encoding.
        public var codec: Swift.String?
        /// Number of audio samples recorded per second.
        public var sampleRate: Swift.Int
        /// The expected ingest bitrate (bits per second). This is configured in the encoder.
        public var targetBitrate: Swift.Int

        public init (
            channels: Swift.Int = 0,
            codec: Swift.String? = nil,
            sampleRate: Swift.Int = 0,
            targetBitrate: Swift.Int = 0
        )
        {
            self.channels = channels
            self.codec = codec
            self.sampleRate = sampleRate
            self.targetBitrate = targetBitrate
        }
    }

}

extension IvsClientTypes.BatchError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IvsClientTypes {
    /// Error related to a specific channel, specified by its ARN.
    public struct BatchError: Swift.Equatable {
        /// Channel ARN.
        public var arn: Swift.String?
        /// Error code.
        public var code: Swift.String?
        /// Error message, determined by the application.
        public var message: Swift.String?

        public init (
            arn: Swift.String? = nil,
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.arn = arn
            self.code = code
            self.message = message
        }
    }

}

extension BatchGetChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for channelarn0 in arns {
                try arnsContainer.encode(channelarn0)
            }
        }
    }
}

extension BatchGetChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/BatchGetChannel"
    }
}

public struct BatchGetChannelInput: Swift.Equatable {
    /// Array of ARNs, one per channel.
    /// This member is required.
    public var arns: [Swift.String]?

    public init (
        arns: [Swift.String]? = nil
    )
    {
        self.arns = arns
    }
}

struct BatchGetChannelInputBody: Swift.Equatable {
    let arns: [Swift.String]?
}

extension BatchGetChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
    }
}

extension BatchGetChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetChannelOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.errors = output.errors
        } else {
            self.channels = nil
            self.errors = nil
        }
    }
}

public struct BatchGetChannelOutputResponse: Swift.Equatable {
    ///
    public var channels: [IvsClientTypes.Channel]?
    /// Each error object is related to a specific ARN in the request.
    public var errors: [IvsClientTypes.BatchError]?

    public init (
        channels: [IvsClientTypes.Channel]? = nil,
        errors: [IvsClientTypes.BatchError]? = nil
    )
    {
        self.channels = channels
        self.errors = errors
    }
}

struct BatchGetChannelOutputResponseBody: Swift.Equatable {
    let channels: [IvsClientTypes.Channel]?
    let errors: [IvsClientTypes.BatchError]?
}

extension BatchGetChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels
        case errors
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([IvsClientTypes.Channel?].self, forKey: .channels)
        var channelsDecoded0:[IvsClientTypes.Channel]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [IvsClientTypes.Channel]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([IvsClientTypes.BatchError?].self, forKey: .errors)
        var errorsDecoded0:[IvsClientTypes.BatchError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IvsClientTypes.BatchError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension BatchGetStreamKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arns = arns {
            var arnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .arns)
            for streamkeyarn0 in arns {
                try arnsContainer.encode(streamkeyarn0)
            }
        }
    }
}

extension BatchGetStreamKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/BatchGetStreamKey"
    }
}

public struct BatchGetStreamKeyInput: Swift.Equatable {
    /// Array of ARNs, one per stream key.
    /// This member is required.
    public var arns: [Swift.String]?

    public init (
        arns: [Swift.String]? = nil
    )
    {
        self.arns = arns
    }
}

struct BatchGetStreamKeyInputBody: Swift.Equatable {
    let arns: [Swift.String]?
}

extension BatchGetStreamKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .arns)
        var arnsDecoded0:[Swift.String]? = nil
        if let arnsContainer = arnsContainer {
            arnsDecoded0 = [Swift.String]()
            for string0 in arnsContainer {
                if let string0 = string0 {
                    arnsDecoded0?.append(string0)
                }
            }
        }
        arns = arnsDecoded0
    }
}

extension BatchGetStreamKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension BatchGetStreamKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum BatchGetStreamKeyOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension BatchGetStreamKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BatchGetStreamKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.streamKeys = output.streamKeys
        } else {
            self.errors = nil
            self.streamKeys = nil
        }
    }
}

public struct BatchGetStreamKeyOutputResponse: Swift.Equatable {
    ///
    public var errors: [IvsClientTypes.BatchError]?
    ///
    public var streamKeys: [IvsClientTypes.StreamKey]?

    public init (
        errors: [IvsClientTypes.BatchError]? = nil,
        streamKeys: [IvsClientTypes.StreamKey]? = nil
    )
    {
        self.errors = errors
        self.streamKeys = streamKeys
    }
}

struct BatchGetStreamKeyOutputResponseBody: Swift.Equatable {
    let streamKeys: [IvsClientTypes.StreamKey]?
    let errors: [IvsClientTypes.BatchError]?
}

extension BatchGetStreamKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case streamKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamKeysContainer = try containerValues.decodeIfPresent([IvsClientTypes.StreamKey?].self, forKey: .streamKeys)
        var streamKeysDecoded0:[IvsClientTypes.StreamKey]? = nil
        if let streamKeysContainer = streamKeysContainer {
            streamKeysDecoded0 = [IvsClientTypes.StreamKey]()
            for structure0 in streamKeysContainer {
                if let structure0 = structure0 {
                    streamKeysDecoded0?.append(structure0)
                }
            }
        }
        streamKeys = streamKeysDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([IvsClientTypes.BatchError?].self, forKey: .errors)
        var errorsDecoded0:[IvsClientTypes.BatchError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IvsClientTypes.BatchError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension IvsClientTypes.Channel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authorized
        case ingestEndpoint
        case latencyMode
        case name
        case playbackUrl
        case recordingConfigurationArn
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if authorized != false {
            try encodeContainer.encode(authorized, forKey: .authorized)
        }
        if let ingestEndpoint = self.ingestEndpoint {
            try encodeContainer.encode(ingestEndpoint, forKey: .ingestEndpoint)
        }
        if let latencyMode = self.latencyMode {
            try encodeContainer.encode(latencyMode.rawValue, forKey: .latencyMode)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let playbackUrl = self.playbackUrl {
            try encodeContainer.encode(playbackUrl, forKey: .playbackUrl)
        }
        if let recordingConfigurationArn = self.recordingConfigurationArn {
            try encodeContainer.encode(recordingConfigurationArn, forKey: .recordingConfigurationArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let latencyModeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelLatencyMode.self, forKey: .latencyMode)
        latencyMode = latencyModeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelType.self, forKey: .type)
        type = typeDecoded
        let recordingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordingConfigurationArn)
        recordingConfigurationArn = recordingConfigurationArnDecoded
        let ingestEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ingestEndpoint)
        ingestEndpoint = ingestEndpointDecoded
        let playbackUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackUrl)
        playbackUrl = playbackUrlDecoded
        let authorizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .authorized) ?? false
        authorized = authorizedDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvsClientTypes {
    /// Object specifying a channel.
    public struct Channel: Swift.Equatable {
        /// Channel ARN.
        public var arn: Swift.String?
        /// Whether the channel is private (enabled for playback authorization). Default: false.
        public var authorized: Swift.Bool
        /// Channel ingest endpoint, part of the definition of an ingest server, used when you set up streaming software.
        public var ingestEndpoint: Swift.String?
        /// Channel latency mode. Use NORMAL to broadcast and deliver live video up to Full HD. Use LOW for near-real-time interaction with viewers. Default: LOW. (Note: In the Amazon IVS console, LOW and NORMAL correspond to Ultra-low and Standard, respectively.)
        public var latencyMode: IvsClientTypes.ChannelLatencyMode?
        /// Channel name.
        public var name: Swift.String?
        /// Channel playback URL.
        public var playbackUrl: Swift.String?
        /// Recording-configuration ARN. A value other than an empty string indicates that recording is enabled. Default: "" (empty string, recording is disabled).
        public var recordingConfigurationArn: Swift.String?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?
        /// Channel type, which determines the allowable resolution and bitrate. If you exceed the allowable resolution or bitrate, the stream probably will disconnect immediately. Default: STANDARD. Valid values:
        ///
        /// * STANDARD: Video is transcoded: multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Transcoding allows higher playback quality across a range of download speeds. Resolution can be up to 1080p and bitrate can be up to 8.5 Mbps. Audio is transcoded only for renditions 360p and below; above that, audio is passed through. This is the default.
        ///
        /// * BASIC: Video is transmuxed: Amazon IVS delivers the original input to viewers. The viewerâ€™s video-quality choice is limited to the original input. Resolution can be up to 1080p and bitrate can be up to 1.5 Mbps for 480p and up to 3.5 Mbps for resolutions between 480p and 1080p.
        public var type: IvsClientTypes.ChannelType?

        public init (
            arn: Swift.String? = nil,
            authorized: Swift.Bool = false,
            ingestEndpoint: Swift.String? = nil,
            latencyMode: IvsClientTypes.ChannelLatencyMode? = nil,
            name: Swift.String? = nil,
            playbackUrl: Swift.String? = nil,
            recordingConfigurationArn: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: IvsClientTypes.ChannelType? = nil
        )
        {
            self.arn = arn
            self.authorized = authorized
            self.ingestEndpoint = ingestEndpoint
            self.latencyMode = latencyMode
            self.name = name
            self.playbackUrl = playbackUrl
            self.recordingConfigurationArn = recordingConfigurationArn
            self.tags = tags
            self.type = type
        }
    }

}

extension IvsClientTypes {
    public enum ChannelLatencyMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lowlatency
        case normallatency
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelLatencyMode] {
            return [
                .lowlatency,
                .normallatency,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lowlatency: return "LOW"
            case .normallatency: return "NORMAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelLatencyMode(rawValue: rawValue) ?? ChannelLatencyMode.sdkUnknown(rawValue)
        }
    }
}

extension ChannelNotBroadcasting {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ChannelNotBroadcastingBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ChannelNotBroadcasting: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The stream is offline for the given channel ARN.
    public var exceptionMessage: Swift.String?

    public init (
        exceptionMessage: Swift.String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct ChannelNotBroadcastingBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension ChannelNotBroadcastingBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IvsClientTypes.ChannelSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authorized
        case latencyMode
        case name
        case recordingConfigurationArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if authorized != false {
            try encodeContainer.encode(authorized, forKey: .authorized)
        }
        if let latencyMode = self.latencyMode {
            try encodeContainer.encode(latencyMode.rawValue, forKey: .latencyMode)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recordingConfigurationArn = self.recordingConfigurationArn {
            try encodeContainer.encode(recordingConfigurationArn, forKey: .recordingConfigurationArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let latencyModeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelLatencyMode.self, forKey: .latencyMode)
        latencyMode = latencyModeDecoded
        let authorizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .authorized) ?? false
        authorized = authorizedDecoded
        let recordingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordingConfigurationArn)
        recordingConfigurationArn = recordingConfigurationArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvsClientTypes {
    /// Summary information about a channel.
    public struct ChannelSummary: Swift.Equatable {
        /// Channel ARN.
        public var arn: Swift.String?
        /// Whether the channel is private (enabled for playback authorization). Default: false.
        public var authorized: Swift.Bool
        /// Channel latency mode. Use NORMAL to broadcast and deliver live video up to Full HD. Use LOW for near-real-time interaction with viewers. Default: LOW. (Note: In the Amazon IVS console, LOW and NORMAL correspond to Ultra-low and Standard, respectively.)
        public var latencyMode: IvsClientTypes.ChannelLatencyMode?
        /// Channel name.
        public var name: Swift.String?
        /// Recording-configuration ARN. A value other than an empty string indicates that recording is enabled. Default: "" (empty string, recording is disabled).
        public var recordingConfigurationArn: Swift.String?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            authorized: Swift.Bool = false,
            latencyMode: IvsClientTypes.ChannelLatencyMode? = nil,
            name: Swift.String? = nil,
            recordingConfigurationArn: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.authorized = authorized
            self.latencyMode = latencyMode
            self.name = name
            self.recordingConfigurationArn = recordingConfigurationArn
            self.tags = tags
        }
    }

}

extension IvsClientTypes {
    public enum ChannelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basicchanneltype
        case standardchanneltype
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelType] {
            return [
                .basicchanneltype,
                .standardchanneltype,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basicchanneltype: return "BASIC"
            case .standardchanneltype: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelType(rawValue: rawValue) ?? ChannelType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Updating or deleting a resource can cause an inconsistent state.
    public var exceptionMessage: Swift.String?

    public init (
        exceptionMessage: Swift.String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension CreateChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorized
        case latencyMode
        case name
        case recordingConfigurationArn
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if authorized != false {
            try encodeContainer.encode(authorized, forKey: .authorized)
        }
        if let latencyMode = self.latencyMode {
            try encodeContainer.encode(latencyMode.rawValue, forKey: .latencyMode)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recordingConfigurationArn = self.recordingConfigurationArn {
            try encodeContainer.encode(recordingConfigurationArn, forKey: .recordingConfigurationArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateChannel"
    }
}

public struct CreateChannelInput: Swift.Equatable {
    /// Whether the channel is private (enabled for playback authorization). Default: false.
    public var authorized: Swift.Bool
    /// Channel latency mode. Use NORMAL to broadcast and deliver live video up to Full HD. Use LOW for near-real-time interaction with viewers. (Note: In the Amazon IVS console, LOW and NORMAL correspond to Ultra-low and Standard, respectively.) Default: LOW.
    public var latencyMode: IvsClientTypes.ChannelLatencyMode?
    /// Channel name.
    public var name: Swift.String?
    /// Recording-configuration ARN. Default: "" (empty string, recording is disabled).
    public var recordingConfigurationArn: Swift.String?
    /// Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?
    /// Channel type, which determines the allowable resolution and bitrate. If you exceed the allowable resolution or bitrate, the stream probably will disconnect immediately. Default: STANDARD. Valid values:
    ///
    /// * STANDARD: Video is transcoded: multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Transcoding allows higher playback quality across a range of download speeds. Resolution can be up to 1080p and bitrate can be up to 8.5 Mbps. Audio is transcoded only for renditions 360p and below; above that, audio is passed through. This is the default.
    ///
    /// * BASIC: Video is transmuxed: Amazon IVS delivers the original input to viewers. The viewerâ€™s video-quality choice is limited to the original input. Resolution can be up to 1080p and bitrate can be up to 1.5 Mbps for 480p and up to 3.5 Mbps for resolutions between 480p and 1080p.
    public var type: IvsClientTypes.ChannelType?

    public init (
        authorized: Swift.Bool = false,
        latencyMode: IvsClientTypes.ChannelLatencyMode? = nil,
        name: Swift.String? = nil,
        recordingConfigurationArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        type: IvsClientTypes.ChannelType? = nil
    )
    {
        self.authorized = authorized
        self.latencyMode = latencyMode
        self.name = name
        self.recordingConfigurationArn = recordingConfigurationArn
        self.tags = tags
        self.type = type
    }
}

struct CreateChannelInputBody: Swift.Equatable {
    let name: Swift.String?
    let latencyMode: IvsClientTypes.ChannelLatencyMode?
    let type: IvsClientTypes.ChannelType?
    let authorized: Swift.Bool
    let recordingConfigurationArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorized
        case latencyMode
        case name
        case recordingConfigurationArn
        case tags
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let latencyModeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelLatencyMode.self, forKey: .latencyMode)
        latencyMode = latencyModeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelType.self, forKey: .type)
        type = typeDecoded
        let authorizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .authorized) ?? false
        authorized = authorizedDecoded
        let recordingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordingConfigurationArn)
        recordingConfigurationArn = recordingConfigurationArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
            self.streamKey = output.streamKey
        } else {
            self.channel = nil
            self.streamKey = nil
        }
    }
}

public struct CreateChannelOutputResponse: Swift.Equatable {
    ///
    public var channel: IvsClientTypes.Channel?
    ///
    public var streamKey: IvsClientTypes.StreamKey?

    public init (
        channel: IvsClientTypes.Channel? = nil,
        streamKey: IvsClientTypes.StreamKey? = nil
    )
    {
        self.channel = channel
        self.streamKey = streamKey
    }
}

struct CreateChannelOutputResponseBody: Swift.Equatable {
    let channel: IvsClientTypes.Channel?
    let streamKey: IvsClientTypes.StreamKey?
}

extension CreateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel
        case streamKey
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(IvsClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
        let streamKeyDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamKey.self, forKey: .streamKey)
        streamKey = streamKeyDecoded
    }
}

extension CreateRecordingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfiguration
        case name
        case recordingReconnectWindowSeconds
        case tags
        case thumbnailConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfiguration = self.destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if recordingReconnectWindowSeconds != 0 {
            try encodeContainer.encode(recordingReconnectWindowSeconds, forKey: .recordingReconnectWindowSeconds)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let thumbnailConfiguration = self.thumbnailConfiguration {
            try encodeContainer.encode(thumbnailConfiguration, forKey: .thumbnailConfiguration)
        }
    }
}

extension CreateRecordingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateRecordingConfiguration"
    }
}

public struct CreateRecordingConfigurationInput: Swift.Equatable {
    /// A complex type that contains a destination configuration for where recorded video will be stored.
    /// This member is required.
    public var destinationConfiguration: IvsClientTypes.DestinationConfiguration?
    /// Recording-configuration name. The value does not need to be unique.
    public var name: Swift.String?
    /// If a broadcast disconnects and then reconnects within the specified interval, the multiple streams will be considered a single broadcast and merged together. Default: 0.
    public var recordingReconnectWindowSeconds: Swift.Int
    /// Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?
    /// A complex type that allows you to enable/disable the recording of thumbnails for a live session and modify the interval at which thumbnails are generated for the live session.
    public var thumbnailConfiguration: IvsClientTypes.ThumbnailConfiguration?

    public init (
        destinationConfiguration: IvsClientTypes.DestinationConfiguration? = nil,
        name: Swift.String? = nil,
        recordingReconnectWindowSeconds: Swift.Int = 0,
        tags: [Swift.String:Swift.String]? = nil,
        thumbnailConfiguration: IvsClientTypes.ThumbnailConfiguration? = nil
    )
    {
        self.destinationConfiguration = destinationConfiguration
        self.name = name
        self.recordingReconnectWindowSeconds = recordingReconnectWindowSeconds
        self.tags = tags
        self.thumbnailConfiguration = thumbnailConfiguration
    }
}

struct CreateRecordingConfigurationInputBody: Swift.Equatable {
    let name: Swift.String?
    let destinationConfiguration: IvsClientTypes.DestinationConfiguration?
    let tags: [Swift.String:Swift.String]?
    let thumbnailConfiguration: IvsClientTypes.ThumbnailConfiguration?
    let recordingReconnectWindowSeconds: Swift.Int
}

extension CreateRecordingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfiguration
        case name
        case recordingReconnectWindowSeconds
        case tags
        case thumbnailConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let thumbnailConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ThumbnailConfiguration.self, forKey: .thumbnailConfiguration)
        thumbnailConfiguration = thumbnailConfigurationDecoded
        let recordingReconnectWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordingReconnectWindowSeconds) ?? 0
        recordingReconnectWindowSeconds = recordingReconnectWindowSecondsDecoded
    }
}

extension CreateRecordingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateRecordingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateRecordingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case pendingVerification(PendingVerification)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateRecordingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateRecordingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recordingConfiguration = output.recordingConfiguration
        } else {
            self.recordingConfiguration = nil
        }
    }
}

public struct CreateRecordingConfigurationOutputResponse: Swift.Equatable {
    ///
    public var recordingConfiguration: IvsClientTypes.RecordingConfiguration?

    public init (
        recordingConfiguration: IvsClientTypes.RecordingConfiguration? = nil
    )
    {
        self.recordingConfiguration = recordingConfiguration
    }
}

struct CreateRecordingConfigurationOutputResponseBody: Swift.Equatable {
    let recordingConfiguration: IvsClientTypes.RecordingConfiguration?
}

extension CreateRecordingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordingConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordingConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.RecordingConfiguration.self, forKey: .recordingConfiguration)
        recordingConfiguration = recordingConfigurationDecoded
    }
}

extension CreateStreamKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateStreamKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateStreamKey"
    }
}

public struct CreateStreamKeyInput: Swift.Equatable {
    /// ARN of the channel for which to create the stream key.
    /// This member is required.
    public var channelArn: Swift.String?
    /// Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?

    public init (
        channelArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.channelArn = channelArn
        self.tags = tags
    }
}

struct CreateStreamKeyInputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateStreamKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStreamKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateStreamKeyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateStreamKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamKey = output.streamKey
        } else {
            self.streamKey = nil
        }
    }
}

public struct CreateStreamKeyOutputResponse: Swift.Equatable {
    /// Stream key used to authenticate an RTMPS stream for ingestion.
    public var streamKey: IvsClientTypes.StreamKey?

    public init (
        streamKey: IvsClientTypes.StreamKey? = nil
    )
    {
        self.streamKey = streamKey
    }
}

struct CreateStreamKeyOutputResponseBody: Swift.Equatable {
    let streamKey: IvsClientTypes.StreamKey?
}

extension CreateStreamKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamKey
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamKeyDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamKey.self, forKey: .streamKey)
        streamKey = streamKeyDecoded
    }
}

extension DeleteChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteChannel"
    }
}

public struct DeleteChannelInput: Swift.Equatable {
    /// ARN of the channel to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteChannelInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteChannelOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeletePlaybackKeyPairInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeletePlaybackKeyPairInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeletePlaybackKeyPair"
    }
}

public struct DeletePlaybackKeyPairInput: Swift.Equatable {
    /// ARN of the key pair to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeletePlaybackKeyPairInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeletePlaybackKeyPairInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeletePlaybackKeyPairOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePlaybackKeyPairOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePlaybackKeyPairOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePlaybackKeyPairOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePlaybackKeyPairOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteRecordingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteRecordingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteRecordingConfiguration"
    }
}

public struct DeleteRecordingConfigurationInput: Swift.Equatable {
    /// ARN of the recording configuration to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteRecordingConfigurationInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteRecordingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteRecordingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteRecordingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteRecordingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteRecordingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteRecordingConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteStreamKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension DeleteStreamKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteStreamKey"
    }
}

public struct DeleteStreamKeyInput: Swift.Equatable {
    /// ARN of the stream key to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct DeleteStreamKeyInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension DeleteStreamKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension DeleteStreamKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStreamKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteStreamKeyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStreamKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStreamKeyOutputResponse: Swift.Equatable {

    public init () { }
}

extension IvsClientTypes.DestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3 = self.s3 {
            try encodeContainer.encode(s3, forKey: .s3)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try containerValues.decodeIfPresent(IvsClientTypes.S3DestinationConfiguration.self, forKey: .s3)
        s3 = s3Decoded
    }
}

extension IvsClientTypes {
    /// A complex type that describes a location where recorded videos will be stored. Each member represents a type of destination configuration. For recording, you define one and only one type of destination configuration.
    public struct DestinationConfiguration: Swift.Equatable {
        /// An S3 destination configuration where recorded videos will be stored.
        public var s3: IvsClientTypes.S3DestinationConfiguration?

        public init (
            s3: IvsClientTypes.S3DestinationConfiguration? = nil
        )
        {
            self.s3 = s3
        }
    }

}

extension GetChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetChannel"
    }
}

public struct GetChannelInput: Swift.Equatable {
    /// ARN of the channel for which the configuration is to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetChannelInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
        } else {
            self.channel = nil
        }
    }
}

public struct GetChannelOutputResponse: Swift.Equatable {
    ///
    public var channel: IvsClientTypes.Channel?

    public init (
        channel: IvsClientTypes.Channel? = nil
    )
    {
        self.channel = channel
    }
}

struct GetChannelOutputResponseBody: Swift.Equatable {
    let channel: IvsClientTypes.Channel?
}

extension GetChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(IvsClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension GetPlaybackKeyPairInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetPlaybackKeyPairInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetPlaybackKeyPair"
    }
}

public struct GetPlaybackKeyPairInput: Swift.Equatable {
    /// ARN of the key pair to be returned.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetPlaybackKeyPairInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetPlaybackKeyPairInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetPlaybackKeyPairOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPlaybackKeyPairOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPlaybackKeyPairOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPlaybackKeyPairOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPlaybackKeyPairOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.keyPair = output.keyPair
        } else {
            self.keyPair = nil
        }
    }
}

public struct GetPlaybackKeyPairOutputResponse: Swift.Equatable {
    ///
    public var keyPair: IvsClientTypes.PlaybackKeyPair?

    public init (
        keyPair: IvsClientTypes.PlaybackKeyPair? = nil
    )
    {
        self.keyPair = keyPair
    }
}

struct GetPlaybackKeyPairOutputResponseBody: Swift.Equatable {
    let keyPair: IvsClientTypes.PlaybackKeyPair?
}

extension GetPlaybackKeyPairOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyPair
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPairDecoded = try containerValues.decodeIfPresent(IvsClientTypes.PlaybackKeyPair.self, forKey: .keyPair)
        keyPair = keyPairDecoded
    }
}

extension GetRecordingConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetRecordingConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetRecordingConfiguration"
    }
}

public struct GetRecordingConfigurationInput: Swift.Equatable {
    /// ARN of the recording configuration to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetRecordingConfigurationInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetRecordingConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetRecordingConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRecordingConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRecordingConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRecordingConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRecordingConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.recordingConfiguration = output.recordingConfiguration
        } else {
            self.recordingConfiguration = nil
        }
    }
}

public struct GetRecordingConfigurationOutputResponse: Swift.Equatable {
    ///
    public var recordingConfiguration: IvsClientTypes.RecordingConfiguration?

    public init (
        recordingConfiguration: IvsClientTypes.RecordingConfiguration? = nil
    )
    {
        self.recordingConfiguration = recordingConfiguration
    }
}

struct GetRecordingConfigurationOutputResponseBody: Swift.Equatable {
    let recordingConfiguration: IvsClientTypes.RecordingConfiguration?
}

extension GetRecordingConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordingConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordingConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.RecordingConfiguration.self, forKey: .recordingConfiguration)
        recordingConfiguration = recordingConfigurationDecoded
    }
}

extension GetStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
    }
}

extension GetStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetStream"
    }
}

public struct GetStreamInput: Swift.Equatable {
    /// Channel ARN for stream to be accessed.
    /// This member is required.
    public var channelArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct GetStreamInputBody: Swift.Equatable {
    let channelArn: Swift.String?
}

extension GetStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

extension GetStreamKeyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }
}

extension GetStreamKeyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetStreamKey"
    }
}

public struct GetStreamKeyInput: Swift.Equatable {
    /// ARN for the stream key to be retrieved.
    /// This member is required.
    public var arn: Swift.String?

    public init (
        arn: Swift.String? = nil
    )
    {
        self.arn = arn
    }
}

struct GetStreamKeyInputBody: Swift.Equatable {
    let arn: Swift.String?
}

extension GetStreamKeyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension GetStreamKeyOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStreamKeyOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetStreamKeyOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamKeyOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetStreamKeyOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamKey = output.streamKey
        } else {
            self.streamKey = nil
        }
    }
}

public struct GetStreamKeyOutputResponse: Swift.Equatable {
    ///
    public var streamKey: IvsClientTypes.StreamKey?

    public init (
        streamKey: IvsClientTypes.StreamKey? = nil
    )
    {
        self.streamKey = streamKey
    }
}

struct GetStreamKeyOutputResponseBody: Swift.Equatable {
    let streamKey: IvsClientTypes.StreamKey?
}

extension GetStreamKeyOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamKey
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamKeyDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamKey.self, forKey: .streamKey)
        streamKey = streamKeyDecoded
    }
}

extension GetStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ChannelNotBroadcasting" : self = .channelNotBroadcasting(try ChannelNotBroadcasting(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetStreamOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case channelNotBroadcasting(ChannelNotBroadcasting)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.stream = output.stream
        } else {
            self.stream = nil
        }
    }
}

public struct GetStreamOutputResponse: Swift.Equatable {
    ///
    public var stream: IvsClientTypes.Stream?

    public init (
        stream: IvsClientTypes.Stream? = nil
    )
    {
        self.stream = stream
    }
}

struct GetStreamOutputResponseBody: Swift.Equatable {
    let stream: IvsClientTypes.Stream?
}

extension GetStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stream
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDecoded = try containerValues.decodeIfPresent(IvsClientTypes.Stream.self, forKey: .stream)
        stream = streamDecoded
    }
}

extension GetStreamSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case streamId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
    }
}

extension GetStreamSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetStreamSession"
    }
}

public struct GetStreamSessionInput: Swift.Equatable {
    /// ARN of the channel resource
    /// This member is required.
    public var channelArn: Swift.String?
    /// Unique identifier for a live or previously live stream in the specified channel. If no streamId is provided, this returns the most recent stream session for the channel, if it exists.
    public var streamId: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        streamId: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.streamId = streamId
    }
}

struct GetStreamSessionInputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let streamId: Swift.String?
}

extension GetStreamSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case streamId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
    }
}

extension GetStreamSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetStreamSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetStreamSessionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetStreamSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetStreamSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamSession = output.streamSession
        } else {
            self.streamSession = nil
        }
    }
}

public struct GetStreamSessionOutputResponse: Swift.Equatable {
    /// List of stream details.
    public var streamSession: IvsClientTypes.StreamSession?

    public init (
        streamSession: IvsClientTypes.StreamSession? = nil
    )
    {
        self.streamSession = streamSession
    }
}

struct GetStreamSessionOutputResponseBody: Swift.Equatable {
    let streamSession: IvsClientTypes.StreamSession?
}

extension GetStreamSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamSession
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamSessionDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamSession.self, forKey: .streamSession)
        streamSession = streamSessionDecoded
    }
}

extension ImportPlaybackKeyPairInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case publicKeyMaterial
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let publicKeyMaterial = self.publicKeyMaterial {
            try encodeContainer.encode(publicKeyMaterial, forKey: .publicKeyMaterial)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension ImportPlaybackKeyPairInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ImportPlaybackKeyPair"
    }
}

public struct ImportPlaybackKeyPairInput: Swift.Equatable {
    /// Playback-key-pair name. The value does not need to be unique.
    public var name: Swift.String?
    /// The public portion of a customer-generated key pair.
    /// This member is required.
    public var publicKeyMaterial: Swift.String?
    /// Any tags provided with the request are added to the playback key pair tags. See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
    public var tags: [Swift.String:Swift.String]?

    public init (
        name: Swift.String? = nil,
        publicKeyMaterial: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.name = name
        self.publicKeyMaterial = publicKeyMaterial
        self.tags = tags
    }
}

struct ImportPlaybackKeyPairInputBody: Swift.Equatable {
    let publicKeyMaterial: Swift.String?
    let name: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension ImportPlaybackKeyPairInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case publicKeyMaterial
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let publicKeyMaterialDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicKeyMaterial)
        publicKeyMaterial = publicKeyMaterialDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ImportPlaybackKeyPairOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ImportPlaybackKeyPairOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ImportPlaybackKeyPairOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case pendingVerification(PendingVerification)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ImportPlaybackKeyPairOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ImportPlaybackKeyPairOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.keyPair = output.keyPair
        } else {
            self.keyPair = nil
        }
    }
}

public struct ImportPlaybackKeyPairOutputResponse: Swift.Equatable {
    ///
    public var keyPair: IvsClientTypes.PlaybackKeyPair?

    public init (
        keyPair: IvsClientTypes.PlaybackKeyPair? = nil
    )
    {
        self.keyPair = keyPair
    }
}

struct ImportPlaybackKeyPairOutputResponseBody: Swift.Equatable {
    let keyPair: IvsClientTypes.PlaybackKeyPair?
}

extension ImportPlaybackKeyPairOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyPair
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPairDecoded = try containerValues.decodeIfPresent(IvsClientTypes.PlaybackKeyPair.self, forKey: .keyPair)
        keyPair = keyPairDecoded
    }
}

extension IvsClientTypes.IngestConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audio
        case video
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let audio = self.audio {
            try encodeContainer.encode(audio, forKey: .audio)
        }
        if let video = self.video {
            try encodeContainer.encode(video, forKey: .video)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let videoDecoded = try containerValues.decodeIfPresent(IvsClientTypes.VideoConfiguration.self, forKey: .video)
        video = videoDecoded
        let audioDecoded = try containerValues.decodeIfPresent(IvsClientTypes.AudioConfiguration.self, forKey: .audio)
        audio = audioDecoded
    }
}

extension IvsClientTypes {
    /// Object specifying the ingest configuration set up by the broadcaster, usually in an encoder.
    public struct IngestConfiguration: Swift.Equatable {
        /// Encoder settings for audio.
        public var audio: IvsClientTypes.AudioConfiguration?
        /// Encoder settings for video.
        public var video: IvsClientTypes.VideoConfiguration?

        public init (
            audio: IvsClientTypes.AudioConfiguration? = nil,
            video: IvsClientTypes.VideoConfiguration? = nil
        )
        {
            self.audio = audio
            self.video = video
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// Unexpected error during processing of request.
    public var exceptionMessage: Swift.String?

    public init (
        exceptionMessage: Swift.String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension ListChannelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterByName
        case filterByRecordingConfigurationArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterByName = self.filterByName {
            try encodeContainer.encode(filterByName, forKey: .filterByName)
        }
        if let filterByRecordingConfigurationArn = self.filterByRecordingConfigurationArn {
            try encodeContainer.encode(filterByRecordingConfigurationArn, forKey: .filterByRecordingConfigurationArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListChannels"
    }
}

public struct ListChannelsInput: Swift.Equatable {
    /// Filters the channel list to match the specified name.
    public var filterByName: Swift.String?
    /// Filters the channel list to match the specified recording-configuration ARN.
    public var filterByRecordingConfigurationArn: Swift.String?
    /// Maximum number of channels to return. Default: 100.
    public var maxResults: Swift.Int
    /// The first channel to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init (
        filterByName: Swift.String? = nil,
        filterByRecordingConfigurationArn: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filterByName = filterByName
        self.filterByRecordingConfigurationArn = filterByRecordingConfigurationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChannelsInputBody: Swift.Equatable {
    let filterByName: Swift.String?
    let filterByRecordingConfigurationArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListChannelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterByName
        case filterByRecordingConfigurationArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterByNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterByName)
        filterByName = filterByNameDecoded
        let filterByRecordingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterByRecordingConfigurationArn)
        filterByRecordingConfigurationArn = filterByRecordingConfigurationArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension ListChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListChannelsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channels = output.channels
            self.nextToken = output.nextToken
        } else {
            self.channels = nil
            self.nextToken = nil
        }
    }
}

public struct ListChannelsOutputResponse: Swift.Equatable {
    /// List of the matching channels.
    /// This member is required.
    public var channels: [IvsClientTypes.ChannelSummary]?
    /// If there are more channels than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?

    public init (
        channels: [IvsClientTypes.ChannelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channels = channels
        self.nextToken = nextToken
    }
}

struct ListChannelsOutputResponseBody: Swift.Equatable {
    let channels: [IvsClientTypes.ChannelSummary]?
    let nextToken: Swift.String?
}

extension ListChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channels
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelsContainer = try containerValues.decodeIfPresent([IvsClientTypes.ChannelSummary?].self, forKey: .channels)
        var channelsDecoded0:[IvsClientTypes.ChannelSummary]? = nil
        if let channelsContainer = channelsContainer {
            channelsDecoded0 = [IvsClientTypes.ChannelSummary]()
            for structure0 in channelsContainer {
                if let structure0 = structure0 {
                    channelsDecoded0?.append(structure0)
                }
            }
        }
        channels = channelsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPlaybackKeyPairsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPlaybackKeyPairsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListPlaybackKeyPairs"
    }
}

public struct ListPlaybackKeyPairsInput: Swift.Equatable {
    /// Maximum number of key pairs to return. Default: your service quota or 100, whichever is smaller.
    public var maxResults: Swift.Int
    /// The first key pair to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPlaybackKeyPairsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListPlaybackKeyPairsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension ListPlaybackKeyPairsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPlaybackKeyPairsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPlaybackKeyPairsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPlaybackKeyPairsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPlaybackKeyPairsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.keyPairs = output.keyPairs
            self.nextToken = output.nextToken
        } else {
            self.keyPairs = nil
            self.nextToken = nil
        }
    }
}

public struct ListPlaybackKeyPairsOutputResponse: Swift.Equatable {
    /// List of key pairs.
    /// This member is required.
    public var keyPairs: [IvsClientTypes.PlaybackKeyPairSummary]?
    /// If there are more key pairs than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?

    public init (
        keyPairs: [IvsClientTypes.PlaybackKeyPairSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.keyPairs = keyPairs
        self.nextToken = nextToken
    }
}

struct ListPlaybackKeyPairsOutputResponseBody: Swift.Equatable {
    let keyPairs: [IvsClientTypes.PlaybackKeyPairSummary]?
    let nextToken: Swift.String?
}

extension ListPlaybackKeyPairsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case keyPairs
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyPairsContainer = try containerValues.decodeIfPresent([IvsClientTypes.PlaybackKeyPairSummary?].self, forKey: .keyPairs)
        var keyPairsDecoded0:[IvsClientTypes.PlaybackKeyPairSummary]? = nil
        if let keyPairsContainer = keyPairsContainer {
            keyPairsDecoded0 = [IvsClientTypes.PlaybackKeyPairSummary]()
            for structure0 in keyPairsContainer {
                if let structure0 = structure0 {
                    keyPairsDecoded0?.append(structure0)
                }
            }
        }
        keyPairs = keyPairsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecordingConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRecordingConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListRecordingConfigurations"
    }
}

public struct ListRecordingConfigurationsInput: Swift.Equatable {
    /// Maximum number of recording configurations to return. Default: your service quota or 100, whichever is smaller.
    public var maxResults: Swift.Int
    /// The first recording configuration to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRecordingConfigurationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListRecordingConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension ListRecordingConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListRecordingConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListRecordingConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListRecordingConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListRecordingConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recordingConfigurations = output.recordingConfigurations
        } else {
            self.nextToken = nil
            self.recordingConfigurations = nil
        }
    }
}

public struct ListRecordingConfigurationsOutputResponse: Swift.Equatable {
    /// If there are more recording configurations than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of the matching recording configurations.
    /// This member is required.
    public var recordingConfigurations: [IvsClientTypes.RecordingConfigurationSummary]?

    public init (
        nextToken: Swift.String? = nil,
        recordingConfigurations: [IvsClientTypes.RecordingConfigurationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recordingConfigurations = recordingConfigurations
    }
}

struct ListRecordingConfigurationsOutputResponseBody: Swift.Equatable {
    let recordingConfigurations: [IvsClientTypes.RecordingConfigurationSummary]?
    let nextToken: Swift.String?
}

extension ListRecordingConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case recordingConfigurations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordingConfigurationsContainer = try containerValues.decodeIfPresent([IvsClientTypes.RecordingConfigurationSummary?].self, forKey: .recordingConfigurations)
        var recordingConfigurationsDecoded0:[IvsClientTypes.RecordingConfigurationSummary]? = nil
        if let recordingConfigurationsContainer = recordingConfigurationsContainer {
            recordingConfigurationsDecoded0 = [IvsClientTypes.RecordingConfigurationSummary]()
            for structure0 in recordingConfigurationsContainer {
                if let structure0 = structure0 {
                    recordingConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        recordingConfigurations = recordingConfigurationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListStreamKeysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListStreamKeysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListStreamKeys"
    }
}

public struct ListStreamKeysInput: Swift.Equatable {
    /// Channel ARN used to filter the list.
    /// This member is required.
    public var channelArn: Swift.String?
    /// Maximum number of streamKeys to return. Default: 1.
    public var maxResults: Swift.Int
    /// The first stream key to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStreamKeysInputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListStreamKeysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension ListStreamKeysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamKeysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListStreamKeysOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamKeysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListStreamKeysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.streamKeys = output.streamKeys
        } else {
            self.nextToken = nil
            self.streamKeys = nil
        }
    }
}

public struct ListStreamKeysOutputResponse: Swift.Equatable {
    /// If there are more stream keys than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of stream keys.
    /// This member is required.
    public var streamKeys: [IvsClientTypes.StreamKeySummary]?

    public init (
        nextToken: Swift.String? = nil,
        streamKeys: [IvsClientTypes.StreamKeySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.streamKeys = streamKeys
    }
}

struct ListStreamKeysOutputResponseBody: Swift.Equatable {
    let streamKeys: [IvsClientTypes.StreamKeySummary]?
    let nextToken: Swift.String?
}

extension ListStreamKeysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case streamKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamKeysContainer = try containerValues.decodeIfPresent([IvsClientTypes.StreamKeySummary?].self, forKey: .streamKeys)
        var streamKeysDecoded0:[IvsClientTypes.StreamKeySummary]? = nil
        if let streamKeysContainer = streamKeysContainer {
            streamKeysDecoded0 = [IvsClientTypes.StreamKeySummary]()
            for structure0 in streamKeysContainer {
                if let structure0 = structure0 {
                    streamKeysDecoded0?.append(structure0)
                }
            }
        }
        streamKeys = streamKeysDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListStreamSessionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListStreamSessionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListStreamSessions"
    }
}

public struct ListStreamSessionsInput: Swift.Equatable {
    /// Channel ARN used to filter the list.
    /// This member is required.
    public var channelArn: Swift.String?
    /// Maximum number of streams to return. Default: 100.
    public var maxResults: Swift.Int
    /// The first stream to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStreamSessionsInputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListStreamSessionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension ListStreamSessionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamSessionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListStreamSessionsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamSessionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListStreamSessionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.streamSessions = output.streamSessions
        } else {
            self.nextToken = nil
            self.streamSessions = nil
        }
    }
}

public struct ListStreamSessionsOutputResponse: Swift.Equatable {
    /// If there are more streams than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of stream sessions.
    /// This member is required.
    public var streamSessions: [IvsClientTypes.StreamSessionSummary]?

    public init (
        nextToken: Swift.String? = nil,
        streamSessions: [IvsClientTypes.StreamSessionSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.streamSessions = streamSessions
    }
}

struct ListStreamSessionsOutputResponseBody: Swift.Equatable {
    let streamSessions: [IvsClientTypes.StreamSessionSummary]?
    let nextToken: Swift.String?
}

extension ListStreamSessionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case streamSessions
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamSessionsContainer = try containerValues.decodeIfPresent([IvsClientTypes.StreamSessionSummary?].self, forKey: .streamSessions)
        var streamSessionsDecoded0:[IvsClientTypes.StreamSessionSummary]? = nil
        if let streamSessionsContainer = streamSessionsContainer {
            streamSessionsDecoded0 = [IvsClientTypes.StreamSessionSummary]()
            for structure0 in streamSessionsContainer {
                if let structure0 = structure0 {
                    streamSessionsDecoded0?.append(structure0)
                }
            }
        }
        streamSessions = streamSessionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListStreamsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterBy
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterBy = self.filterBy {
            try encodeContainer.encode(filterBy, forKey: .filterBy)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListStreamsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListStreams"
    }
}

public struct ListStreamsInput: Swift.Equatable {
    /// Filters the stream list to match the specified criterion.
    public var filterBy: IvsClientTypes.StreamFilters?
    /// Maximum number of streams to return. Default: 100.
    public var maxResults: Swift.Int
    /// The first stream to retrieve. This is used for pagination; see the nextToken response field.
    public var nextToken: Swift.String?

    public init (
        filterBy: IvsClientTypes.StreamFilters? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filterBy = filterBy
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStreamsInputBody: Swift.Equatable {
    let filterBy: IvsClientTypes.StreamFilters?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension ListStreamsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterBy
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterByDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamFilters.self, forKey: .filterBy)
        filterBy = filterByDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension ListStreamsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListStreamsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListStreamsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.streams = output.streams
        } else {
            self.nextToken = nil
            self.streams = nil
        }
    }
}

public struct ListStreamsOutputResponse: Swift.Equatable {
    /// If there are more streams than maxResults, use nextToken in the request to get the next set.
    public var nextToken: Swift.String?
    /// List of streams.
    /// This member is required.
    public var streams: [IvsClientTypes.StreamSummary]?

    public init (
        nextToken: Swift.String? = nil,
        streams: [IvsClientTypes.StreamSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.streams = streams
    }
}

struct ListStreamsOutputResponseBody: Swift.Equatable {
    let streams: [IvsClientTypes.StreamSummary]?
    let nextToken: Swift.String?
}

extension ListStreamsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case streams
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamsContainer = try containerValues.decodeIfPresent([IvsClientTypes.StreamSummary?].self, forKey: .streams)
        var streamsDecoded0:[IvsClientTypes.StreamSummary]? = nil
        if let streamsContainer = streamsContainer {
            streamsDecoded0 = [IvsClientTypes.StreamSummary]()
            for structure0 in streamsContainer {
                if let structure0 = structure0 {
                    streamsDecoded0?.append(structure0)
                }
            }
        }
        streams = streamsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource to be retrieved. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Tags attached to the resource. Array of maps, each of the form string:string (key:value).
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension PendingVerification {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PendingVerificationBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct PendingVerification: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Your account is pending verification.
    public var exceptionMessage: Swift.String?

    public init (
        exceptionMessage: Swift.String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct PendingVerificationBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension PendingVerificationBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IvsClientTypes.PlaybackKeyPair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case fingerprint
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let fingerprint = self.fingerprint {
            try encodeContainer.encode(fingerprint, forKey: .fingerprint)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let fingerprintDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fingerprint)
        fingerprint = fingerprintDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvsClientTypes {
    /// A key pair used to sign and validate a playback authorization token.
    public struct PlaybackKeyPair: Swift.Equatable {
        /// Key-pair ARN.
        public var arn: Swift.String?
        /// Key-pair identifier.
        public var fingerprint: Swift.String?
        /// Playback-key-pair name. The value does not need to be unique.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            fingerprint: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.fingerprint = fingerprint
            self.name = name
            self.tags = tags
        }
    }

}

extension IvsClientTypes.PlaybackKeyPairSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case name
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvsClientTypes {
    /// Summary information about a playback key pair.
    public struct PlaybackKeyPairSummary: Swift.Equatable {
        /// Key-pair ARN.
        public var arn: Swift.String?
        /// Playback-key-pair name. The value does not need to be unique.
        public var name: Swift.String?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.name = name
            self.tags = tags
        }
    }

}

extension PutMetadataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutMetadataInput(channelArn: \(Swift.String(describing: channelArn)), metadata: \"CONTENT_REDACTED\")"}
}

extension PutMetadataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case metadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
    }
}

extension PutMetadataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/PutMetadata"
    }
}

public struct PutMetadataInput: Swift.Equatable {
    /// ARN of the channel into which metadata is inserted. This channel must have an active stream.
    /// This member is required.
    public var channelArn: Swift.String?
    /// Metadata to insert into the stream. Maximum: 1 KB per request.
    /// This member is required.
    public var metadata: Swift.String?

    public init (
        channelArn: Swift.String? = nil,
        metadata: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
        self.metadata = metadata
    }
}

struct PutMetadataInputBody: Swift.Equatable {
    let channelArn: Swift.String?
    let metadata: Swift.String?
}

extension PutMetadataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case metadata
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension PutMetadataOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutMetadataOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ChannelNotBroadcasting" : self = .channelNotBroadcasting(try ChannelNotBroadcasting(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutMetadataOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case channelNotBroadcasting(ChannelNotBroadcasting)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutMetadataOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutMetadataOutputResponse: Swift.Equatable {

    public init () { }
}

extension IvsClientTypes.RecordingConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case destinationConfiguration
        case name
        case recordingReconnectWindowSeconds
        case state
        case tags
        case thumbnailConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let destinationConfiguration = self.destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if recordingReconnectWindowSeconds != 0 {
            try encodeContainer.encode(recordingReconnectWindowSeconds, forKey: .recordingReconnectWindowSeconds)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let thumbnailConfiguration = self.thumbnailConfiguration {
            try encodeContainer.encode(thumbnailConfiguration, forKey: .thumbnailConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IvsClientTypes.RecordingConfigurationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let thumbnailConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ThumbnailConfiguration.self, forKey: .thumbnailConfiguration)
        thumbnailConfiguration = thumbnailConfigurationDecoded
        let recordingReconnectWindowSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recordingReconnectWindowSeconds) ?? 0
        recordingReconnectWindowSeconds = recordingReconnectWindowSecondsDecoded
    }
}

extension IvsClientTypes {
    /// An object representing a configuration to record a channel stream.
    public struct RecordingConfiguration: Swift.Equatable {
        /// Recording-configuration ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// A complex type that contains information about where recorded video will be stored.
        /// This member is required.
        public var destinationConfiguration: IvsClientTypes.DestinationConfiguration?
        /// Recording-configuration name. The value does not need to be unique.
        public var name: Swift.String?
        /// If a broadcast disconnects and then reconnects within the specified interval, the multiple streams will be considered a single broadcast and merged together. Default: 0.
        public var recordingReconnectWindowSeconds: Swift.Int
        /// Indicates the current state of the recording configuration. When the state is ACTIVE, the configuration is ready for recording a channel stream.
        /// This member is required.
        public var state: IvsClientTypes.RecordingConfigurationState?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?
        /// A complex type that allows you to enable/disable the recording of thumbnails for a live session and modify the interval at which thumbnails are generated for the live session.
        public var thumbnailConfiguration: IvsClientTypes.ThumbnailConfiguration?

        public init (
            arn: Swift.String? = nil,
            destinationConfiguration: IvsClientTypes.DestinationConfiguration? = nil,
            name: Swift.String? = nil,
            recordingReconnectWindowSeconds: Swift.Int = 0,
            state: IvsClientTypes.RecordingConfigurationState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            thumbnailConfiguration: IvsClientTypes.ThumbnailConfiguration? = nil
        )
        {
            self.arn = arn
            self.destinationConfiguration = destinationConfiguration
            self.name = name
            self.recordingReconnectWindowSeconds = recordingReconnectWindowSeconds
            self.state = state
            self.tags = tags
            self.thumbnailConfiguration = thumbnailConfiguration
        }
    }

}

extension IvsClientTypes {
    public enum RecordingConfigurationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createfailed
        case creating
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordingConfigurationState] {
            return [
                .active,
                .createfailed,
                .creating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createfailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecordingConfigurationState(rawValue: rawValue) ?? RecordingConfigurationState.sdkUnknown(rawValue)
        }
    }
}

extension IvsClientTypes.RecordingConfigurationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case destinationConfiguration
        case name
        case state
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let destinationConfiguration = self.destinationConfiguration {
            try encodeContainer.encode(destinationConfiguration, forKey: .destinationConfiguration)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let destinationConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.DestinationConfiguration.self, forKey: .destinationConfiguration)
        destinationConfiguration = destinationConfigurationDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IvsClientTypes.RecordingConfigurationState.self, forKey: .state)
        state = stateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvsClientTypes {
    /// Summary information about a RecordingConfiguration.
    public struct RecordingConfigurationSummary: Swift.Equatable {
        /// Recording-configuration ARN.
        /// This member is required.
        public var arn: Swift.String?
        /// A complex type that contains information about where recorded video will be stored.
        /// This member is required.
        public var destinationConfiguration: IvsClientTypes.DestinationConfiguration?
        /// Recording-configuration name. The value does not need to be unique.
        public var name: Swift.String?
        /// Indicates the current state of the recording configuration. When the state is ACTIVE, the configuration is ready for recording a channel stream.
        /// This member is required.
        public var state: IvsClientTypes.RecordingConfigurationState?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            destinationConfiguration: IvsClientTypes.DestinationConfiguration? = nil,
            name: Swift.String? = nil,
            state: IvsClientTypes.RecordingConfigurationState? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.destinationConfiguration = destinationConfiguration
            self.name = name
            self.state = state
            self.tags = tags
        }
    }

}

extension IvsClientTypes {
    public enum RecordingMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case interval
        case sdkUnknown(Swift.String)

        public static var allCases: [RecordingMode] {
            return [
                .disabled,
                .interval,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .interval: return "INTERVAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecordingMode(rawValue: rawValue) ?? RecordingMode.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Request references a resource which does not exist.
    public var exceptionMessage: Swift.String?

    public init (
        exceptionMessage: Swift.String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IvsClientTypes.S3DestinationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucketName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucketName = self.bucketName {
            try encodeContainer.encode(bucketName, forKey: .bucketName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucketName)
        bucketName = bucketNameDecoded
    }
}

extension IvsClientTypes {
    /// A complex type that describes an S3 location where recorded videos will be stored.
    public struct S3DestinationConfiguration: Swift.Equatable {
        /// Location (S3 bucket name) where recorded videos will be stored.
        /// This member is required.
        public var bucketName: Swift.String?

        public init (
            bucketName: Swift.String? = nil
        )
        {
            self.bucketName = bucketName
        }
    }

}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Request would cause a service quota to be exceeded.
    public var exceptionMessage: Swift.String?

    public init (
        exceptionMessage: Swift.String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension StopStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
    }
}

extension StopStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StopStream"
    }
}

public struct StopStreamInput: Swift.Equatable {
    /// ARN of the channel for which the stream is to be stopped.
    /// This member is required.
    public var channelArn: Swift.String?

    public init (
        channelArn: Swift.String? = nil
    )
    {
        self.channelArn = channelArn
    }
}

struct StopStreamInputBody: Swift.Equatable {
    let channelArn: Swift.String?
}

extension StopStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
    }
}

extension StopStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ChannelNotBroadcasting" : self = .channelNotBroadcasting(try ChannelNotBroadcasting(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StreamUnavailable" : self = .streamUnavailable(try StreamUnavailable(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopStreamOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case channelNotBroadcasting(ChannelNotBroadcasting)
    case resourceNotFoundException(ResourceNotFoundException)
    case streamUnavailable(StreamUnavailable)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopStreamOutputResponse: Swift.Equatable {

    public init () { }
}

extension IvsClientTypes.Stream: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case health
        case playbackUrl
        case startTime
        case state
        case streamId
        case viewerCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let health = self.health {
            try encodeContainer.encode(health.rawValue, forKey: .health)
        }
        if let playbackUrl = self.playbackUrl {
            try encodeContainer.encode(playbackUrl, forKey: .playbackUrl)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if viewerCount != 0 {
            try encodeContainer.encode(viewerCount, forKey: .viewerCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let playbackUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .playbackUrl)
        playbackUrl = playbackUrlDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamState.self, forKey: .state)
        state = stateDecoded
        let healthDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamHealth.self, forKey: .health)
        health = healthDecoded
        let viewerCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .viewerCount) ?? 0
        viewerCount = viewerCountDecoded
    }
}

extension IvsClientTypes {
    /// Specifies a live video stream that has been ingested and distributed.
    public struct Stream: Swift.Equatable {
        /// Channel ARN for the stream.
        public var channelArn: Swift.String?
        /// The streamâ€™s health.
        public var health: IvsClientTypes.StreamHealth?
        /// URL of the master playlist, required by the video player to play the HLS stream.
        public var playbackUrl: Swift.String?
        /// Time of the streamâ€™s start. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: ClientRuntime.Date?
        /// The streamâ€™s state.
        public var state: IvsClientTypes.StreamState?
        /// Unique identifier for a live or previously live stream in the specified channel.
        public var streamId: Swift.String?
        /// A count of concurrent views of the stream. Typically, a new view appears in viewerCount within 15 seconds of when video playback starts and a view is removed from viewerCount within 1 minute of when video playback ends. A value of -1 indicates that the request timed out; in this case, retry.
        public var viewerCount: Swift.Int

        public init (
            channelArn: Swift.String? = nil,
            health: IvsClientTypes.StreamHealth? = nil,
            playbackUrl: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: IvsClientTypes.StreamState? = nil,
            streamId: Swift.String? = nil,
            viewerCount: Swift.Int = 0
        )
        {
            self.channelArn = channelArn
            self.health = health
            self.playbackUrl = playbackUrl
            self.startTime = startTime
            self.state = state
            self.streamId = streamId
            self.viewerCount = viewerCount
        }
    }

}

extension IvsClientTypes.StreamEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTime
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTime = self.eventTime {
            try encodeContainer.encodeTimestamp(eventTime, format: .dateTime, forKey: .eventTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let eventTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .eventTime)
        eventTime = eventTimeDecoded
    }
}

extension IvsClientTypes {
    /// Object specifying a streamâ€™s events. For a list of events, see [Using Amazon EventBridge with Amazon IVS](https://docs.aws.amazon.com/ivs/latest/userguide/eventbridge.html).
    public struct StreamEvent: Swift.Equatable {
        /// Time when the event occurred. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var eventTime: ClientRuntime.Date?
        /// Name that identifies the stream event within a type.
        public var name: Swift.String?
        /// Logical group for certain events.
        public var type: Swift.String?

        public init (
            eventTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.eventTime = eventTime
            self.name = name
            self.type = type
        }
    }

}

extension IvsClientTypes.StreamFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case health
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let health = self.health {
            try encodeContainer.encode(health.rawValue, forKey: .health)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let healthDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamHealth.self, forKey: .health)
        health = healthDecoded
    }
}

extension IvsClientTypes {
    /// Object specifying the stream attribute on which to filter.
    public struct StreamFilters: Swift.Equatable {
        /// The streamâ€™s health.
        public var health: IvsClientTypes.StreamHealth?

        public init (
            health: IvsClientTypes.StreamHealth? = nil
        )
        {
            self.health = health
        }
    }

}

extension IvsClientTypes {
    public enum StreamHealth: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case starving
        case streamhealthy
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamHealth] {
            return [
                .starving,
                .streamhealthy,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .starving: return "STARVING"
            case .streamhealthy: return "HEALTHY"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamHealth(rawValue: rawValue) ?? StreamHealth.sdkUnknown(rawValue)
        }
    }
}

extension IvsClientTypes.StreamKey: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case channelArn
        case tags
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvsClientTypes.StreamKey: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StreamKey(arn: \(Swift.String(describing: arn)), channelArn: \(Swift.String(describing: channelArn)), tags: \(Swift.String(describing: tags)), value: \"CONTENT_REDACTED\")"}
}

extension IvsClientTypes {
    /// Object specifying a stream key.
    public struct StreamKey: Swift.Equatable {
        /// Stream-key ARN.
        public var arn: Swift.String?
        /// Channel ARN for the stream.
        public var channelArn: Swift.String?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?
        /// Stream-key value.
        public var value: Swift.String?

        public init (
            arn: Swift.String? = nil,
            channelArn: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            value: Swift.String? = nil
        )
        {
            self.arn = arn
            self.channelArn = channelArn
            self.tags = tags
            self.value = value
        }
    }

}

extension IvsClientTypes.StreamKeySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case channelArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IvsClientTypes {
    /// Summary information about a stream key.
    public struct StreamKeySummary: Swift.Equatable {
        /// Stream-key ARN.
        public var arn: Swift.String?
        /// Channel ARN for the stream.
        public var channelArn: Swift.String?
        /// Tags attached to the resource. Array of 1-50 maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
        public var tags: [Swift.String:Swift.String]?

        public init (
            arn: Swift.String? = nil,
            channelArn: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.channelArn = channelArn
            self.tags = tags
        }
    }

}

extension IvsClientTypes.StreamSession: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel
        case endTime
        case ingestConfiguration
        case recordingConfiguration
        case startTime
        case streamId
        case truncatedEvents
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channel = self.channel {
            try encodeContainer.encode(channel, forKey: .channel)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if let ingestConfiguration = self.ingestConfiguration {
            try encodeContainer.encode(ingestConfiguration, forKey: .ingestConfiguration)
        }
        if let recordingConfiguration = self.recordingConfiguration {
            try encodeContainer.encode(recordingConfiguration, forKey: .recordingConfiguration)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let truncatedEvents = truncatedEvents {
            var truncatedEventsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .truncatedEvents)
            for streamevent0 in truncatedEvents {
                try truncatedEventsContainer.encode(streamevent0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let channelDecoded = try containerValues.decodeIfPresent(IvsClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
        let ingestConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.IngestConfiguration.self, forKey: .ingestConfiguration)
        ingestConfiguration = ingestConfigurationDecoded
        let recordingConfigurationDecoded = try containerValues.decodeIfPresent(IvsClientTypes.RecordingConfiguration.self, forKey: .recordingConfiguration)
        recordingConfiguration = recordingConfigurationDecoded
        let truncatedEventsContainer = try containerValues.decodeIfPresent([IvsClientTypes.StreamEvent?].self, forKey: .truncatedEvents)
        var truncatedEventsDecoded0:[IvsClientTypes.StreamEvent]? = nil
        if let truncatedEventsContainer = truncatedEventsContainer {
            truncatedEventsDecoded0 = [IvsClientTypes.StreamEvent]()
            for structure0 in truncatedEventsContainer {
                if let structure0 = structure0 {
                    truncatedEventsDecoded0?.append(structure0)
                }
            }
        }
        truncatedEvents = truncatedEventsDecoded0
    }
}

extension IvsClientTypes {
    /// Object that captures the Amazon IVS configuration that the customer provisioned, the ingest configurations that the broadcaster used, and the most recent Amazon IVS stream events it encountered.
    public struct StreamSession: Swift.Equatable {
        /// The properties of the channel at the time of going live.
        public var channel: IvsClientTypes.Channel?
        /// Time when the channel went offline. This is an ISO 8601 timestamp; note that this is returned as a string. For live streams, this is NULL.
        public var endTime: ClientRuntime.Date?
        /// The properties of the incoming RTMP stream for the stream.
        public var ingestConfiguration: IvsClientTypes.IngestConfiguration?
        /// The properties of recording the live stream.
        public var recordingConfiguration: IvsClientTypes.RecordingConfiguration?
        /// Time when the channel went live. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: ClientRuntime.Date?
        /// Unique identifier for a live or previously live stream in the specified channel.
        public var streamId: Swift.String?
        /// List of Amazon IVS events that the stream encountered. The list is sorted by most recent events and contains up to 500 events. For Amazon IVS events, see [Using Amazon EventBridge with Amazon IVS](https://docs.aws.amazon.com/ivs/latest/userguide/eventbridge.html).
        public var truncatedEvents: [IvsClientTypes.StreamEvent]?

        public init (
            channel: IvsClientTypes.Channel? = nil,
            endTime: ClientRuntime.Date? = nil,
            ingestConfiguration: IvsClientTypes.IngestConfiguration? = nil,
            recordingConfiguration: IvsClientTypes.RecordingConfiguration? = nil,
            startTime: ClientRuntime.Date? = nil,
            streamId: Swift.String? = nil,
            truncatedEvents: [IvsClientTypes.StreamEvent]? = nil
        )
        {
            self.channel = channel
            self.endTime = endTime
            self.ingestConfiguration = ingestConfiguration
            self.recordingConfiguration = recordingConfiguration
            self.startTime = startTime
            self.streamId = streamId
            self.truncatedEvents = truncatedEvents
        }
    }

}

extension IvsClientTypes.StreamSessionSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case hasErrorEvent
        case startTime
        case streamId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .dateTime, forKey: .endTime)
        }
        if hasErrorEvent != false {
            try encodeContainer.encode(hasErrorEvent, forKey: .hasErrorEvent)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .endTime)
        endTime = endTimeDecoded
        let hasErrorEventDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasErrorEvent) ?? false
        hasErrorEvent = hasErrorEventDecoded
    }
}

extension IvsClientTypes {
    /// Summary information about a stream session.
    public struct StreamSessionSummary: Swift.Equatable {
        /// Time when the channel went offline. This is an ISO 8601 timestamp; note that this is returned as a string. For live streams, this is NULL.
        public var endTime: ClientRuntime.Date?
        /// If true, this stream encountered a quota breach or failure.
        public var hasErrorEvent: Swift.Bool
        /// Time when the channel went live. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: ClientRuntime.Date?
        /// Unique identifier for a live or previously live stream in the specified channel.
        public var streamId: Swift.String?

        public init (
            endTime: ClientRuntime.Date? = nil,
            hasErrorEvent: Swift.Bool = false,
            startTime: ClientRuntime.Date? = nil,
            streamId: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.hasErrorEvent = hasErrorEvent
            self.startTime = startTime
            self.streamId = streamId
        }
    }

}

extension IvsClientTypes {
    public enum StreamState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case streamlive
        case streamoffline
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamState] {
            return [
                .streamlive,
                .streamoffline,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .streamlive: return "LIVE"
            case .streamoffline: return "OFFLINE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamState(rawValue: rawValue) ?? StreamState.sdkUnknown(rawValue)
        }
    }
}

extension IvsClientTypes.StreamSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelArn
        case health
        case startTime
        case state
        case streamId
        case viewerCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelArn = self.channelArn {
            try encodeContainer.encode(channelArn, forKey: .channelArn)
        }
        if let health = self.health {
            try encodeContainer.encode(health.rawValue, forKey: .health)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .dateTime, forKey: .startTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if viewerCount != 0 {
            try encodeContainer.encode(viewerCount, forKey: .viewerCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelArn)
        channelArn = channelArnDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamState.self, forKey: .state)
        state = stateDecoded
        let healthDecoded = try containerValues.decodeIfPresent(IvsClientTypes.StreamHealth.self, forKey: .health)
        health = healthDecoded
        let viewerCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .viewerCount) ?? 0
        viewerCount = viewerCountDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .startTime)
        startTime = startTimeDecoded
    }
}

extension IvsClientTypes {
    /// Summary information about a stream.
    public struct StreamSummary: Swift.Equatable {
        /// Channel ARN for the stream.
        public var channelArn: Swift.String?
        /// The streamâ€™s health.
        public var health: IvsClientTypes.StreamHealth?
        /// Time of the streamâ€™s start. This is an ISO 8601 timestamp; note that this is returned as a string.
        public var startTime: ClientRuntime.Date?
        /// The streamâ€™s state.
        public var state: IvsClientTypes.StreamState?
        /// Unique identifier for a live or previously live stream in the specified channel.
        public var streamId: Swift.String?
        /// A count of concurrent views of the stream. Typically, a new view appears in viewerCount within 15 seconds of when video playback starts and a view is removed from viewerCount within 1 minute of when video playback ends. A value of -1 indicates that the request timed out; in this case, retry.
        public var viewerCount: Swift.Int

        public init (
            channelArn: Swift.String? = nil,
            health: IvsClientTypes.StreamHealth? = nil,
            startTime: ClientRuntime.Date? = nil,
            state: IvsClientTypes.StreamState? = nil,
            streamId: Swift.String? = nil,
            viewerCount: Swift.Int = 0
        )
        {
            self.channelArn = channelArn
            self.health = health
            self.startTime = startTime
            self.state = state
            self.streamId = streamId
            self.viewerCount = viewerCount
        }
    }

}

extension StreamUnavailable {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StreamUnavailableBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct StreamUnavailable: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The stream is temporarily unavailable.
    public var exceptionMessage: Swift.String?

    public init (
        exceptionMessage: Swift.String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct StreamUnavailableBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension StreamUnavailableBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// ARN of the resource for which tags are to be added or updated. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be added or updated. Array of maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Request was denied due to request throttling.
    public var exceptionMessage: Swift.String?

    public init (
        exceptionMessage: Swift.String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IvsClientTypes.ThumbnailConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recordingMode
        case targetIntervalSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recordingMode = self.recordingMode {
            try encodeContainer.encode(recordingMode.rawValue, forKey: .recordingMode)
        }
        if targetIntervalSeconds != 0 {
            try encodeContainer.encode(targetIntervalSeconds, forKey: .targetIntervalSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recordingModeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.RecordingMode.self, forKey: .recordingMode)
        recordingMode = recordingModeDecoded
        let targetIntervalSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetIntervalSeconds) ?? 0
        targetIntervalSeconds = targetIntervalSecondsDecoded
    }
}

extension IvsClientTypes {
    /// An object representing a configuration of thumbnails for recorded video.
    public struct ThumbnailConfiguration: Swift.Equatable {
        /// Thumbnail recording mode. Default: INTERVAL.
        public var recordingMode: IvsClientTypes.RecordingMode?
        /// The targeted thumbnail-generation interval in seconds. This is configurable (and required) only if recordingMode is INTERVAL. Default: 60. Important: Setting a value for targetIntervalSeconds does not guarantee that thumbnails are generated at the specified interval. For thumbnails to be generated at the targetIntervalSeconds interval, the IDR/Keyframe value for the input video must be less than the targetIntervalSeconds value. See [ Amazon IVS Streaming Configuration](https://docs.aws.amazon.com/ivs/latest/userguide/streaming-config.html) for information on setting IDR/Keyframe to the recommended value in video-encoder settings.
        public var targetIntervalSeconds: Swift.Int

        public init (
            recordingMode: IvsClientTypes.RecordingMode? = nil,
            targetIntervalSeconds: Swift.Int = 0
        )
        {
            self.recordingMode = recordingMode
            self.targetIntervalSeconds = targetIntervalSeconds
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// ARN of the resource for which tags are to be removed. The ARN must be URL-encoded.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be removed. Array of maps, each of the form string:string (key:value). See [Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) for more information, including restrictions that apply to tags and "Tag naming limits and requirements"; Amazon IVS has no service-specific constraints beyond what is documented there.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authorized
        case latencyMode
        case name
        case recordingConfigurationArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if authorized != false {
            try encodeContainer.encode(authorized, forKey: .authorized)
        }
        if let latencyMode = self.latencyMode {
            try encodeContainer.encode(latencyMode.rawValue, forKey: .latencyMode)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recordingConfigurationArn = self.recordingConfigurationArn {
            try encodeContainer.encode(recordingConfigurationArn, forKey: .recordingConfigurationArn)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateChannel"
    }
}

public struct UpdateChannelInput: Swift.Equatable {
    /// ARN of the channel to be updated.
    /// This member is required.
    public var arn: Swift.String?
    /// Whether the channel is private (enabled for playback authorization).
    public var authorized: Swift.Bool
    /// Channel latency mode. Use NORMAL to broadcast and deliver live video up to Full HD. Use LOW for near-real-time interaction with viewers. (Note: In the Amazon IVS console, LOW and NORMAL correspond to Ultra-low and Standard, respectively.)
    public var latencyMode: IvsClientTypes.ChannelLatencyMode?
    /// Channel name.
    public var name: Swift.String?
    /// Recording-configuration ARN. If this is set to an empty string, recording is disabled. A value other than an empty string indicates that recording is enabled
    public var recordingConfigurationArn: Swift.String?
    /// Channel type, which determines the allowable resolution and bitrate. If you exceed the allowable resolution or bitrate, the stream probably will disconnect immediately. Valid values:
    ///
    /// * STANDARD: Video is transcoded: multiple qualities are generated from the original input, to automatically give viewers the best experience for their devices and network conditions. Transcoding allows higher playback quality across a range of download speeds. Resolution can be up to 1080p and bitrate can be up to 8.5 Mbps. Audio is transcoded only for renditions 360p and below; above that, audio is passed through. This is the default.
    ///
    /// * BASIC: Video is transmuxed: Amazon IVS delivers the original input to viewers. The viewerâ€™s video-quality choice is limited to the original input. Resolution can be up to 1080p and bitrate can be up to 1.5 Mbps for 480p and up to 3.5 Mbps for resolutions between 480p and 1080p.
    public var type: IvsClientTypes.ChannelType?

    public init (
        arn: Swift.String? = nil,
        authorized: Swift.Bool = false,
        latencyMode: IvsClientTypes.ChannelLatencyMode? = nil,
        name: Swift.String? = nil,
        recordingConfigurationArn: Swift.String? = nil,
        type: IvsClientTypes.ChannelType? = nil
    )
    {
        self.arn = arn
        self.authorized = authorized
        self.latencyMode = latencyMode
        self.name = name
        self.recordingConfigurationArn = recordingConfigurationArn
        self.type = type
    }
}

struct UpdateChannelInputBody: Swift.Equatable {
    let arn: Swift.String?
    let name: Swift.String?
    let latencyMode: IvsClientTypes.ChannelLatencyMode?
    let type: IvsClientTypes.ChannelType?
    let authorized: Swift.Bool
    let recordingConfigurationArn: Swift.String?
}

extension UpdateChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case authorized
        case latencyMode
        case name
        case recordingConfigurationArn
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let latencyModeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelLatencyMode.self, forKey: .latencyMode)
        latencyMode = latencyModeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IvsClientTypes.ChannelType.self, forKey: .type)
        type = typeDecoded
        let authorizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .authorized) ?? false
        authorized = authorizedDecoded
        let recordingConfigurationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recordingConfigurationArn)
        recordingConfigurationArn = recordingConfigurationArnDecoded
    }
}

extension UpdateChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "PendingVerification" : self = .pendingVerification(try PendingVerification(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case pendingVerification(PendingVerification)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channel = output.channel
        } else {
            self.channel = nil
        }
    }
}

public struct UpdateChannelOutputResponse: Swift.Equatable {
    /// Object specifying a channel.
    public var channel: IvsClientTypes.Channel?

    public init (
        channel: IvsClientTypes.Channel? = nil
    )
    {
        self.channel = channel
    }
}

struct UpdateChannelOutputResponseBody: Swift.Equatable {
    let channel: IvsClientTypes.Channel?
}

extension UpdateChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channel
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelDecoded = try containerValues.decodeIfPresent(IvsClientTypes.Channel.self, forKey: .channel)
        channel = channelDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.exceptionMessage = output.exceptionMessage
        } else {
            self.exceptionMessage = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

///
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The input fails to satisfy the constraints specified by an Amazon Web Services service.
    public var exceptionMessage: Swift.String?

    public init (
        exceptionMessage: Swift.String? = nil
    )
    {
        self.exceptionMessage = exceptionMessage
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let exceptionMessage: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exceptionMessage
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exceptionMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exceptionMessage)
        exceptionMessage = exceptionMessageDecoded
    }
}

extension IvsClientTypes.VideoConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case avcLevel
        case avcProfile
        case codec
        case encoder
        case targetBitrate
        case targetFramerate
        case videoHeight
        case videoWidth
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let avcLevel = self.avcLevel {
            try encodeContainer.encode(avcLevel, forKey: .avcLevel)
        }
        if let avcProfile = self.avcProfile {
            try encodeContainer.encode(avcProfile, forKey: .avcProfile)
        }
        if let codec = self.codec {
            try encodeContainer.encode(codec, forKey: .codec)
        }
        if let encoder = self.encoder {
            try encodeContainer.encode(encoder, forKey: .encoder)
        }
        if targetBitrate != 0 {
            try encodeContainer.encode(targetBitrate, forKey: .targetBitrate)
        }
        if targetFramerate != 0 {
            try encodeContainer.encode(targetFramerate, forKey: .targetFramerate)
        }
        if videoHeight != 0 {
            try encodeContainer.encode(videoHeight, forKey: .videoHeight)
        }
        if videoWidth != 0 {
            try encodeContainer.encode(videoWidth, forKey: .videoWidth)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let avcProfileDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .avcProfile)
        avcProfile = avcProfileDecoded
        let avcLevelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .avcLevel)
        avcLevel = avcLevelDecoded
        let codecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .codec)
        codec = codecDecoded
        let encoderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encoder)
        encoder = encoderDecoded
        let targetBitrateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetBitrate) ?? 0
        targetBitrate = targetBitrateDecoded
        let targetFramerateDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .targetFramerate) ?? 0
        targetFramerate = targetFramerateDecoded
        let videoHeightDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .videoHeight) ?? 0
        videoHeight = videoHeightDecoded
        let videoWidthDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .videoWidth) ?? 0
        videoWidth = videoWidthDecoded
    }
}

extension IvsClientTypes {
    /// Object specifying a streamâ€™s video configuration, as set up by the broadcaster (usually in an encoder). This is part of the [IngestConfiguration] object and used for monitoring stream health.
    public struct VideoConfiguration: Swift.Equatable {
        /// Indicates the degree of required decoder performance for a profile. Normally this is set automatically by the encoder. For details, see the H.264 specification.
        public var avcLevel: Swift.String?
        /// Indicates to the decoder the requirements for decoding the stream. For definitions of the valid values, see the H.264 specification.
        public var avcProfile: Swift.String?
        /// Codec used for the video encoding.
        public var codec: Swift.String?
        /// Software or hardware used to encode the video.
        public var encoder: Swift.String?
        /// The expected ingest bitrate (bits per second). This is configured in the encoder.
        public var targetBitrate: Swift.Int
        /// The expected ingest framerate. This is configured in the encoder.
        public var targetFramerate: Swift.Int
        /// Video-resolution height in pixels.
        public var videoHeight: Swift.Int
        /// Video-resolution width in pixels.
        public var videoWidth: Swift.Int

        public init (
            avcLevel: Swift.String? = nil,
            avcProfile: Swift.String? = nil,
            codec: Swift.String? = nil,
            encoder: Swift.String? = nil,
            targetBitrate: Swift.Int = 0,
            targetFramerate: Swift.Int = 0,
            videoHeight: Swift.Int = 0,
            videoWidth: Swift.Int = 0
        )
        {
            self.avcLevel = avcLevel
            self.avcProfile = avcProfile
            self.codec = codec
            self.encoder = encoder
            self.targetBitrate = targetBitrate
            self.targetFramerate = targetFramerate
            self.videoHeight = videoHeight
            self.videoWidth = videoWidth
        }
    }

}
