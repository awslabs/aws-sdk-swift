//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem


public struct DeleteApplicationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteStreamGroupOutput: Swift.Sendable {

    public init() { }
}

public struct RemoveStreamGroupLocationsOutput: Swift.Sendable {

    public init() { }
}

public struct TerminateStreamSessionOutput: Swift.Sendable {

    public init() { }
}

/// You don't have the required permissions to access this Amazon GameLift Streams resource. Correct the permissions before you try again.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The service encountered an internal error and is unable to complete the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The resource specified in the request was not found. Correct the request before you try again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request would cause the resource to exceed an allowed service quota. Resolve the issue before you try again.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling. Retry the request after the suggested wait time.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// One or more parameter values in the request fail to satisfy the specified constraints. Correct the invalid parameter values before retrying the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension GameLiftStreamsClientTypes {

    /// Configuration settings that define a stream group's stream capacity for a location. When configuring a location for the first time, you must specify a numeric value for at least one of the two capacity types. To update the capacity for an existing stream group, call [UpdateStreamGroup](https://docs.aws.amazon.com/gameliftstreams/latest/apireference/API_UpdateStreamGroup.html). To add a new location and specify its capacity, call [AddStreamGroupLocations](https://docs.aws.amazon.com/gameliftstreams/latest/apireference/API_AddStreamGroupLocations.html).
    public struct LocationConfiguration: Swift.Sendable {
        /// The streaming capacity that is allocated and ready to handle stream requests without delay. You pay for this capacity whether it's in use or not. Best for quickest time from streaming request to streaming session.
        public var alwaysOnCapacity: Swift.Int?
        /// A location's name. For example, us-east-1. For a complete list of locations that Amazon GameLift Streams supports, refer to [Regions and quotas](https://docs.aws.amazon.com/gameliftstreams/latest/developerguide/regions-quotas.html) in the Amazon GameLift Streams Developer Guide.
        /// This member is required.
        public var locationName: Swift.String?
        /// The streaming capacity that Amazon GameLift Streams can allocate in response to stream requests, and then de-allocate when the session has terminated. This offers a cost control measure at the expense of a greater startup time (typically under 5 minutes).
        public var onDemandCapacity: Swift.Int?

        public init(
            alwaysOnCapacity: Swift.Int? = nil,
            locationName: Swift.String? = nil,
            onDemandCapacity: Swift.Int? = nil
        ) {
            self.alwaysOnCapacity = alwaysOnCapacity
            self.locationName = locationName
            self.onDemandCapacity = onDemandCapacity
        }
    }
}

public struct AddStreamGroupLocationsInput: Swift.Sendable {
    /// A stream group to add the specified locations to. This value is a Amazon Resource Name (ARN) that uniquely identifies the stream group resource. Format example: sg-1AB2C3De4.
    /// This member is required.
    public var identifier: Swift.String?
    /// A set of one or more locations and the streaming capacity for each location.
    /// This member is required.
    public var locationConfigurations: [GameLiftStreamsClientTypes.LocationConfiguration]?

    public init(
        identifier: Swift.String? = nil,
        locationConfigurations: [GameLiftStreamsClientTypes.LocationConfiguration]? = nil
    ) {
        self.identifier = identifier
        self.locationConfigurations = locationConfigurations
    }
}

extension GameLiftStreamsClientTypes {

    public enum StreamGroupLocationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activating
        case active
        case error
        case removing
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamGroupLocationStatus] {
            return [
                .activating,
                .active,
                .error,
                .removing
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .error: return "ERROR"
            case .removing: return "REMOVING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GameLiftStreamsClientTypes {

    /// Represents a location and its corresponding stream capacity and status.
    public struct LocationState: Swift.Sendable {
        /// This value is the number of compute resources that a stream group has provisioned and is ready to stream. It includes resources that are currently streaming and resources that are idle and ready to respond to stream requests.
        public var allocatedCapacity: Swift.Int?
        /// The streaming capacity that is allocated and ready to handle stream requests without delay. You pay for this capacity whether it's in use or not. Best for quickest time from streaming request to streaming session.
        public var alwaysOnCapacity: Swift.Int?
        /// This value is the amount of allocated capacity that is not currently streaming. It represents the stream group's availability to respond to new stream requests, but not including on-demand capacity.
        public var idleCapacity: Swift.Int?
        /// A location's name. For example, us-east-1. For a complete list of locations that Amazon GameLift Streams supports, refer to [Regions and quotas](https://docs.aws.amazon.com/gameliftstreams/latest/developerguide/regions-quotas.html) in the Amazon GameLift Streams Developer Guide.
        public var locationName: Swift.String?
        /// The streaming capacity that Amazon GameLift Streams can allocate in response to stream requests, and then de-allocate when the session has terminated. This offers a cost control measure at the expense of a greater startup time (typically under 5 minutes).
        public var onDemandCapacity: Swift.Int?
        /// This value is the total number of compute resources that you request for a stream group. This includes resources that Amazon GameLift Streams has either already provisioned or is working to provision. You request capacity for each location in a stream group.
        public var requestedCapacity: Swift.Int?
        /// This value is set of locations, including their name, current status, and capacities. A location can be in one of the following states:
        ///
        /// * ACTIVATING: Amazon GameLift Streams is preparing the location. You cannot stream from, scale the capacity of, or remove this location yet.
        ///
        /// * ACTIVE: The location is provisioned with initial capacity. You can now stream from, scale the capacity of, or remove this location.
        ///
        /// * ERROR: Amazon GameLift Streams failed to set up this location. The StatusReason field describes the error. You can remove this location and try to add it again.
        ///
        /// * REMOVING: Amazon GameLift Streams is working to remove this location. It releases all provisioned capacity for this location in this stream group.
        public var status: GameLiftStreamsClientTypes.StreamGroupLocationStatus?

        public init(
            allocatedCapacity: Swift.Int? = nil,
            alwaysOnCapacity: Swift.Int? = nil,
            idleCapacity: Swift.Int? = nil,
            locationName: Swift.String? = nil,
            onDemandCapacity: Swift.Int? = nil,
            requestedCapacity: Swift.Int? = nil,
            status: GameLiftStreamsClientTypes.StreamGroupLocationStatus? = nil
        ) {
            self.allocatedCapacity = allocatedCapacity
            self.alwaysOnCapacity = alwaysOnCapacity
            self.idleCapacity = idleCapacity
            self.locationName = locationName
            self.onDemandCapacity = onDemandCapacity
            self.requestedCapacity = requestedCapacity
            self.status = status
        }
    }
}

public struct AddStreamGroupLocationsOutput: Swift.Sendable {
    /// This value is the Amazon Resource Name (ARN) that uniquely identifies the stream group resource. Format example: sg-1AB2C3De4.
    /// This member is required.
    public var identifier: Swift.String?
    /// This value is set of locations, including their name, current status, and capacities. A location can be in one of the following states:
    ///
    /// * ACTIVATING: Amazon GameLift Streams is preparing the location. You cannot stream from, scale the capacity of, or remove this location yet.
    ///
    /// * ACTIVE: The location is provisioned with initial capacity. You can now stream from, scale the capacity of, or remove this location.
    ///
    /// * ERROR: Amazon GameLift Streams failed to set up this location. The StatusReason field describes the error. You can remove this location and try to add it again.
    ///
    /// * REMOVING: Amazon GameLift Streams is working to remove this location. It releases all provisioned capacity for this location in this stream group.
    /// This member is required.
    public var locations: [GameLiftStreamsClientTypes.LocationState]?

    public init(
        identifier: Swift.String? = nil,
        locations: [GameLiftStreamsClientTypes.LocationState]? = nil
    ) {
        self.identifier = identifier
        self.locations = locations
    }
}

extension GameLiftStreamsClientTypes {

    public enum ApplicationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleting
        case error
        case initialized
        case processing
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationStatus] {
            return [
                .deleting,
                .error,
                .initialized,
                .processing,
                .ready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .initialized: return "INITIALIZED"
            case .processing: return "PROCESSING"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GameLiftStreamsClientTypes {

    public enum ApplicationStatusReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case internalError
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationStatusReason] {
            return [
                .accessDenied,
                .internalError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "accessDenied"
            case .internalError: return "internalError"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Description of the error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension GameLiftStreamsClientTypes {

    public enum RuntimeEnvironmentType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case proton
        case ubuntu
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [RuntimeEnvironmentType] {
            return [
                .proton,
                .ubuntu,
                .windows
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .proton: return "PROTON"
            case .ubuntu: return "UBUNTU"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GameLiftStreamsClientTypes {

    /// Configuration settings that identify the operating system for an application resource. This can also include a compatibility layer and other drivers. A runtime environment can be one of the following:
    ///
    /// * For Linux applications
    ///
    /// * Ubuntu 22.04 LTS (Type=UBUNTU, Version=22_04_LTS)
    ///
    ///
    ///
    ///
    /// * For Windows applications
    ///
    /// * Microsoft Windows Server 2022 Base (Type=WINDOWS, Version=2022)
    ///
    /// * Proton 8.0-5 (Type=PROTON, Version=20241007)
    ///
    /// * Proton 8.0-2c (Type=PROTON, Version=20230704)
    public struct RuntimeEnvironment: Swift.Sendable {
        /// The operating system and other drivers. For Proton, this also includes the Proton compatibility layer.
        /// This member is required.
        public var type: GameLiftStreamsClientTypes.RuntimeEnvironmentType?
        /// Versioned container environment for the application operating system.
        /// This member is required.
        public var version: Swift.String?

        public init(
            type: GameLiftStreamsClientTypes.RuntimeEnvironmentType? = nil,
            version: Swift.String? = nil
        ) {
            self.type = type
            self.version = version
        }
    }
}

public struct CreateApplicationInput: Swift.Sendable {
    /// An Amazon S3 URI to a bucket where you would like Amazon GameLift Streams to save application logs. Required if you specify one or more ApplicationLogPaths. The log bucket must have permissions that give Amazon GameLift Streams access to write the log files. For more information, see Getting Started in the Amazon GameLift Streams Developer Guide.
    public var applicationLogOutputUri: Swift.String?
    /// Locations of log files that your content generates during a stream session. Enter path values that are relative to the ApplicationSourceUri location. You can specify up to 10 log paths. Amazon GameLift Streams uploads designated log files to the Amazon S3 bucket that you specify in ApplicationLogOutputUri at the end of a stream session. To retrieve stored log files, call [GetStreamSession](https://docs.aws.amazon.com/gameliftstreams/latest/apireference/API_GetStreamSession.html) and get the LogFileLocationUri.
    public var applicationLogPaths: [Swift.String]?
    /// The location of the content that you want to stream. Enter an Amazon S3 URI to a bucket that contains your game or other application. The location can have a multi-level prefix structure, but it must include all the files needed to run the content. Amazon GameLift Streams copies everything under the specified location. This value is immutable. To designate a different content location, create a new application. The Amazon S3 bucket and the Amazon GameLift Streams application must be in the same Amazon Web Services Region.
    /// This member is required.
    public var applicationSourceUri: Swift.String?
    /// A unique identifier that represents a client request. The request is idempotent, which ensures that an API request completes only once. When users send a request, Amazon GameLift Streams automatically populates this field.
    public var clientToken: Swift.String?
    /// A human-readable label for the application. You can update this value later.
    /// This member is required.
    public var description: Swift.String?
    /// The path and file name of the executable file that launches the content for streaming. Enter a path value that is relative to the location set in ApplicationSourceUri.
    /// This member is required.
    public var executablePath: Swift.String?
    /// Configuration settings that identify the operating system for an application resource. This can also include a compatibility layer and other drivers. A runtime environment can be one of the following:
    ///
    /// * For Linux applications
    ///
    /// * Ubuntu 22.04 LTS (Type=UBUNTU, Version=22_04_LTS)
    ///
    ///
    ///
    ///
    /// * For Windows applications
    ///
    /// * Microsoft Windows Server 2022 Base (Type=WINDOWS, Version=2022)
    ///
    /// * Proton 8.0-5 (Type=PROTON, Version=20241007)
    ///
    /// * Proton 8.0-2c (Type=PROTON, Version=20230704)
    /// This member is required.
    public var runtimeEnvironment: GameLiftStreamsClientTypes.RuntimeEnvironment?
    /// A list of labels to assign to the new application resource. Tags are developer-defined key-value pairs. Tagging Amazon Web Services resources is useful for resource management, access management and cost allocation. See [ Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the Amazon Web Services General Reference. You can use [TagResource](https://docs.aws.amazon.com/gameliftstreams/latest/apireference/API_TagResource.html) to add tags, [UntagResource](https://docs.aws.amazon.com/gameliftstreams/latest/apireference/API_UntagResource.html) to remove tags, and [ListTagsForResource](https://docs.aws.amazon.com/gameliftstreams/latest/apireference/API_ListTagsForResource.html) to view tags on existing resources.
    public var tags: [Swift.String: Swift.String]?

    public init(
        applicationLogOutputUri: Swift.String? = nil,
        applicationLogPaths: [Swift.String]? = nil,
        applicationSourceUri: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        executablePath: Swift.String? = nil,
        runtimeEnvironment: GameLiftStreamsClientTypes.RuntimeEnvironment? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.applicationLogOutputUri = applicationLogOutputUri
        self.applicationLogPaths = applicationLogPaths
        self.applicationSourceUri = applicationSourceUri
        self.clientToken = clientToken
        self.description = description
        self.executablePath = executablePath
        self.runtimeEnvironment = runtimeEnvironment
        self.tags = tags
    }
}

extension GameLiftStreamsClientTypes {

    public enum ReplicationStatusType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case completed
        case replicating
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationStatusType] {
            return [
                .completed,
                .replicating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .replicating: return "REPLICATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GameLiftStreamsClientTypes {

    /// Represents the status of the replication of an application to a location. An application cannot be streamed from a location until it has finished replicating there.
    public struct ReplicationStatus: Swift.Sendable {
        /// A location's name. For example, us-east-1. For a complete list of locations that Amazon GameLift Streams supports, refer to [Regions and quotas](https://docs.aws.amazon.com/gameliftstreams/latest/developerguide/regions-quotas.html) in the Amazon GameLift Streams Developer Guide.
        public var location: Swift.String?
        /// The current status of the replication process.
        public var status: GameLiftStreamsClientTypes.ReplicationStatusType?

        public init(
            location: Swift.String? = nil,
            status: GameLiftStreamsClientTypes.ReplicationStatusType? = nil
        ) {
            self.location = location
            self.status = status
        }
    }
}

public struct CreateApplicationOutput: Swift.Sendable {
    /// An Amazon S3 URI to a bucket where you would like Amazon GameLift Streams to save application logs. Required if you specify one or more ApplicationLogPaths.
    public var applicationLogOutputUri: Swift.String?
    /// Locations of log files that your content generates during a stream session. Amazon GameLift Streams uploads log files to the Amazon S3 bucket that you specify in ApplicationLogOutputUri at the end of a stream session. To retrieve stored log files, call [GetStreamSession](https://docs.aws.amazon.com/gameliftstreams/latest/apireference/API_GetStreamSession.html) and get the LogFileLocationUri.
    public var applicationLogPaths: [Swift.String]?
    /// The original Amazon S3 location of uploaded stream content for the application.
    public var applicationSourceUri: Swift.String?
    /// An Amazon Resource Name (ARN) that's assigned to an application resource and uniquely identifies it across all Amazon Web Services Regions. Format is arn:aws:gameliftstreams:[AWS Region]:[AWS account]:application/[resource ID].
    /// This member is required.
    public var arn: Swift.String?
    /// A newly created application is not associated to any stream groups. This value is empty.
    public var associatedStreamGroups: [Swift.String]?
    /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
    public var createdAt: Foundation.Date?
    /// A human-readable label for the application. You can edit this value.
    public var description: Swift.String?
    /// The path and file name of the executable file that launches the content for streaming.
    public var executablePath: Swift.String?
    /// An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the application resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/a-9ZY8X7Wv6 or ID-a-9ZY8X7Wv6.
    public var id: Swift.String?
    /// A timestamp that indicates when this resource was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
    public var lastUpdatedAt: Foundation.Date?
    /// A set of replication statuses for each location.
    public var replicationStatuses: [GameLiftStreamsClientTypes.ReplicationStatus]?
    /// Configuration settings that identify the operating system for an application resource. This can also include a compatibility layer and other drivers. A runtime environment can be one of the following:
    ///
    /// * For Linux applications
    ///
    /// * Ubuntu 22.04 LTS (Type=UBUNTU, Version=22_04_LTS)
    ///
    ///
    ///
    ///
    /// * For Windows applications
    ///
    /// * Microsoft Windows Server 2022 Base (Type=WINDOWS, Version=2022)
    ///
    /// * Proton 8.0-5 (Type=PROTON, Version=20241007)
    ///
    /// * Proton 8.0-2c (Type=PROTON, Version=20230704)
    public var runtimeEnvironment: GameLiftStreamsClientTypes.RuntimeEnvironment?
    /// The current status of the application resource. Possible statuses include the following:
    ///
    /// * INITIALIZED: Amazon GameLift Streams has received the request and is initiating the work flow to create an application.
    ///
    /// * PROCESSING: The create application work flow is in process. Amazon GameLift Streams is copying the content and caching for future deployment in a stream group.
    ///
    /// * READY: The application is ready to deploy in a stream group.
    ///
    /// * ERROR: An error occurred when setting up the application. See StatusReason for more information.
    ///
    /// * DELETING: Amazon GameLift Streams is in the process of deleting the application.
    public var status: GameLiftStreamsClientTypes.ApplicationStatus?
    /// A short description of the status reason when the application is in ERROR status.
    public var statusReason: GameLiftStreamsClientTypes.ApplicationStatusReason?

    public init(
        applicationLogOutputUri: Swift.String? = nil,
        applicationLogPaths: [Swift.String]? = nil,
        applicationSourceUri: Swift.String? = nil,
        arn: Swift.String? = nil,
        associatedStreamGroups: [Swift.String]? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        executablePath: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        replicationStatuses: [GameLiftStreamsClientTypes.ReplicationStatus]? = nil,
        runtimeEnvironment: GameLiftStreamsClientTypes.RuntimeEnvironment? = nil,
        status: GameLiftStreamsClientTypes.ApplicationStatus? = nil,
        statusReason: GameLiftStreamsClientTypes.ApplicationStatusReason? = nil
    ) {
        self.applicationLogOutputUri = applicationLogOutputUri
        self.applicationLogPaths = applicationLogPaths
        self.applicationSourceUri = applicationSourceUri
        self.arn = arn
        self.associatedStreamGroups = associatedStreamGroups
        self.createdAt = createdAt
        self.description = description
        self.executablePath = executablePath
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.replicationStatuses = replicationStatuses
        self.runtimeEnvironment = runtimeEnvironment
        self.status = status
        self.statusReason = statusReason
    }
}

public struct DeleteApplicationInput: Swift.Sendable {
    /// An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the application resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/a-9ZY8X7Wv6 or ID-a-9ZY8X7Wv6.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetApplicationInput: Swift.Sendable {
    /// An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the application resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/a-9ZY8X7Wv6 or ID-a-9ZY8X7Wv6.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetApplicationOutput: Swift.Sendable {
    /// An Amazon S3 URI to a bucket where you would like Amazon GameLift Streams to save application logs. Required if you specify one or more ApplicationLogPaths.
    public var applicationLogOutputUri: Swift.String?
    /// Locations of log files that your content generates during a stream session. Amazon GameLift Streams uploads log files to the Amazon S3 bucket that you specify in ApplicationLogOutputUri at the end of a stream session. To retrieve stored log files, call [GetStreamSession](https://docs.aws.amazon.com/gameliftstreams/latest/apireference/API_GetStreamSession.html) and get the LogFileLocationUri.
    public var applicationLogPaths: [Swift.String]?
    /// The original Amazon S3 location of uploaded stream content for the application.
    public var applicationSourceUri: Swift.String?
    /// An Amazon Resource Name (ARN) that's assigned to an application resource and uniquely identifies it across all Amazon Web Services Regions. Format is arn:aws:gameliftstreams:[AWS Region]:[AWS account]:application/[resource ID].
    /// This member is required.
    public var arn: Swift.String?
    /// A set of stream groups that this application is associated with. You can use any of these stream groups to stream your application. This value is a set of [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) that uniquely identify stream group resources. Format example: arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/sg-1AB2C3De4.
    public var associatedStreamGroups: [Swift.String]?
    /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
    public var createdAt: Foundation.Date?
    /// A human-readable label for the application. You can edit this value.
    public var description: Swift.String?
    /// The path and file name of the executable file that launches the content for streaming.
    public var executablePath: Swift.String?
    /// An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the application resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/a-9ZY8X7Wv6 or ID-a-9ZY8X7Wv6.
    public var id: Swift.String?
    /// A timestamp that indicates when this resource was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
    public var lastUpdatedAt: Foundation.Date?
    /// A set of replication statuses for each location.
    public var replicationStatuses: [GameLiftStreamsClientTypes.ReplicationStatus]?
    /// Configuration settings that identify the operating system for an application resource. This can also include a compatibility layer and other drivers. A runtime environment can be one of the following:
    ///
    /// * For Linux applications
    ///
    /// * Ubuntu 22.04 LTS (Type=UBUNTU, Version=22_04_LTS)
    ///
    ///
    ///
    ///
    /// * For Windows applications
    ///
    /// * Microsoft Windows Server 2022 Base (Type=WINDOWS, Version=2022)
    ///
    /// * Proton 8.0-5 (Type=PROTON, Version=20241007)
    ///
    /// * Proton 8.0-2c (Type=PROTON, Version=20230704)
    public var runtimeEnvironment: GameLiftStreamsClientTypes.RuntimeEnvironment?
    /// The current status of the application resource. Possible statuses include the following:
    ///
    /// * INITIALIZED: Amazon GameLift Streams has received the request and is initiating the work flow to create an application.
    ///
    /// * PROCESSING: The create application work flow is in process. Amazon GameLift Streams is copying the content and caching for future deployment in a stream group.
    ///
    /// * READY: The application is ready to deploy in a stream group.
    ///
    /// * ERROR: An error occurred when setting up the application. See StatusReason for more information.
    ///
    /// * DELETING: Amazon GameLift Streams is in the process of deleting the application.
    public var status: GameLiftStreamsClientTypes.ApplicationStatus?
    /// A short description of the status reason when the application is in ERROR status.
    public var statusReason: GameLiftStreamsClientTypes.ApplicationStatusReason?

    public init(
        applicationLogOutputUri: Swift.String? = nil,
        applicationLogPaths: [Swift.String]? = nil,
        applicationSourceUri: Swift.String? = nil,
        arn: Swift.String? = nil,
        associatedStreamGroups: [Swift.String]? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        executablePath: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        replicationStatuses: [GameLiftStreamsClientTypes.ReplicationStatus]? = nil,
        runtimeEnvironment: GameLiftStreamsClientTypes.RuntimeEnvironment? = nil,
        status: GameLiftStreamsClientTypes.ApplicationStatus? = nil,
        statusReason: GameLiftStreamsClientTypes.ApplicationStatusReason? = nil
    ) {
        self.applicationLogOutputUri = applicationLogOutputUri
        self.applicationLogPaths = applicationLogPaths
        self.applicationSourceUri = applicationSourceUri
        self.arn = arn
        self.associatedStreamGroups = associatedStreamGroups
        self.createdAt = createdAt
        self.description = description
        self.executablePath = executablePath
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.replicationStatuses = replicationStatuses
        self.runtimeEnvironment = runtimeEnvironment
        self.status = status
        self.statusReason = statusReason
    }
}

public struct ListApplicationsInput: Swift.Sendable {
    /// The number of results to return. Use this parameter with NextToken to return results in sequential pages. Default value is 25.
    public var maxResults: Swift.Int?
    /// The token that marks the start of the next set of results. Use this token when you retrieve results as sequential pages. To get the first page of results, omit a token value. To get the remaining pages, provide the token returned with the previous result set.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension GameLiftStreamsClientTypes {

    /// Describes an application resource that represents a collection of content for streaming with Amazon GameLift Streams. To retrieve additional application details, call [GetApplication](https://docs.aws.amazon.com/gameliftstreams/latest/apireference/API_GetApplication.html).
    public struct ApplicationSummary: Swift.Sendable {
        /// An Amazon Resource Name (ARN) that's assigned to an application resource and uniquely identifies the application across all Amazon Web Services Regions. Format is arn:aws:gameliftstreams:[AWS Region]:[AWS account]:application/[resource ID].
        /// This member is required.
        public var arn: Swift.String?
        /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public var createdAt: Foundation.Date?
        /// A human-readable label for the application. You can edit this value.
        public var description: Swift.String?
        /// An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the application resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/a-9ZY8X7Wv6 or ID-a-9ZY8X7Wv6.
        public var id: Swift.String?
        /// A timestamp that indicates when this resource was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public var lastUpdatedAt: Foundation.Date?
        /// Configuration settings that identify the operating system for an application resource. This can also include a compatibility layer and other drivers. A runtime environment can be one of the following:
        ///
        /// * For Linux applications
        ///
        /// * Ubuntu 22.04 LTS (Type=UBUNTU, Version=22_04_LTS)
        ///
        ///
        ///
        ///
        /// * For Windows applications
        ///
        /// * Microsoft Windows Server 2022 Base (Type=WINDOWS, Version=2022)
        ///
        /// * Proton 8.0-5 (Type=PROTON, Version=20241007)
        ///
        /// * Proton 8.0-2c (Type=PROTON, Version=20230704)
        public var runtimeEnvironment: GameLiftStreamsClientTypes.RuntimeEnvironment?
        /// The current status of the application resource. Possible statuses include the following:
        ///
        /// * INITIALIZED: Amazon GameLift Streams has received the request and is initiating the work flow to create an application.
        ///
        /// * PROCESSING: The create application work flow is in process. Amazon GameLift Streams is copying the content and caching for future deployment in a stream group.
        ///
        /// * READY: The application is ready to deploy in a stream group.
        ///
        /// * ERROR: An error occurred when setting up the application. See StatusReason for more information.
        ///
        /// * DELETING: Amazon GameLift Streams is in the process of deleting the application.
        public var status: GameLiftStreamsClientTypes.ApplicationStatus?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            runtimeEnvironment: GameLiftStreamsClientTypes.RuntimeEnvironment? = nil,
            status: GameLiftStreamsClientTypes.ApplicationStatus? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.runtimeEnvironment = runtimeEnvironment
            self.status = status
        }
    }
}

public struct ListApplicationsOutput: Swift.Sendable {
    /// A collection of Amazon GameLift Streams applications that are associated with the Amazon Web Services account in use. Each item includes application metadata and status.
    public var items: [GameLiftStreamsClientTypes.ApplicationSummary]?
    /// A token that marks the start of the next sequential page of results. If an operation doesn't return a token, you've reached the end of the list.
    public var nextToken: Swift.String?

    public init(
        items: [GameLiftStreamsClientTypes.ApplicationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UpdateApplicationInput: Swift.Sendable {
    /// An Amazon S3 URI to a bucket where you would like Amazon GameLift Streams to save application logs. Required if you specify one or more ApplicationLogPaths. The log bucket must have permissions that give Amazon GameLift Streams access to write the log files. For more information, see Getting Started in the Amazon GameLift Streams Developer Guide.
    public var applicationLogOutputUri: Swift.String?
    /// Locations of log files that your content generates during a stream session. Enter path values that are relative to the ApplicationSourceUri location. You can specify up to 10 log paths. Amazon GameLift Streams uploads designated log files to the Amazon S3 bucket that you specify in ApplicationLogOutputUri at the end of a stream session. To retrieve stored log files, call [GetStreamSession](https://docs.aws.amazon.com/gameliftstreams/latest/apireference/API_GetStreamSession.html) and get the LogFileLocationUri.
    public var applicationLogPaths: [Swift.String]?
    /// A human-readable label for the application.
    public var description: Swift.String?
    /// An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the application resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/a-9ZY8X7Wv6 or ID-a-9ZY8X7Wv6.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        applicationLogOutputUri: Swift.String? = nil,
        applicationLogPaths: [Swift.String]? = nil,
        description: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.applicationLogOutputUri = applicationLogOutputUri
        self.applicationLogPaths = applicationLogPaths
        self.description = description
        self.identifier = identifier
    }
}

public struct UpdateApplicationOutput: Swift.Sendable {
    /// An Amazon S3 URI to a bucket where you would like Amazon GameLift Streams to save application logs. Required if you specify one or more ApplicationLogPaths.
    public var applicationLogOutputUri: Swift.String?
    /// Locations of log files that your content generates during a stream session. Amazon GameLift Streams uploads log files to the Amazon S3 bucket that you specify in ApplicationLogOutputUri at the end of a stream session. To retrieve stored log files, call [GetStreamSession](https://docs.aws.amazon.com/gameliftstreams/latest/apireference/API_GetStreamSession.html) and get the LogFileLocationUri.
    public var applicationLogPaths: [Swift.String]?
    /// The original Amazon S3 location of uploaded stream content for the application.
    public var applicationSourceUri: Swift.String?
    /// An Amazon Resource Name (ARN) that's assigned to an application resource and uniquely identifies it across all Amazon Web Services Regions. Format is arn:aws:gameliftstreams:[AWS Region]:[AWS account]:application/[resource ID].
    /// This member is required.
    public var arn: Swift.String?
    /// A set of stream groups that this application is associated with. You can use any of these stream groups to stream your application. This value is a set of [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) that uniquely identify stream group resources. Format example: arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/sg-1AB2C3De4.
    public var associatedStreamGroups: [Swift.String]?
    /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
    public var createdAt: Foundation.Date?
    /// A human-readable label for the application. You can edit this value.
    public var description: Swift.String?
    /// The path and file name of the executable file that launches the content for streaming.
    public var executablePath: Swift.String?
    /// An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the application resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/a-9ZY8X7Wv6 or ID-a-9ZY8X7Wv6.
    public var id: Swift.String?
    /// A timestamp that indicates when this resource was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
    public var lastUpdatedAt: Foundation.Date?
    /// A set of replication statuses for each location.
    public var replicationStatuses: [GameLiftStreamsClientTypes.ReplicationStatus]?
    /// Configuration settings that identify the operating system for an application resource. This can also include a compatibility layer and other drivers. A runtime environment can be one of the following:
    ///
    /// * For Linux applications
    ///
    /// * Ubuntu 22.04 LTS (Type=UBUNTU, Version=22_04_LTS)
    ///
    ///
    ///
    ///
    /// * For Windows applications
    ///
    /// * Microsoft Windows Server 2022 Base (Type=WINDOWS, Version=2022)
    ///
    /// * Proton 8.0-5 (Type=PROTON, Version=20241007)
    ///
    /// * Proton 8.0-2c (Type=PROTON, Version=20230704)
    public var runtimeEnvironment: GameLiftStreamsClientTypes.RuntimeEnvironment?
    /// The current status of the application resource. Possible statuses include the following:
    ///
    /// * INITIALIZED: Amazon GameLift Streams has received the request and is initiating the work flow to create an application.
    ///
    /// * PROCESSING: The create application work flow is in process. Amazon GameLift Streams is copying the content and caching for future deployment in a stream group.
    ///
    /// * READY: The application is ready to deploy in a stream group.
    ///
    /// * ERROR: An error occurred when setting up the application. See StatusReason for more information.
    ///
    /// * DELETING: Amazon GameLift Streams is in the process of deleting the application.
    public var status: GameLiftStreamsClientTypes.ApplicationStatus?
    /// A short description of the status reason when the application is in ERROR status.
    public var statusReason: GameLiftStreamsClientTypes.ApplicationStatusReason?

    public init(
        applicationLogOutputUri: Swift.String? = nil,
        applicationLogPaths: [Swift.String]? = nil,
        applicationSourceUri: Swift.String? = nil,
        arn: Swift.String? = nil,
        associatedStreamGroups: [Swift.String]? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        executablePath: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        replicationStatuses: [GameLiftStreamsClientTypes.ReplicationStatus]? = nil,
        runtimeEnvironment: GameLiftStreamsClientTypes.RuntimeEnvironment? = nil,
        status: GameLiftStreamsClientTypes.ApplicationStatus? = nil,
        statusReason: GameLiftStreamsClientTypes.ApplicationStatusReason? = nil
    ) {
        self.applicationLogOutputUri = applicationLogOutputUri
        self.applicationLogPaths = applicationLogPaths
        self.applicationSourceUri = applicationSourceUri
        self.arn = arn
        self.associatedStreamGroups = associatedStreamGroups
        self.createdAt = createdAt
        self.description = description
        self.executablePath = executablePath
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.replicationStatuses = replicationStatuses
        self.runtimeEnvironment = runtimeEnvironment
        self.status = status
        self.statusReason = statusReason
    }
}

public struct AssociateApplicationsInput: Swift.Sendable {
    /// A set of applications to associate with the stream group. This value is a set of either [Amazon Resource Names (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or IDs that uniquely identify application resources. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/a-9ZY8X7Wv6 or ID-a-9ZY8X7Wv6.
    /// This member is required.
    public var applicationIdentifiers: [Swift.String]?
    /// A stream group to associate to the applications. This value is a [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/sg-1AB2C3De4 or ID-sg-1AB2C3De4.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        applicationIdentifiers: [Swift.String]? = nil,
        identifier: Swift.String? = nil
    ) {
        self.applicationIdentifiers = applicationIdentifiers
        self.identifier = identifier
    }
}

public struct AssociateApplicationsOutput: Swift.Sendable {
    /// A set of applications that are associated to the stream group. This value is a set of either [Amazon Resource Names (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or IDs that uniquely identify application resources. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/a-9ZY8X7Wv6 or ID-a-9ZY8X7Wv6.
    public var applicationArns: [Swift.String]?
    /// A stream group that is associated to the applications. This value is a [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/sg-1AB2C3De4 or ID-sg-1AB2C3De4.
    public var arn: Swift.String?

    public init(
        applicationArns: [Swift.String]? = nil,
        arn: Swift.String? = nil
    ) {
        self.applicationArns = applicationArns
        self.arn = arn
    }
}

extension GameLiftStreamsClientTypes {

    public enum StreamClass: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gen4nHigh
        case gen4nUltra
        case gen4nWin2022
        case gen5nHigh
        case gen5nUltra
        case gen5nWin2022
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamClass] {
            return [
                .gen4nHigh,
                .gen4nUltra,
                .gen4nWin2022,
                .gen5nHigh,
                .gen5nUltra,
                .gen5nWin2022
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gen4nHigh: return "gen4n_high"
            case .gen4nUltra: return "gen4n_ultra"
            case .gen4nWin2022: return "gen4n_win2022"
            case .gen5nHigh: return "gen5n_high"
            case .gen5nUltra: return "gen5n_ultra"
            case .gen5nWin2022: return "gen5n_win2022"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateStreamGroupInput: Swift.Sendable {
    /// A unique identifier that represents a client request. The request is idempotent, which ensures that an API request completes only once. When users send a request, Amazon GameLift Streams automatically populates this field.
    public var clientToken: Swift.String?
    /// The unique identifier of the Amazon GameLift Streams application that you want to associate to a stream group as the default application. The application must be in READY status. By setting the default application identifier, you will optimize startup performance of this application in your stream group. Once set, this application cannot be disassociated from the stream group, unlike applications that are associated using AssociateApplications. If not set when creating a stream group, you will need to call AssociateApplications later, before you can start streaming.
    public var defaultApplicationIdentifier: Swift.String?
    /// A descriptive label for the stream group.
    /// This member is required.
    public var description: Swift.String?
    /// A set of one or more locations and the streaming capacity for each location.
    public var locationConfigurations: [GameLiftStreamsClientTypes.LocationConfiguration]?
    /// The target stream quality for sessions that are hosted in this stream group. Set a stream class that is appropriate to the type of content that you're streaming. Stream class determines the type of computing resources Amazon GameLift Streams uses and impacts the cost of streaming. The following options are available: A stream class can be one of the following:
    ///
    /// * gen5n_win2022 (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with Unreal Engine versions up through 5.4, 32 and 64-bit applications, and anti-cheat technology. Uses NVIDIA A10G Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM
    ///
    /// * Tenancy: Supports 1 concurrent stream session
    ///
    ///
    ///
    ///
    /// * gen5n_high (NVIDIA, high) Supports applications with moderate to high 3D scene complexity. Uses NVIDIA A10G Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 4 vCPUs, 16 GB RAM, 12 GB VRAM
    ///
    /// * Tenancy: Supports up to 2 concurrent stream sessions
    ///
    ///
    ///
    ///
    /// * gen5n_ultra (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Uses dedicated NVIDIA A10G Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM
    ///
    /// * Tenancy: Supports 1 concurrent stream session
    ///
    ///
    ///
    ///
    /// * gen4n_win2022 (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with Unreal Engine versions up through 5.4, 32 and 64-bit applications, and anti-cheat technology. Uses NVIDIA T4 Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM
    ///
    /// * Tenancy: Supports 1 concurrent stream session
    ///
    ///
    ///
    ///
    /// * gen4n_high (NVIDIA, high) Supports applications with moderate to high 3D scene complexity. Uses NVIDIA T4 Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 4 vCPUs, 16 GB RAM, 8 GB VRAM
    ///
    /// * Tenancy: Supports up to 2 concurrent stream sessions
    ///
    ///
    ///
    ///
    /// * gen4n_ultra (NVIDIA, ultra) Supports applications with high 3D scene complexity. Uses dedicated NVIDIA T4 Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM
    ///
    /// * Tenancy: Supports 1 concurrent stream session
    /// This member is required.
    public var streamClass: GameLiftStreamsClientTypes.StreamClass?
    /// A list of labels to assign to the new stream group resource. Tags are developer-defined key-value pairs. Tagging Amazon Web Services resources is useful for resource management, access management and cost allocation. See [ Tagging Amazon Web Services Resources](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html) in the Amazon Web Services General Reference. You can use [TagResource](https://docs.aws.amazon.com/gameliftstreams/latest/apireference/API_TagResource.html) to add tags, [UntagResource](https://docs.aws.amazon.com/gameliftstreams/latest/apireference/API_UntagResource.html) to remove tags, and [ListTagsForResource](https://docs.aws.amazon.com/gameliftstreams/latest/apireference/API_ListTagsForResource.html) to view tags on existing resources.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        defaultApplicationIdentifier: Swift.String? = nil,
        description: Swift.String? = nil,
        locationConfigurations: [GameLiftStreamsClientTypes.LocationConfiguration]? = nil,
        streamClass: GameLiftStreamsClientTypes.StreamClass? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.clientToken = clientToken
        self.defaultApplicationIdentifier = defaultApplicationIdentifier
        self.description = description
        self.locationConfigurations = locationConfigurations
        self.streamClass = streamClass
        self.tags = tags
    }
}

extension GameLiftStreamsClientTypes {

    /// Represents the default Amazon GameLift Streams application that a stream group hosts.
    public struct DefaultApplication: Swift.Sendable {
        /// An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) that uniquely identifies the application resource. Format example: arn:aws:gameliftstreams:us-west-2:123456789012:application/a-9ZY8X7Wv6.
        public var arn: Swift.String?
        /// An ID that uniquely identifies the application resource. For example: a-9ZY8X7Wv6.
        public var id: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil
        ) {
            self.arn = arn
            self.id = id
        }
    }
}

extension GameLiftStreamsClientTypes {

    public enum StreamGroupStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activating
        case active
        case activeWithErrors
        case deleting
        case error
        case updatingLocations
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamGroupStatus] {
            return [
                .activating,
                .active,
                .activeWithErrors,
                .deleting,
                .error,
                .updatingLocations
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .activeWithErrors: return "ACTIVE_WITH_ERRORS"
            case .deleting: return "DELETING"
            case .error: return "ERROR"
            case .updatingLocations: return "UPDATING_LOCATIONS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GameLiftStreamsClientTypes {

    public enum StreamGroupStatusReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internalError
        case noAvailableInstances
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamGroupStatusReason] {
            return [
                .internalError,
                .noAvailableInstances
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internalError: return "internalError"
            case .noAvailableInstances: return "noAvailableInstances"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateStreamGroupOutput: Swift.Sendable {
    /// An Amazon Resource Name (ARN) that is assigned to the stream group resource and that uniquely identifies the group across all Amazon Web Services Regions. Format is arn:aws:gameliftstreams:[AWS Region]:[AWS account]:streamgroup/[resource ID].
    /// This member is required.
    public var arn: Swift.String?
    /// A set of applications that this stream group is associated to. You can stream any of these applications by using this stream group. This value is a set of [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) that uniquely identify application resources. Format example: arn:aws:gameliftstreams:us-west-2:123456789012:application/a-9ZY8X7Wv6.
    public var associatedApplications: [Swift.String]?
    /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
    public var createdAt: Foundation.Date?
    /// The default Amazon GameLift Streams application that is associated with this stream group.
    public var defaultApplication: GameLiftStreamsClientTypes.DefaultApplication?
    /// A descriptive label for the stream group.
    public var description: Swift.String?
    /// A unique ID value that is assigned to the resource when it's created. Format example: sg-1AB2C3De4.
    public var id: Swift.String?
    /// A timestamp that indicates when this resource was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
    public var lastUpdatedAt: Foundation.Date?
    /// This value is the set of locations, including their name, current status, and capacities. A location can be in one of the following states:
    ///
    /// * ACTIVATING: Amazon GameLift Streams is preparing the location. You cannot stream from, scale the capacity of, or remove this location yet.
    ///
    /// * ACTIVE: The location is provisioned with initial capacity. You can now stream from, scale the capacity of, or remove this location.
    ///
    /// * ERROR: Amazon GameLift Streams failed to set up this location. The StatusReason field describes the error. You can remove this location and try to add it again.
    ///
    /// * REMOVING: Amazon GameLift Streams is working to remove this location. It releases all provisioned capacity for this location in this stream group.
    public var locationStates: [GameLiftStreamsClientTypes.LocationState]?
    /// The current status of the stream group resource. Possible statuses include the following:
    ///
    /// * ACTIVATING: The stream group is deploying and isn't ready to host streams.
    ///
    /// * ACTIVE: The stream group is ready to host streams.
    ///
    /// * ACTIVE_WITH_ERRORS: One or more locations in the stream group are in an error state. Verify the details of individual locations and remove any locations which are in error.
    ///
    /// * ERROR: An error occurred when the stream group deployed. See StatusReason for more information.
    ///
    /// * DELETING: Amazon GameLift Streams is in the process of deleting the stream group.
    ///
    /// * UPDATING_LOCATIONS: One or more locations in the stream group are in the process of updating (either activating or deleting).
    public var status: GameLiftStreamsClientTypes.StreamGroupStatus?
    /// A short description of the reason that the stream group is in ERROR status. The possible reasons can be one of the following:
    ///
    /// * internalError: The request can't process right now bcause of an issue with the server. Try again later. Reach out to the Amazon GameLift Streams team for more help.
    ///
    /// * noAvailableInstances: Amazon GameLift Streams does not currently have enough available On-Demand capacity to fulfill your request. Wait a few minutes and retry the request as capacity can shift frequently. You can also try to make the request using a different stream class or in another region.
    public var statusReason: GameLiftStreamsClientTypes.StreamGroupStatusReason?
    /// The target stream quality for the stream group. A stream class can be one of the following:
    ///
    /// * gen5n_win2022 (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with Unreal Engine versions up through 5.4, 32 and 64-bit applications, and anti-cheat technology. Uses NVIDIA A10G Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM
    ///
    /// * Tenancy: Supports 1 concurrent stream session
    ///
    ///
    ///
    ///
    /// * gen5n_high (NVIDIA, high) Supports applications with moderate to high 3D scene complexity. Uses NVIDIA A10G Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 4 vCPUs, 16 GB RAM, 12 GB VRAM
    ///
    /// * Tenancy: Supports up to 2 concurrent stream sessions
    ///
    ///
    ///
    ///
    /// * gen5n_ultra (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Uses dedicated NVIDIA A10G Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM
    ///
    /// * Tenancy: Supports 1 concurrent stream session
    ///
    ///
    ///
    ///
    /// * gen4n_win2022 (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with Unreal Engine versions up through 5.4, 32 and 64-bit applications, and anti-cheat technology. Uses NVIDIA T4 Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM
    ///
    /// * Tenancy: Supports 1 concurrent stream session
    ///
    ///
    ///
    ///
    /// * gen4n_high (NVIDIA, high) Supports applications with moderate to high 3D scene complexity. Uses NVIDIA T4 Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 4 vCPUs, 16 GB RAM, 8 GB VRAM
    ///
    /// * Tenancy: Supports up to 2 concurrent stream sessions
    ///
    ///
    ///
    ///
    /// * gen4n_ultra (NVIDIA, ultra) Supports applications with high 3D scene complexity. Uses dedicated NVIDIA T4 Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM
    ///
    /// * Tenancy: Supports 1 concurrent stream session
    public var streamClass: GameLiftStreamsClientTypes.StreamClass?

    public init(
        arn: Swift.String? = nil,
        associatedApplications: [Swift.String]? = nil,
        createdAt: Foundation.Date? = nil,
        defaultApplication: GameLiftStreamsClientTypes.DefaultApplication? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        locationStates: [GameLiftStreamsClientTypes.LocationState]? = nil,
        status: GameLiftStreamsClientTypes.StreamGroupStatus? = nil,
        statusReason: GameLiftStreamsClientTypes.StreamGroupStatusReason? = nil,
        streamClass: GameLiftStreamsClientTypes.StreamClass? = nil
    ) {
        self.arn = arn
        self.associatedApplications = associatedApplications
        self.createdAt = createdAt
        self.defaultApplication = defaultApplication
        self.description = description
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.locationStates = locationStates
        self.status = status
        self.statusReason = statusReason
        self.streamClass = streamClass
    }
}

public struct CreateStreamSessionConnectionInput: Swift.Sendable {
    /// A unique identifier that represents a client request. The request is idempotent, which ensures that an API request completes only once. When users send a request, Amazon GameLift Streams automatically populates this field.
    public var clientToken: Swift.String?
    /// [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/sg-1AB2C3De4 or ID-sg-1AB2C3De4. The stream group that you want to run this stream session with. The stream group must be in ACTIVE status and have idle stream capacity.
    /// This member is required.
    public var identifier: Swift.String?
    /// A WebRTC ICE offer string to use when initializing a WebRTC connection. The offer is a very long JSON string. Provide the string as a text value in quotes. The offer must be newly generated, not the same offer provided to StartStreamSession.
    /// This member is required.
    public var signalRequest: Swift.String?
    /// [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) that uniquely identifies the stream session resource. Format example: 1AB2C3De4. The stream session must be in PENDING_CLIENT_RECONNECTION or ACTIVE status.
    /// This member is required.
    public var streamSessionIdentifier: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        identifier: Swift.String? = nil,
        signalRequest: Swift.String? = nil,
        streamSessionIdentifier: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.identifier = identifier
        self.signalRequest = signalRequest
        self.streamSessionIdentifier = streamSessionIdentifier
    }
}

extension CreateStreamSessionConnectionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamSessionConnectionInput(clientToken: \(Swift.String(describing: clientToken)), identifier: \(Swift.String(describing: identifier)), streamSessionIdentifier: \(Swift.String(describing: streamSessionIdentifier)), signalRequest: \"CONTENT_REDACTED\")"}
}

public struct CreateStreamSessionConnectionOutput: Swift.Sendable {
    /// The WebRTC answer string that the stream server generates in response to the SignalRequest.
    public var signalResponse: Swift.String?

    public init(
        signalResponse: Swift.String? = nil
    ) {
        self.signalResponse = signalResponse
    }
}

extension CreateStreamSessionConnectionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateStreamSessionConnectionOutput(signalResponse: \"CONTENT_REDACTED\")"}
}

public struct DeleteStreamGroupInput: Swift.Sendable {
    /// The unique ID value of the stream group resource to delete. Format example: sg-1AB2C3De4.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct DisassociateApplicationsInput: Swift.Sendable {
    /// A set of applications that you want to disassociate from the stream group. This value is a set of either [Amazon Resource Names (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or IDs that uniquely identify application resources. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/a-9ZY8X7Wv6 or ID-a-9ZY8X7Wv6.
    /// This member is required.
    public var applicationIdentifiers: [Swift.String]?
    /// A stream group to disassociate these applications from. This value is an [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/sg-1AB2C3De4 or ID-sg-1AB2C3De4.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        applicationIdentifiers: [Swift.String]? = nil,
        identifier: Swift.String? = nil
    ) {
        self.applicationIdentifiers = applicationIdentifiers
        self.identifier = identifier
    }
}

public struct DisassociateApplicationsOutput: Swift.Sendable {
    /// A set of applications that are disassociated from this stream group. This value is a set of either [Amazon Resource Names (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or IDs that uniquely identify application resources. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/a-9ZY8X7Wv6 or ID-a-9ZY8X7Wv6.
    public var applicationArns: [Swift.String]?
    /// An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/sg-1AB2C3De4 or ID-sg-1AB2C3De4.
    public var arn: Swift.String?

    public init(
        applicationArns: [Swift.String]? = nil,
        arn: Swift.String? = nil
    ) {
        self.applicationArns = applicationArns
        self.arn = arn
    }
}

extension GameLiftStreamsClientTypes {

    public enum ExportFilesStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case pending
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportFilesStatus] {
            return [
                .failed,
                .pending,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GameLiftStreamsClientTypes {

    /// Provides details about the stream session's exported files.
    public struct ExportFilesMetadata: Swift.Sendable {
        /// The S3 bucket URI where Amazon GameLift Streams uploaded the set of compressed exported files for a stream session. Amazon GameLift Streams generates a ZIP file name based on the stream session metadata. Alternatively, you can provide a custom file name with a .zip file extension. Example 1: If you provide an S3 URI called s3://MyBucket/MyGame_Session1.zip, then Amazon GameLift Streams will save the files at that location. Example 2: If you provide an S3 URI called s3://MyBucket/MyGameSessions_ExportedFiles/, then Amazon GameLift Streams will save the files at s3://MyBucket/MyGameSessions_ExportedFiles/YYYYMMDD-HHMMSS-appId-sg-Id-sessionId.zip or another similar name.
        public var outputUri: Swift.String?
        /// The result of the [ExportStreamSessionFiles](https://docs.aws.amazon.com/gameliftstreams/latest/apireference/API_ExportStreamSessionFiles.html) operation.
        public var status: GameLiftStreamsClientTypes.ExportFilesStatus?
        /// A short description of the reason the export is in FAILED status.
        public var statusReason: Swift.String?

        public init(
            outputUri: Swift.String? = nil,
            status: GameLiftStreamsClientTypes.ExportFilesStatus? = nil,
            statusReason: Swift.String? = nil
        ) {
            self.outputUri = outputUri
            self.status = status
            self.statusReason = statusReason
        }
    }
}

public struct ExportStreamSessionFilesInput: Swift.Sendable {
    /// An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/sg-1AB2C3De4 or ID-sg-1AB2C3De4.
    /// This member is required.
    public var identifier: Swift.String?
    /// The S3 bucket URI where Amazon GameLift Streams uploads the set of compressed exported files for this stream session. Amazon GameLift Streams generates a ZIP file name based on the stream session metadata. Alternatively, you can provide a custom file name with a .zip file extension. Example 1: If you provide an S3 URI called s3://MyBucket/MyGame_Session1.zip, then Amazon GameLift Streams will save the files at that location. Example 2: If you provide an S3 URI called s3://MyBucket/MyGameSessions_ExportedFiles/, then Amazon GameLift Streams will save the files at s3://MyBucket/MyGameSessions_ExportedFiles/YYYYMMDD-HHMMSS-appId-sg-Id-sessionId.zip or another similar name.
    /// This member is required.
    public var outputUri: Swift.String?
    /// An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the stream session resource. Format example: 1AB2C3De4.
    /// This member is required.
    public var streamSessionIdentifier: Swift.String?

    public init(
        identifier: Swift.String? = nil,
        outputUri: Swift.String? = nil,
        streamSessionIdentifier: Swift.String? = nil
    ) {
        self.identifier = identifier
        self.outputUri = outputUri
        self.streamSessionIdentifier = streamSessionIdentifier
    }
}

public struct ExportStreamSessionFilesOutput: Swift.Sendable {

    public init() { }
}

public struct GetStreamSessionInput: Swift.Sendable {
    /// The stream group that runs this stream session. This value is an [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/sg-1AB2C3De4 or ID-sg-1AB2C3De4.
    /// This member is required.
    public var identifier: Swift.String?
    /// An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) that uniquely identifies the stream session resource. Format example: 1AB2C3De4.
    /// This member is required.
    public var streamSessionIdentifier: Swift.String?

    public init(
        identifier: Swift.String? = nil,
        streamSessionIdentifier: Swift.String? = nil
    ) {
        self.identifier = identifier
        self.streamSessionIdentifier = streamSessionIdentifier
    }
}

extension GameLiftStreamsClientTypes {

    public enum ModelProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case webrtc
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .webrtc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .webrtc: return "WebRTC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GameLiftStreamsClientTypes {

    public enum StreamSessionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activating
        case active
        case connected
        case error
        case pendingClientReconnection
        case reconnecting
        case terminated
        case terminating
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamSessionStatus] {
            return [
                .activating,
                .active,
                .connected,
                .error,
                .pendingClientReconnection,
                .reconnecting,
                .terminated,
                .terminating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .connected: return "CONNECTED"
            case .error: return "ERROR"
            case .pendingClientReconnection: return "PENDING_CLIENT_RECONNECTION"
            case .reconnecting: return "RECONNECTING"
            case .terminated: return "TERMINATED"
            case .terminating: return "TERMINATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GameLiftStreamsClientTypes {

    public enum StreamSessionStatusReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case appLogS3DestinationError
        case internalError
        case invalidSignalRequest
        case placementTimeout
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamSessionStatusReason] {
            return [
                .appLogS3DestinationError,
                .internalError,
                .invalidSignalRequest,
                .placementTimeout
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .appLogS3DestinationError: return "applicationLogS3DestinationError"
            case .internalError: return "internalError"
            case .invalidSignalRequest: return "invalidSignalRequest"
            case .placementTimeout: return "placementTimeout"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetStreamSessionOutput: Swift.Sendable {
    /// A set of options that you can use to control the stream session runtime environment, expressed as a set of key-value pairs. You can use this to configure the application or stream session details. You can also provide custom environment variables that Amazon GameLift Streams passes to your game client. If you want to debug your application with environment variables, we recommend that you do so in a local environment outside of Amazon GameLift Streams. For more information, refer to the Compatibility Guidance in the troubleshooting section of the Developer Guide. AdditionalEnvironmentVariables and AdditionalLaunchArgs have similar purposes. AdditionalEnvironmentVariables passes data using environment variables; while AdditionalLaunchArgs passes data using command-line arguments.
    public var additionalEnvironmentVariables: [Swift.String: Swift.String]?
    /// A list of CLI arguments that are sent to the streaming server when a stream session launches. You can use this to configure the application or stream session details. You can also provide custom arguments that Amazon GameLift Streams passes to your game client. AdditionalEnvironmentVariables and AdditionalLaunchArgs have similar purposes. AdditionalEnvironmentVariables passes data using environment variables; while AdditionalLaunchArgs passes data using command-line arguments.
    public var additionalLaunchArgs: [Swift.String]?
    /// The application streaming in this session. This value is an [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) that uniquely identifies the application resource. Format example: arn:aws:gameliftstreams:us-west-2:123456789012:application/a-9ZY8X7Wv6.
    public var applicationArn: Swift.String?
    /// The Amazon Resource Name (ARN) assigned to the stream session resource. When combined with the stream group ARN, this value uniquely identifies it across all Amazon Web Services Regions. Format is arn:aws:gameliftstreams:[AWS Region]:[AWS account]:streamsession/[resource ID].
    public var arn: Swift.String?
    /// The maximum length of time (in seconds) that Amazon GameLift Streams keeps the stream session open. At this point, Amazon GameLift Streams ends the stream session regardless of any existing client connections.
    public var connectionTimeoutSeconds: Swift.Int?
    /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
    public var createdAt: Foundation.Date?
    /// A human-readable label for the stream session. You can update this value at any time.
    public var description: Swift.String?
    /// Provides details about the stream session's exported files.
    public var exportFilesMetadata: GameLiftStreamsClientTypes.ExportFilesMetadata?
    /// A timestamp that indicates when this resource was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
    public var lastUpdatedAt: Foundation.Date?
    /// The location where Amazon GameLift Streams is hosting the stream session. A location's name. For example, us-east-1. For a complete list of locations that Amazon GameLift Streams supports, refer to [Regions and quotas](https://docs.aws.amazon.com/gameliftstreams/latest/developerguide/regions-quotas.html) in the Amazon GameLift Streams Developer Guide.
    public var location: Swift.String?
    /// Access location for log files that your content generates during a stream session. These log files are uploaded to cloud storage location at the end of a stream session. The Amazon GameLift Streams application resource defines which log files to upload.
    public var logFileLocationUri: Swift.String?
    /// The data transfer protocol in use with the stream session.
    public var `protocol`: GameLiftStreamsClientTypes.ModelProtocol?
    /// The length of time that Amazon GameLift Streams keeps the game session open.
    public var sessionLengthSeconds: Swift.Int?
    /// The WebRTC ICE offer string that a client generates to initiate a connection to the stream session.
    public var signalRequest: Swift.String?
    /// The WebRTC answer string that the stream server generates in response to the SignalRequest.
    public var signalResponse: Swift.String?
    /// The current status of the stream session. A stream session can host clients when in ACTIVE status.
    public var status: GameLiftStreamsClientTypes.StreamSessionStatus?
    /// A short description of the reason the stream session is in ERROR status.
    public var statusReason: GameLiftStreamsClientTypes.StreamSessionStatusReason?
    /// The unique identifier for the Amazon GameLift Streams stream group that is hosting the stream session.
    public var streamGroupId: Swift.String?
    /// An opaque, unique identifier for an end-user, defined by the developer.
    public var userId: Swift.String?
    /// The URL of an S3 bucket that stores Amazon GameLift Streams WebSDK files. The URL is used to establish connection with the client.
    public var webSdkProtocolUrl: Swift.String?

    public init(
        additionalEnvironmentVariables: [Swift.String: Swift.String]? = nil,
        additionalLaunchArgs: [Swift.String]? = nil,
        applicationArn: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectionTimeoutSeconds: Swift.Int? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        exportFilesMetadata: GameLiftStreamsClientTypes.ExportFilesMetadata? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        location: Swift.String? = nil,
        logFileLocationUri: Swift.String? = nil,
        `protocol`: GameLiftStreamsClientTypes.ModelProtocol? = nil,
        sessionLengthSeconds: Swift.Int? = nil,
        signalRequest: Swift.String? = nil,
        signalResponse: Swift.String? = nil,
        status: GameLiftStreamsClientTypes.StreamSessionStatus? = nil,
        statusReason: GameLiftStreamsClientTypes.StreamSessionStatusReason? = nil,
        streamGroupId: Swift.String? = nil,
        userId: Swift.String? = nil,
        webSdkProtocolUrl: Swift.String? = nil
    ) {
        self.additionalEnvironmentVariables = additionalEnvironmentVariables
        self.additionalLaunchArgs = additionalLaunchArgs
        self.applicationArn = applicationArn
        self.arn = arn
        self.connectionTimeoutSeconds = connectionTimeoutSeconds
        self.createdAt = createdAt
        self.description = description
        self.exportFilesMetadata = exportFilesMetadata
        self.lastUpdatedAt = lastUpdatedAt
        self.location = location
        self.logFileLocationUri = logFileLocationUri
        self.`protocol` = `protocol`
        self.sessionLengthSeconds = sessionLengthSeconds
        self.signalRequest = signalRequest
        self.signalResponse = signalResponse
        self.status = status
        self.statusReason = statusReason
        self.streamGroupId = streamGroupId
        self.userId = userId
        self.webSdkProtocolUrl = webSdkProtocolUrl
    }
}

extension GetStreamSessionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetStreamSessionOutput(protocol: \(Swift.String(describing: `protocol`)), additionalEnvironmentVariables: \(Swift.String(describing: additionalEnvironmentVariables)), additionalLaunchArgs: \(Swift.String(describing: additionalLaunchArgs)), applicationArn: \(Swift.String(describing: applicationArn)), arn: \(Swift.String(describing: arn)), connectionTimeoutSeconds: \(Swift.String(describing: connectionTimeoutSeconds)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), exportFilesMetadata: \(Swift.String(describing: exportFilesMetadata)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), location: \(Swift.String(describing: location)), logFileLocationUri: \(Swift.String(describing: logFileLocationUri)), sessionLengthSeconds: \(Swift.String(describing: sessionLengthSeconds)), status: \(Swift.String(describing: status)), statusReason: \(Swift.String(describing: statusReason)), streamGroupId: \(Swift.String(describing: streamGroupId)), userId: \(Swift.String(describing: userId)), webSdkProtocolUrl: \(Swift.String(describing: webSdkProtocolUrl)), signalRequest: \"CONTENT_REDACTED\", signalResponse: \"CONTENT_REDACTED\")"}
}

public struct ListStreamSessionsInput: Swift.Sendable {
    /// Filter by the exported files status. You can specify one status in each request to retrieve only sessions that currently have that exported files status. Exported files can be in one of the following states:
    ///
    /// * SUCCEEDED: The exported files are successfully stored in S3 bucket.
    ///
    /// * FAILED: The session ended but Amazon GameLift Streams couldn't collect and upload the to S3.
    ///
    /// * PENDING: Either the stream session is still in progress, or uploading the exported files to the S3 bucket is in progress.
    public var exportFilesStatus: GameLiftStreamsClientTypes.ExportFilesStatus?
    /// The unique identifier of a Amazon GameLift Streams stream group to retrieve the stream session for. You can use either the stream group ID or the Amazon Resource Name (ARN).
    /// This member is required.
    public var identifier: Swift.String?
    /// The number of results to return. Use this parameter with NextToken to return results in sequential pages. Default value is 25.
    public var maxResults: Swift.Int?
    /// The token that marks the start of the next set of results. Use this token when you retrieve results as sequential pages. To get the first page of results, omit a token value. To get the remaining pages, provide the token returned with the previous result set.
    public var nextToken: Swift.String?
    /// Filter by the stream session status. You can specify one status in each request to retrieve only sessions that are currently in that status.
    public var status: GameLiftStreamsClientTypes.StreamSessionStatus?

    public init(
        exportFilesStatus: GameLiftStreamsClientTypes.ExportFilesStatus? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: GameLiftStreamsClientTypes.StreamSessionStatus? = nil
    ) {
        self.exportFilesStatus = exportFilesStatus
        self.identifier = identifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension GameLiftStreamsClientTypes {

    /// Describes a Amazon GameLift Streams stream session. To retrieve additional details for the stream session, call [GetStreamSession](https://docs.aws.amazon.com/gameliftstreams/latest/apireference/API_GetStreamSession.html).
    public struct StreamSessionSummary: Swift.Sendable {
        /// An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the application resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/a-9ZY8X7Wv6 or ID-a-9ZY8X7Wv6.
        public var applicationArn: Swift.String?
        /// An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) that uniquely identifies the stream session resource. Format example: 1AB2C3De4. .
        public var arn: Swift.String?
        /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public var createdAt: Foundation.Date?
        /// Provides details about the stream session's exported files.
        public var exportFilesMetadata: GameLiftStreamsClientTypes.ExportFilesMetadata?
        /// A timestamp that indicates when this resource was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public var lastUpdatedAt: Foundation.Date?
        /// The location where Amazon GameLift Streams is hosting the stream session. A location's name. For example, us-east-1. For a complete list of locations that Amazon GameLift Streams supports, refer to [Regions and quotas](https://docs.aws.amazon.com/gameliftstreams/latest/developerguide/regions-quotas.html) in the Amazon GameLift Streams Developer Guide.
        public var location: Swift.String?
        /// The data transfer protocol in use with the stream session.
        public var `protocol`: GameLiftStreamsClientTypes.ModelProtocol?
        /// The current status of the stream session resource. Possible statuses include the following:
        ///
        /// * ACTIVATING: The stream session is starting and preparing to stream.
        ///
        /// * ACTIVE: The stream session is ready to accept client connections.
        ///
        /// * CONNECTED: The stream session has a connected client.
        ///
        /// * PENDING_CLIENT_RECONNECTION: A client has recently disconnected, and the stream session is waiting for the client to reconnect. After a short time, if the client doesn't reconnect, the stream session status transitions to TERMINATED.
        ///
        /// * TERMINATING: The stream session is ending.
        ///
        /// * TERMINATED: The stream session has ended.
        ///
        /// * ERROR: The stream session failed to activate.
        public var status: GameLiftStreamsClientTypes.StreamSessionStatus?
        /// An opaque, unique identifier for an end-user, defined by the developer.
        public var userId: Swift.String?

        public init(
            applicationArn: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            exportFilesMetadata: GameLiftStreamsClientTypes.ExportFilesMetadata? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            location: Swift.String? = nil,
            `protocol`: GameLiftStreamsClientTypes.ModelProtocol? = nil,
            status: GameLiftStreamsClientTypes.StreamSessionStatus? = nil,
            userId: Swift.String? = nil
        ) {
            self.applicationArn = applicationArn
            self.arn = arn
            self.createdAt = createdAt
            self.exportFilesMetadata = exportFilesMetadata
            self.lastUpdatedAt = lastUpdatedAt
            self.location = location
            self.`protocol` = `protocol`
            self.status = status
            self.userId = userId
        }
    }
}

public struct ListStreamSessionsOutput: Swift.Sendable {
    /// A collection of Amazon GameLift Streams stream sessions that are associated with a stream group and returned in response to a list request. Each item includes stream session metadata and status.
    public var items: [GameLiftStreamsClientTypes.StreamSessionSummary]?
    /// A token that marks the start of the next sequential page of results. If an operation doesn't return a token, you've reached the end of the list.
    public var nextToken: Swift.String?

    public init(
        items: [GameLiftStreamsClientTypes.StreamSessionSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListStreamSessionsByAccountInput: Swift.Sendable {
    /// Filter by the exported files status. You can specify one status in each request to retrieve only sessions that currently have that exported files status.
    public var exportFilesStatus: GameLiftStreamsClientTypes.ExportFilesStatus?
    /// The number of results to return. Use this parameter with NextToken to return results in sequential pages. Default value is 25.
    public var maxResults: Swift.Int?
    /// The token that marks the start of the next set of results. Use this token when you retrieve results as sequential pages. To get the first page of results, omit a token value. To get the remaining pages, provide the token returned with the previous result set.
    public var nextToken: Swift.String?
    /// Filter by the stream session status. You can specify one status in each request to retrieve only sessions that are currently in that status.
    public var status: GameLiftStreamsClientTypes.StreamSessionStatus?

    public init(
        exportFilesStatus: GameLiftStreamsClientTypes.ExportFilesStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: GameLiftStreamsClientTypes.StreamSessionStatus? = nil
    ) {
        self.exportFilesStatus = exportFilesStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

public struct ListStreamSessionsByAccountOutput: Swift.Sendable {
    /// A collection of Amazon GameLift Streams stream sessions that are associated with a stream group and returned in response to a list request. Each item includes stream session metadata and status.
    public var items: [GameLiftStreamsClientTypes.StreamSessionSummary]?
    /// A token that marks the start of the next sequential page of results. If an operation doesn't return a token, you've reached the end of the list.
    public var nextToken: Swift.String?

    public init(
        items: [GameLiftStreamsClientTypes.StreamSessionSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ([Amazon Resource Name (ARN)](https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html) that you want to retrieve tags for. To get a Amazon GameLift Streams resource ARN, call a List or Get operation for the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A collection of tags that have been assigned to the specified resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

public struct RemoveStreamGroupLocationsInput: Swift.Sendable {
    /// A stream group to remove the specified locations from. This value is a Amazon Resource Name (ARN) that uniquely identifies the stream group resource. Format example: sg-1AB2C3De4.
    /// This member is required.
    public var identifier: Swift.String?
    /// A set of locations to remove this stream group. A set of location names. For example, us-east-1. For a complete list of locations that Amazon GameLift Streams supports, refer to [Regions and quotas](https://docs.aws.amazon.com/gameliftstreams/latest/developerguide/regions-quotas.html) in the Amazon GameLift Streams Developer Guide.
    /// This member is required.
    public var locations: [Swift.String]?

    public init(
        identifier: Swift.String? = nil,
        locations: [Swift.String]? = nil
    ) {
        self.identifier = identifier
        self.locations = locations
    }
}

public struct StartStreamSessionInput: Swift.Sendable {
    /// A set of options that you can use to control the stream session runtime environment, expressed as a set of key-value pairs. You can use this to configure the application or stream session details. You can also provide custom environment variables that Amazon GameLift Streams passes to your game client. If you want to debug your application with environment variables, we recommend that you do so in a local environment outside of Amazon GameLift Streams. For more information, refer to the Compatibility Guidance in the troubleshooting section of the Developer Guide. AdditionalEnvironmentVariables and AdditionalLaunchArgs have similar purposes. AdditionalEnvironmentVariables passes data using environment variables; while AdditionalLaunchArgs passes data using command-line arguments.
    public var additionalEnvironmentVariables: [Swift.String: Swift.String]?
    /// A list of CLI arguments that are sent to the streaming server when a stream session launches. You can use this to configure the application or stream session details. You can also provide custom arguments that Amazon GameLift Streams passes to your game client. AdditionalEnvironmentVariables and AdditionalLaunchArgs have similar purposes. AdditionalEnvironmentVariables passes data using environment variables; while AdditionalLaunchArgs passes data using command-line arguments.
    public var additionalLaunchArgs: [Swift.String]?
    /// An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the application resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:application/a-9ZY8X7Wv6 or ID-a-9ZY8X7Wv6.
    /// This member is required.
    public var applicationIdentifier: Swift.String?
    /// A unique identifier that represents a client request. The request is idempotent, which ensures that an API request completes only once. When users send a request, Amazon GameLift Streams automatically populates this field.
    public var clientToken: Swift.String?
    /// Length of time (in seconds) that Amazon GameLift Streams should wait for a client to connect to the stream session. This time span starts when the stream session reaches ACTIVE status. If no client connects before the timeout, Amazon GameLift Streams stops the stream session with status of TERMINATED. Default value is 120.
    public var connectionTimeoutSeconds: Swift.Int?
    /// A human-readable label for the stream session. You can update this value later.
    public var description: Swift.String?
    /// The stream group to run this stream session with. This value is an [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/sg-1AB2C3De4 or ID-sg-1AB2C3De4.
    /// This member is required.
    public var identifier: Swift.String?
    /// A list of locations, in order of priority, where you want Amazon GameLift Streams to start a stream from. Amazon GameLift Streams selects the location with the next available capacity to start a single stream session in. If this value is empty, Amazon GameLift Streams attempts to start a stream session in the primary location. This value is A set of location names. For example, us-east-1. For a complete list of locations that Amazon GameLift Streams supports, refer to [Regions and quotas](https://docs.aws.amazon.com/gameliftstreams/latest/developerguide/regions-quotas.html) in the Amazon GameLift Streams Developer Guide.
    public var locations: [Swift.String]?
    /// The data transport protocol to use for the stream session.
    /// This member is required.
    public var `protocol`: GameLiftStreamsClientTypes.ModelProtocol?
    /// The maximum length of time (in seconds) that Amazon GameLift Streams keeps the stream session open. At this point, Amazon GameLift Streams ends the stream session regardless of any existing client connections. Default value is 43200.
    public var sessionLengthSeconds: Swift.Int?
    /// A WebRTC ICE offer string to use when initializing a WebRTC connection. The offer is a very long JSON string. Provide the string as a text value in quotes.
    /// This member is required.
    public var signalRequest: Swift.String?
    /// An opaque, unique identifier for an end-user, defined by the developer.
    public var userId: Swift.String?

    public init(
        additionalEnvironmentVariables: [Swift.String: Swift.String]? = nil,
        additionalLaunchArgs: [Swift.String]? = nil,
        applicationIdentifier: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        connectionTimeoutSeconds: Swift.Int? = nil,
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        locations: [Swift.String]? = nil,
        `protocol`: GameLiftStreamsClientTypes.ModelProtocol? = nil,
        sessionLengthSeconds: Swift.Int? = nil,
        signalRequest: Swift.String? = nil,
        userId: Swift.String? = nil
    ) {
        self.additionalEnvironmentVariables = additionalEnvironmentVariables
        self.additionalLaunchArgs = additionalLaunchArgs
        self.applicationIdentifier = applicationIdentifier
        self.clientToken = clientToken
        self.connectionTimeoutSeconds = connectionTimeoutSeconds
        self.description = description
        self.identifier = identifier
        self.locations = locations
        self.`protocol` = `protocol`
        self.sessionLengthSeconds = sessionLengthSeconds
        self.signalRequest = signalRequest
        self.userId = userId
    }
}

extension StartStreamSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartStreamSessionInput(protocol: \(Swift.String(describing: `protocol`)), additionalEnvironmentVariables: \(Swift.String(describing: additionalEnvironmentVariables)), additionalLaunchArgs: \(Swift.String(describing: additionalLaunchArgs)), applicationIdentifier: \(Swift.String(describing: applicationIdentifier)), clientToken: \(Swift.String(describing: clientToken)), connectionTimeoutSeconds: \(Swift.String(describing: connectionTimeoutSeconds)), description: \(Swift.String(describing: description)), identifier: \(Swift.String(describing: identifier)), locations: \(Swift.String(describing: locations)), sessionLengthSeconds: \(Swift.String(describing: sessionLengthSeconds)), userId: \(Swift.String(describing: userId)), signalRequest: \"CONTENT_REDACTED\")"}
}

public struct StartStreamSessionOutput: Swift.Sendable {
    /// A set of options that you can use to control the stream session runtime environment, expressed as a set of key-value pairs. You can use this to configure the application or stream session details. You can also provide custom environment variables that Amazon GameLift Streams passes to your game client. If you want to debug your application with environment variables, we recommend that you do so in a local environment outside of Amazon GameLift Streams. For more information, refer to the Compatibility Guidance in the troubleshooting section of the Developer Guide. AdditionalEnvironmentVariables and AdditionalLaunchArgs have similar purposes. AdditionalEnvironmentVariables passes data using environment variables; while AdditionalLaunchArgs passes data using command-line arguments.
    public var additionalEnvironmentVariables: [Swift.String: Swift.String]?
    /// A list of CLI arguments that are sent to the streaming server when a stream session launches. You can use this to configure the application or stream session details. You can also provide custom arguments that Amazon GameLift Streams passes to your game client. AdditionalEnvironmentVariables and AdditionalLaunchArgs have similar purposes. AdditionalEnvironmentVariables passes data using environment variables; while AdditionalLaunchArgs passes data using command-line arguments.
    public var additionalLaunchArgs: [Swift.String]?
    /// An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) that uniquely identifies the application resource. Format example: arn:aws:gameliftstreams:us-west-2:123456789012:application/a-9ZY8X7Wv6.
    public var applicationArn: Swift.String?
    /// The Amazon Resource Name (ARN) assigned to the stream session resource. When combined with the stream group ARN, this value uniquely identifies it across all Amazon Web Services Regions. Format is arn:aws:gameliftstreams:[AWS Region]:[AWS account]:streamsession/[resource ID].
    public var arn: Swift.String?
    /// The maximum length of time (in seconds) that Amazon GameLift Streams keeps the stream session open. At this point, Amazon GameLift Streams ends the stream session regardless of any existing client connections.
    public var connectionTimeoutSeconds: Swift.Int?
    /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
    public var createdAt: Foundation.Date?
    /// A human-readable label for the stream session. You can update this value at any time.
    public var description: Swift.String?
    /// Provides details about the stream session's exported files.
    public var exportFilesMetadata: GameLiftStreamsClientTypes.ExportFilesMetadata?
    /// A timestamp that indicates when this resource was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
    public var lastUpdatedAt: Foundation.Date?
    /// The location where Amazon GameLift Streams is streaming your application from. A location's name. For example, us-east-1. For a complete list of locations that Amazon GameLift Streams supports, refer to [Regions and quotas](https://docs.aws.amazon.com/gameliftstreams/latest/developerguide/regions-quotas.html) in the Amazon GameLift Streams Developer Guide.
    public var location: Swift.String?
    /// Access location for log files that your content generates during a stream session. These log files are uploaded to cloud storage location at the end of a stream session. The Amazon GameLift Streams application resource defines which log files to upload.
    public var logFileLocationUri: Swift.String?
    /// The data transfer protocol in use with the stream session.
    public var `protocol`: GameLiftStreamsClientTypes.ModelProtocol?
    /// The length of time that Amazon GameLift Streams keeps the game session open.
    public var sessionLengthSeconds: Swift.Int?
    /// The WebRTC ICE offer string that a client generates to initiate a connection to the stream session.
    public var signalRequest: Swift.String?
    /// The WebRTC answer string that the stream server generates in response to the SignalRequest.
    public var signalResponse: Swift.String?
    /// The current status of the stream session. A stream session can host clients when in ACTIVE status.
    public var status: GameLiftStreamsClientTypes.StreamSessionStatus?
    /// A short description of the reason the stream session is in ERROR status.
    public var statusReason: GameLiftStreamsClientTypes.StreamSessionStatusReason?
    /// The unique identifier for the Amazon GameLift Streams stream group that is hosting the stream session.
    public var streamGroupId: Swift.String?
    /// An opaque, unique identifier for an end-user, defined by the developer.
    public var userId: Swift.String?
    /// The URL of an S3 bucket that stores Amazon GameLift Streams WebSDK files. The URL is used to establish connection with the client.
    public var webSdkProtocolUrl: Swift.String?

    public init(
        additionalEnvironmentVariables: [Swift.String: Swift.String]? = nil,
        additionalLaunchArgs: [Swift.String]? = nil,
        applicationArn: Swift.String? = nil,
        arn: Swift.String? = nil,
        connectionTimeoutSeconds: Swift.Int? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        exportFilesMetadata: GameLiftStreamsClientTypes.ExportFilesMetadata? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        location: Swift.String? = nil,
        logFileLocationUri: Swift.String? = nil,
        `protocol`: GameLiftStreamsClientTypes.ModelProtocol? = nil,
        sessionLengthSeconds: Swift.Int? = nil,
        signalRequest: Swift.String? = nil,
        signalResponse: Swift.String? = nil,
        status: GameLiftStreamsClientTypes.StreamSessionStatus? = nil,
        statusReason: GameLiftStreamsClientTypes.StreamSessionStatusReason? = nil,
        streamGroupId: Swift.String? = nil,
        userId: Swift.String? = nil,
        webSdkProtocolUrl: Swift.String? = nil
    ) {
        self.additionalEnvironmentVariables = additionalEnvironmentVariables
        self.additionalLaunchArgs = additionalLaunchArgs
        self.applicationArn = applicationArn
        self.arn = arn
        self.connectionTimeoutSeconds = connectionTimeoutSeconds
        self.createdAt = createdAt
        self.description = description
        self.exportFilesMetadata = exportFilesMetadata
        self.lastUpdatedAt = lastUpdatedAt
        self.location = location
        self.logFileLocationUri = logFileLocationUri
        self.`protocol` = `protocol`
        self.sessionLengthSeconds = sessionLengthSeconds
        self.signalRequest = signalRequest
        self.signalResponse = signalResponse
        self.status = status
        self.statusReason = statusReason
        self.streamGroupId = streamGroupId
        self.userId = userId
        self.webSdkProtocolUrl = webSdkProtocolUrl
    }
}

extension StartStreamSessionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartStreamSessionOutput(protocol: \(Swift.String(describing: `protocol`)), additionalEnvironmentVariables: \(Swift.String(describing: additionalEnvironmentVariables)), additionalLaunchArgs: \(Swift.String(describing: additionalLaunchArgs)), applicationArn: \(Swift.String(describing: applicationArn)), arn: \(Swift.String(describing: arn)), connectionTimeoutSeconds: \(Swift.String(describing: connectionTimeoutSeconds)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), exportFilesMetadata: \(Swift.String(describing: exportFilesMetadata)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), location: \(Swift.String(describing: location)), logFileLocationUri: \(Swift.String(describing: logFileLocationUri)), sessionLengthSeconds: \(Swift.String(describing: sessionLengthSeconds)), status: \(Swift.String(describing: status)), statusReason: \(Swift.String(describing: statusReason)), streamGroupId: \(Swift.String(describing: streamGroupId)), userId: \(Swift.String(describing: userId)), webSdkProtocolUrl: \(Swift.String(describing: webSdkProtocolUrl)), signalRequest: \"CONTENT_REDACTED\", signalResponse: \"CONTENT_REDACTED\")"}
}

public struct GetStreamGroupInput: Swift.Sendable {
    /// The unique ID value of the stream group resource to retrieve. Format example: sg-1AB2C3De4.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        identifier: Swift.String? = nil
    ) {
        self.identifier = identifier
    }
}

public struct GetStreamGroupOutput: Swift.Sendable {
    /// An Amazon Resource Name (ARN) that is assigned to the stream group resource and that uniquely identifies the group across all Amazon Web Services Regions. Format is arn:aws:gameliftstreams:[AWS Region]:[AWS account]:streamgroup/[resource ID].
    /// This member is required.
    public var arn: Swift.String?
    /// A set of applications that this stream group is associated to. You can stream any of these applications by using this stream group. This value is a set of [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) that uniquely identify application resources. Format example: arn:aws:gameliftstreams:us-west-2:123456789012:application/a-9ZY8X7Wv6.
    public var associatedApplications: [Swift.String]?
    /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
    public var createdAt: Foundation.Date?
    /// The default Amazon GameLift Streams application that is associated with this stream group.
    public var defaultApplication: GameLiftStreamsClientTypes.DefaultApplication?
    /// A descriptive label for the stream group.
    public var description: Swift.String?
    /// A unique ID value that is assigned to the resource when it's created. Format example: sg-1AB2C3De4.
    public var id: Swift.String?
    /// A timestamp that indicates when this resource was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
    public var lastUpdatedAt: Foundation.Date?
    /// This value is the set of locations, including their name, current status, and capacities. A location can be in one of the following states:
    ///
    /// * ACTIVATING: Amazon GameLift Streams is preparing the location. You cannot stream from, scale the capacity of, or remove this location yet.
    ///
    /// * ACTIVE: The location is provisioned with initial capacity. You can now stream from, scale the capacity of, or remove this location.
    ///
    /// * ERROR: Amazon GameLift Streams failed to set up this location. The StatusReason field describes the error. You can remove this location and try to add it again.
    ///
    /// * REMOVING: Amazon GameLift Streams is working to remove this location. It releases all provisioned capacity for this location in this stream group.
    public var locationStates: [GameLiftStreamsClientTypes.LocationState]?
    /// The current status of the stream group resource. Possible statuses include the following:
    ///
    /// * ACTIVATING: The stream group is deploying and isn't ready to host streams.
    ///
    /// * ACTIVE: The stream group is ready to host streams.
    ///
    /// * ACTIVE_WITH_ERRORS: One or more locations in the stream group are in an error state. Verify the details of individual locations and remove any locations which are in error.
    ///
    /// * ERROR: An error occurred when the stream group deployed. See StatusReason for more information.
    ///
    /// * DELETING: Amazon GameLift Streams is in the process of deleting the stream group.
    ///
    /// * UPDATING_LOCATIONS: One or more locations in the stream group are in the process of updating (either activating or deleting).
    public var status: GameLiftStreamsClientTypes.StreamGroupStatus?
    /// A short description of the reason that the stream group is in ERROR status. The possible reasons can be one of the following:
    ///
    /// * internalError: The request can't process right now bcause of an issue with the server. Try again later. Reach out to the Amazon GameLift Streams team for more help.
    ///
    /// * noAvailableInstances: Amazon GameLift Streams does not currently have enough available On-Demand capacity to fulfill your request. Wait a few minutes and retry the request as capacity can shift frequently. You can also try to make the request using a different stream class or in another region.
    public var statusReason: GameLiftStreamsClientTypes.StreamGroupStatusReason?
    /// The target stream quality for the stream group. A stream class can be one of the following:
    ///
    /// * gen5n_win2022 (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with Unreal Engine versions up through 5.4, 32 and 64-bit applications, and anti-cheat technology. Uses NVIDIA A10G Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM
    ///
    /// * Tenancy: Supports 1 concurrent stream session
    ///
    ///
    ///
    ///
    /// * gen5n_high (NVIDIA, high) Supports applications with moderate to high 3D scene complexity. Uses NVIDIA A10G Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 4 vCPUs, 16 GB RAM, 12 GB VRAM
    ///
    /// * Tenancy: Supports up to 2 concurrent stream sessions
    ///
    ///
    ///
    ///
    /// * gen5n_ultra (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Uses dedicated NVIDIA A10G Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM
    ///
    /// * Tenancy: Supports 1 concurrent stream session
    ///
    ///
    ///
    ///
    /// * gen4n_win2022 (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with Unreal Engine versions up through 5.4, 32 and 64-bit applications, and anti-cheat technology. Uses NVIDIA T4 Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM
    ///
    /// * Tenancy: Supports 1 concurrent stream session
    ///
    ///
    ///
    ///
    /// * gen4n_high (NVIDIA, high) Supports applications with moderate to high 3D scene complexity. Uses NVIDIA T4 Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 4 vCPUs, 16 GB RAM, 8 GB VRAM
    ///
    /// * Tenancy: Supports up to 2 concurrent stream sessions
    ///
    ///
    ///
    ///
    /// * gen4n_ultra (NVIDIA, ultra) Supports applications with high 3D scene complexity. Uses dedicated NVIDIA T4 Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM
    ///
    /// * Tenancy: Supports 1 concurrent stream session
    public var streamClass: GameLiftStreamsClientTypes.StreamClass?

    public init(
        arn: Swift.String? = nil,
        associatedApplications: [Swift.String]? = nil,
        createdAt: Foundation.Date? = nil,
        defaultApplication: GameLiftStreamsClientTypes.DefaultApplication? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        locationStates: [GameLiftStreamsClientTypes.LocationState]? = nil,
        status: GameLiftStreamsClientTypes.StreamGroupStatus? = nil,
        statusReason: GameLiftStreamsClientTypes.StreamGroupStatusReason? = nil,
        streamClass: GameLiftStreamsClientTypes.StreamClass? = nil
    ) {
        self.arn = arn
        self.associatedApplications = associatedApplications
        self.createdAt = createdAt
        self.defaultApplication = defaultApplication
        self.description = description
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.locationStates = locationStates
        self.status = status
        self.statusReason = statusReason
        self.streamClass = streamClass
    }
}

public struct ListStreamGroupsInput: Swift.Sendable {
    /// The number of results to return. Use this parameter with NextToken to return results in sequential pages. Default value is 25.
    public var maxResults: Swift.Int?
    /// A token that marks the start of the next set of results. Use this token when you retrieve results as sequential pages. To get the first page of results, omit a token value. To get the remaining pages, provide the token returned with the previous result set.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension GameLiftStreamsClientTypes {

    /// Describes a Amazon GameLift Streams stream group resource for hosting content streams. To retrieve additional stream group details, call [GetStreamGroup](https://docs.aws.amazon.com/gameliftstreams/latest/apireference/API_GetStreamGroup.html).
    public struct StreamGroupSummary: Swift.Sendable {
        /// An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/sg-1AB2C3De4 or ID-sg-1AB2C3De4.
        /// This member is required.
        public var arn: Swift.String?
        /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public var createdAt: Foundation.Date?
        /// Object that identifies the Amazon GameLift Streams application to stream with this stream group.
        public var defaultApplication: GameLiftStreamsClientTypes.DefaultApplication?
        /// A descriptive label for the stream group.
        public var description: Swift.String?
        /// An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/sg-1AB2C3De4 or ID-sg-1AB2C3De4.
        public var id: Swift.String?
        /// A timestamp that indicates when this resource was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
        public var lastUpdatedAt: Foundation.Date?
        /// The current status of the stream group resource. Possible statuses include the following:
        ///
        /// * ACTIVATING: The stream group is deploying and isn't ready to host streams.
        ///
        /// * ACTIVE: The stream group is ready to host streams.
        ///
        /// * ACTIVE_WITH_ERRORS: One or more locations in the stream group are in an error state. Verify the details of individual locations and remove any locations which are in error.
        ///
        /// * ERROR: An error occurred when the stream group deployed. See StatusReason for more information.
        ///
        /// * DELETING: Amazon GameLift Streams is in the process of deleting the stream group.
        ///
        /// * UPDATING_LOCATIONS: One or more locations in the stream group are in the process of updating (either activating or deleting).
        public var status: GameLiftStreamsClientTypes.StreamGroupStatus?
        /// The target stream quality for the stream group. A stream class can be one of the following:
        ///
        /// * gen5n_win2022 (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with Unreal Engine versions up through 5.4, 32 and 64-bit applications, and anti-cheat technology. Uses NVIDIA A10G Tensor GPU.
        ///
        /// * Reference resolution: 1080p
        ///
        /// * Reference frame rate: 60 fps
        ///
        /// * Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM
        ///
        /// * Tenancy: Supports 1 concurrent stream session
        ///
        ///
        ///
        ///
        /// * gen5n_high (NVIDIA, high) Supports applications with moderate to high 3D scene complexity. Uses NVIDIA A10G Tensor GPU.
        ///
        /// * Reference resolution: 1080p
        ///
        /// * Reference frame rate: 60 fps
        ///
        /// * Workload specifications: 4 vCPUs, 16 GB RAM, 12 GB VRAM
        ///
        /// * Tenancy: Supports up to 2 concurrent stream sessions
        ///
        ///
        ///
        ///
        /// * gen5n_ultra (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Uses dedicated NVIDIA A10G Tensor GPU.
        ///
        /// * Reference resolution: 1080p
        ///
        /// * Reference frame rate: 60 fps
        ///
        /// * Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM
        ///
        /// * Tenancy: Supports 1 concurrent stream session
        ///
        ///
        ///
        ///
        /// * gen4n_win2022 (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with Unreal Engine versions up through 5.4, 32 and 64-bit applications, and anti-cheat technology. Uses NVIDIA T4 Tensor GPU.
        ///
        /// * Reference resolution: 1080p
        ///
        /// * Reference frame rate: 60 fps
        ///
        /// * Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM
        ///
        /// * Tenancy: Supports 1 concurrent stream session
        ///
        ///
        ///
        ///
        /// * gen4n_high (NVIDIA, high) Supports applications with moderate to high 3D scene complexity. Uses NVIDIA T4 Tensor GPU.
        ///
        /// * Reference resolution: 1080p
        ///
        /// * Reference frame rate: 60 fps
        ///
        /// * Workload specifications: 4 vCPUs, 16 GB RAM, 8 GB VRAM
        ///
        /// * Tenancy: Supports up to 2 concurrent stream sessions
        ///
        ///
        ///
        ///
        /// * gen4n_ultra (NVIDIA, ultra) Supports applications with high 3D scene complexity. Uses dedicated NVIDIA T4 Tensor GPU.
        ///
        /// * Reference resolution: 1080p
        ///
        /// * Reference frame rate: 60 fps
        ///
        /// * Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM
        ///
        /// * Tenancy: Supports 1 concurrent stream session
        public var streamClass: GameLiftStreamsClientTypes.StreamClass?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            defaultApplication: GameLiftStreamsClientTypes.DefaultApplication? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: Foundation.Date? = nil,
            status: GameLiftStreamsClientTypes.StreamGroupStatus? = nil,
            streamClass: GameLiftStreamsClientTypes.StreamClass? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.defaultApplication = defaultApplication
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.status = status
            self.streamClass = streamClass
        }
    }
}

public struct ListStreamGroupsOutput: Swift.Sendable {
    /// A collection of Amazon GameLift Streams stream groups that are associated with the Amazon Web Services account in use. Each item includes stream group metadata and status, but doesn't include capacity information.
    public var items: [GameLiftStreamsClientTypes.StreamGroupSummary]?
    /// A token that marks the start of the next sequential page of results. If an operation doesn't return a token, you've reached the end of the list.
    public var nextToken: Swift.String?

    public init(
        items: [GameLiftStreamsClientTypes.StreamGroupSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct UpdateStreamGroupInput: Swift.Sendable {
    /// A descriptive label for the stream group.
    public var description: Swift.String?
    /// An [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/sg-1AB2C3De4 or ID-sg-1AB2C3De4.
    /// This member is required.
    public var identifier: Swift.String?
    /// A set of one or more locations and the streaming capacity for each location.
    public var locationConfigurations: [GameLiftStreamsClientTypes.LocationConfiguration]?

    public init(
        description: Swift.String? = nil,
        identifier: Swift.String? = nil,
        locationConfigurations: [GameLiftStreamsClientTypes.LocationConfiguration]? = nil
    ) {
        self.description = description
        self.identifier = identifier
        self.locationConfigurations = locationConfigurations
    }
}

public struct UpdateStreamGroupOutput: Swift.Sendable {
    /// An Amazon Resource Name (ARN) that is assigned to the stream group resource and that uniquely identifies the group across all Amazon Web Services Regions. Format is arn:aws:gameliftstreams:[AWS Region]:[AWS account]:streamgroup/[resource ID].
    /// This member is required.
    public var arn: Swift.String?
    /// A set of applications that this stream group is associated with. You can stream any of these applications with the stream group. This value is a set of [Amazon Resource Names (ARNs)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) that uniquely identify application resources. Format example: arn:aws:gameliftstreams:us-west-2:123456789012:application/a-9ZY8X7Wv6.
    public var associatedApplications: [Swift.String]?
    /// A timestamp that indicates when this resource was created. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
    public var createdAt: Foundation.Date?
    /// The default Amazon GameLift Streams application that is associated with this stream group.
    public var defaultApplication: GameLiftStreamsClientTypes.DefaultApplication?
    /// A descriptive label for the stream group.
    public var description: Swift.String?
    /// A unique ID value that is assigned to the resource when it's created. Format example: sg-1AB2C3De4.
    public var id: Swift.String?
    /// A timestamp that indicates when this resource was last updated. Timestamps are expressed using in ISO8601 format, such as: 2022-12-27T22:29:40+00:00 (UTC).
    public var lastUpdatedAt: Foundation.Date?
    /// This value is set of locations, including their name, current status, and capacities. A location can be in one of the following states:
    ///
    /// * ACTIVATING: Amazon GameLift Streams is preparing the location. You cannot stream from, scale the capacity of, or remove this location yet.
    ///
    /// * ACTIVE: The location is provisioned with initial capacity. You can now stream from, scale the capacity of, or remove this location.
    ///
    /// * ERROR: Amazon GameLift Streams failed to set up this location. The StatusReason field describes the error. You can remove this location and try to add it again.
    ///
    /// * REMOVING: Amazon GameLift Streams is working to remove this location. It releases all provisioned capacity for this location in this stream group.
    public var locationStates: [GameLiftStreamsClientTypes.LocationState]?
    /// The current status of the stream group resource. Possible statuses include the following:
    ///
    /// * ACTIVATING: The stream group is deploying and isn't ready to host streams.
    ///
    /// * ACTIVE: The stream group is ready to host streams.
    ///
    /// * ACTIVE_WITH_ERRORS: One or more locations in the stream group are in an error state. Verify the details of individual locations and remove any locations which are in error.
    ///
    /// * ERROR: An error occurred when the stream group deployed. See StatusReason for more information.
    ///
    /// * DELETING: Amazon GameLift Streams is in the process of deleting the stream group.
    ///
    /// * UPDATING_LOCATIONS: One or more locations in the stream group are in the process of updating (either activating or deleting).
    public var status: GameLiftStreamsClientTypes.StreamGroupStatus?
    /// A short description of the reason that the stream group is in ERROR status. The possible reasons can be one of the following:
    ///
    /// * internalError: The request can't process right now bcause of an issue with the server. Try again later. Reach out to the Amazon GameLift Streams team for more help.
    ///
    /// * noAvailableInstances: Amazon GameLift Streams does not currently have enough available On-Demand capacity to fulfill your request. Wait a few minutes and retry the request as capacity can shift frequently. You can also try to make the request using a different stream class or in another region.
    public var statusReason: GameLiftStreamsClientTypes.StreamGroupStatusReason?
    /// The target stream quality for the stream group. A stream class can be one of the following:
    ///
    /// * gen5n_win2022 (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with Unreal Engine versions up through 5.4, 32 and 64-bit applications, and anti-cheat technology. Uses NVIDIA A10G Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM
    ///
    /// * Tenancy: Supports 1 concurrent stream session
    ///
    ///
    ///
    ///
    /// * gen5n_high (NVIDIA, high) Supports applications with moderate to high 3D scene complexity. Uses NVIDIA A10G Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 4 vCPUs, 16 GB RAM, 12 GB VRAM
    ///
    /// * Tenancy: Supports up to 2 concurrent stream sessions
    ///
    ///
    ///
    ///
    /// * gen5n_ultra (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Uses dedicated NVIDIA A10G Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 8 vCPUs, 32 GB RAM, 24 GB VRAM
    ///
    /// * Tenancy: Supports 1 concurrent stream session
    ///
    ///
    ///
    ///
    /// * gen4n_win2022 (NVIDIA, ultra) Supports applications with extremely high 3D scene complexity. Runs applications on Microsoft Windows Server 2022 Base and supports DirectX 12. Compatible with Unreal Engine versions up through 5.4, 32 and 64-bit applications, and anti-cheat technology. Uses NVIDIA T4 Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM
    ///
    /// * Tenancy: Supports 1 concurrent stream session
    ///
    ///
    ///
    ///
    /// * gen4n_high (NVIDIA, high) Supports applications with moderate to high 3D scene complexity. Uses NVIDIA T4 Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 4 vCPUs, 16 GB RAM, 8 GB VRAM
    ///
    /// * Tenancy: Supports up to 2 concurrent stream sessions
    ///
    ///
    ///
    ///
    /// * gen4n_ultra (NVIDIA, ultra) Supports applications with high 3D scene complexity. Uses dedicated NVIDIA T4 Tensor GPU.
    ///
    /// * Reference resolution: 1080p
    ///
    /// * Reference frame rate: 60 fps
    ///
    /// * Workload specifications: 8 vCPUs, 32 GB RAM, 16 GB VRAM
    ///
    /// * Tenancy: Supports 1 concurrent stream session
    public var streamClass: GameLiftStreamsClientTypes.StreamClass?

    public init(
        arn: Swift.String? = nil,
        associatedApplications: [Swift.String]? = nil,
        createdAt: Foundation.Date? = nil,
        defaultApplication: GameLiftStreamsClientTypes.DefaultApplication? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        locationStates: [GameLiftStreamsClientTypes.LocationState]? = nil,
        status: GameLiftStreamsClientTypes.StreamGroupStatus? = nil,
        statusReason: GameLiftStreamsClientTypes.StreamGroupStatusReason? = nil,
        streamClass: GameLiftStreamsClientTypes.StreamClass? = nil
    ) {
        self.arn = arn
        self.associatedApplications = associatedApplications
        self.createdAt = createdAt
        self.defaultApplication = defaultApplication
        self.description = description
        self.id = id
        self.lastUpdatedAt = lastUpdatedAt
        self.locationStates = locationStates
        self.status = status
        self.statusReason = statusReason
        self.streamClass = streamClass
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html) of the Amazon GameLift Streams resource that you want to apply tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tags, in the form of key-value pairs, to assign to the specified Amazon GameLift Streams resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct TerminateStreamSessionInput: Swift.Sendable {
    /// [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) or ID that uniquely identifies the stream group resource. Format example: ARN-arn:aws:gameliftstreams:us-west-2:123456789012:streamgroup/sg-1AB2C3De4 or ID-sg-1AB2C3De4. The stream group that runs this stream session.
    /// This member is required.
    public var identifier: Swift.String?
    /// [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference-arns.html) that uniquely identifies the stream session resource. Format example: 1AB2C3De4.
    /// This member is required.
    public var streamSessionIdentifier: Swift.String?

    public init(
        identifier: Swift.String? = nil,
        streamSessionIdentifier: Swift.String? = nil
    ) {
        self.identifier = identifier
        self.streamSessionIdentifier = streamSessionIdentifier
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The [Amazon Resource Name (ARN)](https://docs.aws.amazon.com/AmazonS3/latest/dev/s3-arn-format.html) of the Amazon GameLift Streams resource that you want to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag keys to remove from the specified Amazon GameLift Streams resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension AddStreamGroupLocationsInput {

    static func urlPathProvider(_ value: AddStreamGroupLocationsInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/streamgroups/\(identifier.urlPercentEncoding())/locations"
    }
}

extension AssociateApplicationsInput {

    static func urlPathProvider(_ value: AssociateApplicationsInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/streamgroups/\(identifier.urlPercentEncoding())/associations"
    }
}

extension CreateApplicationInput {

    static func urlPathProvider(_ value: CreateApplicationInput) -> Swift.String? {
        return "/applications"
    }
}

extension CreateStreamGroupInput {

    static func urlPathProvider(_ value: CreateStreamGroupInput) -> Swift.String? {
        return "/streamgroups"
    }
}

extension CreateStreamSessionConnectionInput {

    static func urlPathProvider(_ value: CreateStreamSessionConnectionInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        guard let streamSessionIdentifier = value.streamSessionIdentifier else {
            return nil
        }
        return "/streamgroups/\(identifier.urlPercentEncoding())/streamsessions/\(streamSessionIdentifier.urlPercentEncoding())/connections"
    }
}

extension DeleteApplicationInput {

    static func urlPathProvider(_ value: DeleteApplicationInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/applications/\(identifier.urlPercentEncoding())"
    }
}

extension DeleteStreamGroupInput {

    static func urlPathProvider(_ value: DeleteStreamGroupInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/streamgroups/\(identifier.urlPercentEncoding())"
    }
}

extension DisassociateApplicationsInput {

    static func urlPathProvider(_ value: DisassociateApplicationsInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/streamgroups/\(identifier.urlPercentEncoding())/disassociations"
    }
}

extension ExportStreamSessionFilesInput {

    static func urlPathProvider(_ value: ExportStreamSessionFilesInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        guard let streamSessionIdentifier = value.streamSessionIdentifier else {
            return nil
        }
        return "/streamgroups/\(identifier.urlPercentEncoding())/streamsessions/\(streamSessionIdentifier.urlPercentEncoding())/exportfiles"
    }
}

extension GetApplicationInput {

    static func urlPathProvider(_ value: GetApplicationInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/applications/\(identifier.urlPercentEncoding())"
    }
}

extension GetStreamGroupInput {

    static func urlPathProvider(_ value: GetStreamGroupInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/streamgroups/\(identifier.urlPercentEncoding())"
    }
}

extension GetStreamSessionInput {

    static func urlPathProvider(_ value: GetStreamSessionInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        guard let streamSessionIdentifier = value.streamSessionIdentifier else {
            return nil
        }
        return "/streamgroups/\(identifier.urlPercentEncoding())/streamsessions/\(streamSessionIdentifier.urlPercentEncoding())"
    }
}

extension ListApplicationsInput {

    static func urlPathProvider(_ value: ListApplicationsInput) -> Swift.String? {
        return "/applications"
    }
}

extension ListApplicationsInput {

    static func queryItemProvider(_ value: ListApplicationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListStreamGroupsInput {

    static func urlPathProvider(_ value: ListStreamGroupsInput) -> Swift.String? {
        return "/streamgroups"
    }
}

extension ListStreamGroupsInput {

    static func queryItemProvider(_ value: ListStreamGroupsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListStreamSessionsInput {

    static func urlPathProvider(_ value: ListStreamSessionsInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/streamgroups/\(identifier.urlPercentEncoding())/streamsessions"
    }
}

extension ListStreamSessionsInput {

    static func queryItemProvider(_ value: ListStreamSessionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let exportFilesStatus = value.exportFilesStatus {
            let exportFilesStatusQueryItem = Smithy.URIQueryItem(name: "ExportFilesStatus".urlPercentEncoding(), value: Swift.String(exportFilesStatus.rawValue).urlPercentEncoding())
            items.append(exportFilesStatusQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListStreamSessionsByAccountInput {

    static func urlPathProvider(_ value: ListStreamSessionsByAccountInput) -> Swift.String? {
        return "/streamsessions"
    }
}

extension ListStreamSessionsByAccountInput {

    static func queryItemProvider(_ value: ListStreamSessionsByAccountInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "Status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        if let exportFilesStatus = value.exportFilesStatus {
            let exportFilesStatusQueryItem = Smithy.URIQueryItem(name: "ExportFilesStatus".urlPercentEncoding(), value: Swift.String(exportFilesStatus.rawValue).urlPercentEncoding())
            items.append(exportFilesStatusQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension RemoveStreamGroupLocationsInput {

    static func urlPathProvider(_ value: RemoveStreamGroupLocationsInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/streamgroups/\(identifier.urlPercentEncoding())/locations"
    }
}

extension RemoveStreamGroupLocationsInput {

    static func queryItemProvider(_ value: RemoveStreamGroupLocationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let locations = value.locations else {
            let message = "Creating a URL Query Item failed. locations is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        locations.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "locations".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension StartStreamSessionInput {

    static func urlPathProvider(_ value: StartStreamSessionInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/streamgroups/\(identifier.urlPercentEncoding())/streamsessions"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TerminateStreamSessionInput {

    static func urlPathProvider(_ value: TerminateStreamSessionInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        guard let streamSessionIdentifier = value.streamSessionIdentifier else {
            return nil
        }
        return "/streamgroups/\(identifier.urlPercentEncoding())/streamsessions/\(streamSessionIdentifier.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateApplicationInput {

    static func urlPathProvider(_ value: UpdateApplicationInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/applications/\(identifier.urlPercentEncoding())"
    }
}

extension UpdateStreamGroupInput {

    static func urlPathProvider(_ value: UpdateStreamGroupInput) -> Swift.String? {
        guard let identifier = value.identifier else {
            return nil
        }
        return "/streamgroups/\(identifier.urlPercentEncoding())"
    }
}

extension AddStreamGroupLocationsInput {

    static func write(value: AddStreamGroupLocationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LocationConfigurations"].writeList(value.locationConfigurations, memberWritingClosure: GameLiftStreamsClientTypes.LocationConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AssociateApplicationsInput {

    static func write(value: AssociateApplicationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationIdentifiers"].writeList(value.applicationIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateApplicationInput {

    static func write(value: CreateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationLogOutputUri"].write(value.applicationLogOutputUri)
        try writer["ApplicationLogPaths"].writeList(value.applicationLogPaths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ApplicationSourceUri"].write(value.applicationSourceUri)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["ExecutablePath"].write(value.executablePath)
        try writer["RuntimeEnvironment"].write(value.runtimeEnvironment, with: GameLiftStreamsClientTypes.RuntimeEnvironment.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateStreamGroupInput {

    static func write(value: CreateStreamGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["DefaultApplicationIdentifier"].write(value.defaultApplicationIdentifier)
        try writer["Description"].write(value.description)
        try writer["LocationConfigurations"].writeList(value.locationConfigurations, memberWritingClosure: GameLiftStreamsClientTypes.LocationConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["StreamClass"].write(value.streamClass)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateStreamSessionConnectionInput {

    static func write(value: CreateStreamSessionConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["SignalRequest"].write(value.signalRequest)
    }
}

extension DisassociateApplicationsInput {

    static func write(value: DisassociateApplicationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationIdentifiers"].writeList(value.applicationIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ExportStreamSessionFilesInput {

    static func write(value: ExportStreamSessionFilesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["OutputUri"].write(value.outputUri)
    }
}

extension StartStreamSessionInput {

    static func write(value: StartStreamSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalEnvironmentVariables"].writeMap(value.additionalEnvironmentVariables, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["AdditionalLaunchArgs"].writeList(value.additionalLaunchArgs, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ApplicationIdentifier"].write(value.applicationIdentifier)
        try writer["ClientToken"].write(value.clientToken)
        try writer["ConnectionTimeoutSeconds"].write(value.connectionTimeoutSeconds)
        try writer["Description"].write(value.description)
        try writer["Locations"].writeList(value.locations, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Protocol"].write(value.`protocol`)
        try writer["SessionLengthSeconds"].write(value.sessionLengthSeconds)
        try writer["SignalRequest"].write(value.signalRequest)
        try writer["UserId"].write(value.userId)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateApplicationInput {

    static func write(value: UpdateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationLogOutputUri"].write(value.applicationLogOutputUri)
        try writer["ApplicationLogPaths"].writeList(value.applicationLogPaths, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
    }
}

extension UpdateStreamGroupInput {

    static func write(value: UpdateStreamGroupInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["LocationConfigurations"].writeList(value.locationConfigurations, memberWritingClosure: GameLiftStreamsClientTypes.LocationConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AddStreamGroupLocationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AddStreamGroupLocationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AddStreamGroupLocationsOutput()
        value.identifier = try reader["Identifier"].readIfPresent() ?? ""
        value.locations = try reader["Locations"].readListIfPresent(memberReadingClosure: GameLiftStreamsClientTypes.LocationState.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension AssociateApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateApplicationsOutput()
        value.applicationArns = try reader["ApplicationArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension CreateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApplicationOutput()
        value.applicationLogOutputUri = try reader["ApplicationLogOutputUri"].readIfPresent()
        value.applicationLogPaths = try reader["ApplicationLogPaths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.applicationSourceUri = try reader["ApplicationSourceUri"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.associatedStreamGroups = try reader["AssociatedStreamGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.executablePath = try reader["ExecutablePath"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.replicationStatuses = try reader["ReplicationStatuses"].readListIfPresent(memberReadingClosure: GameLiftStreamsClientTypes.ReplicationStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.runtimeEnvironment = try reader["RuntimeEnvironment"].readIfPresent(with: GameLiftStreamsClientTypes.RuntimeEnvironment.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        return value
    }
}

extension CreateStreamGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStreamGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStreamGroupOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.associatedApplications = try reader["AssociatedApplications"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.defaultApplication = try reader["DefaultApplication"].readIfPresent(with: GameLiftStreamsClientTypes.DefaultApplication.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.locationStates = try reader["LocationStates"].readListIfPresent(memberReadingClosure: GameLiftStreamsClientTypes.LocationState.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.streamClass = try reader["StreamClass"].readIfPresent()
        return value
    }
}

extension CreateStreamSessionConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStreamSessionConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStreamSessionConnectionOutput()
        value.signalResponse = try reader["SignalResponse"].readIfPresent()
        return value
    }
}

extension DeleteApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationOutput {
        return DeleteApplicationOutput()
    }
}

extension DeleteStreamGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStreamGroupOutput {
        return DeleteStreamGroupOutput()
    }
}

extension DisassociateApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateApplicationsOutput()
        value.applicationArns = try reader["ApplicationArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension ExportStreamSessionFilesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExportStreamSessionFilesOutput {
        return ExportStreamSessionFilesOutput()
    }
}

extension GetApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApplicationOutput()
        value.applicationLogOutputUri = try reader["ApplicationLogOutputUri"].readIfPresent()
        value.applicationLogPaths = try reader["ApplicationLogPaths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.applicationSourceUri = try reader["ApplicationSourceUri"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.associatedStreamGroups = try reader["AssociatedStreamGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.executablePath = try reader["ExecutablePath"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.replicationStatuses = try reader["ReplicationStatuses"].readListIfPresent(memberReadingClosure: GameLiftStreamsClientTypes.ReplicationStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.runtimeEnvironment = try reader["RuntimeEnvironment"].readIfPresent(with: GameLiftStreamsClientTypes.RuntimeEnvironment.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        return value
    }
}

extension GetStreamGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStreamGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStreamGroupOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.associatedApplications = try reader["AssociatedApplications"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.defaultApplication = try reader["DefaultApplication"].readIfPresent(with: GameLiftStreamsClientTypes.DefaultApplication.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.locationStates = try reader["LocationStates"].readListIfPresent(memberReadingClosure: GameLiftStreamsClientTypes.LocationState.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.streamClass = try reader["StreamClass"].readIfPresent()
        return value
    }
}

extension GetStreamSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetStreamSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetStreamSessionOutput()
        value.additionalEnvironmentVariables = try reader["AdditionalEnvironmentVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.additionalLaunchArgs = try reader["AdditionalLaunchArgs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.applicationArn = try reader["ApplicationArn"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.connectionTimeoutSeconds = try reader["ConnectionTimeoutSeconds"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.exportFilesMetadata = try reader["ExportFilesMetadata"].readIfPresent(with: GameLiftStreamsClientTypes.ExportFilesMetadata.read(from:))
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.location = try reader["Location"].readIfPresent()
        value.logFileLocationUri = try reader["LogFileLocationUri"].readIfPresent()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        value.sessionLengthSeconds = try reader["SessionLengthSeconds"].readIfPresent()
        value.signalRequest = try reader["SignalRequest"].readIfPresent()
        value.signalResponse = try reader["SignalResponse"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.streamGroupId = try reader["StreamGroupId"].readIfPresent()
        value.userId = try reader["UserId"].readIfPresent()
        value.webSdkProtocolUrl = try reader["WebSdkProtocolUrl"].readIfPresent()
        return value
    }
}

extension ListApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: GameLiftStreamsClientTypes.ApplicationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListStreamGroupsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStreamGroupsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStreamGroupsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: GameLiftStreamsClientTypes.StreamGroupSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListStreamSessionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStreamSessionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStreamSessionsOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: GameLiftStreamsClientTypes.StreamSessionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListStreamSessionsByAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStreamSessionsByAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStreamSessionsByAccountOutput()
        value.items = try reader["Items"].readListIfPresent(memberReadingClosure: GameLiftStreamsClientTypes.StreamSessionSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension RemoveStreamGroupLocationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RemoveStreamGroupLocationsOutput {
        return RemoveStreamGroupLocationsOutput()
    }
}

extension StartStreamSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartStreamSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartStreamSessionOutput()
        value.additionalEnvironmentVariables = try reader["AdditionalEnvironmentVariables"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.additionalLaunchArgs = try reader["AdditionalLaunchArgs"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.applicationArn = try reader["ApplicationArn"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.connectionTimeoutSeconds = try reader["ConnectionTimeoutSeconds"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.exportFilesMetadata = try reader["ExportFilesMetadata"].readIfPresent(with: GameLiftStreamsClientTypes.ExportFilesMetadata.read(from:))
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.location = try reader["Location"].readIfPresent()
        value.logFileLocationUri = try reader["LogFileLocationUri"].readIfPresent()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        value.sessionLengthSeconds = try reader["SessionLengthSeconds"].readIfPresent()
        value.signalRequest = try reader["SignalRequest"].readIfPresent()
        value.signalResponse = try reader["SignalResponse"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.streamGroupId = try reader["StreamGroupId"].readIfPresent()
        value.userId = try reader["UserId"].readIfPresent()
        value.webSdkProtocolUrl = try reader["WebSdkProtocolUrl"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension TerminateStreamSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TerminateStreamSessionOutput {
        return TerminateStreamSessionOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateApplicationOutput()
        value.applicationLogOutputUri = try reader["ApplicationLogOutputUri"].readIfPresent()
        value.applicationLogPaths = try reader["ApplicationLogPaths"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.applicationSourceUri = try reader["ApplicationSourceUri"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.associatedStreamGroups = try reader["AssociatedStreamGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.executablePath = try reader["ExecutablePath"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.replicationStatuses = try reader["ReplicationStatuses"].readListIfPresent(memberReadingClosure: GameLiftStreamsClientTypes.ReplicationStatus.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.runtimeEnvironment = try reader["RuntimeEnvironment"].readIfPresent(with: GameLiftStreamsClientTypes.RuntimeEnvironment.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        return value
    }
}

extension UpdateStreamGroupOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateStreamGroupOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateStreamGroupOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.associatedApplications = try reader["AssociatedApplications"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.defaultApplication = try reader["DefaultApplication"].readIfPresent(with: GameLiftStreamsClientTypes.DefaultApplication.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.locationStates = try reader["LocationStates"].readListIfPresent(memberReadingClosure: GameLiftStreamsClientTypes.LocationState.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.streamClass = try reader["StreamClass"].readIfPresent()
        return value
    }
}

enum AddStreamGroupLocationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStreamGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStreamSessionConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStreamGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExportStreamSessionFilesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStreamGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetStreamSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStreamGroupsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStreamSessionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStreamSessionsByAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RemoveStreamGroupLocationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartStreamSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TerminateStreamSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateStreamGroupOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension GameLiftStreamsClientTypes.LocationState {

    static func read(from reader: SmithyJSON.Reader) throws -> GameLiftStreamsClientTypes.LocationState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GameLiftStreamsClientTypes.LocationState()
        value.locationName = try reader["LocationName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.alwaysOnCapacity = try reader["AlwaysOnCapacity"].readIfPresent()
        value.onDemandCapacity = try reader["OnDemandCapacity"].readIfPresent()
        value.requestedCapacity = try reader["RequestedCapacity"].readIfPresent()
        value.allocatedCapacity = try reader["AllocatedCapacity"].readIfPresent()
        value.idleCapacity = try reader["IdleCapacity"].readIfPresent()
        return value
    }
}

extension GameLiftStreamsClientTypes.RuntimeEnvironment {

    static func write(value: GameLiftStreamsClientTypes.RuntimeEnvironment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Type"].write(value.type)
        try writer["Version"].write(value.version)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> GameLiftStreamsClientTypes.RuntimeEnvironment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GameLiftStreamsClientTypes.RuntimeEnvironment()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.version = try reader["Version"].readIfPresent() ?? ""
        return value
    }
}

extension GameLiftStreamsClientTypes.ReplicationStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> GameLiftStreamsClientTypes.ReplicationStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GameLiftStreamsClientTypes.ReplicationStatus()
        value.location = try reader["Location"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension GameLiftStreamsClientTypes.DefaultApplication {

    static func read(from reader: SmithyJSON.Reader) throws -> GameLiftStreamsClientTypes.DefaultApplication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GameLiftStreamsClientTypes.DefaultApplication()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension GameLiftStreamsClientTypes.ExportFilesMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> GameLiftStreamsClientTypes.ExportFilesMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GameLiftStreamsClientTypes.ExportFilesMetadata()
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        value.outputUri = try reader["OutputUri"].readIfPresent()
        return value
    }
}

extension GameLiftStreamsClientTypes.ApplicationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GameLiftStreamsClientTypes.ApplicationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GameLiftStreamsClientTypes.ApplicationSummary()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.runtimeEnvironment = try reader["RuntimeEnvironment"].readIfPresent(with: GameLiftStreamsClientTypes.RuntimeEnvironment.read(from:))
        return value
    }
}

extension GameLiftStreamsClientTypes.StreamGroupSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GameLiftStreamsClientTypes.StreamGroupSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GameLiftStreamsClientTypes.StreamGroupSummary()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.defaultApplication = try reader["DefaultApplication"].readIfPresent(with: GameLiftStreamsClientTypes.DefaultApplication.read(from:))
        value.streamClass = try reader["StreamClass"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension GameLiftStreamsClientTypes.StreamSessionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> GameLiftStreamsClientTypes.StreamSessionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = GameLiftStreamsClientTypes.StreamSessionSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.userId = try reader["UserId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        value.lastUpdatedAt = try reader["LastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.applicationArn = try reader["ApplicationArn"].readIfPresent()
        value.exportFilesMetadata = try reader["ExportFilesMetadata"].readIfPresent(with: GameLiftStreamsClientTypes.ExportFilesMetadata.read(from:))
        value.location = try reader["Location"].readIfPresent()
        return value
    }
}

extension GameLiftStreamsClientTypes.LocationConfiguration {

    static func write(value: GameLiftStreamsClientTypes.LocationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AlwaysOnCapacity"].write(value.alwaysOnCapacity)
        try writer["LocationName"].write(value.locationName)
        try writer["OnDemandCapacity"].write(value.onDemandCapacity)
    }
}

public enum GameLiftStreamsClientTypes {}
