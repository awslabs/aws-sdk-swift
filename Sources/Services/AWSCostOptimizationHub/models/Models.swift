// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You are not authorized to use this operation with the given parameters.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CostOptimizationHubClientTypes.AccountEnrollmentStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case createdTimestamp
        case lastUpdatedTimestamp
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdatedTimestamp, format: .epochSeconds, forKey: .lastUpdatedTimestamp)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.EnrollmentStatus.self, forKey: .status)
        status = statusDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// Describes the enrollment status of an organization's member accounts in Cost Optimization Hub.
    public struct AccountEnrollmentStatus: Swift.Equatable {
        /// The Amazon Web Services account ID.
        public var accountId: Swift.String?
        /// The time when the account enrollment status was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time when the account enrollment status was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The account enrollment status.
        public var status: CostOptimizationHubClientTypes.EnrollmentStatus?

        public init(
            accountId: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            status: CostOptimizationHubClientTypes.EnrollmentStatus? = nil
        )
        {
            self.accountId = accountId
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.status = status
        }
    }

}

extension CostOptimizationHubClientTypes {
    public enum ActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case migrateToGraviton
        case purchaseReservedInstances
        case purchaseSavingsPlans
        case rightsize
        case stop
        case upgrade
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionType] {
            return [
                .migrateToGraviton,
                .purchaseReservedInstances,
                .purchaseSavingsPlans,
                .rightsize,
                .stop,
                .upgrade,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .migrateToGraviton: return "MigrateToGraviton"
            case .purchaseReservedInstances: return "PurchaseReservedInstances"
            case .purchaseSavingsPlans: return "PurchaseSavingsPlans"
            case .rightsize: return "Rightsize"
            case .stop: return "Stop"
            case .upgrade: return "Upgrade"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionType(rawValue: rawValue) ?? ActionType.sdkUnknown(rawValue)
        }
    }
}

extension CostOptimizationHubClientTypes.BlockStoragePerformanceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iops
        case throughput
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iops = self.iops {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let throughput = self.throughput {
            try encodeContainer.encode(throughput, forKey: .throughput)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .iops)
        iops = iopsDecoded
        let throughputDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .throughput)
        throughput = throughputDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// Describes the Amazon Elastic Block Store performance configuration of the current and recommended resource configuration for a recommendation.
    public struct BlockStoragePerformanceConfiguration: Swift.Equatable {
        /// The number of I/O operations per second.
        public var iops: Swift.Double?
        /// The throughput that the volume supports.
        public var throughput: Swift.Double?

        public init(
            iops: Swift.Double? = nil,
            throughput: Swift.Double? = nil
        )
        {
            self.iops = iops
            self.throughput = throughput
        }
    }

}

extension CostOptimizationHubClientTypes.ComputeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case memorySizeInMB
        case platform
        case vCpu
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture, forKey: .architecture)
        }
        if let memorySizeInMB = self.memorySizeInMB {
            try encodeContainer.encode(memorySizeInMB, forKey: .memorySizeInMB)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let vCpu = self.vCpu {
            try encodeContainer.encode(vCpu, forKey: .vCpu)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vCpuDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .vCpu)
        vCpu = vCpuDecoded
        let memorySizeInMBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .memorySizeInMB)
        memorySizeInMB = memorySizeInMBDecoded
        let architectureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecture)
        architecture = architectureDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// Describes the performance configuration for compute services such as Amazon EC2, Lambda, and ECS.
    public struct ComputeConfiguration: Swift.Equatable {
        /// The architecture of the resource.
        public var architecture: Swift.String?
        /// The memory size of the resource.
        public var memorySizeInMB: Swift.Int?
        /// The platform of the resource. The platform is the specific combination of operating system, license model, and software on an instance.
        public var platform: Swift.String?
        /// The number of vCPU cores in the resource.
        public var vCpu: Swift.Double?

        public init(
            architecture: Swift.String? = nil,
            memorySizeInMB: Swift.Int? = nil,
            platform: Swift.String? = nil,
            vCpu: Swift.Double? = nil
        )
        {
            self.architecture = architecture
            self.memorySizeInMB = memorySizeInMB
            self.platform = platform
            self.vCpu = vCpu
        }
    }

}

extension CostOptimizationHubClientTypes.ComputeSavingsPlans: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case costCalculation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let costCalculation = self.costCalculation {
            try encodeContainer.encode(costCalculation, forKey: .costCalculation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ComputeSavingsPlansConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let costCalculationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.SavingsPlansCostCalculation.self, forKey: .costCalculation)
        costCalculation = costCalculationDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The Compute Savings Plans recommendation details.
    public struct ComputeSavingsPlans: Swift.Equatable {
        /// Configuration details of the Compute Savings Plans to purchase.
        public var configuration: CostOptimizationHubClientTypes.ComputeSavingsPlansConfiguration?
        /// Cost impact of the Savings Plans purchase recommendation.
        public var costCalculation: CostOptimizationHubClientTypes.SavingsPlansCostCalculation?

        public init(
            configuration: CostOptimizationHubClientTypes.ComputeSavingsPlansConfiguration? = nil,
            costCalculation: CostOptimizationHubClientTypes.SavingsPlansCostCalculation? = nil
        )
        {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }
    }

}

extension CostOptimizationHubClientTypes.ComputeSavingsPlansConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountScope
        case hourlyCommitment
        case paymentOption
        case term
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountScope = self.accountScope {
            try encodeContainer.encode(accountScope, forKey: .accountScope)
        }
        if let hourlyCommitment = self.hourlyCommitment {
            try encodeContainer.encode(hourlyCommitment, forKey: .hourlyCommitment)
        }
        if let paymentOption = self.paymentOption {
            try encodeContainer.encode(paymentOption, forKey: .paymentOption)
        }
        if let term = self.term {
            try encodeContainer.encode(term, forKey: .term)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let termDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .term)
        term = termDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let hourlyCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hourlyCommitment)
        hourlyCommitment = hourlyCommitmentDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The Compute Savings Plans configuration used for recommendations.
    public struct ComputeSavingsPlansConfiguration: Swift.Equatable {
        /// The account scope that you want your recommendations for. Amazon Web Services calculates recommendations including the management account and member accounts if the value is set to PAYER. If the value is LINKED, recommendations are calculated for individual member accounts only.
        public var accountScope: Swift.String?
        /// The hourly commitment for the Savings Plans type.
        public var hourlyCommitment: Swift.String?
        /// The payment option for the commitment.
        public var paymentOption: Swift.String?
        /// The Savings Plans recommendation term in years.
        public var term: Swift.String?

        public init(
            accountScope: Swift.String? = nil,
            hourlyCommitment: Swift.String? = nil,
            paymentOption: Swift.String? = nil,
            term: Swift.String? = nil
        )
        {
            self.accountScope = accountScope
            self.hourlyCommitment = hourlyCommitment
            self.paymentOption = paymentOption
            self.term = term
        }
    }

}

extension CostOptimizationHubClientTypes.EbsVolume: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case costCalculation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let costCalculation = self.costCalculation {
            try encodeContainer.encode(costCalculation, forKey: .costCalculation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.EbsVolumeConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let costCalculationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ResourceCostCalculation.self, forKey: .costCalculation)
        costCalculation = costCalculationDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// Describes the Amazon Elastic Block Store volume configuration of the current and recommended resource configuration for a recommendation.
    public struct EbsVolume: Swift.Equatable {
        /// The Amazon Elastic Block Store volume configuration used for recommendations.
        public var configuration: CostOptimizationHubClientTypes.EbsVolumeConfiguration?
        /// Cost impact of the recommendation.
        public var costCalculation: CostOptimizationHubClientTypes.ResourceCostCalculation?

        public init(
            configuration: CostOptimizationHubClientTypes.EbsVolumeConfiguration? = nil,
            costCalculation: CostOptimizationHubClientTypes.ResourceCostCalculation? = nil
        )
        {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }
    }

}

extension CostOptimizationHubClientTypes.EbsVolumeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentState
        case performance
        case storage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentState = self.attachmentState {
            try encodeContainer.encode(attachmentState, forKey: .attachmentState)
        }
        if let performance = self.performance {
            try encodeContainer.encode(performance, forKey: .performance)
        }
        if let storage = self.storage {
            try encodeContainer.encode(storage, forKey: .storage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.StorageConfiguration.self, forKey: .storage)
        storage = storageDecoded
        let performanceDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.BlockStoragePerformanceConfiguration.self, forKey: .performance)
        performance = performanceDecoded
        let attachmentStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentState)
        attachmentState = attachmentStateDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The Amazon Elastic Block Store volume configuration used for recommendations.
    public struct EbsVolumeConfiguration: Swift.Equatable {
        /// The Amazon Elastic Block Store attachment state.
        public var attachmentState: Swift.String?
        /// The Amazon Elastic Block Store performance configuration.
        public var performance: CostOptimizationHubClientTypes.BlockStoragePerformanceConfiguration?
        /// The disk storage of the Amazon Elastic Block Store volume.
        public var storage: CostOptimizationHubClientTypes.StorageConfiguration?

        public init(
            attachmentState: Swift.String? = nil,
            performance: CostOptimizationHubClientTypes.BlockStoragePerformanceConfiguration? = nil,
            storage: CostOptimizationHubClientTypes.StorageConfiguration? = nil
        )
        {
            self.attachmentState = attachmentState
            self.performance = performance
            self.storage = storage
        }
    }

}

extension CostOptimizationHubClientTypes.Ec2AutoScalingGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case costCalculation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let costCalculation = self.costCalculation {
            try encodeContainer.encode(costCalculation, forKey: .costCalculation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.Ec2AutoScalingGroupConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let costCalculationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ResourceCostCalculation.self, forKey: .costCalculation)
        costCalculation = costCalculationDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The EC2 Auto Scaling group recommendation details.
    public struct Ec2AutoScalingGroup: Swift.Equatable {
        /// The EC2 Auto Scaling group configuration used for recommendations.
        public var configuration: CostOptimizationHubClientTypes.Ec2AutoScalingGroupConfiguration?
        /// Cost impact of the recommendation.
        public var costCalculation: CostOptimizationHubClientTypes.ResourceCostCalculation?

        public init(
            configuration: CostOptimizationHubClientTypes.Ec2AutoScalingGroupConfiguration? = nil,
            costCalculation: CostOptimizationHubClientTypes.ResourceCostCalculation? = nil
        )
        {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }
    }

}

extension CostOptimizationHubClientTypes.Ec2AutoScalingGroupConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instance
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instance = self.instance {
            try encodeContainer.encode(instance, forKey: .instance)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.InstanceConfiguration.self, forKey: .instance)
        instance = instanceDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The EC2 auto scaling group configuration used for recommendations.
    public struct Ec2AutoScalingGroupConfiguration: Swift.Equatable {
        /// Details about the instance.
        public var instance: CostOptimizationHubClientTypes.InstanceConfiguration?

        public init(
            instance: CostOptimizationHubClientTypes.InstanceConfiguration? = nil
        )
        {
            self.instance = instance
        }
    }

}

extension CostOptimizationHubClientTypes.Ec2Instance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case costCalculation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let costCalculation = self.costCalculation {
            try encodeContainer.encode(costCalculation, forKey: .costCalculation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.Ec2InstanceConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let costCalculationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ResourceCostCalculation.self, forKey: .costCalculation)
        costCalculation = costCalculationDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// Describes the EC2 instance configuration of the current and recommended resource configuration for a recommendation.
    public struct Ec2Instance: Swift.Equatable {
        /// The EC2 instance configuration used for recommendations.
        public var configuration: CostOptimizationHubClientTypes.Ec2InstanceConfiguration?
        /// Cost impact of the recommendation.
        public var costCalculation: CostOptimizationHubClientTypes.ResourceCostCalculation?

        public init(
            configuration: CostOptimizationHubClientTypes.Ec2InstanceConfiguration? = nil,
            costCalculation: CostOptimizationHubClientTypes.ResourceCostCalculation? = nil
        )
        {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }
    }

}

extension CostOptimizationHubClientTypes.Ec2InstanceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instance
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instance = self.instance {
            try encodeContainer.encode(instance, forKey: .instance)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.InstanceConfiguration.self, forKey: .instance)
        instance = instanceDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The EC2 instance configuration used for recommendations.
    public struct Ec2InstanceConfiguration: Swift.Equatable {
        /// Details about the instance.
        public var instance: CostOptimizationHubClientTypes.InstanceConfiguration?

        public init(
            instance: CostOptimizationHubClientTypes.InstanceConfiguration? = nil
        )
        {
            self.instance = instance
        }
    }

}

extension CostOptimizationHubClientTypes.Ec2InstanceSavingsPlans: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case costCalculation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let costCalculation = self.costCalculation {
            try encodeContainer.encode(costCalculation, forKey: .costCalculation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.Ec2InstanceSavingsPlansConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let costCalculationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.SavingsPlansCostCalculation.self, forKey: .costCalculation)
        costCalculation = costCalculationDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The EC2 instance Savings Plans recommendation details.
    public struct Ec2InstanceSavingsPlans: Swift.Equatable {
        /// The EC2 instance Savings Plans configuration used for recommendations.
        public var configuration: CostOptimizationHubClientTypes.Ec2InstanceSavingsPlansConfiguration?
        /// Cost impact of the Savings Plans purchase recommendation.
        public var costCalculation: CostOptimizationHubClientTypes.SavingsPlansCostCalculation?

        public init(
            configuration: CostOptimizationHubClientTypes.Ec2InstanceSavingsPlansConfiguration? = nil,
            costCalculation: CostOptimizationHubClientTypes.SavingsPlansCostCalculation? = nil
        )
        {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }
    }

}

extension CostOptimizationHubClientTypes.Ec2InstanceSavingsPlansConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountScope
        case hourlyCommitment
        case instanceFamily
        case paymentOption
        case savingsPlansRegion
        case term
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountScope = self.accountScope {
            try encodeContainer.encode(accountScope, forKey: .accountScope)
        }
        if let hourlyCommitment = self.hourlyCommitment {
            try encodeContainer.encode(hourlyCommitment, forKey: .hourlyCommitment)
        }
        if let instanceFamily = self.instanceFamily {
            try encodeContainer.encode(instanceFamily, forKey: .instanceFamily)
        }
        if let paymentOption = self.paymentOption {
            try encodeContainer.encode(paymentOption, forKey: .paymentOption)
        }
        if let savingsPlansRegion = self.savingsPlansRegion {
            try encodeContainer.encode(savingsPlansRegion, forKey: .savingsPlansRegion)
        }
        if let term = self.term {
            try encodeContainer.encode(term, forKey: .term)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let termDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .term)
        term = termDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let hourlyCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hourlyCommitment)
        hourlyCommitment = hourlyCommitmentDecoded
        let instanceFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceFamily)
        instanceFamily = instanceFamilyDecoded
        let savingsPlansRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .savingsPlansRegion)
        savingsPlansRegion = savingsPlansRegionDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The EC2 instance Savings Plans configuration used for recommendations.
    public struct Ec2InstanceSavingsPlansConfiguration: Swift.Equatable {
        /// The account scope that you want your recommendations for.
        public var accountScope: Swift.String?
        /// The hourly commitment for the Savings Plans type.
        public var hourlyCommitment: Swift.String?
        /// The instance family of the recommended Savings Plan.
        public var instanceFamily: Swift.String?
        /// The payment option for the commitment.
        public var paymentOption: Swift.String?
        /// The Amazon Web Services Region of the commitment.
        public var savingsPlansRegion: Swift.String?
        /// The Savings Plans recommendation term in years.
        public var term: Swift.String?

        public init(
            accountScope: Swift.String? = nil,
            hourlyCommitment: Swift.String? = nil,
            instanceFamily: Swift.String? = nil,
            paymentOption: Swift.String? = nil,
            savingsPlansRegion: Swift.String? = nil,
            term: Swift.String? = nil
        )
        {
            self.accountScope = accountScope
            self.hourlyCommitment = hourlyCommitment
            self.instanceFamily = instanceFamily
            self.paymentOption = paymentOption
            self.savingsPlansRegion = savingsPlansRegion
            self.term = term
        }
    }

}

extension CostOptimizationHubClientTypes.Ec2ReservedInstances: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case costCalculation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let costCalculation = self.costCalculation {
            try encodeContainer.encode(costCalculation, forKey: .costCalculation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.Ec2ReservedInstancesConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let costCalculationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ReservedInstancesCostCalculation.self, forKey: .costCalculation)
        costCalculation = costCalculationDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The EC2 reserved instances recommendation details.
    public struct Ec2ReservedInstances: Swift.Equatable {
        /// The EC2 reserved instances configuration used for recommendations.
        public var configuration: CostOptimizationHubClientTypes.Ec2ReservedInstancesConfiguration?
        /// Cost impact of the purchase recommendation.
        public var costCalculation: CostOptimizationHubClientTypes.ReservedInstancesCostCalculation?

        public init(
            configuration: CostOptimizationHubClientTypes.Ec2ReservedInstancesConfiguration? = nil,
            costCalculation: CostOptimizationHubClientTypes.ReservedInstancesCostCalculation? = nil
        )
        {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }
    }

}

extension CostOptimizationHubClientTypes.Ec2ReservedInstancesConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountScope
        case currentGeneration
        case instanceFamily
        case instanceType
        case monthlyRecurringCost
        case normalizedUnitsToPurchase
        case numberOfInstancesToPurchase
        case offeringClass
        case paymentOption
        case platform
        case reservedInstancesRegion
        case service
        case sizeFlexEligible
        case tenancy
        case term
        case upfrontCost
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountScope = self.accountScope {
            try encodeContainer.encode(accountScope, forKey: .accountScope)
        }
        if let currentGeneration = self.currentGeneration {
            try encodeContainer.encode(currentGeneration, forKey: .currentGeneration)
        }
        if let instanceFamily = self.instanceFamily {
            try encodeContainer.encode(instanceFamily, forKey: .instanceFamily)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let monthlyRecurringCost = self.monthlyRecurringCost {
            try encodeContainer.encode(monthlyRecurringCost, forKey: .monthlyRecurringCost)
        }
        if let normalizedUnitsToPurchase = self.normalizedUnitsToPurchase {
            try encodeContainer.encode(normalizedUnitsToPurchase, forKey: .normalizedUnitsToPurchase)
        }
        if let numberOfInstancesToPurchase = self.numberOfInstancesToPurchase {
            try encodeContainer.encode(numberOfInstancesToPurchase, forKey: .numberOfInstancesToPurchase)
        }
        if let offeringClass = self.offeringClass {
            try encodeContainer.encode(offeringClass, forKey: .offeringClass)
        }
        if let paymentOption = self.paymentOption {
            try encodeContainer.encode(paymentOption, forKey: .paymentOption)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let reservedInstancesRegion = self.reservedInstancesRegion {
            try encodeContainer.encode(reservedInstancesRegion, forKey: .reservedInstancesRegion)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let sizeFlexEligible = self.sizeFlexEligible {
            try encodeContainer.encode(sizeFlexEligible, forKey: .sizeFlexEligible)
        }
        if let tenancy = self.tenancy {
            try encodeContainer.encode(tenancy, forKey: .tenancy)
        }
        if let term = self.term {
            try encodeContainer.encode(term, forKey: .term)
        }
        if let upfrontCost = self.upfrontCost {
            try encodeContainer.encode(upfrontCost, forKey: .upfrontCost)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let normalizedUnitsToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .normalizedUnitsToPurchase)
        normalizedUnitsToPurchase = normalizedUnitsToPurchaseDecoded
        let termDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .term)
        term = termDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let numberOfInstancesToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .numberOfInstancesToPurchase)
        numberOfInstancesToPurchase = numberOfInstancesToPurchaseDecoded
        let offeringClassDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringClass)
        offeringClass = offeringClassDecoded
        let instanceFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceFamily)
        instanceFamily = instanceFamilyDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let reservedInstancesRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedInstancesRegion)
        reservedInstancesRegion = reservedInstancesRegionDecoded
        let currentGenerationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentGeneration)
        currentGeneration = currentGenerationDecoded
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let tenancyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tenancy)
        tenancy = tenancyDecoded
        let sizeFlexEligibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sizeFlexEligible)
        sizeFlexEligible = sizeFlexEligibleDecoded
        let upfrontCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upfrontCost)
        upfrontCost = upfrontCostDecoded
        let monthlyRecurringCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monthlyRecurringCost)
        monthlyRecurringCost = monthlyRecurringCostDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The EC2 reserved instances configuration used for recommendations.
    public struct Ec2ReservedInstancesConfiguration: Swift.Equatable {
        /// The account scope that you want your recommendations for.
        public var accountScope: Swift.String?
        /// Determines whether the recommendation is for a current generation instance.
        public var currentGeneration: Swift.String?
        /// The instance family of the recommended reservation.
        public var instanceFamily: Swift.String?
        /// The type of instance that Amazon Web Services recommends.
        public var instanceType: Swift.String?
        /// How much purchasing reserved instances costs you on a monthly basis.
        public var monthlyRecurringCost: Swift.String?
        /// The number of normalized units that Amazon Web Services recommends that you purchase.
        public var normalizedUnitsToPurchase: Swift.String?
        /// The number of instances that Amazon Web Services recommends that you purchase.
        public var numberOfInstancesToPurchase: Swift.String?
        /// Indicates whether the recommendation is for standard or convertible reservations.
        public var offeringClass: Swift.String?
        /// The payment option for the commitment.
        public var paymentOption: Swift.String?
        /// The platform of the recommended reservation. The platform is the specific combination of operating system, license model, and software on an instance.
        public var platform: Swift.String?
        /// The Amazon Web Services Region of the commitment.
        public var reservedInstancesRegion: Swift.String?
        /// The service that you want your recommendations for.
        public var service: Swift.String?
        /// Determines whether the recommendation is size flexible.
        public var sizeFlexEligible: Swift.Bool?
        /// Determines whether the recommended reservation is dedicated or shared.
        public var tenancy: Swift.String?
        /// The reserved instances recommendation term in years.
        public var term: Swift.String?
        /// How much purchasing this instance costs you upfront.
        public var upfrontCost: Swift.String?

        public init(
            accountScope: Swift.String? = nil,
            currentGeneration: Swift.String? = nil,
            instanceFamily: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            monthlyRecurringCost: Swift.String? = nil,
            normalizedUnitsToPurchase: Swift.String? = nil,
            numberOfInstancesToPurchase: Swift.String? = nil,
            offeringClass: Swift.String? = nil,
            paymentOption: Swift.String? = nil,
            platform: Swift.String? = nil,
            reservedInstancesRegion: Swift.String? = nil,
            service: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool? = nil,
            tenancy: Swift.String? = nil,
            term: Swift.String? = nil,
            upfrontCost: Swift.String? = nil
        )
        {
            self.accountScope = accountScope
            self.currentGeneration = currentGeneration
            self.instanceFamily = instanceFamily
            self.instanceType = instanceType
            self.monthlyRecurringCost = monthlyRecurringCost
            self.normalizedUnitsToPurchase = normalizedUnitsToPurchase
            self.numberOfInstancesToPurchase = numberOfInstancesToPurchase
            self.offeringClass = offeringClass
            self.paymentOption = paymentOption
            self.platform = platform
            self.reservedInstancesRegion = reservedInstancesRegion
            self.service = service
            self.sizeFlexEligible = sizeFlexEligible
            self.tenancy = tenancy
            self.term = term
            self.upfrontCost = upfrontCost
        }
    }

}

extension CostOptimizationHubClientTypes.EcsService: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case costCalculation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let costCalculation = self.costCalculation {
            try encodeContainer.encode(costCalculation, forKey: .costCalculation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.EcsServiceConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let costCalculationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ResourceCostCalculation.self, forKey: .costCalculation)
        costCalculation = costCalculationDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The ECS service recommendation details.
    public struct EcsService: Swift.Equatable {
        /// The ECS service configuration used for recommendations.
        public var configuration: CostOptimizationHubClientTypes.EcsServiceConfiguration?
        /// Cost impact of the recommendation.
        public var costCalculation: CostOptimizationHubClientTypes.ResourceCostCalculation?

        public init(
            configuration: CostOptimizationHubClientTypes.EcsServiceConfiguration? = nil,
            costCalculation: CostOptimizationHubClientTypes.ResourceCostCalculation? = nil
        )
        {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }
    }

}

extension CostOptimizationHubClientTypes.EcsServiceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compute
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compute = self.compute {
            try encodeContainer.encode(compute, forKey: .compute)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computeDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ComputeConfiguration.self, forKey: .compute)
        compute = computeDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The ECS service configuration used for recommendations.
    public struct EcsServiceConfiguration: Swift.Equatable {
        /// Details about the compute configuration.
        public var compute: CostOptimizationHubClientTypes.ComputeConfiguration?

        public init(
            compute: CostOptimizationHubClientTypes.ComputeConfiguration? = nil
        )
        {
            self.compute = compute
        }
    }

}

extension CostOptimizationHubClientTypes.ElastiCacheReservedInstances: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case costCalculation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let costCalculation = self.costCalculation {
            try encodeContainer.encode(costCalculation, forKey: .costCalculation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ElastiCacheReservedInstancesConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let costCalculationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ReservedInstancesCostCalculation.self, forKey: .costCalculation)
        costCalculation = costCalculationDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The ElastiCache reserved instances recommendation details.
    public struct ElastiCacheReservedInstances: Swift.Equatable {
        /// The ElastiCache reserved instances configuration used for recommendations.
        public var configuration: CostOptimizationHubClientTypes.ElastiCacheReservedInstancesConfiguration?
        /// Cost impact of the purchase recommendation.
        public var costCalculation: CostOptimizationHubClientTypes.ReservedInstancesCostCalculation?

        public init(
            configuration: CostOptimizationHubClientTypes.ElastiCacheReservedInstancesConfiguration? = nil,
            costCalculation: CostOptimizationHubClientTypes.ReservedInstancesCostCalculation? = nil
        )
        {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }
    }

}

extension CostOptimizationHubClientTypes.ElastiCacheReservedInstancesConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountScope
        case currentGeneration
        case instanceFamily
        case instanceType
        case monthlyRecurringCost
        case normalizedUnitsToPurchase
        case numberOfInstancesToPurchase
        case paymentOption
        case reservedInstancesRegion
        case service
        case sizeFlexEligible
        case term
        case upfrontCost
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountScope = self.accountScope {
            try encodeContainer.encode(accountScope, forKey: .accountScope)
        }
        if let currentGeneration = self.currentGeneration {
            try encodeContainer.encode(currentGeneration, forKey: .currentGeneration)
        }
        if let instanceFamily = self.instanceFamily {
            try encodeContainer.encode(instanceFamily, forKey: .instanceFamily)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let monthlyRecurringCost = self.monthlyRecurringCost {
            try encodeContainer.encode(monthlyRecurringCost, forKey: .monthlyRecurringCost)
        }
        if let normalizedUnitsToPurchase = self.normalizedUnitsToPurchase {
            try encodeContainer.encode(normalizedUnitsToPurchase, forKey: .normalizedUnitsToPurchase)
        }
        if let numberOfInstancesToPurchase = self.numberOfInstancesToPurchase {
            try encodeContainer.encode(numberOfInstancesToPurchase, forKey: .numberOfInstancesToPurchase)
        }
        if let paymentOption = self.paymentOption {
            try encodeContainer.encode(paymentOption, forKey: .paymentOption)
        }
        if let reservedInstancesRegion = self.reservedInstancesRegion {
            try encodeContainer.encode(reservedInstancesRegion, forKey: .reservedInstancesRegion)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let sizeFlexEligible = self.sizeFlexEligible {
            try encodeContainer.encode(sizeFlexEligible, forKey: .sizeFlexEligible)
        }
        if let term = self.term {
            try encodeContainer.encode(term, forKey: .term)
        }
        if let upfrontCost = self.upfrontCost {
            try encodeContainer.encode(upfrontCost, forKey: .upfrontCost)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let normalizedUnitsToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .normalizedUnitsToPurchase)
        normalizedUnitsToPurchase = normalizedUnitsToPurchaseDecoded
        let termDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .term)
        term = termDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let numberOfInstancesToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .numberOfInstancesToPurchase)
        numberOfInstancesToPurchase = numberOfInstancesToPurchaseDecoded
        let instanceFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceFamily)
        instanceFamily = instanceFamilyDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let reservedInstancesRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedInstancesRegion)
        reservedInstancesRegion = reservedInstancesRegionDecoded
        let currentGenerationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentGeneration)
        currentGeneration = currentGenerationDecoded
        let sizeFlexEligibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sizeFlexEligible)
        sizeFlexEligible = sizeFlexEligibleDecoded
        let upfrontCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upfrontCost)
        upfrontCost = upfrontCostDecoded
        let monthlyRecurringCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monthlyRecurringCost)
        monthlyRecurringCost = monthlyRecurringCostDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The ElastiCache reserved instances configuration used for recommendations.
    public struct ElastiCacheReservedInstancesConfiguration: Swift.Equatable {
        /// The account scope that you want your recommendations for.
        public var accountScope: Swift.String?
        /// Determines whether the recommendation is for a current generation instance.
        public var currentGeneration: Swift.String?
        /// The instance family of the recommended reservation.
        public var instanceFamily: Swift.String?
        /// The type of instance that Amazon Web Services recommends.
        public var instanceType: Swift.String?
        /// How much purchasing reserved instances costs you on a monthly basis.
        public var monthlyRecurringCost: Swift.String?
        /// The number of normalized units that Amazon Web Services recommends that you purchase.
        public var normalizedUnitsToPurchase: Swift.String?
        /// The number of instances that Amazon Web Services recommends that you purchase.
        public var numberOfInstancesToPurchase: Swift.String?
        /// The payment option for the commitment.
        public var paymentOption: Swift.String?
        /// The Amazon Web Services Region of the commitment.
        public var reservedInstancesRegion: Swift.String?
        /// The service that you want your recommendations for.
        public var service: Swift.String?
        /// Determines whether the recommendation is size flexible.
        public var sizeFlexEligible: Swift.Bool?
        /// The reserved instances recommendation term in years.
        public var term: Swift.String?
        /// How much purchasing this instance costs you upfront.
        public var upfrontCost: Swift.String?

        public init(
            accountScope: Swift.String? = nil,
            currentGeneration: Swift.String? = nil,
            instanceFamily: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            monthlyRecurringCost: Swift.String? = nil,
            normalizedUnitsToPurchase: Swift.String? = nil,
            numberOfInstancesToPurchase: Swift.String? = nil,
            paymentOption: Swift.String? = nil,
            reservedInstancesRegion: Swift.String? = nil,
            service: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool? = nil,
            term: Swift.String? = nil,
            upfrontCost: Swift.String? = nil
        )
        {
            self.accountScope = accountScope
            self.currentGeneration = currentGeneration
            self.instanceFamily = instanceFamily
            self.instanceType = instanceType
            self.monthlyRecurringCost = monthlyRecurringCost
            self.normalizedUnitsToPurchase = normalizedUnitsToPurchase
            self.numberOfInstancesToPurchase = numberOfInstancesToPurchase
            self.paymentOption = paymentOption
            self.reservedInstancesRegion = reservedInstancesRegion
            self.service = service
            self.sizeFlexEligible = sizeFlexEligible
            self.term = term
            self.upfrontCost = upfrontCost
        }
    }

}

extension CostOptimizationHubClientTypes {
    public enum EnrollmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [EnrollmentStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .inactive: return "Inactive"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnrollmentStatus(rawValue: rawValue) ?? EnrollmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension CostOptimizationHubClientTypes.EstimatedDiscounts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case otherDiscount
        case reservedInstancesDiscount
        case savingsPlansDiscount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let otherDiscount = self.otherDiscount {
            try encodeContainer.encode(otherDiscount, forKey: .otherDiscount)
        }
        if let reservedInstancesDiscount = self.reservedInstancesDiscount {
            try encodeContainer.encode(reservedInstancesDiscount, forKey: .reservedInstancesDiscount)
        }
        if let savingsPlansDiscount = self.savingsPlansDiscount {
            try encodeContainer.encode(savingsPlansDiscount, forKey: .savingsPlansDiscount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlansDiscountDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .savingsPlansDiscount)
        savingsPlansDiscount = savingsPlansDiscountDecoded
        let reservedInstancesDiscountDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .reservedInstancesDiscount)
        reservedInstancesDiscount = reservedInstancesDiscountDecoded
        let otherDiscountDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .otherDiscount)
        otherDiscount = otherDiscountDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// Estimated discount details of the current and recommended resource configuration for a recommendation.
    public struct EstimatedDiscounts: Swift.Equatable {
        /// Estimated other discounts include all discounts that are not itemized. Itemized discounts include reservedInstanceDiscount and savingsPlansDiscount.
        public var otherDiscount: Swift.Double?
        /// Estimated reserved instance discounts.
        public var reservedInstancesDiscount: Swift.Double?
        /// Estimated Savings Plans discounts.
        public var savingsPlansDiscount: Swift.Double?

        public init(
            otherDiscount: Swift.Double? = nil,
            reservedInstancesDiscount: Swift.Double? = nil,
            savingsPlansDiscount: Swift.Double? = nil
        )
        {
            self.otherDiscount = otherDiscount
            self.reservedInstancesDiscount = reservedInstancesDiscount
            self.savingsPlansDiscount = savingsPlansDiscount
        }
    }

}

extension CostOptimizationHubClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds
        case actionTypes
        case implementationEfforts
        case recommendationIds
        case regions
        case resourceArns
        case resourceIds
        case resourceTypes
        case restartNeeded
        case rollbackPossible
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
        if let actionTypes = actionTypes {
            var actionTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actionTypes)
            for actiontype0 in actionTypes {
                try actionTypesContainer.encode(actiontype0.rawValue)
            }
        }
        if let implementationEfforts = implementationEfforts {
            var implementationEffortsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .implementationEfforts)
            for implementationeffort0 in implementationEfforts {
                try implementationEffortsContainer.encode(implementationeffort0.rawValue)
            }
        }
        if let recommendationIds = recommendationIds {
            var recommendationIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recommendationIds)
            for string0 in recommendationIds {
                try recommendationIdsContainer.encode(string0)
            }
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for string0 in regions {
                try regionsContainer.encode(string0)
            }
        }
        if let resourceArns = resourceArns {
            var resourceArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceArns)
            for string0 in resourceArns {
                try resourceArnsContainer.encode(string0)
            }
        }
        if let resourceIds = resourceIds {
            var resourceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceIds)
            for string0 in resourceIds {
                try resourceIdsContainer.encode(string0)
            }
        }
        if let resourceTypes = resourceTypes {
            var resourceTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resourceTypes)
            for resourcetype0 in resourceTypes {
                try resourceTypesContainer.encode(resourcetype0.rawValue)
            }
        }
        if let restartNeeded = self.restartNeeded {
            try encodeContainer.encode(restartNeeded, forKey: .restartNeeded)
        }
        if let rollbackPossible = self.rollbackPossible {
            try encodeContainer.encode(rollbackPossible, forKey: .rollbackPossible)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let restartNeededDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .restartNeeded)
        restartNeeded = restartNeededDecoded
        let rollbackPossibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rollbackPossible)
        rollbackPossible = rollbackPossibleDecoded
        let implementationEffortsContainer = try containerValues.decodeIfPresent([CostOptimizationHubClientTypes.ImplementationEffort?].self, forKey: .implementationEfforts)
        var implementationEffortsDecoded0:[CostOptimizationHubClientTypes.ImplementationEffort]? = nil
        if let implementationEffortsContainer = implementationEffortsContainer {
            implementationEffortsDecoded0 = [CostOptimizationHubClientTypes.ImplementationEffort]()
            for enum0 in implementationEffortsContainer {
                if let enum0 = enum0 {
                    implementationEffortsDecoded0?.append(enum0)
                }
            }
        }
        implementationEfforts = implementationEffortsDecoded0
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let resourceTypesContainer = try containerValues.decodeIfPresent([CostOptimizationHubClientTypes.ResourceType?].self, forKey: .resourceTypes)
        var resourceTypesDecoded0:[CostOptimizationHubClientTypes.ResourceType]? = nil
        if let resourceTypesContainer = resourceTypesContainer {
            resourceTypesDecoded0 = [CostOptimizationHubClientTypes.ResourceType]()
            for enum0 in resourceTypesContainer {
                if let enum0 = enum0 {
                    resourceTypesDecoded0?.append(enum0)
                }
            }
        }
        resourceTypes = resourceTypesDecoded0
        let actionTypesContainer = try containerValues.decodeIfPresent([CostOptimizationHubClientTypes.ActionType?].self, forKey: .actionTypes)
        var actionTypesDecoded0:[CostOptimizationHubClientTypes.ActionType]? = nil
        if let actionTypesContainer = actionTypesContainer {
            actionTypesDecoded0 = [CostOptimizationHubClientTypes.ActionType]()
            for enum0 in actionTypesContainer {
                if let enum0 = enum0 {
                    actionTypesDecoded0?.append(enum0)
                }
            }
        }
        actionTypes = actionTypesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([CostOptimizationHubClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CostOptimizationHubClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CostOptimizationHubClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let resourceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceIds)
        var resourceIdsDecoded0:[Swift.String]? = nil
        if let resourceIdsContainer = resourceIdsContainer {
            resourceIdsDecoded0 = [Swift.String]()
            for string0 in resourceIdsContainer {
                if let string0 = string0 {
                    resourceIdsDecoded0?.append(string0)
                }
            }
        }
        resourceIds = resourceIdsDecoded0
        let resourceArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resourceArns)
        var resourceArnsDecoded0:[Swift.String]? = nil
        if let resourceArnsContainer = resourceArnsContainer {
            resourceArnsDecoded0 = [Swift.String]()
            for string0 in resourceArnsContainer {
                if let string0 = string0 {
                    resourceArnsDecoded0?.append(string0)
                }
            }
        }
        resourceArns = resourceArnsDecoded0
        let recommendationIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recommendationIds)
        var recommendationIdsDecoded0:[Swift.String]? = nil
        if let recommendationIdsContainer = recommendationIdsContainer {
            recommendationIdsDecoded0 = [Swift.String]()
            for string0 in recommendationIdsContainer {
                if let string0 = string0 {
                    recommendationIdsDecoded0?.append(string0)
                }
            }
        }
        recommendationIds = recommendationIdsDecoded0
    }
}

extension CostOptimizationHubClientTypes {
    /// Describes a filter that returns a more specific list of recommendations. Filters recommendations by different dimensions.
    public struct Filter: Swift.Equatable {
        /// The account that the recommendation is for.
        public var accountIds: [Swift.String]?
        /// The type of action you can take by adopting the recommendation.
        public var actionTypes: [CostOptimizationHubClientTypes.ActionType]?
        /// The effort required to implement the recommendation.
        public var implementationEfforts: [CostOptimizationHubClientTypes.ImplementationEffort]?
        /// The IDs for the recommendations.
        public var recommendationIds: [Swift.String]?
        /// The Amazon Web Services Region of the resource.
        public var regions: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the recommendation.
        public var resourceArns: [Swift.String]?
        /// The resource ID of the recommendation.
        public var resourceIds: [Swift.String]?
        /// The resource type of the recommendation.
        public var resourceTypes: [CostOptimizationHubClientTypes.ResourceType]?
        /// Whether or not implementing the recommendation requires a restart.
        public var restartNeeded: Swift.Bool?
        /// Whether or not implementing the recommendation can be rolled back.
        public var rollbackPossible: Swift.Bool?
        /// A list of tags assigned to the recommendation.
        public var tags: [CostOptimizationHubClientTypes.Tag]?

        public init(
            accountIds: [Swift.String]? = nil,
            actionTypes: [CostOptimizationHubClientTypes.ActionType]? = nil,
            implementationEfforts: [CostOptimizationHubClientTypes.ImplementationEffort]? = nil,
            recommendationIds: [Swift.String]? = nil,
            regions: [Swift.String]? = nil,
            resourceArns: [Swift.String]? = nil,
            resourceIds: [Swift.String]? = nil,
            resourceTypes: [CostOptimizationHubClientTypes.ResourceType]? = nil,
            restartNeeded: Swift.Bool? = nil,
            rollbackPossible: Swift.Bool? = nil,
            tags: [CostOptimizationHubClientTypes.Tag]? = nil
        )
        {
            self.accountIds = accountIds
            self.actionTypes = actionTypes
            self.implementationEfforts = implementationEfforts
            self.recommendationIds = recommendationIds
            self.regions = regions
            self.resourceArns = resourceArns
            self.resourceIds = resourceIds
            self.resourceTypes = resourceTypes
            self.restartNeeded = restartNeeded
            self.rollbackPossible = rollbackPossible
            self.tags = tags
        }
    }

}

extension GetPreferencesInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetPreferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPreferencesInput: Swift.Equatable {

    public init() { }
}

struct GetPreferencesInputBody: Swift.Equatable {
}

extension GetPreferencesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPreferencesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPreferencesOutputBody = try responseDecoder.decode(responseBody: data)
            self.memberAccountDiscountVisibility = output.memberAccountDiscountVisibility
            self.savingsEstimationMode = output.savingsEstimationMode
        } else {
            self.memberAccountDiscountVisibility = nil
            self.savingsEstimationMode = nil
        }
    }
}

public struct GetPreferencesOutput: Swift.Equatable {
    /// Retrieves the status of the "member account discount visibility" preference.
    public var memberAccountDiscountVisibility: CostOptimizationHubClientTypes.MemberAccountDiscountVisibility?
    /// Retrieves the status of the "savings estimation mode" preference.
    public var savingsEstimationMode: CostOptimizationHubClientTypes.SavingsEstimationMode?

    public init(
        memberAccountDiscountVisibility: CostOptimizationHubClientTypes.MemberAccountDiscountVisibility? = nil,
        savingsEstimationMode: CostOptimizationHubClientTypes.SavingsEstimationMode? = nil
    )
    {
        self.memberAccountDiscountVisibility = memberAccountDiscountVisibility
        self.savingsEstimationMode = savingsEstimationMode
    }
}

struct GetPreferencesOutputBody: Swift.Equatable {
    let savingsEstimationMode: CostOptimizationHubClientTypes.SavingsEstimationMode?
    let memberAccountDiscountVisibility: CostOptimizationHubClientTypes.MemberAccountDiscountVisibility?
}

extension GetPreferencesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountDiscountVisibility
        case savingsEstimationMode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsEstimationModeDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.SavingsEstimationMode.self, forKey: .savingsEstimationMode)
        savingsEstimationMode = savingsEstimationModeDecoded
        let memberAccountDiscountVisibilityDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.MemberAccountDiscountVisibility.self, forKey: .memberAccountDiscountVisibility)
        memberAccountDiscountVisibility = memberAccountDiscountVisibilityDecoded
    }
}

enum GetPreferencesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRecommendationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommendationId = self.recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
    }
}

extension GetRecommendationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRecommendationInput: Swift.Equatable {
    /// The ID for the recommendation.
    /// This member is required.
    public var recommendationId: Swift.String?

    public init(
        recommendationId: Swift.String? = nil
    )
    {
        self.recommendationId = recommendationId
    }
}

struct GetRecommendationInputBody: Swift.Equatable {
    let recommendationId: Swift.String?
}

extension GetRecommendationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendationId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
    }
}

extension GetRecommendationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRecommendationOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.actionType = output.actionType
            self.costCalculationLookbackPeriodInDays = output.costCalculationLookbackPeriodInDays
            self.currencyCode = output.currencyCode
            self.currentResourceDetails = output.currentResourceDetails
            self.currentResourceType = output.currentResourceType
            self.estimatedMonthlyCost = output.estimatedMonthlyCost
            self.estimatedMonthlySavings = output.estimatedMonthlySavings
            self.estimatedSavingsOverCostCalculationLookbackPeriod = output.estimatedSavingsOverCostCalculationLookbackPeriod
            self.estimatedSavingsPercentage = output.estimatedSavingsPercentage
            self.implementationEffort = output.implementationEffort
            self.lastRefreshTimestamp = output.lastRefreshTimestamp
            self.recommendationId = output.recommendationId
            self.recommendationLookbackPeriodInDays = output.recommendationLookbackPeriodInDays
            self.recommendedResourceDetails = output.recommendedResourceDetails
            self.recommendedResourceType = output.recommendedResourceType
            self.region = output.region
            self.resourceArn = output.resourceArn
            self.resourceId = output.resourceId
            self.restartNeeded = output.restartNeeded
            self.rollbackPossible = output.rollbackPossible
            self.source = output.source
            self.tags = output.tags
        } else {
            self.accountId = nil
            self.actionType = nil
            self.costCalculationLookbackPeriodInDays = nil
            self.currencyCode = nil
            self.currentResourceDetails = nil
            self.currentResourceType = nil
            self.estimatedMonthlyCost = nil
            self.estimatedMonthlySavings = nil
            self.estimatedSavingsOverCostCalculationLookbackPeriod = nil
            self.estimatedSavingsPercentage = nil
            self.implementationEffort = nil
            self.lastRefreshTimestamp = nil
            self.recommendationId = nil
            self.recommendationLookbackPeriodInDays = nil
            self.recommendedResourceDetails = nil
            self.recommendedResourceType = nil
            self.region = nil
            self.resourceArn = nil
            self.resourceId = nil
            self.restartNeeded = nil
            self.rollbackPossible = nil
            self.source = nil
            self.tags = nil
        }
    }
}

public struct GetRecommendationOutput: Swift.Equatable {
    /// The account that the recommendation is for.
    public var accountId: Swift.String?
    /// The type of action you can take by adopting the recommendation.
    public var actionType: CostOptimizationHubClientTypes.ActionType?
    /// The lookback period used to calculate cost impact for a recommendation.
    public var costCalculationLookbackPeriodInDays: Swift.Int?
    /// The currency code used for the recommendation.
    public var currencyCode: Swift.String?
    /// The details for the resource.
    public var currentResourceDetails: CostOptimizationHubClientTypes.ResourceDetails?
    /// The type of resource.
    public var currentResourceType: CostOptimizationHubClientTypes.ResourceType?
    /// The estimated monthly cost of the recommendation.
    public var estimatedMonthlyCost: Swift.Double?
    /// The estimated monthly savings amount for the recommendation.
    public var estimatedMonthlySavings: Swift.Double?
    /// The estimated savings amount over the lookback period used to calculate cost impact for a recommendation.
    public var estimatedSavingsOverCostCalculationLookbackPeriod: Swift.Double?
    /// The estimated savings percentage relative to the total cost over the cost calculation lookback period.
    public var estimatedSavingsPercentage: Swift.Double?
    /// The effort required to implement the recommendation.
    public var implementationEffort: CostOptimizationHubClientTypes.ImplementationEffort?
    /// The time when the recommendation was last generated.
    public var lastRefreshTimestamp: ClientRuntime.Date?
    /// The ID for the recommendation.
    public var recommendationId: Swift.String?
    /// The lookback period that's used to generate the recommendation.
    public var recommendationLookbackPeriodInDays: Swift.Int?
    /// The details about the recommended resource.
    public var recommendedResourceDetails: CostOptimizationHubClientTypes.ResourceDetails?
    /// The resource type of the recommendation.
    public var recommendedResourceType: CostOptimizationHubClientTypes.ResourceType?
    /// The Amazon Web Services Region of the resource.
    public var region: Swift.String?
    /// The Amazon Resource Name (ARN) of the resource.
    public var resourceArn: Swift.String?
    /// The unique identifier for the resource. This is the same as the Amazon Resource Name (ARN), if available.
    public var resourceId: Swift.String?
    /// Whether or not implementing the recommendation requires a restart.
    public var restartNeeded: Swift.Bool?
    /// Whether or not implementing the recommendation can be rolled back.
    public var rollbackPossible: Swift.Bool?
    /// The source of the recommendation.
    public var source: CostOptimizationHubClientTypes.Source?
    /// A list of tags associated with the resource for which the recommendation exists.
    public var tags: [CostOptimizationHubClientTypes.Tag]?

    public init(
        accountId: Swift.String? = nil,
        actionType: CostOptimizationHubClientTypes.ActionType? = nil,
        costCalculationLookbackPeriodInDays: Swift.Int? = nil,
        currencyCode: Swift.String? = nil,
        currentResourceDetails: CostOptimizationHubClientTypes.ResourceDetails? = nil,
        currentResourceType: CostOptimizationHubClientTypes.ResourceType? = nil,
        estimatedMonthlyCost: Swift.Double? = nil,
        estimatedMonthlySavings: Swift.Double? = nil,
        estimatedSavingsOverCostCalculationLookbackPeriod: Swift.Double? = nil,
        estimatedSavingsPercentage: Swift.Double? = nil,
        implementationEffort: CostOptimizationHubClientTypes.ImplementationEffort? = nil,
        lastRefreshTimestamp: ClientRuntime.Date? = nil,
        recommendationId: Swift.String? = nil,
        recommendationLookbackPeriodInDays: Swift.Int? = nil,
        recommendedResourceDetails: CostOptimizationHubClientTypes.ResourceDetails? = nil,
        recommendedResourceType: CostOptimizationHubClientTypes.ResourceType? = nil,
        region: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        restartNeeded: Swift.Bool? = nil,
        rollbackPossible: Swift.Bool? = nil,
        source: CostOptimizationHubClientTypes.Source? = nil,
        tags: [CostOptimizationHubClientTypes.Tag]? = nil
    )
    {
        self.accountId = accountId
        self.actionType = actionType
        self.costCalculationLookbackPeriodInDays = costCalculationLookbackPeriodInDays
        self.currencyCode = currencyCode
        self.currentResourceDetails = currentResourceDetails
        self.currentResourceType = currentResourceType
        self.estimatedMonthlyCost = estimatedMonthlyCost
        self.estimatedMonthlySavings = estimatedMonthlySavings
        self.estimatedSavingsOverCostCalculationLookbackPeriod = estimatedSavingsOverCostCalculationLookbackPeriod
        self.estimatedSavingsPercentage = estimatedSavingsPercentage
        self.implementationEffort = implementationEffort
        self.lastRefreshTimestamp = lastRefreshTimestamp
        self.recommendationId = recommendationId
        self.recommendationLookbackPeriodInDays = recommendationLookbackPeriodInDays
        self.recommendedResourceDetails = recommendedResourceDetails
        self.recommendedResourceType = recommendedResourceType
        self.region = region
        self.resourceArn = resourceArn
        self.resourceId = resourceId
        self.restartNeeded = restartNeeded
        self.rollbackPossible = rollbackPossible
        self.source = source
        self.tags = tags
    }
}

struct GetRecommendationOutputBody: Swift.Equatable {
    let recommendationId: Swift.String?
    let resourceId: Swift.String?
    let resourceArn: Swift.String?
    let accountId: Swift.String?
    let currencyCode: Swift.String?
    let recommendationLookbackPeriodInDays: Swift.Int?
    let costCalculationLookbackPeriodInDays: Swift.Int?
    let estimatedSavingsPercentage: Swift.Double?
    let estimatedSavingsOverCostCalculationLookbackPeriod: Swift.Double?
    let currentResourceType: CostOptimizationHubClientTypes.ResourceType?
    let recommendedResourceType: CostOptimizationHubClientTypes.ResourceType?
    let region: Swift.String?
    let source: CostOptimizationHubClientTypes.Source?
    let lastRefreshTimestamp: ClientRuntime.Date?
    let estimatedMonthlySavings: Swift.Double?
    let estimatedMonthlyCost: Swift.Double?
    let implementationEffort: CostOptimizationHubClientTypes.ImplementationEffort?
    let restartNeeded: Swift.Bool?
    let actionType: CostOptimizationHubClientTypes.ActionType?
    let rollbackPossible: Swift.Bool?
    let currentResourceDetails: CostOptimizationHubClientTypes.ResourceDetails?
    let recommendedResourceDetails: CostOptimizationHubClientTypes.ResourceDetails?
    let tags: [CostOptimizationHubClientTypes.Tag]?
}

extension GetRecommendationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case actionType
        case costCalculationLookbackPeriodInDays
        case currencyCode
        case currentResourceDetails
        case currentResourceType
        case estimatedMonthlyCost
        case estimatedMonthlySavings
        case estimatedSavingsOverCostCalculationLookbackPeriod
        case estimatedSavingsPercentage
        case implementationEffort
        case lastRefreshTimestamp
        case recommendationId
        case recommendationLookbackPeriodInDays
        case recommendedResourceDetails
        case recommendedResourceType
        case region
        case resourceArn
        case resourceId
        case restartNeeded
        case rollbackPossible
        case source
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let recommendationLookbackPeriodInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recommendationLookbackPeriodInDays)
        recommendationLookbackPeriodInDays = recommendationLookbackPeriodInDaysDecoded
        let costCalculationLookbackPeriodInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .costCalculationLookbackPeriodInDays)
        costCalculationLookbackPeriodInDays = costCalculationLookbackPeriodInDaysDecoded
        let estimatedSavingsPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedSavingsPercentage)
        estimatedSavingsPercentage = estimatedSavingsPercentageDecoded
        let estimatedSavingsOverCostCalculationLookbackPeriodDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedSavingsOverCostCalculationLookbackPeriod)
        estimatedSavingsOverCostCalculationLookbackPeriod = estimatedSavingsOverCostCalculationLookbackPeriodDecoded
        let currentResourceTypeDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ResourceType.self, forKey: .currentResourceType)
        currentResourceType = currentResourceTypeDecoded
        let recommendedResourceTypeDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ResourceType.self, forKey: .recommendedResourceType)
        recommendedResourceType = recommendedResourceTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let lastRefreshTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastRefreshTimestamp)
        lastRefreshTimestamp = lastRefreshTimestampDecoded
        let estimatedMonthlySavingsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedMonthlySavings)
        estimatedMonthlySavings = estimatedMonthlySavingsDecoded
        let estimatedMonthlyCostDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedMonthlyCost)
        estimatedMonthlyCost = estimatedMonthlyCostDecoded
        let implementationEffortDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ImplementationEffort.self, forKey: .implementationEffort)
        implementationEffort = implementationEffortDecoded
        let restartNeededDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .restartNeeded)
        restartNeeded = restartNeededDecoded
        let actionTypeDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let rollbackPossibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rollbackPossible)
        rollbackPossible = rollbackPossibleDecoded
        let currentResourceDetailsDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ResourceDetails.self, forKey: .currentResourceDetails)
        currentResourceDetails = currentResourceDetailsDecoded
        let recommendedResourceDetailsDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ResourceDetails.self, forKey: .recommendedResourceDetails)
        recommendedResourceDetails = recommendedResourceDetailsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CostOptimizationHubClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CostOptimizationHubClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CostOptimizationHubClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetRecommendationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CostOptimizationHubClientTypes {
    public enum ImplementationEffort: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case veryHigh
        case veryLow
        case sdkUnknown(Swift.String)

        public static var allCases: [ImplementationEffort] {
            return [
                .high,
                .low,
                .medium,
                .veryHigh,
                .veryLow,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "High"
            case .low: return "Low"
            case .medium: return "Medium"
            case .veryHigh: return "VeryHigh"
            case .veryLow: return "VeryLow"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImplementationEffort(rawValue: rawValue) ?? ImplementationEffort.sdkUnknown(rawValue)
        }
    }
}

extension CostOptimizationHubClientTypes.InstanceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The Instance configuration used for recommendations.
    public struct InstanceConfiguration: Swift.Equatable {
        /// Details about the type.
        public var type: Swift.String?

        public init(
            type: Swift.String? = nil
        )
        {
            self.type = type
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An error on the server occurred during the processing of your request. Try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CostOptimizationHubClientTypes.LambdaFunction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case costCalculation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let costCalculation = self.costCalculation {
            try encodeContainer.encode(costCalculation, forKey: .costCalculation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.LambdaFunctionConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let costCalculationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ResourceCostCalculation.self, forKey: .costCalculation)
        costCalculation = costCalculationDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The Lambda function recommendation details.
    public struct LambdaFunction: Swift.Equatable {
        /// The Lambda function configuration used for recommendations.
        public var configuration: CostOptimizationHubClientTypes.LambdaFunctionConfiguration?
        /// Cost impact of the recommendation.
        public var costCalculation: CostOptimizationHubClientTypes.ResourceCostCalculation?

        public init(
            configuration: CostOptimizationHubClientTypes.LambdaFunctionConfiguration? = nil,
            costCalculation: CostOptimizationHubClientTypes.ResourceCostCalculation? = nil
        )
        {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }
    }

}

extension CostOptimizationHubClientTypes.LambdaFunctionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case compute
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let compute = self.compute {
            try encodeContainer.encode(compute, forKey: .compute)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computeDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ComputeConfiguration.self, forKey: .compute)
        compute = computeDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The Lambda function configuration used for recommendations.
    public struct LambdaFunctionConfiguration: Swift.Equatable {
        /// Details about the compute configuration.
        public var compute: CostOptimizationHubClientTypes.ComputeConfiguration?

        public init(
            compute: CostOptimizationHubClientTypes.ComputeConfiguration? = nil
        )
        {
            self.compute = compute
        }
    }

}

extension ListEnrollmentStatusesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case includeOrganizationInfo
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let includeOrganizationInfo = self.includeOrganizationInfo {
            try encodeContainer.encode(includeOrganizationInfo, forKey: .includeOrganizationInfo)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEnrollmentStatusesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEnrollmentStatusesInput: Swift.Equatable {
    /// The enrollment status of a specific account ID in the organization.
    public var accountId: Swift.String?
    /// Indicates whether to return the enrollment status for the organization.
    public var includeOrganizationInfo: Swift.Bool?
    /// The maximum number of objects that are returned for the request.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        includeOrganizationInfo: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.includeOrganizationInfo = includeOrganizationInfo
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnrollmentStatusesInputBody: Swift.Equatable {
    let includeOrganizationInfo: Swift.Bool?
    let accountId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEnrollmentStatusesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case includeOrganizationInfo
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let includeOrganizationInfoDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeOrganizationInfo)
        includeOrganizationInfo = includeOrganizationInfoDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEnrollmentStatusesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnrollmentStatusesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnrollmentStatusesOutput: Swift.Equatable {
    /// The account enrollment statuses.
    public var items: [CostOptimizationHubClientTypes.AccountEnrollmentStatus]?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [CostOptimizationHubClientTypes.AccountEnrollmentStatus]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListEnrollmentStatusesOutputBody: Swift.Equatable {
    let items: [CostOptimizationHubClientTypes.AccountEnrollmentStatus]?
    let nextToken: Swift.String?
}

extension ListEnrollmentStatusesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CostOptimizationHubClientTypes.AccountEnrollmentStatus?].self, forKey: .items)
        var itemsDecoded0:[CostOptimizationHubClientTypes.AccountEnrollmentStatus]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CostOptimizationHubClientTypes.AccountEnrollmentStatus]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEnrollmentStatusesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRecommendationSummariesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case groupBy
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let groupBy = self.groupBy {
            try encodeContainer.encode(groupBy, forKey: .groupBy)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListRecommendationSummariesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRecommendationSummariesInput: Swift.Equatable {
    /// Describes a filter that returns a more specific list of recommendations. Filters recommendations by different dimensions.
    public var filter: CostOptimizationHubClientTypes.Filter?
    /// The grouping of recommendations by a dimension.
    /// This member is required.
    public var groupBy: Swift.String?
    /// The maximum number of recommendations that are returned for the request.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        filter: CostOptimizationHubClientTypes.Filter? = nil,
        groupBy: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.groupBy = groupBy
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListRecommendationSummariesInputBody: Swift.Equatable {
    let filter: CostOptimizationHubClientTypes.Filter?
    let groupBy: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListRecommendationSummariesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case groupBy
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.Filter.self, forKey: .filter)
        filter = filterDecoded
        let groupByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupBy)
        groupBy = groupByDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecommendationSummariesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRecommendationSummariesOutputBody = try responseDecoder.decode(responseBody: data)
            self.currencyCode = output.currencyCode
            self.estimatedTotalDedupedSavings = output.estimatedTotalDedupedSavings
            self.groupBy = output.groupBy
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.currencyCode = nil
            self.estimatedTotalDedupedSavings = nil
            self.groupBy = nil
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListRecommendationSummariesOutput: Swift.Equatable {
    /// The currency code used for the recommendation.
    public var currencyCode: Swift.String?
    /// The total overall savings for the aggregated view.
    public var estimatedTotalDedupedSavings: Swift.Double?
    /// The dimension used to group the recommendations by.
    public var groupBy: Swift.String?
    /// List of all savings recommendations.
    public var items: [CostOptimizationHubClientTypes.RecommendationSummary]?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        currencyCode: Swift.String? = nil,
        estimatedTotalDedupedSavings: Swift.Double? = nil,
        groupBy: Swift.String? = nil,
        items: [CostOptimizationHubClientTypes.RecommendationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.currencyCode = currencyCode
        self.estimatedTotalDedupedSavings = estimatedTotalDedupedSavings
        self.groupBy = groupBy
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListRecommendationSummariesOutputBody: Swift.Equatable {
    let estimatedTotalDedupedSavings: Swift.Double?
    let items: [CostOptimizationHubClientTypes.RecommendationSummary]?
    let groupBy: Swift.String?
    let currencyCode: Swift.String?
    let nextToken: Swift.String?
}

extension ListRecommendationSummariesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencyCode
        case estimatedTotalDedupedSavings
        case groupBy
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let estimatedTotalDedupedSavingsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedTotalDedupedSavings)
        estimatedTotalDedupedSavings = estimatedTotalDedupedSavingsDecoded
        let itemsContainer = try containerValues.decodeIfPresent([CostOptimizationHubClientTypes.RecommendationSummary?].self, forKey: .items)
        var itemsDecoded0:[CostOptimizationHubClientTypes.RecommendationSummary]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CostOptimizationHubClientTypes.RecommendationSummary]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let groupByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupBy)
        groupBy = groupByDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRecommendationSummariesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRecommendationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case includeAllRecommendations
        case maxResults
        case nextToken
        case orderBy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let includeAllRecommendations = self.includeAllRecommendations {
            try encodeContainer.encode(includeAllRecommendations, forKey: .includeAllRecommendations)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let orderBy = self.orderBy {
            try encodeContainer.encode(orderBy, forKey: .orderBy)
        }
    }
}

extension ListRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListRecommendationsInput: Swift.Equatable {
    /// The constraints that you want all returned recommendations to match.
    public var filter: CostOptimizationHubClientTypes.Filter?
    /// List of all recommendations for a resource, or a single recommendation if de-duped by resourceId.
    public var includeAllRecommendations: Swift.Bool?
    /// The maximum number of recommendations that are returned for the request.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The ordering of recommendations by a dimension.
    public var orderBy: CostOptimizationHubClientTypes.OrderBy?

    public init(
        filter: CostOptimizationHubClientTypes.Filter? = nil,
        includeAllRecommendations: Swift.Bool? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        orderBy: CostOptimizationHubClientTypes.OrderBy? = nil
    )
    {
        self.filter = filter
        self.includeAllRecommendations = includeAllRecommendations
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.orderBy = orderBy
    }
}

struct ListRecommendationsInputBody: Swift.Equatable {
    let filter: CostOptimizationHubClientTypes.Filter?
    let orderBy: CostOptimizationHubClientTypes.OrderBy?
    let includeAllRecommendations: Swift.Bool?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListRecommendationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case includeAllRecommendations
        case maxResults
        case nextToken
        case orderBy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.Filter.self, forKey: .filter)
        filter = filterDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
        let includeAllRecommendationsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeAllRecommendations)
        includeAllRecommendations = includeAllRecommendationsDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListRecommendationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRecommendationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListRecommendationsOutput: Swift.Equatable {
    /// List of all savings recommendations.
    public var items: [CostOptimizationHubClientTypes.Recommendation]?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        items: [CostOptimizationHubClientTypes.Recommendation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListRecommendationsOutputBody: Swift.Equatable {
    let items: [CostOptimizationHubClientTypes.Recommendation]?
    let nextToken: Swift.String?
}

extension ListRecommendationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([CostOptimizationHubClientTypes.Recommendation?].self, forKey: .items)
        var itemsDecoded0:[CostOptimizationHubClientTypes.Recommendation]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [CostOptimizationHubClientTypes.Recommendation]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListRecommendationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CostOptimizationHubClientTypes {
    public enum MemberAccountDiscountVisibility: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberAccountDiscountVisibility] {
            return [
                .all,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "All"
            case .none: return "None"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MemberAccountDiscountVisibility(rawValue: rawValue) ?? MemberAccountDiscountVisibility.sdkUnknown(rawValue)
        }
    }
}

extension CostOptimizationHubClientTypes.OpenSearchReservedInstances: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case costCalculation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let costCalculation = self.costCalculation {
            try encodeContainer.encode(costCalculation, forKey: .costCalculation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.OpenSearchReservedInstancesConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let costCalculationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ReservedInstancesCostCalculation.self, forKey: .costCalculation)
        costCalculation = costCalculationDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The OpenSearch reserved instances recommendation details.
    public struct OpenSearchReservedInstances: Swift.Equatable {
        /// The OpenSearch reserved instances configuration used for recommendations.
        public var configuration: CostOptimizationHubClientTypes.OpenSearchReservedInstancesConfiguration?
        /// Cost impact of the purchase recommendation.
        public var costCalculation: CostOptimizationHubClientTypes.ReservedInstancesCostCalculation?

        public init(
            configuration: CostOptimizationHubClientTypes.OpenSearchReservedInstancesConfiguration? = nil,
            costCalculation: CostOptimizationHubClientTypes.ReservedInstancesCostCalculation? = nil
        )
        {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }
    }

}

extension CostOptimizationHubClientTypes.OpenSearchReservedInstancesConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountScope
        case currentGeneration
        case instanceType
        case monthlyRecurringCost
        case normalizedUnitsToPurchase
        case numberOfInstancesToPurchase
        case paymentOption
        case reservedInstancesRegion
        case service
        case sizeFlexEligible
        case term
        case upfrontCost
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountScope = self.accountScope {
            try encodeContainer.encode(accountScope, forKey: .accountScope)
        }
        if let currentGeneration = self.currentGeneration {
            try encodeContainer.encode(currentGeneration, forKey: .currentGeneration)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let monthlyRecurringCost = self.monthlyRecurringCost {
            try encodeContainer.encode(monthlyRecurringCost, forKey: .monthlyRecurringCost)
        }
        if let normalizedUnitsToPurchase = self.normalizedUnitsToPurchase {
            try encodeContainer.encode(normalizedUnitsToPurchase, forKey: .normalizedUnitsToPurchase)
        }
        if let numberOfInstancesToPurchase = self.numberOfInstancesToPurchase {
            try encodeContainer.encode(numberOfInstancesToPurchase, forKey: .numberOfInstancesToPurchase)
        }
        if let paymentOption = self.paymentOption {
            try encodeContainer.encode(paymentOption, forKey: .paymentOption)
        }
        if let reservedInstancesRegion = self.reservedInstancesRegion {
            try encodeContainer.encode(reservedInstancesRegion, forKey: .reservedInstancesRegion)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let sizeFlexEligible = self.sizeFlexEligible {
            try encodeContainer.encode(sizeFlexEligible, forKey: .sizeFlexEligible)
        }
        if let term = self.term {
            try encodeContainer.encode(term, forKey: .term)
        }
        if let upfrontCost = self.upfrontCost {
            try encodeContainer.encode(upfrontCost, forKey: .upfrontCost)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let normalizedUnitsToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .normalizedUnitsToPurchase)
        normalizedUnitsToPurchase = normalizedUnitsToPurchaseDecoded
        let termDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .term)
        term = termDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let numberOfInstancesToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .numberOfInstancesToPurchase)
        numberOfInstancesToPurchase = numberOfInstancesToPurchaseDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let reservedInstancesRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedInstancesRegion)
        reservedInstancesRegion = reservedInstancesRegionDecoded
        let currentGenerationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentGeneration)
        currentGeneration = currentGenerationDecoded
        let sizeFlexEligibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sizeFlexEligible)
        sizeFlexEligible = sizeFlexEligibleDecoded
        let upfrontCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upfrontCost)
        upfrontCost = upfrontCostDecoded
        let monthlyRecurringCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monthlyRecurringCost)
        monthlyRecurringCost = monthlyRecurringCostDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The OpenSearch reserved instances configuration used for recommendations.
    public struct OpenSearchReservedInstancesConfiguration: Swift.Equatable {
        /// The account scope that you want your recommendations for.
        public var accountScope: Swift.String?
        /// Determines whether the recommendation is for a current generation instance.
        public var currentGeneration: Swift.String?
        /// The type of instance that Amazon Web Services recommends.
        public var instanceType: Swift.String?
        /// How much purchasing reserved instances costs you on a monthly basis.
        public var monthlyRecurringCost: Swift.String?
        /// The number of normalized units that Amazon Web Services recommends that you purchase.
        public var normalizedUnitsToPurchase: Swift.String?
        /// The number of instances that Amazon Web Services recommends that you purchase.
        public var numberOfInstancesToPurchase: Swift.String?
        /// The payment option for the commitment.
        public var paymentOption: Swift.String?
        /// The Amazon Web Services Region of the commitment.
        public var reservedInstancesRegion: Swift.String?
        /// The service that you want your recommendations for.
        public var service: Swift.String?
        /// Determines whether the recommendation is size flexible.
        public var sizeFlexEligible: Swift.Bool?
        /// The reserved instances recommendation term in years.
        public var term: Swift.String?
        /// How much purchasing this instance costs you upfront.
        public var upfrontCost: Swift.String?

        public init(
            accountScope: Swift.String? = nil,
            currentGeneration: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            monthlyRecurringCost: Swift.String? = nil,
            normalizedUnitsToPurchase: Swift.String? = nil,
            numberOfInstancesToPurchase: Swift.String? = nil,
            paymentOption: Swift.String? = nil,
            reservedInstancesRegion: Swift.String? = nil,
            service: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool? = nil,
            term: Swift.String? = nil,
            upfrontCost: Swift.String? = nil
        )
        {
            self.accountScope = accountScope
            self.currentGeneration = currentGeneration
            self.instanceType = instanceType
            self.monthlyRecurringCost = monthlyRecurringCost
            self.normalizedUnitsToPurchase = normalizedUnitsToPurchase
            self.numberOfInstancesToPurchase = numberOfInstancesToPurchase
            self.paymentOption = paymentOption
            self.reservedInstancesRegion = reservedInstancesRegion
            self.service = service
            self.sizeFlexEligible = sizeFlexEligible
            self.term = term
            self.upfrontCost = upfrontCost
        }
    }

}

extension CostOptimizationHubClientTypes {
    public enum Order: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [Order] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "Asc"
            case .desc: return "Desc"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Order(rawValue: rawValue) ?? Order.sdkUnknown(rawValue)
        }
    }
}

extension CostOptimizationHubClientTypes.OrderBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dimension
        case order
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dimension = self.dimension {
            try encodeContainer.encode(dimension, forKey: .dimension)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dimensionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dimension)
        dimension = dimensionDecoded
        let orderDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.Order.self, forKey: .order)
        order = orderDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// Defines how rows will be sorted in the response.
    public struct OrderBy: Swift.Equatable {
        /// Sorts by dimension values.
        public var dimension: Swift.String?
        /// The order that's used to sort the data.
        public var order: CostOptimizationHubClientTypes.Order?

        public init(
            dimension: Swift.String? = nil,
            order: CostOptimizationHubClientTypes.Order? = nil
        )
        {
            self.dimension = dimension
            self.order = order
        }
    }

}

extension CostOptimizationHubClientTypes.RdsReservedInstances: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case costCalculation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let costCalculation = self.costCalculation {
            try encodeContainer.encode(costCalculation, forKey: .costCalculation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.RdsReservedInstancesConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let costCalculationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ReservedInstancesCostCalculation.self, forKey: .costCalculation)
        costCalculation = costCalculationDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The RDS reserved instances recommendation details.
    public struct RdsReservedInstances: Swift.Equatable {
        /// The RDS reserved instances configuration used for recommendations.
        public var configuration: CostOptimizationHubClientTypes.RdsReservedInstancesConfiguration?
        /// Cost impact of the purchase recommendation.
        public var costCalculation: CostOptimizationHubClientTypes.ReservedInstancesCostCalculation?

        public init(
            configuration: CostOptimizationHubClientTypes.RdsReservedInstancesConfiguration? = nil,
            costCalculation: CostOptimizationHubClientTypes.ReservedInstancesCostCalculation? = nil
        )
        {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }
    }

}

extension CostOptimizationHubClientTypes.RdsReservedInstancesConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountScope
        case currentGeneration
        case databaseEdition
        case databaseEngine
        case deploymentOption
        case instanceFamily
        case instanceType
        case licenseModel
        case monthlyRecurringCost
        case normalizedUnitsToPurchase
        case numberOfInstancesToPurchase
        case paymentOption
        case reservedInstancesRegion
        case service
        case sizeFlexEligible
        case term
        case upfrontCost
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountScope = self.accountScope {
            try encodeContainer.encode(accountScope, forKey: .accountScope)
        }
        if let currentGeneration = self.currentGeneration {
            try encodeContainer.encode(currentGeneration, forKey: .currentGeneration)
        }
        if let databaseEdition = self.databaseEdition {
            try encodeContainer.encode(databaseEdition, forKey: .databaseEdition)
        }
        if let databaseEngine = self.databaseEngine {
            try encodeContainer.encode(databaseEngine, forKey: .databaseEngine)
        }
        if let deploymentOption = self.deploymentOption {
            try encodeContainer.encode(deploymentOption, forKey: .deploymentOption)
        }
        if let instanceFamily = self.instanceFamily {
            try encodeContainer.encode(instanceFamily, forKey: .instanceFamily)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let licenseModel = self.licenseModel {
            try encodeContainer.encode(licenseModel, forKey: .licenseModel)
        }
        if let monthlyRecurringCost = self.monthlyRecurringCost {
            try encodeContainer.encode(monthlyRecurringCost, forKey: .monthlyRecurringCost)
        }
        if let normalizedUnitsToPurchase = self.normalizedUnitsToPurchase {
            try encodeContainer.encode(normalizedUnitsToPurchase, forKey: .normalizedUnitsToPurchase)
        }
        if let numberOfInstancesToPurchase = self.numberOfInstancesToPurchase {
            try encodeContainer.encode(numberOfInstancesToPurchase, forKey: .numberOfInstancesToPurchase)
        }
        if let paymentOption = self.paymentOption {
            try encodeContainer.encode(paymentOption, forKey: .paymentOption)
        }
        if let reservedInstancesRegion = self.reservedInstancesRegion {
            try encodeContainer.encode(reservedInstancesRegion, forKey: .reservedInstancesRegion)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let sizeFlexEligible = self.sizeFlexEligible {
            try encodeContainer.encode(sizeFlexEligible, forKey: .sizeFlexEligible)
        }
        if let term = self.term {
            try encodeContainer.encode(term, forKey: .term)
        }
        if let upfrontCost = self.upfrontCost {
            try encodeContainer.encode(upfrontCost, forKey: .upfrontCost)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let normalizedUnitsToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .normalizedUnitsToPurchase)
        normalizedUnitsToPurchase = normalizedUnitsToPurchaseDecoded
        let termDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .term)
        term = termDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let numberOfInstancesToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .numberOfInstancesToPurchase)
        numberOfInstancesToPurchase = numberOfInstancesToPurchaseDecoded
        let instanceFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceFamily)
        instanceFamily = instanceFamilyDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let reservedInstancesRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedInstancesRegion)
        reservedInstancesRegion = reservedInstancesRegionDecoded
        let sizeFlexEligibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sizeFlexEligible)
        sizeFlexEligible = sizeFlexEligibleDecoded
        let currentGenerationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentGeneration)
        currentGeneration = currentGenerationDecoded
        let upfrontCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upfrontCost)
        upfrontCost = upfrontCostDecoded
        let monthlyRecurringCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monthlyRecurringCost)
        monthlyRecurringCost = monthlyRecurringCostDecoded
        let licenseModelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .licenseModel)
        licenseModel = licenseModelDecoded
        let databaseEditionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseEdition)
        databaseEdition = databaseEditionDecoded
        let databaseEngineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseEngine)
        databaseEngine = databaseEngineDecoded
        let deploymentOptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deploymentOption)
        deploymentOption = deploymentOptionDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The RDS reserved instances configuration used for recommendations.
    public struct RdsReservedInstancesConfiguration: Swift.Equatable {
        /// The account scope that you want your recommendations for.
        public var accountScope: Swift.String?
        /// Determines whether the recommendation is for a current generation instance.
        public var currentGeneration: Swift.String?
        /// The database edition that the recommended reservation supports.
        public var databaseEdition: Swift.String?
        /// The database engine that the recommended reservation supports.
        public var databaseEngine: Swift.String?
        /// Determines whether the recommendation is for a reservation in a single Availability Zone or a reservation with a backup in a second Availability Zone.
        public var deploymentOption: Swift.String?
        /// The instance family of the recommended reservation.
        public var instanceFamily: Swift.String?
        /// The type of instance that Amazon Web Services recommends.
        public var instanceType: Swift.String?
        /// The license model that the recommended reservation supports.
        public var licenseModel: Swift.String?
        /// How much purchasing this instance costs you on a monthly basis.
        public var monthlyRecurringCost: Swift.String?
        /// The number of normalized units that Amazon Web Services recommends that you purchase.
        public var normalizedUnitsToPurchase: Swift.String?
        /// The number of instances that Amazon Web Services recommends that you purchase.
        public var numberOfInstancesToPurchase: Swift.String?
        /// The payment option for the commitment.
        public var paymentOption: Swift.String?
        /// The Amazon Web Services Region of the commitment.
        public var reservedInstancesRegion: Swift.String?
        /// The service that you want your recommendations for.
        public var service: Swift.String?
        /// Determines whether the recommendation is size flexible.
        public var sizeFlexEligible: Swift.Bool?
        /// The reserved instances recommendation term in years.
        public var term: Swift.String?
        /// How much purchasing this instance costs you upfront.
        public var upfrontCost: Swift.String?

        public init(
            accountScope: Swift.String? = nil,
            currentGeneration: Swift.String? = nil,
            databaseEdition: Swift.String? = nil,
            databaseEngine: Swift.String? = nil,
            deploymentOption: Swift.String? = nil,
            instanceFamily: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            licenseModel: Swift.String? = nil,
            monthlyRecurringCost: Swift.String? = nil,
            normalizedUnitsToPurchase: Swift.String? = nil,
            numberOfInstancesToPurchase: Swift.String? = nil,
            paymentOption: Swift.String? = nil,
            reservedInstancesRegion: Swift.String? = nil,
            service: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool? = nil,
            term: Swift.String? = nil,
            upfrontCost: Swift.String? = nil
        )
        {
            self.accountScope = accountScope
            self.currentGeneration = currentGeneration
            self.databaseEdition = databaseEdition
            self.databaseEngine = databaseEngine
            self.deploymentOption = deploymentOption
            self.instanceFamily = instanceFamily
            self.instanceType = instanceType
            self.licenseModel = licenseModel
            self.monthlyRecurringCost = monthlyRecurringCost
            self.normalizedUnitsToPurchase = normalizedUnitsToPurchase
            self.numberOfInstancesToPurchase = numberOfInstancesToPurchase
            self.paymentOption = paymentOption
            self.reservedInstancesRegion = reservedInstancesRegion
            self.service = service
            self.sizeFlexEligible = sizeFlexEligible
            self.term = term
            self.upfrontCost = upfrontCost
        }
    }

}

extension CostOptimizationHubClientTypes.Recommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case actionType
        case currencyCode
        case currentResourceSummary
        case currentResourceType
        case estimatedMonthlyCost
        case estimatedMonthlySavings
        case estimatedSavingsPercentage
        case implementationEffort
        case lastRefreshTimestamp
        case recommendationId
        case recommendationLookbackPeriodInDays
        case recommendedResourceSummary
        case recommendedResourceType
        case region
        case resourceArn
        case resourceId
        case restartNeeded
        case rollbackPossible
        case source
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionType = self.actionType {
            try encodeContainer.encode(actionType, forKey: .actionType)
        }
        if let currencyCode = self.currencyCode {
            try encodeContainer.encode(currencyCode, forKey: .currencyCode)
        }
        if let currentResourceSummary = self.currentResourceSummary {
            try encodeContainer.encode(currentResourceSummary, forKey: .currentResourceSummary)
        }
        if let currentResourceType = self.currentResourceType {
            try encodeContainer.encode(currentResourceType, forKey: .currentResourceType)
        }
        if let estimatedMonthlyCost = self.estimatedMonthlyCost {
            try encodeContainer.encode(estimatedMonthlyCost, forKey: .estimatedMonthlyCost)
        }
        if let estimatedMonthlySavings = self.estimatedMonthlySavings {
            try encodeContainer.encode(estimatedMonthlySavings, forKey: .estimatedMonthlySavings)
        }
        if let estimatedSavingsPercentage = self.estimatedSavingsPercentage {
            try encodeContainer.encode(estimatedSavingsPercentage, forKey: .estimatedSavingsPercentage)
        }
        if let implementationEffort = self.implementationEffort {
            try encodeContainer.encode(implementationEffort, forKey: .implementationEffort)
        }
        if let lastRefreshTimestamp = self.lastRefreshTimestamp {
            try encodeContainer.encodeTimestamp(lastRefreshTimestamp, format: .epochSeconds, forKey: .lastRefreshTimestamp)
        }
        if let recommendationId = self.recommendationId {
            try encodeContainer.encode(recommendationId, forKey: .recommendationId)
        }
        if let recommendationLookbackPeriodInDays = self.recommendationLookbackPeriodInDays {
            try encodeContainer.encode(recommendationLookbackPeriodInDays, forKey: .recommendationLookbackPeriodInDays)
        }
        if let recommendedResourceSummary = self.recommendedResourceSummary {
            try encodeContainer.encode(recommendedResourceSummary, forKey: .recommendedResourceSummary)
        }
        if let recommendedResourceType = self.recommendedResourceType {
            try encodeContainer.encode(recommendedResourceType, forKey: .recommendedResourceType)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let restartNeeded = self.restartNeeded {
            try encodeContainer.encode(restartNeeded, forKey: .restartNeeded)
        }
        if let rollbackPossible = self.rollbackPossible {
            try encodeContainer.encode(rollbackPossible, forKey: .rollbackPossible)
        }
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationId)
        recommendationId = recommendationIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let currentResourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentResourceType)
        currentResourceType = currentResourceTypeDecoded
        let recommendedResourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedResourceType)
        recommendedResourceType = recommendedResourceTypeDecoded
        let estimatedMonthlySavingsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedMonthlySavings)
        estimatedMonthlySavings = estimatedMonthlySavingsDecoded
        let estimatedSavingsPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedSavingsPercentage)
        estimatedSavingsPercentage = estimatedSavingsPercentageDecoded
        let estimatedMonthlyCostDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedMonthlyCost)
        estimatedMonthlyCost = estimatedMonthlyCostDecoded
        let currencyCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currencyCode)
        currencyCode = currencyCodeDecoded
        let implementationEffortDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .implementationEffort)
        implementationEffort = implementationEffortDecoded
        let restartNeededDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .restartNeeded)
        restartNeeded = restartNeededDecoded
        let actionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let rollbackPossibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .rollbackPossible)
        rollbackPossible = rollbackPossibleDecoded
        let currentResourceSummaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentResourceSummary)
        currentResourceSummary = currentResourceSummaryDecoded
        let recommendedResourceSummaryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedResourceSummary)
        recommendedResourceSummary = recommendedResourceSummaryDecoded
        let lastRefreshTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastRefreshTimestamp)
        lastRefreshTimestamp = lastRefreshTimestampDecoded
        let recommendationLookbackPeriodInDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recommendationLookbackPeriodInDays)
        recommendationLookbackPeriodInDays = recommendationLookbackPeriodInDaysDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([CostOptimizationHubClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[CostOptimizationHubClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [CostOptimizationHubClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CostOptimizationHubClientTypes {
    /// Describes a recommendation.
    public struct Recommendation: Swift.Equatable {
        /// The account that the recommendation is for.
        public var accountId: Swift.String?
        /// The type of tasks that can be carried out by this action.
        public var actionType: Swift.String?
        /// The currency code used for the recommendation.
        public var currencyCode: Swift.String?
        /// Describes the current resource.
        public var currentResourceSummary: Swift.String?
        /// The current resource type.
        public var currentResourceType: Swift.String?
        /// The estimated monthly cost for the recommendation.
        public var estimatedMonthlyCost: Swift.Double?
        /// The estimated monthly savings amount for the recommendation.
        public var estimatedMonthlySavings: Swift.Double?
        /// The estimated savings percentage relative to the total cost over the cost calculation lookback period.
        public var estimatedSavingsPercentage: Swift.Double?
        /// The effort required to implement the recommendation.
        public var implementationEffort: Swift.String?
        /// The time when the recommendation was last generated.
        public var lastRefreshTimestamp: ClientRuntime.Date?
        /// The ID for the recommendation.
        public var recommendationId: Swift.String?
        /// The lookback period that's used to generate the recommendation.
        public var recommendationLookbackPeriodInDays: Swift.Int?
        /// Describes the recommended resource.
        public var recommendedResourceSummary: Swift.String?
        /// The recommended resource type.
        public var recommendedResourceType: Swift.String?
        /// The Amazon Web Services Region of the resource.
        public var region: Swift.String?
        /// The Amazon Resource Name (ARN) for the recommendation.
        public var resourceArn: Swift.String?
        /// The resource ID for the recommendation.
        public var resourceId: Swift.String?
        /// Whether or not implementing the recommendation requires a restart.
        public var restartNeeded: Swift.Bool?
        /// Whether or not implementing the recommendation can be rolled back.
        public var rollbackPossible: Swift.Bool?
        /// The source of the recommendation.
        public var source: CostOptimizationHubClientTypes.Source?
        /// A list of tags assigned to the recommendation.
        public var tags: [CostOptimizationHubClientTypes.Tag]?

        public init(
            accountId: Swift.String? = nil,
            actionType: Swift.String? = nil,
            currencyCode: Swift.String? = nil,
            currentResourceSummary: Swift.String? = nil,
            currentResourceType: Swift.String? = nil,
            estimatedMonthlyCost: Swift.Double? = nil,
            estimatedMonthlySavings: Swift.Double? = nil,
            estimatedSavingsPercentage: Swift.Double? = nil,
            implementationEffort: Swift.String? = nil,
            lastRefreshTimestamp: ClientRuntime.Date? = nil,
            recommendationId: Swift.String? = nil,
            recommendationLookbackPeriodInDays: Swift.Int? = nil,
            recommendedResourceSummary: Swift.String? = nil,
            recommendedResourceType: Swift.String? = nil,
            region: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            restartNeeded: Swift.Bool? = nil,
            rollbackPossible: Swift.Bool? = nil,
            source: CostOptimizationHubClientTypes.Source? = nil,
            tags: [CostOptimizationHubClientTypes.Tag]? = nil
        )
        {
            self.accountId = accountId
            self.actionType = actionType
            self.currencyCode = currencyCode
            self.currentResourceSummary = currentResourceSummary
            self.currentResourceType = currentResourceType
            self.estimatedMonthlyCost = estimatedMonthlyCost
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.estimatedSavingsPercentage = estimatedSavingsPercentage
            self.implementationEffort = implementationEffort
            self.lastRefreshTimestamp = lastRefreshTimestamp
            self.recommendationId = recommendationId
            self.recommendationLookbackPeriodInDays = recommendationLookbackPeriodInDays
            self.recommendedResourceSummary = recommendedResourceSummary
            self.recommendedResourceType = recommendedResourceType
            self.region = region
            self.resourceArn = resourceArn
            self.resourceId = resourceId
            self.restartNeeded = restartNeeded
            self.rollbackPossible = rollbackPossible
            self.source = source
            self.tags = tags
        }
    }

}

extension CostOptimizationHubClientTypes.RecommendationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case estimatedMonthlySavings
        case group
        case recommendationCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let estimatedMonthlySavings = self.estimatedMonthlySavings {
            try encodeContainer.encode(estimatedMonthlySavings, forKey: .estimatedMonthlySavings)
        }
        if let group = self.group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let recommendationCount = self.recommendationCount {
            try encodeContainer.encode(recommendationCount, forKey: .recommendationCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
        let estimatedMonthlySavingsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedMonthlySavings)
        estimatedMonthlySavings = estimatedMonthlySavingsDecoded
        let recommendationCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .recommendationCount)
        recommendationCount = recommendationCountDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The summary of rightsizing recommendations, including de-duped savings from all types of recommendations.
    public struct RecommendationSummary: Swift.Equatable {
        /// The estimated total savings resulting from modifications, on a monthly basis.
        public var estimatedMonthlySavings: Swift.Double?
        /// The grouping of recommendations.
        public var group: Swift.String?
        /// The total number of instance recommendations.
        public var recommendationCount: Swift.Int?

        public init(
            estimatedMonthlySavings: Swift.Double? = nil,
            group: Swift.String? = nil,
            recommendationCount: Swift.Int? = nil
        )
        {
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.group = group
            self.recommendationCount = recommendationCount
        }
    }

}

extension CostOptimizationHubClientTypes.RedshiftReservedInstances: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case costCalculation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let costCalculation = self.costCalculation {
            try encodeContainer.encode(costCalculation, forKey: .costCalculation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.RedshiftReservedInstancesConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let costCalculationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ReservedInstancesCostCalculation.self, forKey: .costCalculation)
        costCalculation = costCalculationDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The Redshift reserved instances recommendation details.
    public struct RedshiftReservedInstances: Swift.Equatable {
        /// The Redshift reserved instances configuration used for recommendations.
        public var configuration: CostOptimizationHubClientTypes.RedshiftReservedInstancesConfiguration?
        /// Cost impact of the purchase recommendation.
        public var costCalculation: CostOptimizationHubClientTypes.ReservedInstancesCostCalculation?

        public init(
            configuration: CostOptimizationHubClientTypes.RedshiftReservedInstancesConfiguration? = nil,
            costCalculation: CostOptimizationHubClientTypes.ReservedInstancesCostCalculation? = nil
        )
        {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }
    }

}

extension CostOptimizationHubClientTypes.RedshiftReservedInstancesConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountScope
        case currentGeneration
        case instanceFamily
        case instanceType
        case monthlyRecurringCost
        case normalizedUnitsToPurchase
        case numberOfInstancesToPurchase
        case paymentOption
        case reservedInstancesRegion
        case service
        case sizeFlexEligible
        case term
        case upfrontCost
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountScope = self.accountScope {
            try encodeContainer.encode(accountScope, forKey: .accountScope)
        }
        if let currentGeneration = self.currentGeneration {
            try encodeContainer.encode(currentGeneration, forKey: .currentGeneration)
        }
        if let instanceFamily = self.instanceFamily {
            try encodeContainer.encode(instanceFamily, forKey: .instanceFamily)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let monthlyRecurringCost = self.monthlyRecurringCost {
            try encodeContainer.encode(monthlyRecurringCost, forKey: .monthlyRecurringCost)
        }
        if let normalizedUnitsToPurchase = self.normalizedUnitsToPurchase {
            try encodeContainer.encode(normalizedUnitsToPurchase, forKey: .normalizedUnitsToPurchase)
        }
        if let numberOfInstancesToPurchase = self.numberOfInstancesToPurchase {
            try encodeContainer.encode(numberOfInstancesToPurchase, forKey: .numberOfInstancesToPurchase)
        }
        if let paymentOption = self.paymentOption {
            try encodeContainer.encode(paymentOption, forKey: .paymentOption)
        }
        if let reservedInstancesRegion = self.reservedInstancesRegion {
            try encodeContainer.encode(reservedInstancesRegion, forKey: .reservedInstancesRegion)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let sizeFlexEligible = self.sizeFlexEligible {
            try encodeContainer.encode(sizeFlexEligible, forKey: .sizeFlexEligible)
        }
        if let term = self.term {
            try encodeContainer.encode(term, forKey: .term)
        }
        if let upfrontCost = self.upfrontCost {
            try encodeContainer.encode(upfrontCost, forKey: .upfrontCost)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let normalizedUnitsToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .normalizedUnitsToPurchase)
        normalizedUnitsToPurchase = normalizedUnitsToPurchaseDecoded
        let termDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .term)
        term = termDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let numberOfInstancesToPurchaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .numberOfInstancesToPurchase)
        numberOfInstancesToPurchase = numberOfInstancesToPurchaseDecoded
        let instanceFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceFamily)
        instanceFamily = instanceFamilyDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let reservedInstancesRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reservedInstancesRegion)
        reservedInstancesRegion = reservedInstancesRegionDecoded
        let sizeFlexEligibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .sizeFlexEligible)
        sizeFlexEligible = sizeFlexEligibleDecoded
        let currentGenerationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentGeneration)
        currentGeneration = currentGenerationDecoded
        let upfrontCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upfrontCost)
        upfrontCost = upfrontCostDecoded
        let monthlyRecurringCostDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .monthlyRecurringCost)
        monthlyRecurringCost = monthlyRecurringCostDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The Redshift reserved instances configuration used for recommendations.
    public struct RedshiftReservedInstancesConfiguration: Swift.Equatable {
        /// The account scope that you want your recommendations for.
        public var accountScope: Swift.String?
        /// Determines whether the recommendation is for a current generation instance.
        public var currentGeneration: Swift.String?
        /// The instance family of the recommended reservation.
        public var instanceFamily: Swift.String?
        /// The type of instance that Amazon Web Services recommends.
        public var instanceType: Swift.String?
        /// How much purchasing reserved instances costs you on a monthly basis.
        public var monthlyRecurringCost: Swift.String?
        /// The number of normalized units that Amazon Web Services recommends that you purchase.
        public var normalizedUnitsToPurchase: Swift.String?
        /// The number of instances that Amazon Web Services recommends that you purchase.
        public var numberOfInstancesToPurchase: Swift.String?
        /// The payment option for the commitment.
        public var paymentOption: Swift.String?
        /// The Amazon Web Services Region of the commitment.
        public var reservedInstancesRegion: Swift.String?
        /// The service that you want your recommendations for.
        public var service: Swift.String?
        /// Determines whether the recommendation is size flexible.
        public var sizeFlexEligible: Swift.Bool?
        /// The reserved instances recommendation term in years.
        public var term: Swift.String?
        /// How much purchasing this instance costs you upfront.
        public var upfrontCost: Swift.String?

        public init(
            accountScope: Swift.String? = nil,
            currentGeneration: Swift.String? = nil,
            instanceFamily: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            monthlyRecurringCost: Swift.String? = nil,
            normalizedUnitsToPurchase: Swift.String? = nil,
            numberOfInstancesToPurchase: Swift.String? = nil,
            paymentOption: Swift.String? = nil,
            reservedInstancesRegion: Swift.String? = nil,
            service: Swift.String? = nil,
            sizeFlexEligible: Swift.Bool? = nil,
            term: Swift.String? = nil,
            upfrontCost: Swift.String? = nil
        )
        {
            self.accountScope = accountScope
            self.currentGeneration = currentGeneration
            self.instanceFamily = instanceFamily
            self.instanceType = instanceType
            self.monthlyRecurringCost = monthlyRecurringCost
            self.normalizedUnitsToPurchase = normalizedUnitsToPurchase
            self.numberOfInstancesToPurchase = numberOfInstancesToPurchase
            self.paymentOption = paymentOption
            self.reservedInstancesRegion = reservedInstancesRegion
            self.service = service
            self.sizeFlexEligible = sizeFlexEligible
            self.term = term
            self.upfrontCost = upfrontCost
        }
    }

}

extension CostOptimizationHubClientTypes.ReservedInstancesCostCalculation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pricing
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pricing = self.pricing {
            try encodeContainer.encode(pricing, forKey: .pricing)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ReservedInstancesPricing.self, forKey: .pricing)
        pricing = pricingDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// Cost impact of the purchase recommendation.
    public struct ReservedInstancesCostCalculation: Swift.Equatable {
        /// Pricing details of the purchase recommendation.
        public var pricing: CostOptimizationHubClientTypes.ReservedInstancesPricing?

        public init(
            pricing: CostOptimizationHubClientTypes.ReservedInstancesPricing? = nil
        )
        {
            self.pricing = pricing
        }
    }

}

extension CostOptimizationHubClientTypes.ReservedInstancesPricing: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case estimatedMonthlyAmortizedReservationCost
        case estimatedOnDemandCost
        case monthlyReservationEligibleCost
        case savingsPercentage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let estimatedMonthlyAmortizedReservationCost = self.estimatedMonthlyAmortizedReservationCost {
            try encodeContainer.encode(estimatedMonthlyAmortizedReservationCost, forKey: .estimatedMonthlyAmortizedReservationCost)
        }
        if let estimatedOnDemandCost = self.estimatedOnDemandCost {
            try encodeContainer.encode(estimatedOnDemandCost, forKey: .estimatedOnDemandCost)
        }
        if let monthlyReservationEligibleCost = self.monthlyReservationEligibleCost {
            try encodeContainer.encode(monthlyReservationEligibleCost, forKey: .monthlyReservationEligibleCost)
        }
        if let savingsPercentage = self.savingsPercentage {
            try encodeContainer.encode(savingsPercentage, forKey: .savingsPercentage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let estimatedOnDemandCostDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedOnDemandCost)
        estimatedOnDemandCost = estimatedOnDemandCostDecoded
        let monthlyReservationEligibleCostDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .monthlyReservationEligibleCost)
        monthlyReservationEligibleCost = monthlyReservationEligibleCostDecoded
        let savingsPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .savingsPercentage)
        savingsPercentage = savingsPercentageDecoded
        let estimatedMonthlyAmortizedReservationCostDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedMonthlyAmortizedReservationCost)
        estimatedMonthlyAmortizedReservationCost = estimatedMonthlyAmortizedReservationCostDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// Pricing details for your recommended reserved instance.
    public struct ReservedInstancesPricing: Swift.Equatable {
        /// The estimated cost of your recurring monthly fees for the recommended reserved instance across the month.
        public var estimatedMonthlyAmortizedReservationCost: Swift.Double?
        /// The remaining On-Demand cost estimated to not be covered by the recommended reserved instance, over the length of the lookback period.
        public var estimatedOnDemandCost: Swift.Double?
        /// The cost of paying for the recommended reserved instance monthly.
        public var monthlyReservationEligibleCost: Swift.Double?
        /// The savings percentage relative to the total On-Demand costs that are associated with this instance.
        public var savingsPercentage: Swift.Double?

        public init(
            estimatedMonthlyAmortizedReservationCost: Swift.Double? = nil,
            estimatedOnDemandCost: Swift.Double? = nil,
            monthlyReservationEligibleCost: Swift.Double? = nil,
            savingsPercentage: Swift.Double? = nil
        )
        {
            self.estimatedMonthlyAmortizedReservationCost = estimatedMonthlyAmortizedReservationCost
            self.estimatedOnDemandCost = estimatedOnDemandCost
            self.monthlyReservationEligibleCost = monthlyReservationEligibleCost
            self.savingsPercentage = savingsPercentage
        }
    }

}

extension CostOptimizationHubClientTypes.ResourceCostCalculation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pricing
        case usages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pricing = self.pricing {
            try encodeContainer.encode(pricing, forKey: .pricing)
        }
        if let usages = usages {
            var usagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usages)
            for usage0 in usages {
                try usagesContainer.encode(usage0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usagesContainer = try containerValues.decodeIfPresent([CostOptimizationHubClientTypes.Usage?].self, forKey: .usages)
        var usagesDecoded0:[CostOptimizationHubClientTypes.Usage]? = nil
        if let usagesContainer = usagesContainer {
            usagesDecoded0 = [CostOptimizationHubClientTypes.Usage]()
            for structure0 in usagesContainer {
                if let structure0 = structure0 {
                    usagesDecoded0?.append(structure0)
                }
            }
        }
        usages = usagesDecoded0
        let pricingDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ResourcePricing.self, forKey: .pricing)
        pricing = pricingDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// Cost impact of the resource recommendation.
    public struct ResourceCostCalculation: Swift.Equatable {
        /// Pricing details of the resource recommendation.
        public var pricing: CostOptimizationHubClientTypes.ResourcePricing?
        /// Usage details of the resource recommendation.
        public var usages: [CostOptimizationHubClientTypes.Usage]?

        public init(
            pricing: CostOptimizationHubClientTypes.ResourcePricing? = nil,
            usages: [CostOptimizationHubClientTypes.Usage]? = nil
        )
        {
            self.pricing = pricing
            self.usages = usages
        }
    }

}

extension CostOptimizationHubClientTypes.ResourceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computesavingsplans = "computeSavingsPlans"
        case ebsvolume = "ebsVolume"
        case ec2autoscalinggroup = "ec2AutoScalingGroup"
        case ec2instance = "ec2Instance"
        case ec2instancesavingsplans = "ec2InstanceSavingsPlans"
        case ec2reservedinstances = "ec2ReservedInstances"
        case ecsservice = "ecsService"
        case elasticachereservedinstances = "elastiCacheReservedInstances"
        case lambdafunction = "lambdaFunction"
        case opensearchreservedinstances = "openSearchReservedInstances"
        case rdsreservedinstances = "rdsReservedInstances"
        case redshiftreservedinstances = "redshiftReservedInstances"
        case sagemakersavingsplans = "sageMakerSavingsPlans"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .computesavingsplans(computesavingsplans):
                try container.encode(computesavingsplans, forKey: .computesavingsplans)
            case let .ebsvolume(ebsvolume):
                try container.encode(ebsvolume, forKey: .ebsvolume)
            case let .ec2autoscalinggroup(ec2autoscalinggroup):
                try container.encode(ec2autoscalinggroup, forKey: .ec2autoscalinggroup)
            case let .ec2instance(ec2instance):
                try container.encode(ec2instance, forKey: .ec2instance)
            case let .ec2instancesavingsplans(ec2instancesavingsplans):
                try container.encode(ec2instancesavingsplans, forKey: .ec2instancesavingsplans)
            case let .ec2reservedinstances(ec2reservedinstances):
                try container.encode(ec2reservedinstances, forKey: .ec2reservedinstances)
            case let .ecsservice(ecsservice):
                try container.encode(ecsservice, forKey: .ecsservice)
            case let .elasticachereservedinstances(elasticachereservedinstances):
                try container.encode(elasticachereservedinstances, forKey: .elasticachereservedinstances)
            case let .lambdafunction(lambdafunction):
                try container.encode(lambdafunction, forKey: .lambdafunction)
            case let .opensearchreservedinstances(opensearchreservedinstances):
                try container.encode(opensearchreservedinstances, forKey: .opensearchreservedinstances)
            case let .rdsreservedinstances(rdsreservedinstances):
                try container.encode(rdsreservedinstances, forKey: .rdsreservedinstances)
            case let .redshiftreservedinstances(redshiftreservedinstances):
                try container.encode(redshiftreservedinstances, forKey: .redshiftreservedinstances)
            case let .sagemakersavingsplans(sagemakersavingsplans):
                try container.encode(sagemakersavingsplans, forKey: .sagemakersavingsplans)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let lambdafunctionDecoded = try values.decodeIfPresent(CostOptimizationHubClientTypes.LambdaFunction.self, forKey: .lambdafunction)
        if let lambdafunction = lambdafunctionDecoded {
            self = .lambdafunction(lambdafunction)
            return
        }
        let ecsserviceDecoded = try values.decodeIfPresent(CostOptimizationHubClientTypes.EcsService.self, forKey: .ecsservice)
        if let ecsservice = ecsserviceDecoded {
            self = .ecsservice(ecsservice)
            return
        }
        let ec2instanceDecoded = try values.decodeIfPresent(CostOptimizationHubClientTypes.Ec2Instance.self, forKey: .ec2instance)
        if let ec2instance = ec2instanceDecoded {
            self = .ec2instance(ec2instance)
            return
        }
        let ebsvolumeDecoded = try values.decodeIfPresent(CostOptimizationHubClientTypes.EbsVolume.self, forKey: .ebsvolume)
        if let ebsvolume = ebsvolumeDecoded {
            self = .ebsvolume(ebsvolume)
            return
        }
        let ec2autoscalinggroupDecoded = try values.decodeIfPresent(CostOptimizationHubClientTypes.Ec2AutoScalingGroup.self, forKey: .ec2autoscalinggroup)
        if let ec2autoscalinggroup = ec2autoscalinggroupDecoded {
            self = .ec2autoscalinggroup(ec2autoscalinggroup)
            return
        }
        let ec2reservedinstancesDecoded = try values.decodeIfPresent(CostOptimizationHubClientTypes.Ec2ReservedInstances.self, forKey: .ec2reservedinstances)
        if let ec2reservedinstances = ec2reservedinstancesDecoded {
            self = .ec2reservedinstances(ec2reservedinstances)
            return
        }
        let rdsreservedinstancesDecoded = try values.decodeIfPresent(CostOptimizationHubClientTypes.RdsReservedInstances.self, forKey: .rdsreservedinstances)
        if let rdsreservedinstances = rdsreservedinstancesDecoded {
            self = .rdsreservedinstances(rdsreservedinstances)
            return
        }
        let elasticachereservedinstancesDecoded = try values.decodeIfPresent(CostOptimizationHubClientTypes.ElastiCacheReservedInstances.self, forKey: .elasticachereservedinstances)
        if let elasticachereservedinstances = elasticachereservedinstancesDecoded {
            self = .elasticachereservedinstances(elasticachereservedinstances)
            return
        }
        let opensearchreservedinstancesDecoded = try values.decodeIfPresent(CostOptimizationHubClientTypes.OpenSearchReservedInstances.self, forKey: .opensearchreservedinstances)
        if let opensearchreservedinstances = opensearchreservedinstancesDecoded {
            self = .opensearchreservedinstances(opensearchreservedinstances)
            return
        }
        let redshiftreservedinstancesDecoded = try values.decodeIfPresent(CostOptimizationHubClientTypes.RedshiftReservedInstances.self, forKey: .redshiftreservedinstances)
        if let redshiftreservedinstances = redshiftreservedinstancesDecoded {
            self = .redshiftreservedinstances(redshiftreservedinstances)
            return
        }
        let ec2instancesavingsplansDecoded = try values.decodeIfPresent(CostOptimizationHubClientTypes.Ec2InstanceSavingsPlans.self, forKey: .ec2instancesavingsplans)
        if let ec2instancesavingsplans = ec2instancesavingsplansDecoded {
            self = .ec2instancesavingsplans(ec2instancesavingsplans)
            return
        }
        let computesavingsplansDecoded = try values.decodeIfPresent(CostOptimizationHubClientTypes.ComputeSavingsPlans.self, forKey: .computesavingsplans)
        if let computesavingsplans = computesavingsplansDecoded {
            self = .computesavingsplans(computesavingsplans)
            return
        }
        let sagemakersavingsplansDecoded = try values.decodeIfPresent(CostOptimizationHubClientTypes.SageMakerSavingsPlans.self, forKey: .sagemakersavingsplans)
        if let sagemakersavingsplans = sagemakersavingsplansDecoded {
            self = .sagemakersavingsplans(sagemakersavingsplans)
            return
        }
        self = .sdkUnknown("")
    }
}

extension CostOptimizationHubClientTypes {
    /// Contains detailed information about the specified resource.
    public enum ResourceDetails: Swift.Equatable {
        /// The Lambda function recommendation details.
        case lambdafunction(CostOptimizationHubClientTypes.LambdaFunction)
        /// The ECS service recommendation details.
        case ecsservice(CostOptimizationHubClientTypes.EcsService)
        /// The EC2 instance recommendation details.
        case ec2instance(CostOptimizationHubClientTypes.Ec2Instance)
        /// The Amazon Elastic Block Store volume recommendation details.
        case ebsvolume(CostOptimizationHubClientTypes.EbsVolume)
        /// The EC2 Auto Scaling group recommendation details.
        case ec2autoscalinggroup(CostOptimizationHubClientTypes.Ec2AutoScalingGroup)
        /// The EC2 reserved instances recommendation details.
        case ec2reservedinstances(CostOptimizationHubClientTypes.Ec2ReservedInstances)
        /// The RDS reserved instances recommendation details.
        case rdsreservedinstances(CostOptimizationHubClientTypes.RdsReservedInstances)
        /// The ElastiCache reserved instances recommendation details.
        case elasticachereservedinstances(CostOptimizationHubClientTypes.ElastiCacheReservedInstances)
        /// The OpenSearch reserved instances recommendation details.
        case opensearchreservedinstances(CostOptimizationHubClientTypes.OpenSearchReservedInstances)
        /// The Redshift reserved instances recommendation details.
        case redshiftreservedinstances(CostOptimizationHubClientTypes.RedshiftReservedInstances)
        /// The EC2 instance Savings Plans recommendation details.
        case ec2instancesavingsplans(CostOptimizationHubClientTypes.Ec2InstanceSavingsPlans)
        /// The Compute Savings Plans recommendation details.
        case computesavingsplans(CostOptimizationHubClientTypes.ComputeSavingsPlans)
        /// The SageMaker Savings Plans recommendation details.
        case sagemakersavingsplans(CostOptimizationHubClientTypes.SageMakerSavingsPlans)
        case sdkUnknown(Swift.String)
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified Amazon Resource Name (ARN) in the request doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource that was not found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
    }
}

extension CostOptimizationHubClientTypes.ResourcePricing: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case estimatedCostAfterDiscounts
        case estimatedCostBeforeDiscounts
        case estimatedDiscounts
        case estimatedNetUnusedAmortizedCommitments
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let estimatedCostAfterDiscounts = self.estimatedCostAfterDiscounts {
            try encodeContainer.encode(estimatedCostAfterDiscounts, forKey: .estimatedCostAfterDiscounts)
        }
        if let estimatedCostBeforeDiscounts = self.estimatedCostBeforeDiscounts {
            try encodeContainer.encode(estimatedCostBeforeDiscounts, forKey: .estimatedCostBeforeDiscounts)
        }
        if let estimatedDiscounts = self.estimatedDiscounts {
            try encodeContainer.encode(estimatedDiscounts, forKey: .estimatedDiscounts)
        }
        if let estimatedNetUnusedAmortizedCommitments = self.estimatedNetUnusedAmortizedCommitments {
            try encodeContainer.encode(estimatedNetUnusedAmortizedCommitments, forKey: .estimatedNetUnusedAmortizedCommitments)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let estimatedCostBeforeDiscountsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedCostBeforeDiscounts)
        estimatedCostBeforeDiscounts = estimatedCostBeforeDiscountsDecoded
        let estimatedNetUnusedAmortizedCommitmentsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedNetUnusedAmortizedCommitments)
        estimatedNetUnusedAmortizedCommitments = estimatedNetUnusedAmortizedCommitmentsDecoded
        let estimatedDiscountsDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.EstimatedDiscounts.self, forKey: .estimatedDiscounts)
        estimatedDiscounts = estimatedDiscountsDecoded
        let estimatedCostAfterDiscountsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedCostAfterDiscounts)
        estimatedCostAfterDiscounts = estimatedCostAfterDiscountsDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// Contains pricing information about the specified resource.
    public struct ResourcePricing: Swift.Equatable {
        /// The savings estimate incorporating all discounts with Amazon Web Services, such as Reserved Instances and Savings Plans.
        public var estimatedCostAfterDiscounts: Swift.Double?
        /// The savings estimate using Amazon Web Services public pricing without incorporating any discounts.
        public var estimatedCostBeforeDiscounts: Swift.Double?
        /// The estimated discounts for a recommendation.
        public var estimatedDiscounts: CostOptimizationHubClientTypes.EstimatedDiscounts?
        /// The estimated net unused amortized commitment for the recommendation.
        public var estimatedNetUnusedAmortizedCommitments: Swift.Double?

        public init(
            estimatedCostAfterDiscounts: Swift.Double? = nil,
            estimatedCostBeforeDiscounts: Swift.Double? = nil,
            estimatedDiscounts: CostOptimizationHubClientTypes.EstimatedDiscounts? = nil,
            estimatedNetUnusedAmortizedCommitments: Swift.Double? = nil
        )
        {
            self.estimatedCostAfterDiscounts = estimatedCostAfterDiscounts
            self.estimatedCostBeforeDiscounts = estimatedCostBeforeDiscounts
            self.estimatedDiscounts = estimatedDiscounts
            self.estimatedNetUnusedAmortizedCommitments = estimatedNetUnusedAmortizedCommitments
        }
    }

}

extension CostOptimizationHubClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case computeSavingsPlans
        case ebsVolume
        case ec2AutoScalingGroup
        case ec2Instance
        case ec2InstanceSavingsPlans
        case ec2ReservedInstances
        case ecsService
        case elastiCacheReservedInstances
        case lambdaFunction
        case openSearchReservedInstances
        case rdsReservedInstances
        case redshiftReservedInstances
        case sageMakerSavingsPlans
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .computeSavingsPlans,
                .ebsVolume,
                .ec2AutoScalingGroup,
                .ec2Instance,
                .ec2InstanceSavingsPlans,
                .ec2ReservedInstances,
                .ecsService,
                .elastiCacheReservedInstances,
                .lambdaFunction,
                .openSearchReservedInstances,
                .rdsReservedInstances,
                .redshiftReservedInstances,
                .sageMakerSavingsPlans,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .computeSavingsPlans: return "ComputeSavingsPlans"
            case .ebsVolume: return "EbsVolume"
            case .ec2AutoScalingGroup: return "Ec2AutoScalingGroup"
            case .ec2Instance: return "Ec2Instance"
            case .ec2InstanceSavingsPlans: return "Ec2InstanceSavingsPlans"
            case .ec2ReservedInstances: return "Ec2ReservedInstances"
            case .ecsService: return "EcsService"
            case .elastiCacheReservedInstances: return "ElastiCacheReservedInstances"
            case .lambdaFunction: return "LambdaFunction"
            case .openSearchReservedInstances: return "OpenSearchReservedInstances"
            case .rdsReservedInstances: return "RdsReservedInstances"
            case .redshiftReservedInstances: return "RedshiftReservedInstances"
            case .sageMakerSavingsPlans: return "SageMakerSavingsPlans"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension CostOptimizationHubClientTypes.SageMakerSavingsPlans: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration
        case costCalculation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let costCalculation = self.costCalculation {
            try encodeContainer.encode(costCalculation, forKey: .costCalculation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configurationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.SageMakerSavingsPlansConfiguration.self, forKey: .configuration)
        configuration = configurationDecoded
        let costCalculationDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.SavingsPlansCostCalculation.self, forKey: .costCalculation)
        costCalculation = costCalculationDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The SageMaker Savings Plans recommendation details.
    public struct SageMakerSavingsPlans: Swift.Equatable {
        /// The SageMaker Savings Plans configuration used for recommendations.
        public var configuration: CostOptimizationHubClientTypes.SageMakerSavingsPlansConfiguration?
        /// Cost impact of the Savings Plans purchase recommendation.
        public var costCalculation: CostOptimizationHubClientTypes.SavingsPlansCostCalculation?

        public init(
            configuration: CostOptimizationHubClientTypes.SageMakerSavingsPlansConfiguration? = nil,
            costCalculation: CostOptimizationHubClientTypes.SavingsPlansCostCalculation? = nil
        )
        {
            self.configuration = configuration
            self.costCalculation = costCalculation
        }
    }

}

extension CostOptimizationHubClientTypes.SageMakerSavingsPlansConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountScope
        case hourlyCommitment
        case paymentOption
        case term
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountScope = self.accountScope {
            try encodeContainer.encode(accountScope, forKey: .accountScope)
        }
        if let hourlyCommitment = self.hourlyCommitment {
            try encodeContainer.encode(hourlyCommitment, forKey: .hourlyCommitment)
        }
        if let paymentOption = self.paymentOption {
            try encodeContainer.encode(paymentOption, forKey: .paymentOption)
        }
        if let term = self.term {
            try encodeContainer.encode(term, forKey: .term)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountScopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountScope)
        accountScope = accountScopeDecoded
        let termDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .term)
        term = termDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let hourlyCommitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hourlyCommitment)
        hourlyCommitment = hourlyCommitmentDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The SageMaker Savings Plans configuration used for recommendations.
    public struct SageMakerSavingsPlansConfiguration: Swift.Equatable {
        /// The account scope that you want your recommendations for.
        public var accountScope: Swift.String?
        /// The hourly commitment for the Savings Plans type.
        public var hourlyCommitment: Swift.String?
        /// The payment option for the commitment.
        public var paymentOption: Swift.String?
        /// The Savings Plans recommendation term in years.
        public var term: Swift.String?

        public init(
            accountScope: Swift.String? = nil,
            hourlyCommitment: Swift.String? = nil,
            paymentOption: Swift.String? = nil,
            term: Swift.String? = nil
        )
        {
            self.accountScope = accountScope
            self.hourlyCommitment = hourlyCommitment
            self.paymentOption = paymentOption
            self.term = term
        }
    }

}

extension CostOptimizationHubClientTypes {
    public enum SavingsEstimationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case afterDiscounts
        case beforeDiscounts
        case sdkUnknown(Swift.String)

        public static var allCases: [SavingsEstimationMode] {
            return [
                .afterDiscounts,
                .beforeDiscounts,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .afterDiscounts: return "AfterDiscounts"
            case .beforeDiscounts: return "BeforeDiscounts"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SavingsEstimationMode(rawValue: rawValue) ?? SavingsEstimationMode.sdkUnknown(rawValue)
        }
    }
}

extension CostOptimizationHubClientTypes.SavingsPlansCostCalculation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pricing
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pricing = self.pricing {
            try encodeContainer.encode(pricing, forKey: .pricing)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pricingDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.SavingsPlansPricing.self, forKey: .pricing)
        pricing = pricingDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// Cost impact of the purchase recommendation.
    public struct SavingsPlansCostCalculation: Swift.Equatable {
        /// Pricing details of the purchase recommendation.
        public var pricing: CostOptimizationHubClientTypes.SavingsPlansPricing?

        public init(
            pricing: CostOptimizationHubClientTypes.SavingsPlansPricing? = nil
        )
        {
            self.pricing = pricing
        }
    }

}

extension CostOptimizationHubClientTypes.SavingsPlansPricing: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case estimatedMonthlyCommitment
        case estimatedOnDemandCost
        case monthlySavingsPlansEligibleCost
        case savingsPercentage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let estimatedMonthlyCommitment = self.estimatedMonthlyCommitment {
            try encodeContainer.encode(estimatedMonthlyCommitment, forKey: .estimatedMonthlyCommitment)
        }
        if let estimatedOnDemandCost = self.estimatedOnDemandCost {
            try encodeContainer.encode(estimatedOnDemandCost, forKey: .estimatedOnDemandCost)
        }
        if let monthlySavingsPlansEligibleCost = self.monthlySavingsPlansEligibleCost {
            try encodeContainer.encode(monthlySavingsPlansEligibleCost, forKey: .monthlySavingsPlansEligibleCost)
        }
        if let savingsPercentage = self.savingsPercentage {
            try encodeContainer.encode(savingsPercentage, forKey: .savingsPercentage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let monthlySavingsPlansEligibleCostDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .monthlySavingsPlansEligibleCost)
        monthlySavingsPlansEligibleCost = monthlySavingsPlansEligibleCostDecoded
        let estimatedMonthlyCommitmentDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedMonthlyCommitment)
        estimatedMonthlyCommitment = estimatedMonthlyCommitmentDecoded
        let savingsPercentageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .savingsPercentage)
        savingsPercentage = savingsPercentageDecoded
        let estimatedOnDemandCostDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedOnDemandCost)
        estimatedOnDemandCost = estimatedOnDemandCostDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// Pricing information about a Savings Plan.
    public struct SavingsPlansPricing: Swift.Equatable {
        /// Estimated monthly commitment for the Savings Plan.
        public var estimatedMonthlyCommitment: Swift.Double?
        /// Estimated On-Demand cost you will pay after buying the Savings Plan.
        public var estimatedOnDemandCost: Swift.Double?
        /// The cost of paying for the recommended Savings Plan monthly.
        public var monthlySavingsPlansEligibleCost: Swift.Double?
        /// Estimated savings as a percentage of your overall costs after buying the Savings Plan.
        public var savingsPercentage: Swift.Double?

        public init(
            estimatedMonthlyCommitment: Swift.Double? = nil,
            estimatedOnDemandCost: Swift.Double? = nil,
            monthlySavingsPlansEligibleCost: Swift.Double? = nil,
            savingsPercentage: Swift.Double? = nil
        )
        {
            self.estimatedMonthlyCommitment = estimatedMonthlyCommitment
            self.estimatedOnDemandCost = estimatedOnDemandCost
            self.monthlySavingsPlansEligibleCost = monthlySavingsPlansEligibleCost
            self.savingsPercentage = savingsPercentage
        }
    }

}

extension CostOptimizationHubClientTypes {
    public enum Source: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case computeOptimizer
        case costExplorer
        case sdkUnknown(Swift.String)

        public static var allCases: [Source] {
            return [
                .computeOptimizer,
                .costExplorer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .computeOptimizer: return "ComputeOptimizer"
            case .costExplorer: return "CostExplorer"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Source(rawValue: rawValue) ?? Source.sdkUnknown(rawValue)
        }
    }
}

extension CostOptimizationHubClientTypes.StorageConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sizeInGb
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sizeInGb = self.sizeInGb {
            try encodeContainer.encode(sizeInGb, forKey: .sizeInGb)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let sizeInGbDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .sizeInGb)
        sizeInGb = sizeInGbDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The storage configuration used for recommendations.
    public struct StorageConfiguration: Swift.Equatable {
        /// The storage volume.
        public var sizeInGb: Swift.Double?
        /// The storage type.
        public var type: Swift.String?

        public init(
            sizeInGb: Swift.Double? = nil,
            type: Swift.String? = nil
        )
        {
            self.sizeInGb = sizeInGb
            self.type = type
        }
    }

}

extension CostOptimizationHubClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The tag structure that contains a tag key and value.
    public struct Tag: Swift.Equatable {
        /// The key that's associated with the tag.
        public var key: Swift.String?
        /// The value that's associated with the tag.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateEnrollmentStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeMemberAccounts
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeMemberAccounts = self.includeMemberAccounts {
            try encodeContainer.encode(includeMemberAccounts, forKey: .includeMemberAccounts)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateEnrollmentStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateEnrollmentStatusInput: Swift.Equatable {
    /// Indicates whether to enroll member accounts of the organization if the account is the management account.
    public var includeMemberAccounts: Swift.Bool?
    /// Sets the account status.
    /// This member is required.
    public var status: CostOptimizationHubClientTypes.EnrollmentStatus?

    public init(
        includeMemberAccounts: Swift.Bool? = nil,
        status: CostOptimizationHubClientTypes.EnrollmentStatus? = nil
    )
    {
        self.includeMemberAccounts = includeMemberAccounts
        self.status = status
    }
}

struct UpdateEnrollmentStatusInputBody: Swift.Equatable {
    let status: CostOptimizationHubClientTypes.EnrollmentStatus?
    let includeMemberAccounts: Swift.Bool?
}

extension UpdateEnrollmentStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeMemberAccounts
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.EnrollmentStatus.self, forKey: .status)
        status = statusDecoded
        let includeMemberAccountsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeMemberAccounts)
        includeMemberAccounts = includeMemberAccountsDecoded
    }
}

extension UpdateEnrollmentStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEnrollmentStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.status = output.status
        } else {
            self.status = nil
        }
    }
}

public struct UpdateEnrollmentStatusOutput: Swift.Equatable {
    /// The enrollment status of the account.
    public var status: Swift.String?

    public init(
        status: Swift.String? = nil
    )
    {
        self.status = status
    }
}

struct UpdateEnrollmentStatusOutputBody: Swift.Equatable {
    let status: Swift.String?
}

extension UpdateEnrollmentStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
    }
}

enum UpdateEnrollmentStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePreferencesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountDiscountVisibility
        case savingsEstimationMode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let memberAccountDiscountVisibility = self.memberAccountDiscountVisibility {
            try encodeContainer.encode(memberAccountDiscountVisibility.rawValue, forKey: .memberAccountDiscountVisibility)
        }
        if let savingsEstimationMode = self.savingsEstimationMode {
            try encodeContainer.encode(savingsEstimationMode.rawValue, forKey: .savingsEstimationMode)
        }
    }
}

extension UpdatePreferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePreferencesInput: Swift.Equatable {
    /// Sets the "member account discount visibility" preference.
    public var memberAccountDiscountVisibility: CostOptimizationHubClientTypes.MemberAccountDiscountVisibility?
    /// Sets the "savings estimation mode" preference.
    public var savingsEstimationMode: CostOptimizationHubClientTypes.SavingsEstimationMode?

    public init(
        memberAccountDiscountVisibility: CostOptimizationHubClientTypes.MemberAccountDiscountVisibility? = nil,
        savingsEstimationMode: CostOptimizationHubClientTypes.SavingsEstimationMode? = nil
    )
    {
        self.memberAccountDiscountVisibility = memberAccountDiscountVisibility
        self.savingsEstimationMode = savingsEstimationMode
    }
}

struct UpdatePreferencesInputBody: Swift.Equatable {
    let savingsEstimationMode: CostOptimizationHubClientTypes.SavingsEstimationMode?
    let memberAccountDiscountVisibility: CostOptimizationHubClientTypes.MemberAccountDiscountVisibility?
}

extension UpdatePreferencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountDiscountVisibility
        case savingsEstimationMode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsEstimationModeDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.SavingsEstimationMode.self, forKey: .savingsEstimationMode)
        savingsEstimationMode = savingsEstimationModeDecoded
        let memberAccountDiscountVisibilityDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.MemberAccountDiscountVisibility.self, forKey: .memberAccountDiscountVisibility)
        memberAccountDiscountVisibility = memberAccountDiscountVisibilityDecoded
    }
}

extension UpdatePreferencesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePreferencesOutputBody = try responseDecoder.decode(responseBody: data)
            self.memberAccountDiscountVisibility = output.memberAccountDiscountVisibility
            self.savingsEstimationMode = output.savingsEstimationMode
        } else {
            self.memberAccountDiscountVisibility = nil
            self.savingsEstimationMode = nil
        }
    }
}

public struct UpdatePreferencesOutput: Swift.Equatable {
    /// Shows the status of the "member account discount visibility" preference.
    public var memberAccountDiscountVisibility: CostOptimizationHubClientTypes.MemberAccountDiscountVisibility?
    /// Shows the status of the "savings estimation mode" preference.
    public var savingsEstimationMode: CostOptimizationHubClientTypes.SavingsEstimationMode?

    public init(
        memberAccountDiscountVisibility: CostOptimizationHubClientTypes.MemberAccountDiscountVisibility? = nil,
        savingsEstimationMode: CostOptimizationHubClientTypes.SavingsEstimationMode? = nil
    )
    {
        self.memberAccountDiscountVisibility = memberAccountDiscountVisibility
        self.savingsEstimationMode = savingsEstimationMode
    }
}

struct UpdatePreferencesOutputBody: Swift.Equatable {
    let savingsEstimationMode: CostOptimizationHubClientTypes.SavingsEstimationMode?
    let memberAccountDiscountVisibility: CostOptimizationHubClientTypes.MemberAccountDiscountVisibility?
}

extension UpdatePreferencesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberAccountDiscountVisibility
        case savingsEstimationMode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsEstimationModeDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.SavingsEstimationMode.self, forKey: .savingsEstimationMode)
        savingsEstimationMode = savingsEstimationModeDecoded
        let memberAccountDiscountVisibilityDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.MemberAccountDiscountVisibility.self, forKey: .memberAccountDiscountVisibility)
        memberAccountDiscountVisibility = memberAccountDiscountVisibilityDecoded
    }
}

enum UpdatePreferencesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CostOptimizationHubClientTypes.Usage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operation
        case productCode
        case unit
        case usageAmount
        case usageType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operation = self.operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let productCode = self.productCode {
            try encodeContainer.encode(productCode, forKey: .productCode)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
        if let usageAmount = self.usageAmount {
            try encodeContainer.encode(usageAmount, forKey: .usageAmount)
        }
        if let usageType = self.usageType {
            try encodeContainer.encode(usageType, forKey: .usageType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageType)
        usageType = usageTypeDecoded
        let usageAmountDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .usageAmount)
        usageAmount = usageAmountDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let productCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productCode)
        productCode = productCodeDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// Details about the usage.
    public struct Usage: Swift.Equatable {
        /// The operation value.
        public var operation: Swift.String?
        /// The product code.
        public var productCode: Swift.String?
        /// The usage unit.
        public var unit: Swift.String?
        /// The usage amount.
        public var usageAmount: Swift.Double?
        /// The usage type.
        public var usageType: Swift.String?

        public init(
            operation: Swift.String? = nil,
            productCode: Swift.String? = nil,
            unit: Swift.String? = nil,
            usageAmount: Swift.Double? = nil,
            usageType: Swift.String? = nil
        )
        {
            self.operation = operation
            self.productCode = productCode
            self.unit = unit
            self.usageAmount = usageAmount
            self.usageType = usageType
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fields = output.fields
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fields = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an Amazon Web Services service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The list of fields that are invalid.
        public internal(set) var fields: [CostOptimizationHubClientTypes.ValidationExceptionDetail]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the validation exception.
        public internal(set) var reason: CostOptimizationHubClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fields: [CostOptimizationHubClientTypes.ValidationExceptionDetail]? = nil,
        message: Swift.String? = nil,
        reason: CostOptimizationHubClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fields = fields
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: CostOptimizationHubClientTypes.ValidationExceptionReason?
    let fields: [CostOptimizationHubClientTypes.ValidationExceptionDetail]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fields
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(CostOptimizationHubClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldsContainer = try containerValues.decodeIfPresent([CostOptimizationHubClientTypes.ValidationExceptionDetail?].self, forKey: .fields)
        var fieldsDecoded0:[CostOptimizationHubClientTypes.ValidationExceptionDetail]? = nil
        if let fieldsContainer = fieldsContainer {
            fieldsDecoded0 = [CostOptimizationHubClientTypes.ValidationExceptionDetail]()
            for structure0 in fieldsContainer {
                if let structure0 = structure0 {
                    fieldsDecoded0?.append(structure0)
                }
            }
        }
        fields = fieldsDecoded0
    }
}

extension CostOptimizationHubClientTypes.ValidationExceptionDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldName
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fieldName = self.fieldName {
            try encodeContainer.encode(fieldName, forKey: .fieldName)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fieldNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fieldName)
        fieldName = fieldNameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CostOptimizationHubClientTypes {
    /// The input failed to meet the constraints specified by the Amazon Web Services service in a specified field.
    public struct ValidationExceptionDetail: Swift.Equatable {
        /// The field name where the invalid entry was detected.
        /// This member is required.
        public var fieldName: Swift.String?
        /// A message with the reason for the validation exception error.
        /// This member is required.
        public var message: Swift.String?

        public init(
            fieldName: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.fieldName = fieldName
            self.message = message
        }
    }

}

extension CostOptimizationHubClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fieldValidationFailed
        case other
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .fieldValidationFailed,
                .other,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fieldValidationFailed: return "FieldValidationFailed"
            case .other: return "Other"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
