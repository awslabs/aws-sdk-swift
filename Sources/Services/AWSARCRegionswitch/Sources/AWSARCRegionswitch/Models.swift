//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
@_spi(SmithyReadWrite) import class SmithyCBOR.Reader
@_spi(SmithyReadWrite) import class SmithyCBOR.Writer
import class SmithyHTTPAPI.HTTPResponse
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.mapWritingClosure
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
import protocol ClientRuntime.ServiceError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct ClientRuntime.RpcV2CborError
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

extension ARCRegionswitchClientTypes {

    public enum ExecutionAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activate
        case deactivate
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionAction] {
            return [
                .activate,
                .deactivate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activate: return "activate"
            case .deactivate: return "deactivate"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCRegionswitchClientTypes {

    public enum ExecutionState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case completedMonitoringApplicationHealth
        case completedWithExceptions
        case failed
        case inProgress
        case pausedByFailedStep
        case pausedByOperator
        case pending
        case pendingManualApproval
        case planExecutionTimedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionState] {
            return [
                .cancelled,
                .completed,
                .completedMonitoringApplicationHealth,
                .completedWithExceptions,
                .failed,
                .inProgress,
                .pausedByFailedStep,
                .pausedByOperator,
                .pending,
                .pendingManualApproval,
                .planExecutionTimedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "canceled"
            case .completed: return "completed"
            case .completedMonitoringApplicationHealth: return "completedMonitoringApplicationHealth"
            case .completedWithExceptions: return "completedWithExceptions"
            case .failed: return "failed"
            case .inProgress: return "inProgress"
            case .pausedByFailedStep: return "pausedByFailedStep"
            case .pausedByOperator: return "pausedByOperator"
            case .pending: return "pending"
            case .pendingManualApproval: return "pendingManualApproval"
            case .planExecutionTimedOut: return "planExecutionTimedOut"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCRegionswitchClientTypes {

    public enum ExecutionMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case graceful
        case ungraceful
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionMode] {
            return [
                .graceful,
                .ungraceful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .graceful: return "graceful"
            case .ungraceful: return "ungraceful"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// A summarized representation of a plan execution. This structure contains key information about an execution without all the detailed step data.
    public struct AbbreviatedExecution: Swift.Sendable {
        /// The actual recovery time that Region switch calculates for a plan execution. Actual recovery time includes the time for the plan to run added to the time elapsed until the application health alarms that you've specified are healthy again.
        public var actualRecoveryTime: Swift.String?
        /// An optional comment about the plan execution.
        public var comment: Swift.String?
        /// The timestamp when the plan execution was ended.
        public var endTime: Foundation.Date?
        /// The plan execution action. Valid values are Activate, to activate an Amazon Web Services Region, or Deactivate, to deactivate a Region.
        /// This member is required.
        public var executionAction: ARCRegionswitchClientTypes.ExecutionAction?
        /// The execution identifier of a plan execution.
        /// This member is required.
        public var executionId: Swift.String?
        /// The Amazon Web Services Region for a plan execution.
        /// This member is required.
        public var executionRegion: Swift.String?
        /// The plan execution state. Provides the state of a plan execution, for example, In Progress or Paused by Operator.
        /// This member is required.
        public var executionState: ARCRegionswitchClientTypes.ExecutionState?
        /// The plan execution mode. Valid values are Practice, for testing without making actual changes, or Recovery, for actual traffic shifting and application recovery.
        /// This member is required.
        public var mode: ARCRegionswitchClientTypes.ExecutionMode?
        /// The Amazon Resource Name (ARN) of the plan.
        /// This member is required.
        public var planArn: Swift.String?
        /// The timestamp when the plan execution was started.
        /// This member is required.
        public var startTime: Foundation.Date?
        /// The timestamp when the plan execution was last updated.
        public var updatedAt: Foundation.Date?
        /// The version for the plan.
        public var version: Swift.String?

        public init(
            actualRecoveryTime: Swift.String? = nil,
            comment: Swift.String? = nil,
            endTime: Foundation.Date? = nil,
            executionAction: ARCRegionswitchClientTypes.ExecutionAction? = nil,
            executionId: Swift.String? = nil,
            executionRegion: Swift.String? = nil,
            executionState: ARCRegionswitchClientTypes.ExecutionState? = nil,
            mode: ARCRegionswitchClientTypes.ExecutionMode? = nil,
            planArn: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            updatedAt: Foundation.Date? = nil,
            version: Swift.String? = nil
        ) {
            self.actualRecoveryTime = actualRecoveryTime
            self.comment = comment
            self.endTime = endTime
            self.executionAction = executionAction
            self.executionId = executionId
            self.executionRegion = executionRegion
            self.executionState = executionState
            self.mode = mode
            self.planArn = planArn
            self.startTime = startTime
            self.updatedAt = updatedAt
            self.version = version
        }
    }
}

extension ARCRegionswitchClientTypes {

    public enum RecoveryApproach: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activeActive
        case activePassive
        case sdkUnknown(Swift.String)

        public static var allCases: [RecoveryApproach] {
            return [
                .activeActive,
                .activePassive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activeActive: return "activeActive"
            case .activePassive: return "activePassive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// A summarized representation of a Region switch plan. This structure contains key information about a plan without all the detailed workflow and step data.
    public struct AbbreviatedPlan: Swift.Sendable {
        /// Specifies if this is the active plan execution at this time.
        public var activePlanExecution: Swift.String?
        /// The Amazon Resource Name (ARN) of the Region switch plan.
        /// This member is required.
        public var arn: Swift.String?
        /// The description of a Region switch plan.
        public var description: Swift.String?
        /// The execution role is a way to categorize a Region switch plan.
        public var executionRole: Swift.String?
        /// The name of a Region switch plan.
        /// This member is required.
        public var name: Swift.String?
        /// The owner of a Region switch plan.
        /// This member is required.
        public var owner: Swift.String?
        /// The primary Region for a plan.
        public var primaryRegion: Swift.String?
        /// The recovery approach for a Region switch plan, which can be active/active (activeActive) or active/passive (activePassive).
        /// This member is required.
        public var recoveryApproach: ARCRegionswitchClientTypes.RecoveryApproach?
        /// The recovery time objective that you've specified.
        public var recoveryTimeObjectiveMinutes: Swift.Int?
        /// The Amazon Web Services Region specified for a Region switch plan.
        /// This member is required.
        public var regions: [Swift.String]?
        /// The timestamp when the plan execution was last updated.
        public var updatedAt: Foundation.Date?
        /// The version for the plan.
        public var version: Swift.String?

        public init(
            activePlanExecution: Swift.String? = nil,
            arn: Swift.String? = nil,
            description: Swift.String? = nil,
            executionRole: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            primaryRegion: Swift.String? = nil,
            recoveryApproach: ARCRegionswitchClientTypes.RecoveryApproach? = nil,
            recoveryTimeObjectiveMinutes: Swift.Int? = nil,
            regions: [Swift.String]? = nil,
            updatedAt: Foundation.Date? = nil,
            version: Swift.String? = nil
        ) {
            self.activePlanExecution = activePlanExecution
            self.arn = arn
            self.description = description
            self.executionRole = executionRole
            self.name = name
            self.owner = owner
            self.primaryRegion = primaryRegion
            self.recoveryApproach = recoveryApproach
            self.recoveryTimeObjectiveMinutes = recoveryTimeObjectiveMinutes
            self.regions = regions
            self.updatedAt = updatedAt
            self.version = version
        }
    }
}

/// You do not have sufficient access to perform this action. HTTP Status Code: 403
public struct AccessDeniedException: ClientRuntime.ModeledError, ClientRuntime.ServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension ARCRegionswitchClientTypes {

    public enum AlarmCondition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case green
        case red
        case sdkUnknown(Swift.String)

        public static var allCases: [AlarmCondition] {
            return [
                .green,
                .red
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .green: return "green"
            case .red: return "red"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCRegionswitchClientTypes {

    public enum AlarmType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case applicationHealth
        case trigger
        case sdkUnknown(Swift.String)

        public static var allCases: [AlarmType] {
            return [
                .applicationHealth,
                .trigger
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .applicationHealth: return "applicationHealth"
            case .trigger: return "trigger"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCRegionswitchClientTypes {

    public enum Approval: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approve
        case decline
        case sdkUnknown(Swift.String)

        public static var allCases: [Approval] {
            return [
                .approve,
                .decline
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approve: return "approve"
            case .decline: return "decline"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The specified resource was not found. HTTP Status Code: 404
public struct ResourceNotFoundException: ClientRuntime.ModeledError, ClientRuntime.ServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct ApprovePlanExecutionStepInput: Swift.Sendable {
    /// The status of approval for a plan execution step.
    /// This member is required.
    public var approval: ARCRegionswitchClientTypes.Approval?
    /// A comment that you can enter about a plan execution.
    public var comment: Swift.String?
    /// The execution identifier of a plan execution.
    /// This member is required.
    public var executionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the plan.
    /// This member is required.
    public var planArn: Swift.String?
    /// The name of a step in a plan execution.
    /// This member is required.
    public var stepName: Swift.String?

    public init(
        approval: ARCRegionswitchClientTypes.Approval? = nil,
        comment: Swift.String? = nil,
        executionId: Swift.String? = nil,
        planArn: Swift.String? = nil,
        stepName: Swift.String? = nil
    ) {
        self.approval = approval
        self.comment = comment
        self.executionId = executionId
        self.planArn = planArn
        self.stepName = stepName
    }
}

public struct ApprovePlanExecutionStepOutput: Swift.Sendable {

    public init() { }
}

public struct CancelPlanExecutionInput: Swift.Sendable {
    /// A comment that you can enter about canceling a plan execution step.
    public var comment: Swift.String?
    /// The execution identifier of a plan execution.
    /// This member is required.
    public var executionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the plan.
    /// This member is required.
    public var planArn: Swift.String?

    public init(
        comment: Swift.String? = nil,
        executionId: Swift.String? = nil,
        planArn: Swift.String? = nil
    ) {
        self.comment = comment
        self.executionId = executionId
        self.planArn = planArn
    }
}

public struct CancelPlanExecutionOutput: Swift.Sendable {

    public init() { }
}

public struct GetPlanEvaluationStatusInput: Swift.Sendable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the Region switch plan to retrieve evaluation status for.
    /// This member is required.
    public var planArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        planArn: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.planArn = planArn
    }
}

extension ARCRegionswitchClientTypes {

    public enum EvaluationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actionRequired
        case passed
        case pendingEvaluation
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [EvaluationStatus] {
            return [
                .actionRequired,
                .passed,
                .pendingEvaluation,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actionRequired: return "actionRequired"
            case .passed: return "passed"
            case .pendingEvaluation: return "pendingEvaluation"
            case .unknown: return "unknown"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCRegionswitchClientTypes {

    public enum ResourceWarningStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceWarningStatus] {
            return [
                .active,
                .resolved
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "active"
            case .resolved: return "resolved"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// A simplified representation of a workflow in a Region switch plan.
    public struct MinimalWorkflow: Swift.Sendable {
        /// The action for a minimal workflow, which can be Activate or Deactivate.
        public var action: ARCRegionswitchClientTypes.ExecutionAction?
        /// The name for a minimal workflow
        public var name: Swift.String?

        public init(
            action: ARCRegionswitchClientTypes.ExecutionAction? = nil,
            name: Swift.String? = nil
        ) {
            self.action = action
            self.name = name
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Represents a warning about a resource in a Region switch plan.
    public struct ResourceWarning: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the resource.
        public var resourceArn: Swift.String?
        /// The name of the step for the resource warning.
        public var stepName: Swift.String?
        /// The version for the resource warning.
        /// This member is required.
        public var version: Swift.String?
        /// The warning message about what needs to be corrected.
        /// This member is required.
        public var warningMessage: Swift.String?
        /// The status of the resource warning.
        /// This member is required.
        public var warningStatus: ARCRegionswitchClientTypes.ResourceWarningStatus?
        /// The timestamp when the warning was last updated.
        /// This member is required.
        public var warningUpdatedTime: Foundation.Date?
        /// The workflow for the resource warning.
        public var workflow: ARCRegionswitchClientTypes.MinimalWorkflow?

        public init(
            resourceArn: Swift.String? = nil,
            stepName: Swift.String? = nil,
            version: Swift.String? = nil,
            warningMessage: Swift.String? = nil,
            warningStatus: ARCRegionswitchClientTypes.ResourceWarningStatus? = nil,
            warningUpdatedTime: Foundation.Date? = nil,
            workflow: ARCRegionswitchClientTypes.MinimalWorkflow? = nil
        ) {
            self.resourceArn = resourceArn
            self.stepName = stepName
            self.version = version
            self.warningMessage = warningMessage
            self.warningStatus = warningStatus
            self.warningUpdatedTime = warningUpdatedTime
            self.workflow = workflow
        }
    }
}

public struct GetPlanEvaluationStatusOutput: Swift.Sendable {
    /// The evaluation state for the plan.
    public var evaluationState: ARCRegionswitchClientTypes.EvaluationStatus?
    /// The version of the last evaluation of the plan.
    public var lastEvaluatedVersion: Swift.String?
    /// The time of the last time that Region switch ran an evaluation of the plan.
    public var lastEvaluationTime: Foundation.Date?
    /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the plan.
    /// This member is required.
    public var planArn: Swift.String?
    /// The Amazon Web Services Region for the plan.
    public var region: Swift.String?
    /// The current evaluation warnings for the plan.
    public var warnings: [ARCRegionswitchClientTypes.ResourceWarning]?

    public init(
        evaluationState: ARCRegionswitchClientTypes.EvaluationStatus? = nil,
        lastEvaluatedVersion: Swift.String? = nil,
        lastEvaluationTime: Foundation.Date? = nil,
        nextToken: Swift.String? = nil,
        planArn: Swift.String? = nil,
        region: Swift.String? = nil,
        warnings: [ARCRegionswitchClientTypes.ResourceWarning]? = nil
    ) {
        self.evaluationState = evaluationState
        self.lastEvaluatedVersion = lastEvaluatedVersion
        self.lastEvaluationTime = lastEvaluationTime
        self.nextToken = nextToken
        self.planArn = planArn
        self.region = region
        self.warnings = warnings
    }
}

public struct GetPlanExecutionInput: Swift.Sendable {
    /// The execution identifier of a plan execution.
    /// This member is required.
    public var executionId: Swift.String?
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the plan with the execution to retrieve.
    /// This member is required.
    public var planArn: Swift.String?

    public init(
        executionId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        planArn: Swift.String? = nil
    ) {
        self.executionId = executionId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.planArn = planArn
    }
}

extension ARCRegionswitchClientTypes {

    /// An Amazon CloudWatch alarm associated with a Region switch plan. These alarms can be used to trigger automatic execution of the plan.
    public struct AssociatedAlarm: Swift.Sendable {
        /// The alarm type for an associated alarm. An associated CloudWatch alarm can be an application health alarm or a trigger alarm.
        /// This member is required.
        public var alarmType: ARCRegionswitchClientTypes.AlarmType?
        /// The cross account role for the configuration.
        public var crossAccountRole: Swift.String?
        /// The external ID (secret key) for the configuration.
        public var externalId: Swift.String?
        /// The resource identifier for alarms that you associate with a plan.
        /// This member is required.
        public var resourceIdentifier: Swift.String?

        public init(
            alarmType: ARCRegionswitchClientTypes.AlarmType? = nil,
            crossAccountRole: Swift.String? = nil,
            externalId: Swift.String? = nil,
            resourceIdentifier: Swift.String? = nil
        ) {
            self.alarmType = alarmType
            self.crossAccountRole = crossAccountRole
            self.externalId = externalId
            self.resourceIdentifier = resourceIdentifier
        }
    }
}

extension ARCRegionswitchClientTypes {

    public enum WorkflowTargetAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activate
        case deactivate
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkflowTargetAction] {
            return [
                .activate,
                .deactivate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activate: return "activate"
            case .deactivate: return "deactivate"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Defines a condition that must be met for a trigger to fire.
    public struct TriggerCondition: Swift.Sendable {
        /// The name of the CloudWatch alarm associated with the condition.
        /// This member is required.
        public var associatedAlarmName: Swift.String?
        /// The condition that must be met. Valid values include ALARM and OK.
        /// This member is required.
        public var condition: ARCRegionswitchClientTypes.AlarmCondition?

        public init(
            associatedAlarmName: Swift.String? = nil,
            condition: ARCRegionswitchClientTypes.AlarmCondition? = nil
        ) {
            self.associatedAlarmName = associatedAlarmName
            self.condition = condition
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Defines a condition that can automatically trigger the execution of a Region switch plan.
    public struct Trigger: Swift.Sendable {
        /// The action to perform when the trigger fires. Valid values include ACTIVATE and DEACTIVATE.
        /// This member is required.
        public var action: ARCRegionswitchClientTypes.WorkflowTargetAction?
        /// The conditions that must be met for the trigger to fire.
        /// This member is required.
        public var conditions: [ARCRegionswitchClientTypes.TriggerCondition]?
        /// The description for a trigger.
        public var description: Swift.String?
        /// The minimum time, in minutes, that must elapse between automatic executions of the plan.
        /// This member is required.
        public var minDelayMinutesBetweenExecutions: Swift.Int?
        /// The Amazon Web Services Region for a trigger.
        /// This member is required.
        public var targetRegion: Swift.String?

        public init(
            action: ARCRegionswitchClientTypes.WorkflowTargetAction? = nil,
            conditions: [ARCRegionswitchClientTypes.TriggerCondition]? = nil,
            description: Swift.String? = nil,
            minDelayMinutesBetweenExecutions: Swift.Int? = nil,
            targetRegion: Swift.String? = nil
        ) {
            self.action = action
            self.conditions = conditions
            self.description = description
            self.minDelayMinutesBetweenExecutions = minDelayMinutesBetweenExecutions
            self.targetRegion = targetRegion
        }
    }
}

extension ARCRegionswitchClientTypes {

    public enum RoutingControlStateChange: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case off
        case on
        case sdkUnknown(Swift.String)

        public static var allCases: [RoutingControlStateChange] {
            return [
                .off,
                .on
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .off: return "Off"
            case .on: return "On"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Represents the state of an ARC routing control.
    public struct ArcRoutingControlState: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of a routing control.
        /// This member is required.
        public var routingControlArn: Swift.String?
        /// The state of an ARC routing control, On or Off.
        /// This member is required.
        public var state: ARCRegionswitchClientTypes.RoutingControlStateChange?

        public init(
            routingControlArn: Swift.String? = nil,
            state: ARCRegionswitchClientTypes.RoutingControlStateChange? = nil
        ) {
            self.routingControlArn = routingControlArn
            self.state = state
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Configuration for ARC routing controls used in a Region switch plan. Routing controls are simple on/off switches that you can use to shift traffic away from an impaired Region.
    public struct ArcRoutingControlConfiguration: Swift.Sendable {
        /// The cross account role for the configuration.
        public var crossAccountRole: Swift.String?
        /// The external ID (secret key) for the configuration.
        public var externalId: Swift.String?
        /// The Region and ARC routing controls for the configuration.
        /// This member is required.
        public var regionAndRoutingControls: [Swift.String: [ARCRegionswitchClientTypes.ArcRoutingControlState]]?
        /// The timeout value specified for the configuration.
        public var timeoutMinutes: Swift.Int?

        public init(
            crossAccountRole: Swift.String? = nil,
            externalId: Swift.String? = nil,
            regionAndRoutingControls: [Swift.String: [ARCRegionswitchClientTypes.ArcRoutingControlState]]? = nil,
            timeoutMinutes: Swift.Int? = 60
        ) {
            self.crossAccountRole = crossAccountRole
            self.externalId = externalId
            self.regionAndRoutingControls = regionAndRoutingControls
            self.timeoutMinutes = timeoutMinutes
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Configuration for Amazon Web Services Lambda functions used in a Region switch plan.
    public struct Lambdas: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Lambda function.
        public var arn: Swift.String?
        /// The cross account role for the configuration.
        public var crossAccountRole: Swift.String?
        /// The external ID (secret key) for the configuration.
        public var externalId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            crossAccountRole: Swift.String? = nil,
            externalId: Swift.String? = nil
        ) {
            self.arn = arn
            self.crossAccountRole = crossAccountRole
            self.externalId = externalId
        }
    }
}

extension ARCRegionswitchClientTypes {

    public enum RegionToRunIn: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case activatingRegion
        case deactivatingRegion
        case sdkUnknown(Swift.String)

        public static var allCases: [RegionToRunIn] {
            return [
                .activatingRegion,
                .deactivatingRegion
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .activatingRegion: return "activatingRegion"
            case .deactivatingRegion: return "deactivatingRegion"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCRegionswitchClientTypes {

    public enum LambdaUngracefulBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case skip
        case sdkUnknown(Swift.String)

        public static var allCases: [LambdaUngracefulBehavior] {
            return [
                .skip
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .skip: return "skip"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Configuration for handling failures when invoking Lambda functions.
    public struct LambdaUngraceful: Swift.Sendable {
        /// The ungraceful behavior for a Lambda function, which must be set to skip.
        public var behavior: ARCRegionswitchClientTypes.LambdaUngracefulBehavior?

        public init(
            behavior: ARCRegionswitchClientTypes.LambdaUngracefulBehavior? = .skip
        ) {
            self.behavior = behavior
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Configuration for Amazon Web Services Lambda functions that perform custom actions during a Region switch.
    public struct CustomActionLambdaConfiguration: Swift.Sendable {
        /// The Amazon Web Services Lambda functions for the execution block.
        /// This member is required.
        public var lambdas: [ARCRegionswitchClientTypes.Lambdas]?
        /// The Amazon Web Services Region for the function to run in.
        /// This member is required.
        public var regionToRun: ARCRegionswitchClientTypes.RegionToRunIn?
        /// The retry interval specified.
        /// This member is required.
        public var retryIntervalMinutes: Swift.Float?
        /// The timeout value specified for the configuration.
        public var timeoutMinutes: Swift.Int?
        /// The settings for ungraceful execution.
        public var ungraceful: ARCRegionswitchClientTypes.LambdaUngraceful?

        public init(
            lambdas: [ARCRegionswitchClientTypes.Lambdas]? = nil,
            regionToRun: ARCRegionswitchClientTypes.RegionToRunIn? = nil,
            retryIntervalMinutes: Swift.Float? = nil,
            timeoutMinutes: Swift.Int? = 60,
            ungraceful: ARCRegionswitchClientTypes.LambdaUngraceful? = nil
        ) {
            self.lambdas = lambdas
            self.regionToRun = regionToRun
            self.retryIntervalMinutes = retryIntervalMinutes
            self.timeoutMinutes = timeoutMinutes
            self.ungraceful = ungraceful
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Configuration for an Amazon EC2 Auto Scaling group used in a Region switch plan.
    public struct Asg: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the EC2 Auto Scaling group.
        public var arn: Swift.String?
        /// The cross account role for the configuration.
        public var crossAccountRole: Swift.String?
        /// The external ID (secret key) for the configuration.
        public var externalId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            crossAccountRole: Swift.String? = nil,
            externalId: Swift.String? = nil
        ) {
            self.arn = arn
            self.crossAccountRole = crossAccountRole
            self.externalId = externalId
        }
    }
}

extension ARCRegionswitchClientTypes {

    public enum Ec2AsgCapacityMonitoringApproach: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case autoscalingMaxInLast24Hours
        case sampledMaxInLast24Hours
        case sdkUnknown(Swift.String)

        public static var allCases: [Ec2AsgCapacityMonitoringApproach] {
            return [
                .autoscalingMaxInLast24Hours,
                .sampledMaxInLast24Hours
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .autoscalingMaxInLast24Hours: return "autoscalingMaxInLast24Hours"
            case .sampledMaxInLast24Hours: return "sampledMaxInLast24Hours"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Configuration for handling failures when performing operations on EC2 resources.
    public struct Ec2Ungraceful: Swift.Sendable {
        /// The minimum success percentage that you specify for EC2 Auto Scaling groups.
        /// This member is required.
        public var minimumSuccessPercentage: Swift.Int?

        public init(
            minimumSuccessPercentage: Swift.Int? = nil
        ) {
            self.minimumSuccessPercentage = minimumSuccessPercentage
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Configuration for increasing the capacity of Amazon EC2 Auto Scaling groups during a Region switch.
    public struct Ec2AsgCapacityIncreaseConfiguration: Swift.Sendable {
        /// The EC2 Auto Scaling groups for the configuration.
        /// This member is required.
        public var asgs: [ARCRegionswitchClientTypes.Asg]?
        /// The monitoring approach that you specify EC2 Auto Scaling groups for the configuration.
        public var capacityMonitoringApproach: ARCRegionswitchClientTypes.Ec2AsgCapacityMonitoringApproach?
        /// The target percentage that you specify for EC2 Auto Scaling groups.
        public var targetPercent: Swift.Int?
        /// The timeout value specified for the configuration.
        public var timeoutMinutes: Swift.Int?
        /// The settings for ungraceful execution.
        public var ungraceful: ARCRegionswitchClientTypes.Ec2Ungraceful?

        public init(
            asgs: [ARCRegionswitchClientTypes.Asg]? = nil,
            capacityMonitoringApproach: ARCRegionswitchClientTypes.Ec2AsgCapacityMonitoringApproach? = .sampledMaxInLast24Hours,
            targetPercent: Swift.Int? = 100,
            timeoutMinutes: Swift.Int? = 60,
            ungraceful: ARCRegionswitchClientTypes.Ec2Ungraceful? = nil
        ) {
            self.asgs = asgs
            self.capacityMonitoringApproach = capacityMonitoringApproach
            self.targetPercent = targetPercent
            self.timeoutMinutes = timeoutMinutes
            self.ungraceful = ungraceful
        }
    }
}

extension ARCRegionswitchClientTypes {

    public enum EcsCapacityMonitoringApproach: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case containerInsightsMaxInLast24Hours
        case sampledMaxInLast24Hours
        case sdkUnknown(Swift.String)

        public static var allCases: [EcsCapacityMonitoringApproach] {
            return [
                .containerInsightsMaxInLast24Hours,
                .sampledMaxInLast24Hours
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .containerInsightsMaxInLast24Hours: return "containerInsightsMaxInLast24Hours"
            case .sampledMaxInLast24Hours: return "sampledMaxInLast24Hours"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// The service for a cross account role.
    public struct Service: Swift.Sendable {
        /// The cluster Amazon Resource Name (ARN) for a service.
        public var clusterArn: Swift.String?
        /// The cross account role for a service.
        public var crossAccountRole: Swift.String?
        /// The external ID (secret key) for the service.
        public var externalId: Swift.String?
        /// The Amazon Resource Name (ARN) for a service.
        public var serviceArn: Swift.String?

        public init(
            clusterArn: Swift.String? = nil,
            crossAccountRole: Swift.String? = nil,
            externalId: Swift.String? = nil,
            serviceArn: Swift.String? = nil
        ) {
            self.clusterArn = clusterArn
            self.crossAccountRole = crossAccountRole
            self.externalId = externalId
            self.serviceArn = serviceArn
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// The settings for ungraceful execution.
    public struct EcsUngraceful: Swift.Sendable {
        /// The minimum success percentage specified for the configuration.
        /// This member is required.
        public var minimumSuccessPercentage: Swift.Int?

        public init(
            minimumSuccessPercentage: Swift.Int? = nil
        ) {
            self.minimumSuccessPercentage = minimumSuccessPercentage
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// The configuration for an Amazon Web Services ECS capacity increase.
    public struct EcsCapacityIncreaseConfiguration: Swift.Sendable {
        /// The monitoring approach specified for the configuration, for example, Most_Recent.
        public var capacityMonitoringApproach: ARCRegionswitchClientTypes.EcsCapacityMonitoringApproach?
        /// The services specified for the configuration.
        /// This member is required.
        public var services: [ARCRegionswitchClientTypes.Service]?
        /// The target percentage specified for the configuration.
        public var targetPercent: Swift.Int?
        /// The timeout value specified for the configuration.
        public var timeoutMinutes: Swift.Int?
        /// The settings for ungraceful execution.
        public var ungraceful: ARCRegionswitchClientTypes.EcsUngraceful?

        public init(
            capacityMonitoringApproach: ARCRegionswitchClientTypes.EcsCapacityMonitoringApproach? = .sampledMaxInLast24Hours,
            services: [ARCRegionswitchClientTypes.Service]? = nil,
            targetPercent: Swift.Int? = 100,
            timeoutMinutes: Swift.Int? = 60,
            ungraceful: ARCRegionswitchClientTypes.EcsUngraceful? = nil
        ) {
            self.capacityMonitoringApproach = capacityMonitoringApproach
            self.services = services
            self.targetPercent = targetPercent
            self.timeoutMinutes = timeoutMinutes
            self.ungraceful = ungraceful
        }
    }
}

extension ARCRegionswitchClientTypes {

    public enum EksCapacityMonitoringApproach: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sampledMaxInLast24Hours
        case sdkUnknown(Swift.String)

        public static var allCases: [EksCapacityMonitoringApproach] {
            return [
                .sampledMaxInLast24Hours
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sampledMaxInLast24Hours: return "sampledMaxInLast24Hours"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// The Amazon Web Services EKS cluster execution block configuration.
    public struct EksCluster: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of an Amazon Web Services EKS cluster.
        /// This member is required.
        public var clusterArn: Swift.String?
        /// The cross account role for the configuration.
        public var crossAccountRole: Swift.String?
        /// The external ID (secret key) for the configuration.
        public var externalId: Swift.String?

        public init(
            clusterArn: Swift.String? = nil,
            crossAccountRole: Swift.String? = nil,
            externalId: Swift.String? = nil
        ) {
            self.clusterArn = clusterArn
            self.crossAccountRole = crossAccountRole
            self.externalId = externalId
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Defines the type of Kubernetes resource to scale in an Amazon EKS cluster.
    public struct KubernetesResourceType: Swift.Sendable {
        /// The API version type for the Kubernetes resource.
        /// This member is required.
        public var apiVersion: Swift.String?
        /// The kind for the Kubernetes resource.
        /// This member is required.
        public var kind: Swift.String?

        public init(
            apiVersion: Swift.String? = nil,
            kind: Swift.String? = nil
        ) {
            self.apiVersion = apiVersion
            self.kind = kind
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Defines a Kubernetes resource to scale in an Amazon EKS cluster.
    public struct KubernetesScalingResource: Swift.Sendable {
        /// The hpaname for the Kubernetes resource.
        public var hpaName: Swift.String?
        /// The name for the Kubernetes resource.
        /// This member is required.
        public var name: Swift.String?
        /// The namespace for the Kubernetes resource.
        /// This member is required.
        public var namespace: Swift.String?

        public init(
            hpaName: Swift.String? = nil,
            name: Swift.String? = nil,
            namespace: Swift.String? = nil
        ) {
            self.hpaName = hpaName
            self.name = name
            self.namespace = namespace
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// The ungraceful settings for Amazon Web Services EKS resource scaling.
    public struct EksResourceScalingUngraceful: Swift.Sendable {
        /// The minimum success percentage for the configuration.
        /// This member is required.
        public var minimumSuccessPercentage: Swift.Int?

        public init(
            minimumSuccessPercentage: Swift.Int? = nil
        ) {
            self.minimumSuccessPercentage = minimumSuccessPercentage
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// The Amazon Web Services EKS resource scaling configuration.
    public struct EksResourceScalingConfiguration: Swift.Sendable {
        /// The monitoring approach for the configuration, that is, whether it was sampled in the last 24 hours or autoscaled in the last 24 hours.
        public var capacityMonitoringApproach: ARCRegionswitchClientTypes.EksCapacityMonitoringApproach?
        /// The clusters for the configuration.
        public var eksClusters: [ARCRegionswitchClientTypes.EksCluster]?
        /// The Kubernetes resource type for the configuration.
        /// This member is required.
        public var kubernetesResourceType: ARCRegionswitchClientTypes.KubernetesResourceType?
        /// The scaling resources for the configuration.
        public var scalingResources: [[Swift.String: [Swift.String: ARCRegionswitchClientTypes.KubernetesScalingResource]]]?
        /// The target percentage for the configuration.
        public var targetPercent: Swift.Int?
        /// The timeout value specified for the configuration.
        public var timeoutMinutes: Swift.Int?
        /// The settings for ungraceful execution.
        public var ungraceful: ARCRegionswitchClientTypes.EksResourceScalingUngraceful?

        public init(
            capacityMonitoringApproach: ARCRegionswitchClientTypes.EksCapacityMonitoringApproach? = .sampledMaxInLast24Hours,
            eksClusters: [ARCRegionswitchClientTypes.EksCluster]? = nil,
            kubernetesResourceType: ARCRegionswitchClientTypes.KubernetesResourceType? = nil,
            scalingResources: [[Swift.String: [Swift.String: ARCRegionswitchClientTypes.KubernetesScalingResource]]]? = nil,
            targetPercent: Swift.Int? = 100,
            timeoutMinutes: Swift.Int? = 60,
            ungraceful: ARCRegionswitchClientTypes.EksResourceScalingUngraceful? = nil
        ) {
            self.capacityMonitoringApproach = capacityMonitoringApproach
            self.eksClusters = eksClusters
            self.kubernetesResourceType = kubernetesResourceType
            self.scalingResources = scalingResources
            self.targetPercent = targetPercent
            self.timeoutMinutes = timeoutMinutes
            self.ungraceful = ungraceful
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Configuration for approval steps in a Region switch plan execution. Approval steps require manual intervention before the execution can proceed.
    public struct ExecutionApprovalConfiguration: Swift.Sendable {
        /// The IAM approval role for the configuration.
        /// This member is required.
        public var approvalRole: Swift.String?
        /// The timeout value specified for the configuration.
        public var timeoutMinutes: Swift.Int?

        public init(
            approvalRole: Swift.String? = nil,
            timeoutMinutes: Swift.Int? = 60
        ) {
            self.approvalRole = approvalRole
            self.timeoutMinutes = timeoutMinutes
        }
    }
}

extension ARCRegionswitchClientTypes {

    public enum GlobalAuroraDefaultBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failover
        case switchoverOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [GlobalAuroraDefaultBehavior] {
            return [
                .failover,
                .switchoverOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failover: return "failover"
            case .switchoverOnly: return "switchoverOnly"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCRegionswitchClientTypes {

    public enum GlobalAuroraUngracefulBehavior: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failover
        case sdkUnknown(Swift.String)

        public static var allCases: [GlobalAuroraUngracefulBehavior] {
            return [
                .failover
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failover: return "failover"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Configuration for handling failures when performing operations on Aurora global databases.
    public struct GlobalAuroraUngraceful: Swift.Sendable {
        /// The settings for ungraceful execution.
        public var ungraceful: ARCRegionswitchClientTypes.GlobalAuroraUngracefulBehavior?

        public init(
            ungraceful: ARCRegionswitchClientTypes.GlobalAuroraUngracefulBehavior? = nil
        ) {
            self.ungraceful = ungraceful
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Configuration for Amazon Aurora global databases used in a Region switch plan.
    public struct GlobalAuroraConfiguration: Swift.Sendable {
        /// The behavior for a global database, that is, only allow switchover or also allow failover.
        /// This member is required.
        public var behavior: ARCRegionswitchClientTypes.GlobalAuroraDefaultBehavior?
        /// The cross account role for the configuration.
        public var crossAccountRole: Swift.String?
        /// The database cluster Amazon Resource Names (ARNs) for a global database.
        /// This member is required.
        public var databaseClusterArns: [Swift.String]?
        /// The external ID (secret key) for the configuration.
        public var externalId: Swift.String?
        /// The global cluster identifier for a global database.
        /// This member is required.
        public var globalClusterIdentifier: Swift.String?
        /// The timeout value specified for the configuration.
        public var timeoutMinutes: Swift.Int?
        /// The settings for ungraceful execution.
        public var ungraceful: ARCRegionswitchClientTypes.GlobalAuroraUngraceful?

        public init(
            behavior: ARCRegionswitchClientTypes.GlobalAuroraDefaultBehavior? = .switchoverOnly,
            crossAccountRole: Swift.String? = nil,
            databaseClusterArns: [Swift.String]? = nil,
            externalId: Swift.String? = nil,
            globalClusterIdentifier: Swift.String? = nil,
            timeoutMinutes: Swift.Int? = 60,
            ungraceful: ARCRegionswitchClientTypes.GlobalAuroraUngraceful? = nil
        ) {
            self.behavior = behavior
            self.crossAccountRole = crossAccountRole
            self.databaseClusterArns = databaseClusterArns
            self.externalId = externalId
            self.globalClusterIdentifier = globalClusterIdentifier
            self.timeoutMinutes = timeoutMinutes
            self.ungraceful = ungraceful
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Configuration for nested Region switch plans. This allows one Region switch plan to trigger another plan as part of its execution.
    public struct RegionSwitchPlanConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the plan configuration.
        /// This member is required.
        public var arn: Swift.String?
        /// The cross account role for the configuration.
        public var crossAccountRole: Swift.String?
        /// The external ID (secret key) for the configuration.
        public var externalId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            crossAccountRole: Swift.String? = nil,
            externalId: Swift.String? = nil
        ) {
            self.arn = arn
            self.crossAccountRole = crossAccountRole
            self.externalId = externalId
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// The Amazon Route 53 record set.
    public struct Route53ResourceRecordSet: Swift.Sendable {
        /// The Amazon Route 53 record set identifier.
        public var recordSetIdentifier: Swift.String?
        /// The Amazon Route 53 record set Region.
        public var region: Swift.String?

        public init(
            recordSetIdentifier: Swift.String? = nil,
            region: Swift.String? = nil
        ) {
            self.recordSetIdentifier = recordSetIdentifier
            self.region = region
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// The Amazon Route 53 health check configuration.
    public struct Route53HealthCheckConfiguration: Swift.Sendable {
        /// The cross account role for the configuration.
        public var crossAccountRole: Swift.String?
        /// The external ID (secret key) for the configuration.
        public var externalId: Swift.String?
        /// The Amazon Route 53 health check configuration hosted zone ID.
        /// This member is required.
        public var hostedZoneId: Swift.String?
        /// The Amazon Route 53 health check configuration record name.
        /// This member is required.
        public var recordName: Swift.String?
        /// The Amazon Route 53 health check configuration record sets.
        public var recordSets: [ARCRegionswitchClientTypes.Route53ResourceRecordSet]?
        /// The Amazon Route 53 health check configuration time out (in minutes).
        public var timeoutMinutes: Swift.Int?

        public init(
            crossAccountRole: Swift.String? = nil,
            externalId: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil,
            recordName: Swift.String? = nil,
            recordSets: [ARCRegionswitchClientTypes.Route53ResourceRecordSet]? = nil,
            timeoutMinutes: Swift.Int? = 60
        ) {
            self.crossAccountRole = crossAccountRole
            self.externalId = externalId
            self.hostedZoneId = hostedZoneId
            self.recordName = recordName
            self.recordSets = recordSets
            self.timeoutMinutes = timeoutMinutes
        }
    }
}

extension ARCRegionswitchClientTypes {

    public enum ExecutionBlockType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aurora
        case customActionLambda
        case ec2Asg
        case ecs
        case eksResourceScaling
        case executionApproval
        case parallel
        case regionSwitch
        case route53HealthCheck
        case routingControl
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionBlockType] {
            return [
                .aurora,
                .customActionLambda,
                .ec2Asg,
                .ecs,
                .eksResourceScaling,
                .executionApproval,
                .parallel,
                .regionSwitch,
                .route53HealthCheck,
                .routingControl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aurora: return "AuroraGlobalDatabase"
            case .customActionLambda: return "CustomActionLambda"
            case .ec2Asg: return "EC2AutoScaling"
            case .ecs: return "ECSServiceScaling"
            case .eksResourceScaling: return "EKSResourceScaling"
            case .executionApproval: return "ManualApproval"
            case .parallel: return "Parallel"
            case .regionSwitch: return "ARCRegionSwitchPlan"
            case .route53HealthCheck: return "Route53HealthCheck"
            case .routingControl: return "ARCRoutingControl"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCRegionswitchClientTypes {

    public enum StepStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case failed
        case notStarted
        case pendingApproval
        case running
        case skipped
        case sdkUnknown(Swift.String)

        public static var allCases: [StepStatus] {
            return [
                .cancelled,
                .completed,
                .failed,
                .notStarted,
                .pendingApproval,
                .running,
                .skipped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "canceled"
            case .completed: return "completed"
            case .failed: return "failed"
            case .notStarted: return "notStarted"
            case .pendingApproval: return "pendingApproval"
            case .running: return "running"
            case .skipped: return "skipped"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Represents the state of a step in a plan execution.
    public struct StepState: Swift.Sendable {
        /// The timestamp when a step endeded execution.
        public var endTime: Foundation.Date?
        /// The name of a step in a workflow.
        public var name: Swift.String?
        /// The timestamp when a step started execution.
        public var startTime: Foundation.Date?
        /// The status of a step in a workflow. For example, a status might be Completed or Pending Approval.
        public var status: ARCRegionswitchClientTypes.StepStatus?
        /// The mode for a step execution. The mode can be Graceful or Ungraceful.
        public var stepMode: ARCRegionswitchClientTypes.ExecutionMode?

        public init(
            endTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            status: ARCRegionswitchClientTypes.StepStatus? = nil,
            stepMode: ARCRegionswitchClientTypes.ExecutionMode? = nil
        ) {
            self.endTime = endTime
            self.name = name
            self.startTime = startTime
            self.status = status
            self.stepMode = stepMode
        }
    }
}

public struct GetPlanInRegionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the plan in Region.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct ListPlanExecutionEventsInput: Swift.Sendable {
    /// The execution identifier of a plan execution.
    /// This member is required.
    public var executionId: Swift.String?
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The name of the plan execution event.
    public var name: Swift.String?
    /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the plan.
    /// This member is required.
    public var planArn: Swift.String?

    public init(
        executionId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        planArn: Swift.String? = nil
    ) {
        self.executionId = executionId
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
        self.planArn = planArn
    }
}

extension ARCRegionswitchClientTypes {

    public enum ExecutionEventType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case executionBehaviorChangedToGraceful
        case executionBehaviorChangedToUngraceful
        case executionCanceled
        case executionCanceling
        case executionFailed
        case executionPaused
        case executionPausing
        case executionPending
        case executionPendingApproval
        case executionPendingChildPlanManualApproval
        case executionStarted
        case executionSucceeded
        case executionSuccessMonitoringApplicationHealth
        case stepCanceled
        case stepExecutionBehaviorChangedToUngraceful
        case stepFailed
        case stepPausedByError
        case stepPausedByOperator
        case stepPendingApplicationHealthMonitor
        case stepPendingApproval
        case stepSkipped
        case stepStarted
        case stepSucceeded
        case stepUpdate
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionEventType] {
            return [
                .executionBehaviorChangedToGraceful,
                .executionBehaviorChangedToUngraceful,
                .executionCanceled,
                .executionCanceling,
                .executionFailed,
                .executionPaused,
                .executionPausing,
                .executionPending,
                .executionPendingApproval,
                .executionPendingChildPlanManualApproval,
                .executionStarted,
                .executionSucceeded,
                .executionSuccessMonitoringApplicationHealth,
                .stepCanceled,
                .stepExecutionBehaviorChangedToUngraceful,
                .stepFailed,
                .stepPausedByError,
                .stepPausedByOperator,
                .stepPendingApplicationHealthMonitor,
                .stepPendingApproval,
                .stepSkipped,
                .stepStarted,
                .stepSucceeded,
                .stepUpdate,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .executionBehaviorChangedToGraceful: return "executionBehaviorChangedToGraceful"
            case .executionBehaviorChangedToUngraceful: return "executionBehaviorChangedToUngraceful"
            case .executionCanceled: return "executionCanceled"
            case .executionCanceling: return "executionCanceling"
            case .executionFailed: return "executionFailed"
            case .executionPaused: return "executionPaused"
            case .executionPausing: return "executionPausing"
            case .executionPending: return "executionPending"
            case .executionPendingApproval: return "executionPendingApproval"
            case .executionPendingChildPlanManualApproval: return "executionPendingChildPlanManualApproval"
            case .executionStarted: return "executionStarted"
            case .executionSucceeded: return "executionSucceeded"
            case .executionSuccessMonitoringApplicationHealth: return "executionSuccessMonitoringApplicationHealth"
            case .stepCanceled: return "stepCanceled"
            case .stepExecutionBehaviorChangedToUngraceful: return "stepExecutionBehaviorChangedToUngraceful"
            case .stepFailed: return "stepFailed"
            case .stepPausedByError: return "stepPausedByError"
            case .stepPausedByOperator: return "stepPausedByOperator"
            case .stepPendingApplicationHealthMonitor: return "stepPendingApplicationHealthMonitor"
            case .stepPendingApproval: return "stepPendingApproval"
            case .stepSkipped: return "stepSkipped"
            case .stepStarted: return "stepStarted"
            case .stepSucceeded: return "stepSucceeded"
            case .stepUpdate: return "stepUpdate"
            case .unknown: return "unknown"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Represents an event that occurred during a plan execution. These events provide a detailed timeline of the execution process.
    public struct ExecutionEvent: Swift.Sendable {
        /// The description for an execution event.
        public var description: Swift.String?
        /// Errors for an execution event.
        public var error: Swift.String?
        /// The event ID for an execution event.
        /// This member is required.
        public var eventId: Swift.String?
        /// The execution block type for an execution event.
        public var executionBlockType: ARCRegionswitchClientTypes.ExecutionBlockType?
        /// The event ID of the previous execution event.
        public var previousEventId: Swift.String?
        /// The resources for an execution event.
        public var resources: [Swift.String]?
        /// The step name for an execution event.
        public var stepName: Swift.String?
        /// The timestamp for an execution event.
        public var timestamp: Foundation.Date?
        /// The type of an execution event.
        public var type: ARCRegionswitchClientTypes.ExecutionEventType?

        public init(
            description: Swift.String? = nil,
            error: Swift.String? = nil,
            eventId: Swift.String? = nil,
            executionBlockType: ARCRegionswitchClientTypes.ExecutionBlockType? = nil,
            previousEventId: Swift.String? = nil,
            resources: [Swift.String]? = nil,
            stepName: Swift.String? = nil,
            timestamp: Foundation.Date? = nil,
            type: ARCRegionswitchClientTypes.ExecutionEventType? = nil
        ) {
            self.description = description
            self.error = error
            self.eventId = eventId
            self.executionBlockType = executionBlockType
            self.previousEventId = previousEventId
            self.resources = resources
            self.stepName = stepName
            self.timestamp = timestamp
            self.type = type
        }
    }
}

public struct ListPlanExecutionEventsOutput: Swift.Sendable {
    /// The items in the plan execution event.
    public var items: [ARCRegionswitchClientTypes.ExecutionEvent]?
    /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [ARCRegionswitchClientTypes.ExecutionEvent]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListPlanExecutionsInput: Swift.Sendable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// The ARN for the plan.
    /// This member is required.
    public var planArn: Swift.String?
    /// The state of the plan execution. For example, the plan execution might be In Progress.
    public var state: ARCRegionswitchClientTypes.ExecutionState?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        planArn: Swift.String? = nil,
        state: ARCRegionswitchClientTypes.ExecutionState? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.planArn = planArn
        self.state = state
    }
}

public struct ListPlanExecutionsOutput: Swift.Sendable {
    /// The items in the plan execution to return.
    public var items: [ARCRegionswitchClientTypes.AbbreviatedExecution]?
    /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        items: [ARCRegionswitchClientTypes.AbbreviatedExecution]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.items = items
        self.nextToken = nextToken
    }
}

public struct ListPlansInRegionInput: Swift.Sendable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListPlansInRegionOutput: Swift.Sendable {
    /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// The plans that were requested.
    public var plans: [ARCRegionswitchClientTypes.AbbreviatedPlan]?

    public init(
        nextToken: Swift.String? = nil,
        plans: [ARCRegionswitchClientTypes.AbbreviatedPlan]? = nil
    ) {
        self.nextToken = nextToken
        self.plans = plans
    }
}

/// The request processing has failed because of an unknown error, exception, or failure. HTTP Status Code: 500
public struct InternalServerException: ClientRuntime.ModeledError, ClientRuntime.ServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct ListRoute53HealthChecksInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Amazon Route 53 health check request.
    /// This member is required.
    public var arn: Swift.String?
    /// The hosted zone ID for the health checks.
    public var hostedZoneId: Swift.String?
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// The record name for the health checks.
    public var recordName: Swift.String?

    public init(
        arn: Swift.String? = nil,
        hostedZoneId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        recordName: Swift.String? = nil
    ) {
        self.arn = arn
        self.hostedZoneId = hostedZoneId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recordName = recordName
    }
}

extension ARCRegionswitchClientTypes {

    /// The Amazon Route 53 health check.
    public struct Route53HealthCheck: Swift.Sendable {
        /// The Amazon Route 53 health check ID.
        public var healthCheckId: Swift.String?
        /// The Amazon Route 53 health check hosted zone ID.
        /// This member is required.
        public var hostedZoneId: Swift.String?
        /// The Amazon Route 53 record name.
        /// This member is required.
        public var recordName: Swift.String?
        /// The Amazon Route 53 Region.
        /// This member is required.
        public var region: Swift.String?

        public init(
            healthCheckId: Swift.String? = nil,
            hostedZoneId: Swift.String? = nil,
            recordName: Swift.String? = nil,
            region: Swift.String? = nil
        ) {
            self.healthCheckId = healthCheckId
            self.hostedZoneId = hostedZoneId
            self.recordName = recordName
            self.region = region
        }
    }
}

public struct ListRoute53HealthChecksOutput: Swift.Sendable {
    /// List of the health checks requested.
    public var healthChecks: [ARCRegionswitchClientTypes.Route53HealthCheck]?
    /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        healthChecks: [ARCRegionswitchClientTypes.Route53HealthCheck]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.healthChecks = healthChecks
        self.nextToken = nextToken
    }
}

/// The operation failed because the current state of the resource doesn't allow the operation to proceed. HTTP Status Code: 400
public struct IllegalStateException: ClientRuntime.ModeledError, ClientRuntime.ServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalStateException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct DeletePlanInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the plan.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct DeletePlanOutput: Swift.Sendable {

    public init() { }
}

public struct GetPlanInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the plan.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct ListPlansInput: Swift.Sendable {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListPlansOutput: Swift.Sendable {
    /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// The plans that were requested.
    public var plans: [ARCRegionswitchClientTypes.AbbreviatedPlan]?

    public init(
        nextToken: Swift.String? = nil,
        plans: [ARCRegionswitchClientTypes.AbbreviatedPlan]? = nil
    ) {
        self.nextToken = nextToken
        self.plans = plans
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags for a resource.
    public var resourceTags: [Swift.String: Swift.String]?

    public init(
        resourceTags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceTags = resourceTags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for a tag that you add to a resource.
    /// This member is required.
    public var arn: Swift.String?
    /// Tags that you add to a resource. You can add a maximum of 50 tags in Region switch.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        arn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.arn = arn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) for a tag you remove a resource from.
    /// This member is required.
    public var arn: Swift.String?
    /// Tag keys that you remove from a resource.
    /// This member is required.
    public var resourceTagKeys: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        resourceTagKeys: [Swift.String]? = nil
    ) {
        self.arn = arn
        self.resourceTagKeys = resourceTagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

/// The request processing has an invalid argument.
public struct IllegalArgumentException: ClientRuntime.ModeledError, ClientRuntime.ServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "IllegalArgumentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct StartPlanExecutionInput: Swift.Sendable {
    /// The action to perform. Valid values are ACTIVATE (to shift traffic to the target Region) or DEACTIVATE (to shift traffic away from the target Region).
    /// This member is required.
    public var action: ARCRegionswitchClientTypes.ExecutionAction?
    /// An optional comment explaining why the plan execution is being started.
    public var comment: Swift.String?
    /// A boolean value indicating whether to use the latest version of the plan. If set to false, you must specify a specific version.
    public var latestVersion: Swift.String?
    /// The plan execution mode. Valid values are Practice, for testing without making actual changes, or Recovery, for actual traffic shifting and application recovery.
    public var mode: ARCRegionswitchClientTypes.ExecutionMode?
    /// The Amazon Resource Name (ARN) of the plan to execute.
    /// This member is required.
    public var planArn: Swift.String?
    /// The Amazon Web Services Region to target with this execution. This is the Region that traffic will be shifted to or from, depending on the action.
    /// This member is required.
    public var targetRegion: Swift.String?

    public init(
        action: ARCRegionswitchClientTypes.ExecutionAction? = nil,
        comment: Swift.String? = nil,
        latestVersion: Swift.String? = nil,
        mode: ARCRegionswitchClientTypes.ExecutionMode? = nil,
        planArn: Swift.String? = nil,
        targetRegion: Swift.String? = nil
    ) {
        self.action = action
        self.comment = comment
        self.latestVersion = latestVersion
        self.mode = mode
        self.planArn = planArn
        self.targetRegion = targetRegion
    }
}

public struct StartPlanExecutionOutput: Swift.Sendable {
    /// The Amazon Web Services Region to activate.
    public var activateRegion: Swift.String?
    /// The Amazon Web Services Region to deactivate.
    public var deactivateRegion: Swift.String?
    /// The execution identifier of a plan execution.
    public var executionId: Swift.String?
    /// The details of the Region switch plan.
    public var plan: Swift.String?
    /// The version of the plan, a unique number generated by Region switch.
    public var planVersion: Swift.String?

    public init(
        activateRegion: Swift.String? = nil,
        deactivateRegion: Swift.String? = nil,
        executionId: Swift.String? = nil,
        plan: Swift.String? = nil,
        planVersion: Swift.String? = nil
    ) {
        self.activateRegion = activateRegion
        self.deactivateRegion = deactivateRegion
        self.executionId = executionId
        self.plan = plan
        self.planVersion = planVersion
    }
}

extension ARCRegionswitchClientTypes {

    public enum UpdatePlanExecutionAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pause
        case resume
        case switchToGraceful
        case switchToUngraceful
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdatePlanExecutionAction] {
            return [
                .pause,
                .resume,
                .switchToGraceful,
                .switchToUngraceful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pause: return "pause"
            case .resume: return "resume"
            case .switchToGraceful: return "switchToGraceful"
            case .switchToUngraceful: return "switchToUngraceful"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdatePlanExecutionInput: Swift.Sendable {
    /// The action specified for a plan execution, for example, Switch to Graceful or Pause.
    /// This member is required.
    public var action: ARCRegionswitchClientTypes.UpdatePlanExecutionAction?
    /// An optional comment about the plan execution.
    public var comment: Swift.String?
    /// The execution identifier of a plan execution.
    /// This member is required.
    public var executionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the plan with the execution to update.
    /// This member is required.
    public var planArn: Swift.String?

    public init(
        action: ARCRegionswitchClientTypes.UpdatePlanExecutionAction? = nil,
        comment: Swift.String? = nil,
        executionId: Swift.String? = nil,
        planArn: Swift.String? = nil
    ) {
        self.action = action
        self.comment = comment
        self.executionId = executionId
        self.planArn = planArn
    }
}

public struct UpdatePlanExecutionOutput: Swift.Sendable {

    public init() { }
}

extension ARCRegionswitchClientTypes {

    public enum UpdatePlanExecutionStepAction: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case skip
        case switchToUngraceful
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdatePlanExecutionStepAction] {
            return [
                .skip,
                .switchToUngraceful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .skip: return "skip"
            case .switchToUngraceful: return "switchToUngraceful"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdatePlanExecutionStepInput: Swift.Sendable {
    /// The updated action to take for the step. This can be used to skip or retry a step.
    /// This member is required.
    public var actionToTake: ARCRegionswitchClientTypes.UpdatePlanExecutionStepAction?
    /// An optional comment about the plan execution.
    /// This member is required.
    public var comment: Swift.String?
    /// The unique identifier of the plan execution containing the step to update.
    /// This member is required.
    public var executionId: Swift.String?
    /// The Amazon Resource Name (ARN) of the plan containing the execution step to update.
    /// This member is required.
    public var planArn: Swift.String?
    /// The name of the execution step to update.
    /// This member is required.
    public var stepName: Swift.String?

    public init(
        actionToTake: ARCRegionswitchClientTypes.UpdatePlanExecutionStepAction? = nil,
        comment: Swift.String? = nil,
        executionId: Swift.String? = nil,
        planArn: Swift.String? = nil,
        stepName: Swift.String? = nil
    ) {
        self.actionToTake = actionToTake
        self.comment = comment
        self.executionId = executionId
        self.planArn = planArn
        self.stepName = stepName
    }
}

public struct UpdatePlanExecutionStepOutput: Swift.Sendable {

    public init() { }
}

extension ARCRegionswitchClientTypes {

    /// Execution block configurations for a workflow in a Region switch plan. An execution block represents a specific type of action to perform during a Region switch.
    public indirect enum ExecutionBlockConfiguration: Swift.Sendable {
        /// An Amazon Web Services Lambda execution block.
        case customactionlambdaconfig(ARCRegionswitchClientTypes.CustomActionLambdaConfiguration)
        /// An EC2 Auto Scaling group execution block.
        case ec2asgcapacityincreaseconfig(ARCRegionswitchClientTypes.Ec2AsgCapacityIncreaseConfiguration)
        /// A manual approval execution block.
        case executionapprovalconfig(ARCRegionswitchClientTypes.ExecutionApprovalConfiguration)
        /// An ARC routing control execution block.
        case arcroutingcontrolconfig(ARCRegionswitchClientTypes.ArcRoutingControlConfiguration)
        /// An Aurora Global Database execution block.
        case globalauroraconfig(ARCRegionswitchClientTypes.GlobalAuroraConfiguration)
        /// A parallel configuration execution block.
        case parallelconfig(ARCRegionswitchClientTypes.ParallelExecutionBlockConfiguration)
        /// A Region switch plan execution block.
        case regionswitchplanconfig(ARCRegionswitchClientTypes.RegionSwitchPlanConfiguration)
        /// The capacity increase specified for the configuration.
        case ecscapacityincreaseconfig(ARCRegionswitchClientTypes.EcsCapacityIncreaseConfiguration)
        /// An Amazon Web Services EKS resource scaling execution block.
        case eksresourcescalingconfig(ARCRegionswitchClientTypes.EksResourceScalingConfiguration)
        /// The Amazon Route 53 health check configuration.
        case route53healthcheckconfig(ARCRegionswitchClientTypes.Route53HealthCheckConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension ARCRegionswitchClientTypes {

    /// Configuration for steps that should be executed in parallel during a Region switch.
    public struct ParallelExecutionBlockConfiguration: Swift.Sendable {
        /// The steps for a parallel execution block.
        /// This member is required.
        public var steps: [ARCRegionswitchClientTypes.Step]?

        public init(
            steps: [ARCRegionswitchClientTypes.Step]? = nil
        ) {
            self.steps = steps
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Represents a step in a Region switch plan workflow. Each step performs a specific action during the Region switch process.
    public struct Step: Swift.Sendable {
        /// The description of a step in a workflow.
        public var description: Swift.String?
        /// The configuration for an execution block in a workflow.
        /// This member is required.
        public var executionBlockConfiguration: ARCRegionswitchClientTypes.ExecutionBlockConfiguration?
        /// The type of an execution block in a workflow.
        /// This member is required.
        public var executionBlockType: ARCRegionswitchClientTypes.ExecutionBlockType?
        /// The name of a step in a workflow.
        /// This member is required.
        public var name: Swift.String?

        public init(
            description: Swift.String? = nil,
            executionBlockConfiguration: ARCRegionswitchClientTypes.ExecutionBlockConfiguration? = nil,
            executionBlockType: ARCRegionswitchClientTypes.ExecutionBlockType? = nil,
            name: Swift.String? = nil
        ) {
            self.description = description
            self.executionBlockConfiguration = executionBlockConfiguration
            self.executionBlockType = executionBlockType
            self.name = name
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Represents a workflow in a Region switch plan. A workflow defines a sequence of steps to execute during a Region switch.
    public struct Workflow: Swift.Sendable {
        /// The steps that make up the workflow.
        public var steps: [ARCRegionswitchClientTypes.Step]?
        /// The description of the workflow.
        public var workflowDescription: Swift.String?
        /// The action that the workflow performs. Valid values include ACTIVATE and DEACTIVATE.
        /// This member is required.
        public var workflowTargetAction: ARCRegionswitchClientTypes.WorkflowTargetAction?
        /// The Amazon Web Services Region that the workflow targets.
        public var workflowTargetRegion: Swift.String?

        public init(
            steps: [ARCRegionswitchClientTypes.Step]? = nil,
            workflowDescription: Swift.String? = nil,
            workflowTargetAction: ARCRegionswitchClientTypes.WorkflowTargetAction? = nil,
            workflowTargetRegion: Swift.String? = nil
        ) {
            self.steps = steps
            self.workflowDescription = workflowDescription
            self.workflowTargetAction = workflowTargetAction
            self.workflowTargetRegion = workflowTargetRegion
        }
    }
}

extension ARCRegionswitchClientTypes {

    /// Represents a Region switch plan. A plan defines the steps required to shift traffic from one Amazon Web Services Region to another.
    public struct Plan: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the plan.
        /// This member is required.
        public var arn: Swift.String?
        /// The associated application health alarms for a plan.
        public var associatedAlarms: [Swift.String: ARCRegionswitchClientTypes.AssociatedAlarm]?
        /// The description for a plan.
        public var description: Swift.String?
        /// The execution role for a plan.
        /// This member is required.
        public var executionRole: Swift.String?
        /// The name for a plan.
        /// This member is required.
        public var name: Swift.String?
        /// The owner of a plan.
        /// This member is required.
        public var owner: Swift.String?
        /// The primary Region for a plan.
        public var primaryRegion: Swift.String?
        /// The recovery approach for a Region switch plan, which can be active/active (activeActive) or active/passive (activePassive).
        /// This member is required.
        public var recoveryApproach: ARCRegionswitchClientTypes.RecoveryApproach?
        /// The recovery time objective for a plan.
        public var recoveryTimeObjectiveMinutes: Swift.Int?
        /// The Amazon Web Services Regions for a plan.
        /// This member is required.
        public var regions: [Swift.String]?
        /// The triggers for a plan.
        public var triggers: [ARCRegionswitchClientTypes.Trigger]?
        /// The timestamp when the plan was last updated.
        public var updatedAt: Foundation.Date?
        /// The version for the plan.
        public var version: Swift.String?
        /// The workflows for a plan.
        /// This member is required.
        public var workflows: [ARCRegionswitchClientTypes.Workflow]?

        public init(
            arn: Swift.String? = nil,
            associatedAlarms: [Swift.String: ARCRegionswitchClientTypes.AssociatedAlarm]? = nil,
            description: Swift.String? = nil,
            executionRole: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            primaryRegion: Swift.String? = nil,
            recoveryApproach: ARCRegionswitchClientTypes.RecoveryApproach? = nil,
            recoveryTimeObjectiveMinutes: Swift.Int? = nil,
            regions: [Swift.String]? = nil,
            triggers: [ARCRegionswitchClientTypes.Trigger]? = nil,
            updatedAt: Foundation.Date? = nil,
            version: Swift.String? = nil,
            workflows: [ARCRegionswitchClientTypes.Workflow]? = nil
        ) {
            self.arn = arn
            self.associatedAlarms = associatedAlarms
            self.description = description
            self.executionRole = executionRole
            self.name = name
            self.owner = owner
            self.primaryRegion = primaryRegion
            self.recoveryApproach = recoveryApproach
            self.recoveryTimeObjectiveMinutes = recoveryTimeObjectiveMinutes
            self.regions = regions
            self.triggers = triggers
            self.updatedAt = updatedAt
            self.version = version
            self.workflows = workflows
        }
    }
}

public struct CreatePlanInput: Swift.Sendable {
    /// The alarms associated with a Region switch plan.
    public var associatedAlarms: [Swift.String: ARCRegionswitchClientTypes.AssociatedAlarm]?
    /// The description of a Region switch plan.
    public var description: Swift.String?
    /// An execution role is a way to categorize a Region switch plan.
    /// This member is required.
    public var executionRole: Swift.String?
    /// The name of a Region switch plan.
    /// This member is required.
    public var name: Swift.String?
    /// The primary Amazon Web Services Region for the application. This is the Region where the application normally runs before any Region switch occurs.
    public var primaryRegion: Swift.String?
    /// The recovery approach for a Region switch plan, which can be active/active (activeActive) or active/passive (activePassive).
    /// This member is required.
    public var recoveryApproach: ARCRegionswitchClientTypes.RecoveryApproach?
    /// Optionally, you can specify an recovery time objective for a Region switch plan, in minutes.
    public var recoveryTimeObjectiveMinutes: Swift.Int?
    /// An array that specifies the Amazon Web Services Regions for a Region switch plan. Specify two Regions.
    /// This member is required.
    public var regions: [Swift.String]?
    /// The tags to apply to the Region switch plan.
    public var tags: [Swift.String: Swift.String]?
    /// The triggers associated with a Region switch plan.
    public var triggers: [ARCRegionswitchClientTypes.Trigger]?
    /// An array of workflows included in a Region switch plan.
    /// This member is required.
    public var workflows: [ARCRegionswitchClientTypes.Workflow]?

    public init(
        associatedAlarms: [Swift.String: ARCRegionswitchClientTypes.AssociatedAlarm]? = nil,
        description: Swift.String? = nil,
        executionRole: Swift.String? = nil,
        name: Swift.String? = nil,
        primaryRegion: Swift.String? = nil,
        recoveryApproach: ARCRegionswitchClientTypes.RecoveryApproach? = nil,
        recoveryTimeObjectiveMinutes: Swift.Int? = nil,
        regions: [Swift.String]? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        triggers: [ARCRegionswitchClientTypes.Trigger]? = nil,
        workflows: [ARCRegionswitchClientTypes.Workflow]? = nil
    ) {
        self.associatedAlarms = associatedAlarms
        self.description = description
        self.executionRole = executionRole
        self.name = name
        self.primaryRegion = primaryRegion
        self.recoveryApproach = recoveryApproach
        self.recoveryTimeObjectiveMinutes = recoveryTimeObjectiveMinutes
        self.regions = regions
        self.tags = tags
        self.triggers = triggers
        self.workflows = workflows
    }
}

public struct UpdatePlanInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the plan.
    /// This member is required.
    public var arn: Swift.String?
    /// The updated CloudWatch alarms associated with the plan.
    public var associatedAlarms: [Swift.String: ARCRegionswitchClientTypes.AssociatedAlarm]?
    /// The updated description for the Region switch plan.
    public var description: Swift.String?
    /// The updated IAM role ARN that grants Region switch the permissions needed to execute the plan steps.
    /// This member is required.
    public var executionRole: Swift.String?
    /// The updated target recovery time objective (RTO) in minutes for the plan.
    public var recoveryTimeObjectiveMinutes: Swift.Int?
    /// The updated conditions that can automatically trigger the execution of the plan.
    public var triggers: [ARCRegionswitchClientTypes.Trigger]?
    /// The updated workflows for the Region switch plan.
    /// This member is required.
    public var workflows: [ARCRegionswitchClientTypes.Workflow]?

    public init(
        arn: Swift.String? = nil,
        associatedAlarms: [Swift.String: ARCRegionswitchClientTypes.AssociatedAlarm]? = nil,
        description: Swift.String? = nil,
        executionRole: Swift.String? = nil,
        recoveryTimeObjectiveMinutes: Swift.Int? = nil,
        triggers: [ARCRegionswitchClientTypes.Trigger]? = nil,
        workflows: [ARCRegionswitchClientTypes.Workflow]? = nil
    ) {
        self.arn = arn
        self.associatedAlarms = associatedAlarms
        self.description = description
        self.executionRole = executionRole
        self.recoveryTimeObjectiveMinutes = recoveryTimeObjectiveMinutes
        self.triggers = triggers
        self.workflows = workflows
    }
}

public struct CreatePlanOutput: Swift.Sendable {
    /// The details of the created Region switch plan.
    public var plan: ARCRegionswitchClientTypes.Plan?

    public init(
        plan: ARCRegionswitchClientTypes.Plan? = nil
    ) {
        self.plan = plan
    }
}

public struct GetPlanExecutionOutput: Swift.Sendable {
    /// The actual recovery time that Region switch calculates for a plan execution. Actual recovery time includes the time for the plan to run added to the time elapsed until the application health alarms that you've specified are healthy again.
    public var actualRecoveryTime: Swift.String?
    /// A comment included on the plan execution.
    public var comment: Swift.String?
    /// The time (UTC) when the plan execution ended.
    public var endTime: Foundation.Date?
    /// The plan execution action. Valid values are Activate, to activate an Amazon Web Services Region, or Deactivate, to deactivate a Region.
    /// This member is required.
    public var executionAction: ARCRegionswitchClientTypes.ExecutionAction?
    /// The execution identifier of a plan execution.
    /// This member is required.
    public var executionId: Swift.String?
    /// The Amazon Web Services Region for a plan execution.
    /// This member is required.
    public var executionRegion: Swift.String?
    /// The plan execution state. Provides the state of a plan execution, for example, In Progress or Paused by Operator.
    /// This member is required.
    public var executionState: ARCRegionswitchClientTypes.ExecutionState?
    /// The plan execution mode. Valid values are Practice, for testing without making actual changes, or Recovery, for actual traffic shifting and application recovery.
    /// This member is required.
    public var mode: ARCRegionswitchClientTypes.ExecutionMode?
    /// Specifies that you want to receive the next page of results. Valid only if you received a nextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's nextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// The details of the Region switch plan.
    public var plan: ARCRegionswitchClientTypes.Plan?
    /// The Amazon Resource Name (ARN) of the plan.
    /// This member is required.
    public var planArn: Swift.String?
    /// The time (UTC) when the plan execution started.
    /// This member is required.
    public var startTime: Foundation.Date?
    /// The states of the steps in the plan execution.
    public var stepStates: [ARCRegionswitchClientTypes.StepState]?
    /// The timestamp when the plan execution was last updated.
    public var updatedAt: Foundation.Date?
    /// The version for the plan.
    public var version: Swift.String?

    public init(
        actualRecoveryTime: Swift.String? = nil,
        comment: Swift.String? = nil,
        endTime: Foundation.Date? = nil,
        executionAction: ARCRegionswitchClientTypes.ExecutionAction? = nil,
        executionId: Swift.String? = nil,
        executionRegion: Swift.String? = nil,
        executionState: ARCRegionswitchClientTypes.ExecutionState? = nil,
        mode: ARCRegionswitchClientTypes.ExecutionMode? = nil,
        nextToken: Swift.String? = nil,
        plan: ARCRegionswitchClientTypes.Plan? = nil,
        planArn: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        stepStates: [ARCRegionswitchClientTypes.StepState]? = nil,
        updatedAt: Foundation.Date? = nil,
        version: Swift.String? = nil
    ) {
        self.actualRecoveryTime = actualRecoveryTime
        self.comment = comment
        self.endTime = endTime
        self.executionAction = executionAction
        self.executionId = executionId
        self.executionRegion = executionRegion
        self.executionState = executionState
        self.mode = mode
        self.nextToken = nextToken
        self.plan = plan
        self.planArn = planArn
        self.startTime = startTime
        self.stepStates = stepStates
        self.updatedAt = updatedAt
        self.version = version
    }
}

public struct GetPlanInRegionOutput: Swift.Sendable {
    /// The details of the Region switch plan.
    public var plan: ARCRegionswitchClientTypes.Plan?

    public init(
        plan: ARCRegionswitchClientTypes.Plan? = nil
    ) {
        self.plan = plan
    }
}

public struct GetPlanOutput: Swift.Sendable {
    /// The detailed information about the requested Region switch plan.
    public var plan: ARCRegionswitchClientTypes.Plan?

    public init(
        plan: ARCRegionswitchClientTypes.Plan? = nil
    ) {
        self.plan = plan
    }
}

public struct UpdatePlanOutput: Swift.Sendable {
    /// The details of the updated Region switch plan.
    public var plan: ARCRegionswitchClientTypes.Plan?

    public init(
        plan: ARCRegionswitchClientTypes.Plan? = nil
    ) {
        self.plan = plan
    }
}

extension ApprovePlanExecutionStepInput {

    static func urlPathProvider(_ value: ApprovePlanExecutionStepInput) -> Swift.String? {
        return "/service/ArcRegionSwitch/operation/ApprovePlanExecutionStep"
    }
}

extension CancelPlanExecutionInput {

    static func urlPathProvider(_ value: CancelPlanExecutionInput) -> Swift.String? {
        return "/service/ArcRegionSwitch/operation/CancelPlanExecution"
    }
}

extension CreatePlanInput {

    static func urlPathProvider(_ value: CreatePlanInput) -> Swift.String? {
        return "/service/ArcRegionSwitch/operation/CreatePlan"
    }
}

extension DeletePlanInput {

    static func urlPathProvider(_ value: DeletePlanInput) -> Swift.String? {
        return "/service/ArcRegionSwitch/operation/DeletePlan"
    }
}

extension GetPlanInput {

    static func urlPathProvider(_ value: GetPlanInput) -> Swift.String? {
        return "/service/ArcRegionSwitch/operation/GetPlan"
    }
}

extension GetPlanEvaluationStatusInput {

    static func urlPathProvider(_ value: GetPlanEvaluationStatusInput) -> Swift.String? {
        return "/service/ArcRegionSwitch/operation/GetPlanEvaluationStatus"
    }
}

extension GetPlanExecutionInput {

    static func urlPathProvider(_ value: GetPlanExecutionInput) -> Swift.String? {
        return "/service/ArcRegionSwitch/operation/GetPlanExecution"
    }
}

extension GetPlanInRegionInput {

    static func urlPathProvider(_ value: GetPlanInRegionInput) -> Swift.String? {
        return "/service/ArcRegionSwitch/operation/GetPlanInRegion"
    }
}

extension ListPlanExecutionEventsInput {

    static func urlPathProvider(_ value: ListPlanExecutionEventsInput) -> Swift.String? {
        return "/service/ArcRegionSwitch/operation/ListPlanExecutionEvents"
    }
}

extension ListPlanExecutionsInput {

    static func urlPathProvider(_ value: ListPlanExecutionsInput) -> Swift.String? {
        return "/service/ArcRegionSwitch/operation/ListPlanExecutions"
    }
}

extension ListPlansInput {

    static func urlPathProvider(_ value: ListPlansInput) -> Swift.String? {
        return "/service/ArcRegionSwitch/operation/ListPlans"
    }
}

extension ListPlansInRegionInput {

    static func urlPathProvider(_ value: ListPlansInRegionInput) -> Swift.String? {
        return "/service/ArcRegionSwitch/operation/ListPlansInRegion"
    }
}

extension ListRoute53HealthChecksInput {

    static func urlPathProvider(_ value: ListRoute53HealthChecksInput) -> Swift.String? {
        return "/service/ArcRegionSwitch/operation/ListRoute53HealthChecks"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/service/ArcRegionSwitch/operation/ListTagsForResource"
    }
}

extension StartPlanExecutionInput {

    static func urlPathProvider(_ value: StartPlanExecutionInput) -> Swift.String? {
        return "/service/ArcRegionSwitch/operation/StartPlanExecution"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/service/ArcRegionSwitch/operation/TagResource"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/service/ArcRegionSwitch/operation/UntagResource"
    }
}

extension UpdatePlanInput {

    static func urlPathProvider(_ value: UpdatePlanInput) -> Swift.String? {
        return "/service/ArcRegionSwitch/operation/UpdatePlan"
    }
}

extension UpdatePlanExecutionInput {

    static func urlPathProvider(_ value: UpdatePlanExecutionInput) -> Swift.String? {
        return "/service/ArcRegionSwitch/operation/UpdatePlanExecution"
    }
}

extension UpdatePlanExecutionStepInput {

    static func urlPathProvider(_ value: UpdatePlanExecutionStepInput) -> Swift.String? {
        return "/service/ArcRegionSwitch/operation/UpdatePlanExecutionStep"
    }
}

extension ApprovePlanExecutionStepInput {

    static func write(value: ApprovePlanExecutionStepInput?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["approval"].write(value.approval)
        try writer["comment"].write(value.comment)
        try writer["executionId"].write(value.executionId)
        try writer["planArn"].write(value.planArn)
        try writer["stepName"].write(value.stepName)
    }
}

extension CancelPlanExecutionInput {

    static func write(value: CancelPlanExecutionInput?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["comment"].write(value.comment)
        try writer["executionId"].write(value.executionId)
        try writer["planArn"].write(value.planArn)
    }
}

extension CreatePlanInput {

    static func write(value: CreatePlanInput?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["associatedAlarms"].writeMap(value.associatedAlarms, valueWritingClosure: ARCRegionswitchClientTypes.AssociatedAlarm.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["executionRole"].write(value.executionRole)
        try writer["name"].write(value.name)
        try writer["primaryRegion"].write(value.primaryRegion)
        try writer["recoveryApproach"].write(value.recoveryApproach)
        try writer["recoveryTimeObjectiveMinutes"].write(value.recoveryTimeObjectiveMinutes)
        try writer["regions"].writeList(value.regions, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["triggers"].writeList(value.triggers, memberWritingClosure: ARCRegionswitchClientTypes.Trigger.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["workflows"].writeList(value.workflows, memberWritingClosure: ARCRegionswitchClientTypes.Workflow.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeletePlanInput {

    static func write(value: DeletePlanInput?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetPlanInput {

    static func write(value: GetPlanInput?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetPlanEvaluationStatusInput {

    static func write(value: GetPlanEvaluationStatusInput?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["planArn"].write(value.planArn)
    }
}

extension GetPlanExecutionInput {

    static func write(value: GetPlanExecutionInput?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["executionId"].write(value.executionId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["planArn"].write(value.planArn)
    }
}

extension GetPlanInRegionInput {

    static func write(value: GetPlanInRegionInput?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension ListPlanExecutionEventsInput {

    static func write(value: ListPlanExecutionEventsInput?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["executionId"].write(value.executionId)
        try writer["maxResults"].write(value.maxResults)
        try writer["name"].write(value.name)
        try writer["nextToken"].write(value.nextToken)
        try writer["planArn"].write(value.planArn)
    }
}

extension ListPlanExecutionsInput {

    static func write(value: ListPlanExecutionsInput?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["planArn"].write(value.planArn)
        try writer["state"].write(value.state)
    }
}

extension ListPlansInput {

    static func write(value: ListPlansInput?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListPlansInRegionInput {

    static func write(value: ListPlansInRegionInput?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListRoute53HealthChecksInput {

    static func write(value: ListRoute53HealthChecksInput?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["hostedZoneId"].write(value.hostedZoneId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["recordName"].write(value.recordName)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension StartPlanExecutionInput {

    static func write(value: StartPlanExecutionInput?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["comment"].write(value.comment)
        try writer["latestVersion"].write(value.latestVersion)
        try writer["mode"].write(value.mode)
        try writer["planArn"].write(value.planArn)
        try writer["targetRegion"].write(value.targetRegion)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["resourceTagKeys"].writeList(value.resourceTagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdatePlanInput {

    static func write(value: UpdatePlanInput?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["associatedAlarms"].writeMap(value.associatedAlarms, valueWritingClosure: ARCRegionswitchClientTypes.AssociatedAlarm.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["executionRole"].write(value.executionRole)
        try writer["recoveryTimeObjectiveMinutes"].write(value.recoveryTimeObjectiveMinutes)
        try writer["triggers"].writeList(value.triggers, memberWritingClosure: ARCRegionswitchClientTypes.Trigger.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["workflows"].writeList(value.workflows, memberWritingClosure: ARCRegionswitchClientTypes.Workflow.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdatePlanExecutionInput {

    static func write(value: UpdatePlanExecutionInput?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["comment"].write(value.comment)
        try writer["executionId"].write(value.executionId)
        try writer["planArn"].write(value.planArn)
    }
}

extension UpdatePlanExecutionStepInput {

    static func write(value: UpdatePlanExecutionStepInput?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["actionToTake"].write(value.actionToTake)
        try writer["comment"].write(value.comment)
        try writer["executionId"].write(value.executionId)
        try writer["planArn"].write(value.planArn)
        try writer["stepName"].write(value.stepName)
    }
}

extension ApprovePlanExecutionStepOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ApprovePlanExecutionStepOutput {
        return ApprovePlanExecutionStepOutput()
    }
}

extension CancelPlanExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelPlanExecutionOutput {
        return CancelPlanExecutionOutput()
    }
}

extension CreatePlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePlanOutput()
        value.plan = try reader["plan"].readIfPresent(with: ARCRegionswitchClientTypes.Plan.read(from:))
        return value
    }
}

extension DeletePlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePlanOutput {
        return DeletePlanOutput()
    }
}

extension GetPlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let reader = responseReader
        var value = GetPlanOutput()
        value.plan = try reader["plan"].readIfPresent(with: ARCRegionswitchClientTypes.Plan.read(from:))
        return value
    }
}

extension GetPlanEvaluationStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPlanEvaluationStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let reader = responseReader
        var value = GetPlanEvaluationStatusOutput()
        value.evaluationState = try reader["evaluationState"].readIfPresent()
        value.lastEvaluatedVersion = try reader["lastEvaluatedVersion"].readIfPresent()
        value.lastEvaluationTime = try reader["lastEvaluationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.planArn = try reader["planArn"].readIfPresent() ?? ""
        value.region = try reader["region"].readIfPresent()
        value.warnings = try reader["warnings"].readListIfPresent(memberReadingClosure: ARCRegionswitchClientTypes.ResourceWarning.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetPlanExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPlanExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let reader = responseReader
        var value = GetPlanExecutionOutput()
        value.actualRecoveryTime = try reader["actualRecoveryTime"].readIfPresent()
        value.comment = try reader["comment"].readIfPresent()
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.executionAction = try reader["executionAction"].readIfPresent() ?? .sdkUnknown("")
        value.executionId = try reader["executionId"].readIfPresent() ?? ""
        value.executionRegion = try reader["executionRegion"].readIfPresent() ?? ""
        value.executionState = try reader["executionState"].readIfPresent() ?? .sdkUnknown("")
        value.mode = try reader["mode"].readIfPresent() ?? .sdkUnknown("")
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.plan = try reader["plan"].readIfPresent(with: ARCRegionswitchClientTypes.Plan.read(from:))
        value.planArn = try reader["planArn"].readIfPresent() ?? ""
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.stepStates = try reader["stepStates"].readListIfPresent(memberReadingClosure: ARCRegionswitchClientTypes.StepState.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension GetPlanInRegionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPlanInRegionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let reader = responseReader
        var value = GetPlanInRegionOutput()
        value.plan = try reader["plan"].readIfPresent(with: ARCRegionswitchClientTypes.Plan.read(from:))
        return value
    }
}

extension ListPlanExecutionEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPlanExecutionEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let reader = responseReader
        var value = ListPlanExecutionEventsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ARCRegionswitchClientTypes.ExecutionEvent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListPlanExecutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPlanExecutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let reader = responseReader
        var value = ListPlanExecutionsOutput()
        value.items = try reader["items"].readListIfPresent(memberReadingClosure: ARCRegionswitchClientTypes.AbbreviatedExecution.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListPlansOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPlansOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let reader = responseReader
        var value = ListPlansOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.plans = try reader["plans"].readListIfPresent(memberReadingClosure: ARCRegionswitchClientTypes.AbbreviatedPlan.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPlansInRegionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPlansInRegionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let reader = responseReader
        var value = ListPlansInRegionOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.plans = try reader["plans"].readListIfPresent(memberReadingClosure: ARCRegionswitchClientTypes.AbbreviatedPlan.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListRoute53HealthChecksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRoute53HealthChecksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let reader = responseReader
        var value = ListRoute53HealthChecksOutput()
        value.healthChecks = try reader["healthChecks"].readListIfPresent(memberReadingClosure: ARCRegionswitchClientTypes.Route53HealthCheck.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.resourceTags = try reader["resourceTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension StartPlanExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartPlanExecutionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let reader = responseReader
        var value = StartPlanExecutionOutput()
        value.activateRegion = try reader["activateRegion"].readIfPresent()
        value.deactivateRegion = try reader["deactivateRegion"].readIfPresent()
        value.executionId = try reader["executionId"].readIfPresent()
        value.plan = try reader["plan"].readIfPresent()
        value.planVersion = try reader["planVersion"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdatePlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePlanOutput()
        value.plan = try reader["plan"].readIfPresent(with: ARCRegionswitchClientTypes.Plan.read(from:))
        return value
    }
}

extension UpdatePlanExecutionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePlanExecutionOutput {
        return UpdatePlanExecutionOutput()
    }
}

extension UpdatePlanExecutionStepOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePlanExecutionStepOutput {
        return UpdatePlanExecutionStepOutput()
    }
}

enum ApprovePlanExecutionStepOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let baseError = try ClientRuntime.RpcV2CborError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelPlanExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let baseError = try ClientRuntime.RpcV2CborError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let baseError = try ClientRuntime.RpcV2CborError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let baseError = try ClientRuntime.RpcV2CborError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "IllegalStateException": return try IllegalStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let baseError = try ClientRuntime.RpcV2CborError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPlanEvaluationStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let baseError = try ClientRuntime.RpcV2CborError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPlanExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let baseError = try ClientRuntime.RpcV2CborError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPlanInRegionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let baseError = try ClientRuntime.RpcV2CborError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPlanExecutionEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let baseError = try ClientRuntime.RpcV2CborError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPlanExecutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let baseError = try ClientRuntime.RpcV2CborError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPlansOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let baseError = try ClientRuntime.RpcV2CborError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPlansInRegionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let baseError = try ClientRuntime.RpcV2CborError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRoute53HealthChecksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let baseError = try ClientRuntime.RpcV2CborError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let baseError = try ClientRuntime.RpcV2CborError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartPlanExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let baseError = try ClientRuntime.RpcV2CborError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalArgumentException": return try IllegalArgumentException.makeError(baseError: baseError)
            case "IllegalStateException": return try IllegalStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let baseError = try ClientRuntime.RpcV2CborError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let baseError = try ClientRuntime.RpcV2CborError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let baseError = try ClientRuntime.RpcV2CborError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePlanExecutionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let baseError = try ClientRuntime.RpcV2CborError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "IllegalStateException": return try IllegalStateException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePlanExecutionStepOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyCBOR.Reader.from(data: data)
        let baseError = try ClientRuntime.RpcV2CborError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: ClientRuntime.RpcV2CborError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: ClientRuntime.RpcV2CborError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IllegalStateException {

    static func makeError(baseError: ClientRuntime.RpcV2CborError) throws -> IllegalStateException {
        let reader = baseError.errorBodyReader
        var value = IllegalStateException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: ClientRuntime.RpcV2CborError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IllegalArgumentException {

    static func makeError(baseError: ClientRuntime.RpcV2CborError) throws -> IllegalArgumentException {
        let reader = baseError.errorBodyReader
        var value = IllegalArgumentException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ARCRegionswitchClientTypes.Plan {

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.Plan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.Plan()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.workflows = try reader["workflows"].readListIfPresent(memberReadingClosure: ARCRegionswitchClientTypes.Workflow.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.executionRole = try reader["executionRole"].readIfPresent() ?? ""
        value.recoveryTimeObjectiveMinutes = try reader["recoveryTimeObjectiveMinutes"].readIfPresent()
        value.associatedAlarms = try reader["associatedAlarms"].readMapIfPresent(valueReadingClosure: ARCRegionswitchClientTypes.AssociatedAlarm.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.triggers = try reader["triggers"].readListIfPresent(memberReadingClosure: ARCRegionswitchClientTypes.Trigger.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent() ?? ""
        value.regions = try reader["regions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.recoveryApproach = try reader["recoveryApproach"].readIfPresent() ?? .sdkUnknown("")
        value.primaryRegion = try reader["primaryRegion"].readIfPresent()
        value.owner = try reader["owner"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ARCRegionswitchClientTypes.Trigger {

    static func write(value: ARCRegionswitchClientTypes.Trigger?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["action"].write(value.action)
        try writer["conditions"].writeList(value.conditions, memberWritingClosure: ARCRegionswitchClientTypes.TriggerCondition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["minDelayMinutesBetweenExecutions"].write(value.minDelayMinutesBetweenExecutions)
        try writer["targetRegion"].write(value.targetRegion)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.Trigger {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.Trigger()
        value.description = try reader["description"].readIfPresent()
        value.targetRegion = try reader["targetRegion"].readIfPresent() ?? ""
        value.action = try reader["action"].readIfPresent() ?? .sdkUnknown("")
        value.conditions = try reader["conditions"].readListIfPresent(memberReadingClosure: ARCRegionswitchClientTypes.TriggerCondition.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.minDelayMinutesBetweenExecutions = try reader["minDelayMinutesBetweenExecutions"].readIfPresent() ?? 0
        return value
    }
}

extension ARCRegionswitchClientTypes.TriggerCondition {

    static func write(value: ARCRegionswitchClientTypes.TriggerCondition?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["associatedAlarmName"].write(value.associatedAlarmName)
        try writer["condition"].write(value.condition)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.TriggerCondition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.TriggerCondition()
        value.associatedAlarmName = try reader["associatedAlarmName"].readIfPresent() ?? ""
        value.condition = try reader["condition"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ARCRegionswitchClientTypes.AssociatedAlarm {

    static func write(value: ARCRegionswitchClientTypes.AssociatedAlarm?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["alarmType"].write(value.alarmType)
        try writer["crossAccountRole"].write(value.crossAccountRole)
        try writer["externalId"].write(value.externalId)
        try writer["resourceIdentifier"].write(value.resourceIdentifier)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.AssociatedAlarm {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.AssociatedAlarm()
        value.crossAccountRole = try reader["crossAccountRole"].readIfPresent()
        value.externalId = try reader["externalId"].readIfPresent()
        value.resourceIdentifier = try reader["resourceIdentifier"].readIfPresent() ?? ""
        value.alarmType = try reader["alarmType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ARCRegionswitchClientTypes.Workflow {

    static func write(value: ARCRegionswitchClientTypes.Workflow?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["steps"].writeList(value.steps, memberWritingClosure: ARCRegionswitchClientTypes.Step.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["workflowDescription"].write(value.workflowDescription)
        try writer["workflowTargetAction"].write(value.workflowTargetAction)
        try writer["workflowTargetRegion"].write(value.workflowTargetRegion)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.Workflow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.Workflow()
        value.steps = try reader["steps"].readListIfPresent(memberReadingClosure: ARCRegionswitchClientTypes.Step.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.workflowTargetAction = try reader["workflowTargetAction"].readIfPresent() ?? .sdkUnknown("")
        value.workflowTargetRegion = try reader["workflowTargetRegion"].readIfPresent()
        value.workflowDescription = try reader["workflowDescription"].readIfPresent()
        return value
    }
}

extension ARCRegionswitchClientTypes.Step {

    static func write(value: ARCRegionswitchClientTypes.Step?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["executionBlockConfiguration"].write(value.executionBlockConfiguration, with: ARCRegionswitchClientTypes.ExecutionBlockConfiguration.write(value:to:))
        try writer["executionBlockType"].write(value.executionBlockType)
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.Step {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.Step()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.executionBlockConfiguration = try reader["executionBlockConfiguration"].readIfPresent(with: ARCRegionswitchClientTypes.ExecutionBlockConfiguration.read(from:))
        value.executionBlockType = try reader["executionBlockType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ARCRegionswitchClientTypes.ExecutionBlockConfiguration {

    static func write(value: ARCRegionswitchClientTypes.ExecutionBlockConfiguration?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        switch value {
            case let .arcroutingcontrolconfig(arcroutingcontrolconfig):
                try writer["arcRoutingControlConfig"].write(arcroutingcontrolconfig, with: ARCRegionswitchClientTypes.ArcRoutingControlConfiguration.write(value:to:))
            case let .customactionlambdaconfig(customactionlambdaconfig):
                try writer["customActionLambdaConfig"].write(customactionlambdaconfig, with: ARCRegionswitchClientTypes.CustomActionLambdaConfiguration.write(value:to:))
            case let .ec2asgcapacityincreaseconfig(ec2asgcapacityincreaseconfig):
                try writer["ec2AsgCapacityIncreaseConfig"].write(ec2asgcapacityincreaseconfig, with: ARCRegionswitchClientTypes.Ec2AsgCapacityIncreaseConfiguration.write(value:to:))
            case let .ecscapacityincreaseconfig(ecscapacityincreaseconfig):
                try writer["ecsCapacityIncreaseConfig"].write(ecscapacityincreaseconfig, with: ARCRegionswitchClientTypes.EcsCapacityIncreaseConfiguration.write(value:to:))
            case let .eksresourcescalingconfig(eksresourcescalingconfig):
                try writer["eksResourceScalingConfig"].write(eksresourcescalingconfig, with: ARCRegionswitchClientTypes.EksResourceScalingConfiguration.write(value:to:))
            case let .executionapprovalconfig(executionapprovalconfig):
                try writer["executionApprovalConfig"].write(executionapprovalconfig, with: ARCRegionswitchClientTypes.ExecutionApprovalConfiguration.write(value:to:))
            case let .globalauroraconfig(globalauroraconfig):
                try writer["globalAuroraConfig"].write(globalauroraconfig, with: ARCRegionswitchClientTypes.GlobalAuroraConfiguration.write(value:to:))
            case let .parallelconfig(parallelconfig):
                try writer["parallelConfig"].write(parallelconfig, with: ARCRegionswitchClientTypes.ParallelExecutionBlockConfiguration.write(value:to:))
            case let .regionswitchplanconfig(regionswitchplanconfig):
                try writer["regionSwitchPlanConfig"].write(regionswitchplanconfig, with: ARCRegionswitchClientTypes.RegionSwitchPlanConfiguration.write(value:to:))
            case let .route53healthcheckconfig(route53healthcheckconfig):
                try writer["route53HealthCheckConfig"].write(route53healthcheckconfig, with: ARCRegionswitchClientTypes.Route53HealthCheckConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.ExecutionBlockConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "customActionLambdaConfig":
                return .customactionlambdaconfig(try reader["customActionLambdaConfig"].read(with: ARCRegionswitchClientTypes.CustomActionLambdaConfiguration.read(from:)))
            case "ec2AsgCapacityIncreaseConfig":
                return .ec2asgcapacityincreaseconfig(try reader["ec2AsgCapacityIncreaseConfig"].read(with: ARCRegionswitchClientTypes.Ec2AsgCapacityIncreaseConfiguration.read(from:)))
            case "executionApprovalConfig":
                return .executionapprovalconfig(try reader["executionApprovalConfig"].read(with: ARCRegionswitchClientTypes.ExecutionApprovalConfiguration.read(from:)))
            case "arcRoutingControlConfig":
                return .arcroutingcontrolconfig(try reader["arcRoutingControlConfig"].read(with: ARCRegionswitchClientTypes.ArcRoutingControlConfiguration.read(from:)))
            case "globalAuroraConfig":
                return .globalauroraconfig(try reader["globalAuroraConfig"].read(with: ARCRegionswitchClientTypes.GlobalAuroraConfiguration.read(from:)))
            case "parallelConfig":
                return .parallelconfig(try reader["parallelConfig"].read(with: ARCRegionswitchClientTypes.ParallelExecutionBlockConfiguration.read(from:)))
            case "regionSwitchPlanConfig":
                return .regionswitchplanconfig(try reader["regionSwitchPlanConfig"].read(with: ARCRegionswitchClientTypes.RegionSwitchPlanConfiguration.read(from:)))
            case "ecsCapacityIncreaseConfig":
                return .ecscapacityincreaseconfig(try reader["ecsCapacityIncreaseConfig"].read(with: ARCRegionswitchClientTypes.EcsCapacityIncreaseConfiguration.read(from:)))
            case "eksResourceScalingConfig":
                return .eksresourcescalingconfig(try reader["eksResourceScalingConfig"].read(with: ARCRegionswitchClientTypes.EksResourceScalingConfiguration.read(from:)))
            case "route53HealthCheckConfig":
                return .route53healthcheckconfig(try reader["route53HealthCheckConfig"].read(with: ARCRegionswitchClientTypes.Route53HealthCheckConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension ARCRegionswitchClientTypes.Route53HealthCheckConfiguration {

    static func write(value: ARCRegionswitchClientTypes.Route53HealthCheckConfiguration?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["crossAccountRole"].write(value.crossAccountRole)
        try writer["externalId"].write(value.externalId)
        try writer["hostedZoneId"].write(value.hostedZoneId)
        try writer["recordName"].write(value.recordName)
        try writer["recordSets"].writeList(value.recordSets, memberWritingClosure: ARCRegionswitchClientTypes.Route53ResourceRecordSet.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["timeoutMinutes"].write(value.timeoutMinutes)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.Route53HealthCheckConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.Route53HealthCheckConfiguration()
        value.timeoutMinutes = try reader["timeoutMinutes"].readIfPresent() ?? 60
        value.crossAccountRole = try reader["crossAccountRole"].readIfPresent()
        value.externalId = try reader["externalId"].readIfPresent()
        value.hostedZoneId = try reader["hostedZoneId"].readIfPresent() ?? ""
        value.recordName = try reader["recordName"].readIfPresent() ?? ""
        value.recordSets = try reader["recordSets"].readListIfPresent(memberReadingClosure: ARCRegionswitchClientTypes.Route53ResourceRecordSet.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ARCRegionswitchClientTypes.Route53ResourceRecordSet {

    static func write(value: ARCRegionswitchClientTypes.Route53ResourceRecordSet?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["recordSetIdentifier"].write(value.recordSetIdentifier)
        try writer["region"].write(value.region)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.Route53ResourceRecordSet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.Route53ResourceRecordSet()
        value.recordSetIdentifier = try reader["recordSetIdentifier"].readIfPresent()
        value.region = try reader["region"].readIfPresent()
        return value
    }
}

extension ARCRegionswitchClientTypes.EksResourceScalingConfiguration {

    static func write(value: ARCRegionswitchClientTypes.EksResourceScalingConfiguration?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["capacityMonitoringApproach"].write(value.capacityMonitoringApproach)
        try writer["eksClusters"].writeList(value.eksClusters, memberWritingClosure: ARCRegionswitchClientTypes.EksCluster.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["kubernetesResourceType"].write(value.kubernetesResourceType, with: ARCRegionswitchClientTypes.KubernetesResourceType.write(value:to:))
        try writer["scalingResources"].writeList(value.scalingResources, memberWritingClosure: SmithyReadWrite.mapWritingClosure(valueWritingClosure: SmithyReadWrite.mapWritingClosure(valueWritingClosure: ARCRegionswitchClientTypes.KubernetesScalingResource.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        try writer["targetPercent"].write(value.targetPercent)
        try writer["timeoutMinutes"].write(value.timeoutMinutes)
        try writer["ungraceful"].write(value.ungraceful, with: ARCRegionswitchClientTypes.EksResourceScalingUngraceful.write(value:to:))
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.EksResourceScalingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.EksResourceScalingConfiguration()
        value.timeoutMinutes = try reader["timeoutMinutes"].readIfPresent() ?? 60
        value.kubernetesResourceType = try reader["kubernetesResourceType"].readIfPresent(with: ARCRegionswitchClientTypes.KubernetesResourceType.read(from:))
        value.scalingResources = try reader["scalingResources"].readListIfPresent(memberReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: SmithyReadWrite.mapReadingClosure(valueReadingClosure: ARCRegionswitchClientTypes.KubernetesScalingResource.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false), memberNodeInfo: "member", isFlattened: false)
        value.eksClusters = try reader["eksClusters"].readListIfPresent(memberReadingClosure: ARCRegionswitchClientTypes.EksCluster.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ungraceful = try reader["ungraceful"].readIfPresent(with: ARCRegionswitchClientTypes.EksResourceScalingUngraceful.read(from:))
        value.targetPercent = try reader["targetPercent"].readIfPresent() ?? 100
        value.capacityMonitoringApproach = try reader["capacityMonitoringApproach"].readIfPresent() ?? ARCRegionswitchClientTypes.EksCapacityMonitoringApproach.sampledMaxInLast24Hours
        return value
    }
}

extension ARCRegionswitchClientTypes.EksResourceScalingUngraceful {

    static func write(value: ARCRegionswitchClientTypes.EksResourceScalingUngraceful?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["minimumSuccessPercentage"].write(value.minimumSuccessPercentage)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.EksResourceScalingUngraceful {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.EksResourceScalingUngraceful()
        value.minimumSuccessPercentage = try reader["minimumSuccessPercentage"].readIfPresent() ?? 0
        return value
    }
}

extension ARCRegionswitchClientTypes.EksCluster {

    static func write(value: ARCRegionswitchClientTypes.EksCluster?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["clusterArn"].write(value.clusterArn)
        try writer["crossAccountRole"].write(value.crossAccountRole)
        try writer["externalId"].write(value.externalId)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.EksCluster {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.EksCluster()
        value.crossAccountRole = try reader["crossAccountRole"].readIfPresent()
        value.externalId = try reader["externalId"].readIfPresent()
        value.clusterArn = try reader["clusterArn"].readIfPresent() ?? ""
        return value
    }
}

extension ARCRegionswitchClientTypes.KubernetesScalingResource {

    static func write(value: ARCRegionswitchClientTypes.KubernetesScalingResource?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["hpaName"].write(value.hpaName)
        try writer["name"].write(value.name)
        try writer["namespace"].write(value.namespace)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.KubernetesScalingResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.KubernetesScalingResource()
        value.namespace = try reader["namespace"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.hpaName = try reader["hpaName"].readIfPresent()
        return value
    }
}

extension ARCRegionswitchClientTypes.KubernetesResourceType {

    static func write(value: ARCRegionswitchClientTypes.KubernetesResourceType?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["apiVersion"].write(value.apiVersion)
        try writer["kind"].write(value.kind)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.KubernetesResourceType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.KubernetesResourceType()
        value.apiVersion = try reader["apiVersion"].readIfPresent() ?? ""
        value.kind = try reader["kind"].readIfPresent() ?? ""
        return value
    }
}

extension ARCRegionswitchClientTypes.EcsCapacityIncreaseConfiguration {

    static func write(value: ARCRegionswitchClientTypes.EcsCapacityIncreaseConfiguration?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["capacityMonitoringApproach"].write(value.capacityMonitoringApproach)
        try writer["services"].writeList(value.services, memberWritingClosure: ARCRegionswitchClientTypes.Service.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["targetPercent"].write(value.targetPercent)
        try writer["timeoutMinutes"].write(value.timeoutMinutes)
        try writer["ungraceful"].write(value.ungraceful, with: ARCRegionswitchClientTypes.EcsUngraceful.write(value:to:))
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.EcsCapacityIncreaseConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.EcsCapacityIncreaseConfiguration()
        value.timeoutMinutes = try reader["timeoutMinutes"].readIfPresent() ?? 60
        value.services = try reader["services"].readListIfPresent(memberReadingClosure: ARCRegionswitchClientTypes.Service.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.ungraceful = try reader["ungraceful"].readIfPresent(with: ARCRegionswitchClientTypes.EcsUngraceful.read(from:))
        value.targetPercent = try reader["targetPercent"].readIfPresent() ?? 100
        value.capacityMonitoringApproach = try reader["capacityMonitoringApproach"].readIfPresent() ?? ARCRegionswitchClientTypes.EcsCapacityMonitoringApproach.sampledMaxInLast24Hours
        return value
    }
}

extension ARCRegionswitchClientTypes.EcsUngraceful {

    static func write(value: ARCRegionswitchClientTypes.EcsUngraceful?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["minimumSuccessPercentage"].write(value.minimumSuccessPercentage)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.EcsUngraceful {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.EcsUngraceful()
        value.minimumSuccessPercentage = try reader["minimumSuccessPercentage"].readIfPresent() ?? 0
        return value
    }
}

extension ARCRegionswitchClientTypes.Service {

    static func write(value: ARCRegionswitchClientTypes.Service?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["clusterArn"].write(value.clusterArn)
        try writer["crossAccountRole"].write(value.crossAccountRole)
        try writer["externalId"].write(value.externalId)
        try writer["serviceArn"].write(value.serviceArn)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.Service {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.Service()
        value.crossAccountRole = try reader["crossAccountRole"].readIfPresent()
        value.externalId = try reader["externalId"].readIfPresent()
        value.clusterArn = try reader["clusterArn"].readIfPresent()
        value.serviceArn = try reader["serviceArn"].readIfPresent()
        return value
    }
}

extension ARCRegionswitchClientTypes.RegionSwitchPlanConfiguration {

    static func write(value: ARCRegionswitchClientTypes.RegionSwitchPlanConfiguration?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["crossAccountRole"].write(value.crossAccountRole)
        try writer["externalId"].write(value.externalId)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.RegionSwitchPlanConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.RegionSwitchPlanConfiguration()
        value.crossAccountRole = try reader["crossAccountRole"].readIfPresent()
        value.externalId = try reader["externalId"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension ARCRegionswitchClientTypes.ParallelExecutionBlockConfiguration {

    static func write(value: ARCRegionswitchClientTypes.ParallelExecutionBlockConfiguration?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["steps"].writeList(value.steps, memberWritingClosure: ARCRegionswitchClientTypes.Step.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.ParallelExecutionBlockConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.ParallelExecutionBlockConfiguration()
        value.steps = try reader["steps"].readListIfPresent(memberReadingClosure: ARCRegionswitchClientTypes.Step.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ARCRegionswitchClientTypes.GlobalAuroraConfiguration {

    static func write(value: ARCRegionswitchClientTypes.GlobalAuroraConfiguration?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["behavior"].write(value.behavior)
        try writer["crossAccountRole"].write(value.crossAccountRole)
        try writer["databaseClusterArns"].writeList(value.databaseClusterArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["externalId"].write(value.externalId)
        try writer["globalClusterIdentifier"].write(value.globalClusterIdentifier)
        try writer["timeoutMinutes"].write(value.timeoutMinutes)
        try writer["ungraceful"].write(value.ungraceful, with: ARCRegionswitchClientTypes.GlobalAuroraUngraceful.write(value:to:))
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.GlobalAuroraConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.GlobalAuroraConfiguration()
        value.timeoutMinutes = try reader["timeoutMinutes"].readIfPresent() ?? 60
        value.crossAccountRole = try reader["crossAccountRole"].readIfPresent()
        value.externalId = try reader["externalId"].readIfPresent()
        value.behavior = try reader["behavior"].readIfPresent() ?? ARCRegionswitchClientTypes.GlobalAuroraDefaultBehavior.switchoverOnly
        value.ungraceful = try reader["ungraceful"].readIfPresent(with: ARCRegionswitchClientTypes.GlobalAuroraUngraceful.read(from:))
        value.globalClusterIdentifier = try reader["globalClusterIdentifier"].readIfPresent() ?? ""
        value.databaseClusterArns = try reader["databaseClusterArns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ARCRegionswitchClientTypes.GlobalAuroraUngraceful {

    static func write(value: ARCRegionswitchClientTypes.GlobalAuroraUngraceful?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["ungraceful"].write(value.ungraceful)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.GlobalAuroraUngraceful {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.GlobalAuroraUngraceful()
        value.ungraceful = try reader["ungraceful"].readIfPresent()
        return value
    }
}

extension ARCRegionswitchClientTypes.ArcRoutingControlConfiguration {

    static func write(value: ARCRegionswitchClientTypes.ArcRoutingControlConfiguration?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["crossAccountRole"].write(value.crossAccountRole)
        try writer["externalId"].write(value.externalId)
        try writer["regionAndRoutingControls"].writeMap(value.regionAndRoutingControls, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: ARCRegionswitchClientTypes.ArcRoutingControlState.write(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["timeoutMinutes"].write(value.timeoutMinutes)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.ArcRoutingControlConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.ArcRoutingControlConfiguration()
        value.timeoutMinutes = try reader["timeoutMinutes"].readIfPresent() ?? 60
        value.crossAccountRole = try reader["crossAccountRole"].readIfPresent()
        value.externalId = try reader["externalId"].readIfPresent()
        value.regionAndRoutingControls = try reader["regionAndRoutingControls"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: ARCRegionswitchClientTypes.ArcRoutingControlState.read(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension ARCRegionswitchClientTypes.ArcRoutingControlState {

    static func write(value: ARCRegionswitchClientTypes.ArcRoutingControlState?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["routingControlArn"].write(value.routingControlArn)
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.ArcRoutingControlState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.ArcRoutingControlState()
        value.routingControlArn = try reader["routingControlArn"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ARCRegionswitchClientTypes.ExecutionApprovalConfiguration {

    static func write(value: ARCRegionswitchClientTypes.ExecutionApprovalConfiguration?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["approvalRole"].write(value.approvalRole)
        try writer["timeoutMinutes"].write(value.timeoutMinutes)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.ExecutionApprovalConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.ExecutionApprovalConfiguration()
        value.timeoutMinutes = try reader["timeoutMinutes"].readIfPresent() ?? 60
        value.approvalRole = try reader["approvalRole"].readIfPresent() ?? ""
        return value
    }
}

extension ARCRegionswitchClientTypes.Ec2AsgCapacityIncreaseConfiguration {

    static func write(value: ARCRegionswitchClientTypes.Ec2AsgCapacityIncreaseConfiguration?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["asgs"].writeList(value.asgs, memberWritingClosure: ARCRegionswitchClientTypes.Asg.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["capacityMonitoringApproach"].write(value.capacityMonitoringApproach)
        try writer["targetPercent"].write(value.targetPercent)
        try writer["timeoutMinutes"].write(value.timeoutMinutes)
        try writer["ungraceful"].write(value.ungraceful, with: ARCRegionswitchClientTypes.Ec2Ungraceful.write(value:to:))
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.Ec2AsgCapacityIncreaseConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.Ec2AsgCapacityIncreaseConfiguration()
        value.timeoutMinutes = try reader["timeoutMinutes"].readIfPresent() ?? 60
        value.asgs = try reader["asgs"].readListIfPresent(memberReadingClosure: ARCRegionswitchClientTypes.Asg.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.ungraceful = try reader["ungraceful"].readIfPresent(with: ARCRegionswitchClientTypes.Ec2Ungraceful.read(from:))
        value.targetPercent = try reader["targetPercent"].readIfPresent() ?? 100
        value.capacityMonitoringApproach = try reader["capacityMonitoringApproach"].readIfPresent() ?? ARCRegionswitchClientTypes.Ec2AsgCapacityMonitoringApproach.sampledMaxInLast24Hours
        return value
    }
}

extension ARCRegionswitchClientTypes.Ec2Ungraceful {

    static func write(value: ARCRegionswitchClientTypes.Ec2Ungraceful?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["minimumSuccessPercentage"].write(value.minimumSuccessPercentage)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.Ec2Ungraceful {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.Ec2Ungraceful()
        value.minimumSuccessPercentage = try reader["minimumSuccessPercentage"].readIfPresent() ?? 0
        return value
    }
}

extension ARCRegionswitchClientTypes.Asg {

    static func write(value: ARCRegionswitchClientTypes.Asg?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["crossAccountRole"].write(value.crossAccountRole)
        try writer["externalId"].write(value.externalId)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.Asg {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.Asg()
        value.crossAccountRole = try reader["crossAccountRole"].readIfPresent()
        value.externalId = try reader["externalId"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension ARCRegionswitchClientTypes.CustomActionLambdaConfiguration {

    static func write(value: ARCRegionswitchClientTypes.CustomActionLambdaConfiguration?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["lambdas"].writeList(value.lambdas, memberWritingClosure: ARCRegionswitchClientTypes.Lambdas.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["regionToRun"].write(value.regionToRun)
        try writer["retryIntervalMinutes"].write(value.retryIntervalMinutes)
        try writer["timeoutMinutes"].write(value.timeoutMinutes)
        try writer["ungraceful"].write(value.ungraceful, with: ARCRegionswitchClientTypes.LambdaUngraceful.write(value:to:))
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.CustomActionLambdaConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.CustomActionLambdaConfiguration()
        value.timeoutMinutes = try reader["timeoutMinutes"].readIfPresent() ?? 60
        value.lambdas = try reader["lambdas"].readListIfPresent(memberReadingClosure: ARCRegionswitchClientTypes.Lambdas.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.retryIntervalMinutes = try reader["retryIntervalMinutes"].readIfPresent() ?? 0.0
        value.regionToRun = try reader["regionToRun"].readIfPresent() ?? .sdkUnknown("")
        value.ungraceful = try reader["ungraceful"].readIfPresent(with: ARCRegionswitchClientTypes.LambdaUngraceful.read(from:))
        return value
    }
}

extension ARCRegionswitchClientTypes.LambdaUngraceful {

    static func write(value: ARCRegionswitchClientTypes.LambdaUngraceful?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["behavior"].write(value.behavior)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.LambdaUngraceful {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.LambdaUngraceful()
        value.behavior = try reader["behavior"].readIfPresent() ?? ARCRegionswitchClientTypes.LambdaUngracefulBehavior.skip
        return value
    }
}

extension ARCRegionswitchClientTypes.Lambdas {

    static func write(value: ARCRegionswitchClientTypes.Lambdas?, to writer: SmithyCBOR.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["crossAccountRole"].write(value.crossAccountRole)
        try writer["externalId"].write(value.externalId)
    }

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.Lambdas {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.Lambdas()
        value.crossAccountRole = try reader["crossAccountRole"].readIfPresent()
        value.externalId = try reader["externalId"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension ARCRegionswitchClientTypes.ResourceWarning {

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.ResourceWarning {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.ResourceWarning()
        value.workflow = try reader["workflow"].readIfPresent(with: ARCRegionswitchClientTypes.MinimalWorkflow.read(from:))
        value.version = try reader["version"].readIfPresent() ?? ""
        value.stepName = try reader["stepName"].readIfPresent()
        value.resourceArn = try reader["resourceArn"].readIfPresent()
        value.warningStatus = try reader["warningStatus"].readIfPresent() ?? .sdkUnknown("")
        value.warningUpdatedTime = try reader["warningUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.warningMessage = try reader["warningMessage"].readIfPresent() ?? ""
        return value
    }
}

extension ARCRegionswitchClientTypes.MinimalWorkflow {

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.MinimalWorkflow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.MinimalWorkflow()
        value.action = try reader["action"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension ARCRegionswitchClientTypes.StepState {

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.StepState {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.StepState()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.stepMode = try reader["stepMode"].readIfPresent()
        return value
    }
}

extension ARCRegionswitchClientTypes.ExecutionEvent {

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.ExecutionEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.ExecutionEvent()
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.type = try reader["type"].readIfPresent()
        value.stepName = try reader["stepName"].readIfPresent()
        value.executionBlockType = try reader["executionBlockType"].readIfPresent()
        value.resources = try reader["resources"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.error = try reader["error"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.eventId = try reader["eventId"].readIfPresent() ?? ""
        value.previousEventId = try reader["previousEventId"].readIfPresent()
        return value
    }
}

extension ARCRegionswitchClientTypes.AbbreviatedExecution {

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.AbbreviatedExecution {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.AbbreviatedExecution()
        value.planArn = try reader["planArn"].readIfPresent() ?? ""
        value.executionId = try reader["executionId"].readIfPresent() ?? ""
        value.version = try reader["version"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.comment = try reader["comment"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.mode = try reader["mode"].readIfPresent() ?? .sdkUnknown("")
        value.executionState = try reader["executionState"].readIfPresent() ?? .sdkUnknown("")
        value.executionAction = try reader["executionAction"].readIfPresent() ?? .sdkUnknown("")
        value.executionRegion = try reader["executionRegion"].readIfPresent() ?? ""
        value.actualRecoveryTime = try reader["actualRecoveryTime"].readIfPresent()
        return value
    }
}

extension ARCRegionswitchClientTypes.AbbreviatedPlan {

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.AbbreviatedPlan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.AbbreviatedPlan()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.owner = try reader["owner"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.regions = try reader["regions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.recoveryApproach = try reader["recoveryApproach"].readIfPresent() ?? .sdkUnknown("")
        value.primaryRegion = try reader["primaryRegion"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.executionRole = try reader["executionRole"].readIfPresent()
        value.activePlanExecution = try reader["activePlanExecution"].readIfPresent()
        value.recoveryTimeObjectiveMinutes = try reader["recoveryTimeObjectiveMinutes"].readIfPresent()
        return value
    }
}

extension ARCRegionswitchClientTypes.Route53HealthCheck {

    static func read(from reader: SmithyCBOR.Reader) throws -> ARCRegionswitchClientTypes.Route53HealthCheck {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ARCRegionswitchClientTypes.Route53HealthCheck()
        value.hostedZoneId = try reader["hostedZoneId"].readIfPresent() ?? ""
        value.recordName = try reader["recordName"].readIfPresent() ?? ""
        value.healthCheckId = try reader["healthCheckId"].readIfPresent()
        value.region = try reader["region"].readIfPresent() ?? ""
        return value
    }
}

public enum ARCRegionswitchClientTypes {}
