//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import Foundation
import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension ARCRegionswitchClient {
    /// Paginate over `[GetPlanEvaluationStatusOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetPlanEvaluationStatusInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetPlanEvaluationStatusOutput`
    public func getPlanEvaluationStatusPaginated(input: GetPlanEvaluationStatusInput) -> ClientRuntime.PaginatorSequence<GetPlanEvaluationStatusInput, GetPlanEvaluationStatusOutput> {
        return ClientRuntime.PaginatorSequence<GetPlanEvaluationStatusInput, GetPlanEvaluationStatusOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getPlanEvaluationStatus(input:))
    }
}

extension GetPlanEvaluationStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetPlanEvaluationStatusInput {
        return GetPlanEvaluationStatusInput(
            maxResults: self.maxResults,
            nextToken: token,
            planArn: self.planArn
        )}
}

extension PaginatorSequence where OperationStackInput == GetPlanEvaluationStatusInput, OperationStackOutput == GetPlanEvaluationStatusOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getPlanEvaluationStatusPaginated`
    /// to access the nested member `[ARCRegionswitchClientTypes.ResourceWarning]`
    /// - Returns: `[ARCRegionswitchClientTypes.ResourceWarning]`
    public func warnings() async throws -> [ARCRegionswitchClientTypes.ResourceWarning] {
        return try await self.asyncCompactMap { item in item.warnings }
    }
}
extension ARCRegionswitchClient {
    /// Paginate over `[GetPlanExecutionOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[GetPlanExecutionInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `GetPlanExecutionOutput`
    public func getPlanExecutionPaginated(input: GetPlanExecutionInput) -> ClientRuntime.PaginatorSequence<GetPlanExecutionInput, GetPlanExecutionOutput> {
        return ClientRuntime.PaginatorSequence<GetPlanExecutionInput, GetPlanExecutionOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.getPlanExecution(input:))
    }
}

extension GetPlanExecutionInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> GetPlanExecutionInput {
        return GetPlanExecutionInput(
            executionId: self.executionId,
            maxResults: self.maxResults,
            nextToken: token,
            planArn: self.planArn
        )}
}

extension PaginatorSequence where OperationStackInput == GetPlanExecutionInput, OperationStackOutput == GetPlanExecutionOutput {
    /// This paginator transforms the `AsyncSequence` returned by `getPlanExecutionPaginated`
    /// to access the nested member `[ARCRegionswitchClientTypes.StepState]`
    /// - Returns: `[ARCRegionswitchClientTypes.StepState]`
    public func stepStates() async throws -> [ARCRegionswitchClientTypes.StepState] {
        return try await self.asyncCompactMap { item in item.stepStates }
    }
}
extension ARCRegionswitchClient {
    /// Paginate over `[ListPlanExecutionEventsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPlanExecutionEventsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPlanExecutionEventsOutput`
    public func listPlanExecutionEventsPaginated(input: ListPlanExecutionEventsInput) -> ClientRuntime.PaginatorSequence<ListPlanExecutionEventsInput, ListPlanExecutionEventsOutput> {
        return ClientRuntime.PaginatorSequence<ListPlanExecutionEventsInput, ListPlanExecutionEventsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPlanExecutionEvents(input:))
    }
}

extension ListPlanExecutionEventsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPlanExecutionEventsInput {
        return ListPlanExecutionEventsInput(
            executionId: self.executionId,
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token,
            planArn: self.planArn
        )}
}

extension PaginatorSequence where OperationStackInput == ListPlanExecutionEventsInput, OperationStackOutput == ListPlanExecutionEventsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPlanExecutionEventsPaginated`
    /// to access the nested member `[ARCRegionswitchClientTypes.ExecutionEvent]`
    /// - Returns: `[ARCRegionswitchClientTypes.ExecutionEvent]`
    public func items() async throws -> [ARCRegionswitchClientTypes.ExecutionEvent] {
        return try await self.asyncCompactMap { item in item.items }
    }
}
extension ARCRegionswitchClient {
    /// Paginate over `[ListPlanExecutionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPlanExecutionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPlanExecutionsOutput`
    public func listPlanExecutionsPaginated(input: ListPlanExecutionsInput) -> ClientRuntime.PaginatorSequence<ListPlanExecutionsInput, ListPlanExecutionsOutput> {
        return ClientRuntime.PaginatorSequence<ListPlanExecutionsInput, ListPlanExecutionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPlanExecutions(input:))
    }
}

extension ListPlanExecutionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPlanExecutionsInput {
        return ListPlanExecutionsInput(
            maxResults: self.maxResults,
            nextToken: token,
            planArn: self.planArn,
            state: self.state
        )}
}

extension PaginatorSequence where OperationStackInput == ListPlanExecutionsInput, OperationStackOutput == ListPlanExecutionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPlanExecutionsPaginated`
    /// to access the nested member `[ARCRegionswitchClientTypes.AbbreviatedExecution]`
    /// - Returns: `[ARCRegionswitchClientTypes.AbbreviatedExecution]`
    public func items() async throws -> [ARCRegionswitchClientTypes.AbbreviatedExecution] {
        return try await self.asyncCompactMap { item in item.items }
    }
}
extension ARCRegionswitchClient {
    /// Paginate over `[ListPlansInRegionOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPlansInRegionInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPlansInRegionOutput`
    public func listPlansInRegionPaginated(input: ListPlansInRegionInput) -> ClientRuntime.PaginatorSequence<ListPlansInRegionInput, ListPlansInRegionOutput> {
        return ClientRuntime.PaginatorSequence<ListPlansInRegionInput, ListPlansInRegionOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listPlansInRegion(input:))
    }
}

extension ListPlansInRegionInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPlansInRegionInput {
        return ListPlansInRegionInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListPlansInRegionInput, OperationStackOutput == ListPlansInRegionOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPlansInRegionPaginated`
    /// to access the nested member `[ARCRegionswitchClientTypes.AbbreviatedPlan]`
    /// - Returns: `[ARCRegionswitchClientTypes.AbbreviatedPlan]`
    public func plans() async throws -> [ARCRegionswitchClientTypes.AbbreviatedPlan] {
        return try await self.asyncCompactMap { item in item.plans }
    }
}
extension ARCRegionswitchClient {
    /// Paginate over `[ListRoute53HealthChecksOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRoute53HealthChecksInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRoute53HealthChecksOutput`
    public func listRoute53HealthChecksPaginated(input: ListRoute53HealthChecksInput) -> ClientRuntime.PaginatorSequence<ListRoute53HealthChecksInput, ListRoute53HealthChecksOutput> {
        return ClientRuntime.PaginatorSequence<ListRoute53HealthChecksInput, ListRoute53HealthChecksOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRoute53HealthChecks(input:))
    }
}

extension ListRoute53HealthChecksInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRoute53HealthChecksInput {
        return ListRoute53HealthChecksInput(
            arn: self.arn,
            hostedZoneId: self.hostedZoneId,
            maxResults: self.maxResults,
            nextToken: token,
            recordName: self.recordName
        )}
}

extension PaginatorSequence where OperationStackInput == ListRoute53HealthChecksInput, OperationStackOutput == ListRoute53HealthChecksOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRoute53HealthChecksPaginated`
    /// to access the nested member `[ARCRegionswitchClientTypes.Route53HealthCheck]`
    /// - Returns: `[ARCRegionswitchClientTypes.Route53HealthCheck]`
    public func healthChecks() async throws -> [ARCRegionswitchClientTypes.Route53HealthCheck] {
        return try await self.asyncCompactMap { item in item.healthChecks }
    }
}
