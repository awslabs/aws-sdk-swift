//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ByteStream
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers

extension LexRuntimeClientTypes {
    /// The length of time or number of turns that a context remains active.
    public struct ActiveContextTimeToLive {
        /// The number of seconds that the context should be active after it is first sent in a PostContent or PostText response. You can set the value between 5 and 86,400 seconds (24 hours).
        public var timeToLiveInSeconds: Swift.Int?
        /// The number of conversation turns that the context should be active. A conversation turn is one PostContent or PostText request and the corresponding response from Amazon Lex.
        public var turnsToLive: Swift.Int?

        public init(
            timeToLiveInSeconds: Swift.Int? = nil,
            turnsToLive: Swift.Int? = nil
        )
        {
            self.timeToLiveInSeconds = timeToLiveInSeconds
            self.turnsToLive = turnsToLive
        }
    }

}

extension LexRuntimeClientTypes {
    /// A context is a variable that contains information about the current state of the conversation between a user and Amazon Lex. Context can be set automatically by Amazon Lex when an intent is fulfilled, or it can be set at runtime using the PutContent, PutText, or PutSession operation.
    public struct ActiveContext {
        /// The name of the context.
        /// This member is required.
        public var name: Swift.String?
        /// State variables for the current context. You can use these values as default values for slots in subsequent events.
        /// This member is required.
        public var parameters: [Swift.String: Swift.String]?
        /// The length of time or number of turns that a context remains active.
        /// This member is required.
        public var timeToLive: LexRuntimeClientTypes.ActiveContextTimeToLive?

        public init(
            name: Swift.String? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            timeToLive: LexRuntimeClientTypes.ActiveContextTimeToLive? = nil
        )
        {
            self.name = name
            self.parameters = parameters
            self.timeToLive = timeToLive
        }
    }

}

extension LexRuntimeClientTypes.ActiveContext: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ActiveContext(name: \(Swift.String(describing: name)), timeToLive: \(Swift.String(describing: timeToLive)), parameters: [keys: \(Swift.String(describing: parameters?.keys)), values: \"CONTENT_REDACTED\"])"}
}

/// Request validation failed, there is no usable message in the context, or the bot build failed, is still in progress, or contains unbuilt changes.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Two clients are using the same AWS account, Amazon Lex bot, and user ID.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Internal service error. Retry the call.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Exceeded a limit.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var retryAfterSeconds: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The resource (such as the Amazon Lex bot or an alias) that is referred to is not found.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteSessionInput {
    /// The alias in use for the bot that contains the session data.
    /// This member is required.
    public var botAlias: Swift.String?
    /// The name of the bot that contains the session data.
    /// This member is required.
    public var botName: Swift.String?
    /// The identifier of the user associated with the session data.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        botAlias: Swift.String? = nil,
        botName: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.botAlias = botAlias
        self.botName = botName
        self.userId = userId
    }
}

public struct DeleteSessionOutput {
    /// The alias in use for the bot associated with the session data.
    public var botAlias: Swift.String?
    /// The name of the bot associated with the session data.
    public var botName: Swift.String?
    /// The unique identifier for the session.
    public var sessionId: Swift.String?
    /// The ID of the client application user.
    public var userId: Swift.String?

    public init(
        botAlias: Swift.String? = nil,
        botName: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.botAlias = botAlias
        self.botName = botName
        self.sessionId = sessionId
        self.userId = userId
    }
}

public struct GetSessionInput {
    /// The alias in use for the bot that contains the session data.
    /// This member is required.
    public var botAlias: Swift.String?
    /// The name of the bot that contains the session data.
    /// This member is required.
    public var botName: Swift.String?
    /// A string used to filter the intents returned in the recentIntentSummaryView structure. When you specify a filter, only intents with their checkpointLabel field set to that string are returned.
    public var checkpointLabelFilter: Swift.String?
    /// The ID of the client application user. Amazon Lex uses this to identify a user's conversation with your bot.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        botAlias: Swift.String? = nil,
        botName: Swift.String? = nil,
        checkpointLabelFilter: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.botAlias = botAlias
        self.botName = botName
        self.checkpointLabelFilter = checkpointLabelFilter
        self.userId = userId
    }
}

extension LexRuntimeClientTypes {

    public enum FulfillmentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case fulfilled
        case readyForFulfillment
        case sdkUnknown(Swift.String)

        public static var allCases: [FulfillmentState] {
            return [
                .failed,
                .fulfilled,
                .readyForFulfillment
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .fulfilled: return "Fulfilled"
            case .readyForFulfillment: return "ReadyForFulfillment"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LexRuntimeClientTypes {

    public enum MessageFormatType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case composite
        case customPayload
        case plainText
        case ssml
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageFormatType] {
            return [
                .composite,
                .customPayload,
                .plainText,
                .ssml
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .composite: return "Composite"
            case .customPayload: return "CustomPayload"
            case .plainText: return "PlainText"
            case .ssml: return "SSML"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LexRuntimeClientTypes {

    public enum DialogActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case close
        case confirmIntent
        case delegate
        case elicitIntent
        case elicitSlot
        case sdkUnknown(Swift.String)

        public static var allCases: [DialogActionType] {
            return [
                .close,
                .confirmIntent,
                .delegate,
                .elicitIntent,
                .elicitSlot
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .close: return "Close"
            case .confirmIntent: return "ConfirmIntent"
            case .delegate: return "Delegate"
            case .elicitIntent: return "ElicitIntent"
            case .elicitSlot: return "ElicitSlot"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LexRuntimeClientTypes {
    /// Describes the next action that the bot should take in its interaction with the user and provides information about the context in which the action takes place. Use the DialogAction data type to set the interaction to a specific state, or to return the interaction to a previous state.
    public struct DialogAction {
        /// The fulfillment state of the intent. The possible values are:
        ///
        /// * Failed - The Lambda function associated with the intent failed to fulfill the intent.
        ///
        /// * Fulfilled - The intent has fulfilled by the Lambda function associated with the intent.
        ///
        /// * ReadyForFulfillment - All of the information necessary for the intent is present and the intent ready to be fulfilled by the client application.
        public var fulfillmentState: LexRuntimeClientTypes.FulfillmentState?
        /// The name of the intent.
        public var intentName: Swift.String?
        /// The message that should be shown to the user. If you don't specify a message, Amazon Lex will use the message configured for the intent.
        public var message: Swift.String?
        /// * PlainText - The message contains plain UTF-8 text.
        ///
        /// * CustomPayload - The message is a custom format for the client.
        ///
        /// * SSML - The message contains text formatted for voice output.
        ///
        /// * Composite - The message contains an escaped JSON object containing one or more messages. For more information, see [Message Groups](https://docs.aws.amazon.com/lex/latest/dg/howitworks-manage-prompts.html).
        public var messageFormat: LexRuntimeClientTypes.MessageFormatType?
        /// The name of the slot that should be elicited from the user.
        public var slotToElicit: Swift.String?
        /// Map of the slots that have been gathered and their values.
        public var slots: [Swift.String: Swift.String]?
        /// The next action that the bot should take in its interaction with the user. The possible values are:
        ///
        /// * ConfirmIntent - The next action is asking the user if the intent is complete and ready to be fulfilled. This is a yes/no question such as "Place the order?"
        ///
        /// * Close - Indicates that the there will not be a response from the user. For example, the statement "Your order has been placed" does not require a response.
        ///
        /// * Delegate - The next action is determined by Amazon Lex.
        ///
        /// * ElicitIntent - The next action is to determine the intent that the user wants to fulfill.
        ///
        /// * ElicitSlot - The next action is to elicit a slot value from the user.
        /// This member is required.
        public var type: LexRuntimeClientTypes.DialogActionType?

        public init(
            fulfillmentState: LexRuntimeClientTypes.FulfillmentState? = nil,
            intentName: Swift.String? = nil,
            message: Swift.String? = nil,
            messageFormat: LexRuntimeClientTypes.MessageFormatType? = nil,
            slotToElicit: Swift.String? = nil,
            slots: [Swift.String: Swift.String]? = nil,
            type: LexRuntimeClientTypes.DialogActionType? = nil
        )
        {
            self.fulfillmentState = fulfillmentState
            self.intentName = intentName
            self.message = message
            self.messageFormat = messageFormat
            self.slotToElicit = slotToElicit
            self.slots = slots
            self.type = type
        }
    }

}

extension LexRuntimeClientTypes.DialogAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DialogAction(fulfillmentState: \(Swift.String(describing: fulfillmentState)), intentName: \(Swift.String(describing: intentName)), messageFormat: \(Swift.String(describing: messageFormat)), slotToElicit: \(Swift.String(describing: slotToElicit)), type: \(Swift.String(describing: type)), message: \"CONTENT_REDACTED\", slots: \"CONTENT_REDACTED\")"}
}

extension LexRuntimeClientTypes {

    public enum ConfirmationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case confirmed
        case denied
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfirmationStatus] {
            return [
                .confirmed,
                .denied,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .confirmed: return "Confirmed"
            case .denied: return "Denied"
            case .none: return "None"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LexRuntimeClientTypes {
    /// Provides information about the state of an intent. You can use this information to get the current state of an intent so that you can process the intent, or so that you can return the intent to its previous state.
    public struct IntentSummary {
        /// A user-defined label that identifies a particular intent. You can use this label to return to a previous intent. Use the checkpointLabelFilter parameter of the GetSessionRequest operation to filter the intents returned by the operation to those with only the specified label.
        public var checkpointLabel: Swift.String?
        /// The status of the intent after the user responds to the confirmation prompt. If the user confirms the intent, Amazon Lex sets this field to Confirmed. If the user denies the intent, Amazon Lex sets this value to Denied. The possible values are:
        ///
        /// * Confirmed - The user has responded "Yes" to the confirmation prompt, confirming that the intent is complete and that it is ready to be fulfilled.
        ///
        /// * Denied - The user has responded "No" to the confirmation prompt.
        ///
        /// * None - The user has never been prompted for confirmation; or, the user was prompted but did not confirm or deny the prompt.
        public var confirmationStatus: LexRuntimeClientTypes.ConfirmationStatus?
        /// The next action that the bot should take in its interaction with the user. The possible values are:
        ///
        /// * ConfirmIntent - The next action is asking the user if the intent is complete and ready to be fulfilled. This is a yes/no question such as "Place the order?"
        ///
        /// * Close - Indicates that the there will not be a response from the user. For example, the statement "Your order has been placed" does not require a response.
        ///
        /// * ElicitIntent - The next action is to determine the intent that the user wants to fulfill.
        ///
        /// * ElicitSlot - The next action is to elicit a slot value from the user.
        /// This member is required.
        public var dialogActionType: LexRuntimeClientTypes.DialogActionType?
        /// The fulfillment state of the intent. The possible values are:
        ///
        /// * Failed - The Lambda function associated with the intent failed to fulfill the intent.
        ///
        /// * Fulfilled - The intent has fulfilled by the Lambda function associated with the intent.
        ///
        /// * ReadyForFulfillment - All of the information necessary for the intent is present and the intent ready to be fulfilled by the client application.
        public var fulfillmentState: LexRuntimeClientTypes.FulfillmentState?
        /// The name of the intent.
        public var intentName: Swift.String?
        /// The next slot to elicit from the user. If there is not slot to elicit, the field is blank.
        public var slotToElicit: Swift.String?
        /// Map of the slots that have been gathered and their values.
        public var slots: [Swift.String: Swift.String]?

        public init(
            checkpointLabel: Swift.String? = nil,
            confirmationStatus: LexRuntimeClientTypes.ConfirmationStatus? = nil,
            dialogActionType: LexRuntimeClientTypes.DialogActionType? = nil,
            fulfillmentState: LexRuntimeClientTypes.FulfillmentState? = nil,
            intentName: Swift.String? = nil,
            slotToElicit: Swift.String? = nil,
            slots: [Swift.String: Swift.String]? = nil
        )
        {
            self.checkpointLabel = checkpointLabel
            self.confirmationStatus = confirmationStatus
            self.dialogActionType = dialogActionType
            self.fulfillmentState = fulfillmentState
            self.intentName = intentName
            self.slotToElicit = slotToElicit
            self.slots = slots
        }
    }

}

extension LexRuntimeClientTypes.IntentSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IntentSummary(checkpointLabel: \(Swift.String(describing: checkpointLabel)), confirmationStatus: \(Swift.String(describing: confirmationStatus)), dialogActionType: \(Swift.String(describing: dialogActionType)), fulfillmentState: \(Swift.String(describing: fulfillmentState)), intentName: \(Swift.String(describing: intentName)), slotToElicit: \(Swift.String(describing: slotToElicit)), slots: \"CONTENT_REDACTED\")"}
}

public struct GetSessionOutput {
    /// A list of active contexts for the session. A context can be set when an intent is fulfilled or by calling the PostContent, PostText, or PutSession operation. You can use a context to control the intents that can follow up an intent, or to modify the operation of your application.
    public var activeContexts: [LexRuntimeClientTypes.ActiveContext]?
    /// Describes the current state of the bot.
    public var dialogAction: LexRuntimeClientTypes.DialogAction?
    /// An array of information about the intents used in the session. The array can contain a maximum of three summaries. If more than three intents are used in the session, the recentIntentSummaryView operation contains information about the last three intents used. If you set the checkpointLabelFilter parameter in the request, the array contains only the intents with the specified label.
    public var recentIntentSummaryView: [LexRuntimeClientTypes.IntentSummary]?
    /// Map of key/value pairs representing the session-specific context information. It contains application information passed between Amazon Lex and a client application.
    public var sessionAttributes: [Swift.String: Swift.String]?
    /// A unique identifier for the session.
    public var sessionId: Swift.String?

    public init(
        activeContexts: [LexRuntimeClientTypes.ActiveContext]? = nil,
        dialogAction: LexRuntimeClientTypes.DialogAction? = nil,
        recentIntentSummaryView: [LexRuntimeClientTypes.IntentSummary]? = nil,
        sessionAttributes: [Swift.String: Swift.String]? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.activeContexts = activeContexts
        self.dialogAction = dialogAction
        self.recentIntentSummaryView = recentIntentSummaryView
        self.sessionAttributes = sessionAttributes
        self.sessionId = sessionId
    }
}

extension GetSessionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSessionOutput(dialogAction: \(Swift.String(describing: dialogAction)), recentIntentSummaryView: \(Swift.String(describing: recentIntentSummaryView)), sessionId: \(Swift.String(describing: sessionId)), activeContexts: \"CONTENT_REDACTED\", sessionAttributes: \"CONTENT_REDACTED\")"}
}

/// Either the Amazon Lex bot is still building, or one of the dependent services (Amazon Polly, AWS Lambda) failed with an internal service error.
public struct BadGatewayException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadGatewayException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// One of the dependencies, such as AWS Lambda or Amazon Polly, threw an exception. For example,
///
/// * If Amazon Lex does not have sufficient permissions to call a Lambda function.
///
/// * If a Lambda function takes longer than 30 seconds to execute.
///
/// * If a fulfillment Lambda function returns a Delegate dialog action without removing any slot values.
public struct DependencyFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependencyFailedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This exception is not used.
public struct LoopDetectedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LoopDetectedException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The accept header in the request does not have a valid value.
public struct NotAcceptableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotAcceptableException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The input speech is too long.
public struct RequestTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestTimeoutException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The Content-Type header (PostContent API) has an invalid value.
public struct UnsupportedMediaTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedMediaTypeException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct PostContentInput {
    /// You pass this value as the Accept HTTP header. The message Amazon Lex returns in the response can be either text or speech based on the Accept HTTP header value in the request.
    ///
    /// * If the value is text/plain; charset=utf-8, Amazon Lex returns text in the response.
    ///
    /// * If the value begins with audio/, Amazon Lex returns speech in the response. Amazon Lex uses Amazon Polly to generate the speech (using the configuration you specified in the Accept header). For example, if you specify audio/mpeg as the value, Amazon Lex returns speech in the MPEG format.
    ///
    /// * If the value is audio/pcm, the speech returned is audio/pcm in 16-bit, little endian format.
    ///
    /// * The following are the accepted values:
    ///
    /// * audio/mpeg
    ///
    /// * audio/ogg
    ///
    /// * audio/pcm
    ///
    /// * text/plain; charset=utf-8
    ///
    /// * audio/* (defaults to mpeg)
    public var accept: Swift.String?
    /// A list of contexts active for the request. A context can be activated when a previous intent is fulfilled, or by including the context in the request, If you don't specify a list of contexts, Amazon Lex will use the current list of contexts for the session. If you specify an empty list, all contexts for the session are cleared.
    public var activeContexts: Swift.String?
    /// Alias of the Amazon Lex bot.
    /// This member is required.
    public var botAlias: Swift.String?
    /// Name of the Amazon Lex bot.
    /// This member is required.
    public var botName: Swift.String?
    /// You pass this value as the Content-Type HTTP header. Indicates the audio format or text. The header value must start with one of the following prefixes:
    ///
    /// * PCM format, audio data must be in little-endian byte order.
    ///
    /// * audio/l16; rate=16000; channels=1
    ///
    /// * audio/x-l16; sample-rate=16000; channel-count=1
    ///
    /// * audio/lpcm; sample-rate=8000; sample-size-bits=16; channel-count=1; is-big-endian=false
    ///
    ///
    ///
    ///
    /// * Opus format
    ///
    /// * audio/x-cbr-opus-with-preamble; preamble-size=0; bit-rate=256000; frame-size-milliseconds=4
    ///
    ///
    ///
    ///
    /// * Text format
    ///
    /// * text/plain; charset=utf-8
    /// This member is required.
    public var contentType: Swift.String?
    /// User input in PCM or Opus audio format or text format as described in the Content-Type HTTP header. You can stream audio data to Amazon Lex or you can create a local buffer that captures all of the audio data before sending. In general, you get better performance if you stream audio data rather than buffering the data locally.
    /// This member is required.
    public var inputStream: Smithy.ByteStream?
    /// You pass this value as the x-amz-lex-request-attributes HTTP header. Request-specific information passed between Amazon Lex and a client application. The value must be a JSON serialized and base64 encoded map with string keys and values. The total size of the requestAttributes and sessionAttributes headers is limited to 12 KB. The namespace x-amz-lex: is reserved for special attributes. Don't create any request attributes with the prefix x-amz-lex:. For more information, see [Setting Request Attributes](https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-request-attribs).
    public var requestAttributes: Swift.String?
    /// You pass this value as the x-amz-lex-session-attributes HTTP header. Application-specific information passed between Amazon Lex and a client application. The value must be a JSON serialized and base64 encoded map with string keys and values. The total size of the sessionAttributes and requestAttributes headers is limited to 12 KB. For more information, see [Setting Session Attributes](https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-session-attribs).
    public var sessionAttributes: Swift.String?
    /// The ID of the client application user. Amazon Lex uses this to identify a user's conversation with your bot. At runtime, each request must contain the userID field. To decide the user ID to use for your application, consider the following factors.
    ///
    /// * The userID field must not contain any personally identifiable information of the user, for example, name, personal identification numbers, or other end user personal information.
    ///
    /// * If you want a user to start a conversation on one device and continue on another device, use a user-specific identifier.
    ///
    /// * If you want the same user to be able to have two independent conversations on two different devices, choose a device-specific identifier.
    ///
    /// * A user can't have two independent conversations with two different versions of the same bot. For example, a user can't have a conversation with the PROD and BETA versions of the same bot. If you anticipate that a user will need to have conversation with two different versions, for example, while testing, include the bot alias in the user ID to separate the two conversations.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        accept: Swift.String? = nil,
        activeContexts: Swift.String? = nil,
        botAlias: Swift.String? = nil,
        botName: Swift.String? = nil,
        contentType: Swift.String? = nil,
        inputStream: Smithy.ByteStream? = nil,
        requestAttributes: Swift.String? = nil,
        sessionAttributes: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accept = accept
        self.activeContexts = activeContexts
        self.botAlias = botAlias
        self.botName = botName
        self.contentType = contentType
        self.inputStream = inputStream
        self.requestAttributes = requestAttributes
        self.sessionAttributes = sessionAttributes
        self.userId = userId
    }
}

extension PostContentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PostContentInput(accept: \(Swift.String(describing: accept)), botAlias: \(Swift.String(describing: botAlias)), botName: \(Swift.String(describing: botName)), contentType: \(Swift.String(describing: contentType)), inputStream: \(Swift.String(describing: inputStream)), userId: \(Swift.String(describing: userId)), activeContexts: \"CONTENT_REDACTED\", requestAttributes: \"CONTENT_REDACTED\", sessionAttributes: \"CONTENT_REDACTED\")"}
}

extension LexRuntimeClientTypes {

    public enum DialogState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case confirmIntent
        case elicitIntent
        case elicitSlot
        case failed
        case fulfilled
        case readyForFulfillment
        case sdkUnknown(Swift.String)

        public static var allCases: [DialogState] {
            return [
                .confirmIntent,
                .elicitIntent,
                .elicitSlot,
                .failed,
                .fulfilled,
                .readyForFulfillment
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .confirmIntent: return "ConfirmIntent"
            case .elicitIntent: return "ElicitIntent"
            case .elicitSlot: return "ElicitSlot"
            case .failed: return "Failed"
            case .fulfilled: return "Fulfilled"
            case .readyForFulfillment: return "ReadyForFulfillment"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct PostContentOutput {
    /// A list of active contexts for the session. A context can be set when an intent is fulfilled or by calling the PostContent, PostText, or PutSession operation. You can use a context to control the intents that can follow up an intent, or to modify the operation of your application.
    public var activeContexts: Swift.String?
    /// One to four alternative intents that may be applicable to the user's intent. Each alternative includes a score that indicates how confident Amazon Lex is that the intent matches the user's intent. The intents are sorted by the confidence score.
    public var alternativeIntents: Swift.String?
    /// The prompt (or statement) to convey to the user. This is based on the bot configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the clarificationPrompt configured for the bot. If the intent requires confirmation before taking the fulfillment action, it sends the confirmationPrompt. Another example: Suppose that the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. Then Amazon Lex sends that message in the response.
    public var audioStream: Smithy.ByteStream?
    /// The version of the bot that responded to the conversation. You can use this information to help determine if one version of a bot is performing better than another version.
    public var botVersion: Swift.String?
    /// Content type as specified in the Accept HTTP header in the request.
    public var contentType: Swift.String?
    /// Identifies the current state of the user interaction. Amazon Lex returns one of the following values as dialogState. The client can optionally use this information to customize the user interface.
    ///
    /// * ElicitIntent - Amazon Lex wants to elicit the user's intent. Consider the following examples: For example, a user might utter an intent ("I want to order a pizza"). If Amazon Lex cannot infer the user intent from this utterance, it will return this dialog state.
    ///
    /// * ConfirmIntent - Amazon Lex is expecting a "yes" or "no" response. For example, Amazon Lex wants user confirmation before fulfilling an intent. Instead of a simple "yes" or "no" response, a user might respond with additional information. For example, "yes, but make it a thick crust pizza" or "no, I want to order a drink." Amazon Lex can process such additional information (in these examples, update the crust type slot or change the intent from OrderPizza to OrderDrink).
    ///
    /// * ElicitSlot - Amazon Lex is expecting the value of a slot for the current intent. For example, suppose that in the response Amazon Lex sends this message: "What size pizza would you like?". A user might reply with the slot value (e.g., "medium"). The user might also provide additional information in the response (e.g., "medium thick crust pizza"). Amazon Lex can process such additional information appropriately.
    ///
    /// * Fulfilled - Conveys that the Lambda function has successfully fulfilled the intent.
    ///
    /// * ReadyForFulfillment - Conveys that the client has to fulfill the request.
    ///
    /// * Failed - Conveys that the conversation with the user failed. This can happen for various reasons, including that the user does not provide an appropriate response to prompts from the service (you can configure how many times Amazon Lex can prompt a user for specific information), or if the Lambda function fails to fulfill the intent.
    public var dialogState: LexRuntimeClientTypes.DialogState?
    /// The text used to process the request. If the input was an audio stream, the encodedInputTranscript field contains the text extracted from the audio stream. This is the text that is actually processed to recognize intents and slot values. You can use this information to determine if Amazon Lex is correctly processing the audio that you send. The encodedInputTranscript field is base-64 encoded. You must decode the field before you can use the value.
    public var encodedInputTranscript: Swift.String?
    /// The message to convey to the user. The message can come from the bot's configuration or from a Lambda function. If the intent is not configured with a Lambda function, or if the Lambda function returned Delegate as the dialogAction.type in its response, Amazon Lex decides on the next course of action and selects an appropriate message from the bot's configuration based on the current interaction context. For example, if Amazon Lex isn't able to understand user input, it uses a clarification prompt message. When you create an intent you can assign messages to groups. When messages are assigned to groups Amazon Lex returns one message from each group in the response. The message field is an escaped JSON string containing the messages. For more information about the structure of the JSON string returned, see [msg-prompts-formats]. If the Lambda function returns a message, Amazon Lex passes it to the client in its response. The encodedMessage field is base-64 encoded. You must decode the field before you can use the value.
    public var encodedMessage: Swift.String?
    /// The text used to process the request. You can use this field only in the de-DE, en-AU, en-GB, en-US, es-419, es-ES, es-US, fr-CA, fr-FR, and it-IT locales. In all other locales, the inputTranscript field is null. You should use the encodedInputTranscript field instead. If the input was an audio stream, the inputTranscript field contains the text extracted from the audio stream. This is the text that is actually processed to recognize intents and slot values. You can use this information to determine if Amazon Lex is correctly processing the audio that you send.
    @available(*, deprecated, message: "The inputTranscript field is deprecated, use the encodedInputTranscript field instead. The inputTranscript field is available only in the de-DE, en-AU, en-GB, en-US, es-419, es-ES, es-US, fr-CA, fr-FR and it-IT locales.")
    public var inputTranscript: Swift.String?
    /// Current user intent that Amazon Lex is aware of.
    public var intentName: Swift.String?
    /// You can only use this field in the de-DE, en-AU, en-GB, en-US, es-419, es-ES, es-US, fr-CA, fr-FR, and it-IT locales. In all other locales, the message field is null. You should use the encodedMessage field instead. The message to convey to the user. The message can come from the bot's configuration or from a Lambda function. If the intent is not configured with a Lambda function, or if the Lambda function returned Delegate as the dialogAction.type in its response, Amazon Lex decides on the next course of action and selects an appropriate message from the bot's configuration based on the current interaction context. For example, if Amazon Lex isn't able to understand user input, it uses a clarification prompt message. When you create an intent you can assign messages to groups. When messages are assigned to groups Amazon Lex returns one message from each group in the response. The message field is an escaped JSON string containing the messages. For more information about the structure of the JSON string returned, see [msg-prompts-formats]. If the Lambda function returns a message, Amazon Lex passes it to the client in its response.
    @available(*, deprecated, message: "The message field is deprecated, use the encodedMessage field instead. The message field is available only in the de-DE, en-AU, en-GB, en-US, es-419, es-ES, es-US, fr-CA, fr-FR and it-IT locales.")
    public var message: Swift.String?
    /// The format of the response message. One of the following values:
    ///
    /// * PlainText - The message contains plain UTF-8 text.
    ///
    /// * CustomPayload - The message is a custom format for the client.
    ///
    /// * SSML - The message contains text formatted for voice output.
    ///
    /// * Composite - The message contains an escaped JSON object containing one or more messages from the groups that messages were assigned to when the intent was created.
    public var messageFormat: LexRuntimeClientTypes.MessageFormatType?
    /// Provides a score that indicates how confident Amazon Lex is that the returned intent is the one that matches the user's intent. The score is between 0.0 and 1.0. The score is a relative score, not an absolute score. The score may change based on improvements to Amazon Lex.
    public var nluIntentConfidence: Swift.String?
    /// The sentiment expressed in an utterance. When the bot is configured to send utterances to Amazon Comprehend for sentiment analysis, this field contains the result of the analysis.
    public var sentimentResponse: Swift.String?
    /// Map of key/value pairs representing the session-specific context information.
    public var sessionAttributes: Swift.String?
    /// The unique identifier for the session.
    public var sessionId: Swift.String?
    /// If the dialogState value is ElicitSlot, returns the name of the slot for which Amazon Lex is eliciting a value.
    public var slotToElicit: Swift.String?
    /// Map of zero or more intent slots (name/value pairs) Amazon Lex detected from the user input during the conversation. The field is base-64 encoded. Amazon Lex creates a resolution list containing likely values for a slot. The value that it returns is determined by the valueSelectionStrategy selected when the slot type was created or updated. If valueSelectionStrategy is set to ORIGINAL_VALUE, the value provided by the user is returned, if the user value is similar to the slot values. If valueSelectionStrategy is set to TOP_RESOLUTION Amazon Lex returns the first value in the resolution list or, if there is no resolution list, null. If you don't specify a valueSelectionStrategy, the default is ORIGINAL_VALUE.
    public var slots: Swift.String?

    public init(
        activeContexts: Swift.String? = nil,
        alternativeIntents: Swift.String? = nil,
        audioStream: Smithy.ByteStream? = Smithy.ByteStream.data(Foundation.Data("".utf8)),
        botVersion: Swift.String? = nil,
        contentType: Swift.String? = nil,
        dialogState: LexRuntimeClientTypes.DialogState? = nil,
        encodedInputTranscript: Swift.String? = nil,
        encodedMessage: Swift.String? = nil,
        inputTranscript: Swift.String? = nil,
        intentName: Swift.String? = nil,
        message: Swift.String? = nil,
        messageFormat: LexRuntimeClientTypes.MessageFormatType? = nil,
        nluIntentConfidence: Swift.String? = nil,
        sentimentResponse: Swift.String? = nil,
        sessionAttributes: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        slotToElicit: Swift.String? = nil,
        slots: Swift.String? = nil
    )
    {
        self.activeContexts = activeContexts
        self.alternativeIntents = alternativeIntents
        self.audioStream = audioStream
        self.botVersion = botVersion
        self.contentType = contentType
        self.dialogState = dialogState
        self.encodedInputTranscript = encodedInputTranscript
        self.encodedMessage = encodedMessage
        self.inputTranscript = inputTranscript
        self.intentName = intentName
        self.message = message
        self.messageFormat = messageFormat
        self.nluIntentConfidence = nluIntentConfidence
        self.sentimentResponse = sentimentResponse
        self.sessionAttributes = sessionAttributes
        self.sessionId = sessionId
        self.slotToElicit = slotToElicit
        self.slots = slots
    }
}

extension PostContentOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PostContentOutput(alternativeIntents: \(Swift.String(describing: alternativeIntents)), audioStream: \(Swift.String(describing: audioStream)), botVersion: \(Swift.String(describing: botVersion)), contentType: \(Swift.String(describing: contentType)), dialogState: \(Swift.String(describing: dialogState)), inputTranscript: \(Swift.String(describing: inputTranscript)), intentName: \(Swift.String(describing: intentName)), messageFormat: \(Swift.String(describing: messageFormat)), nluIntentConfidence: \(Swift.String(describing: nluIntentConfidence)), sentimentResponse: \(Swift.String(describing: sentimentResponse)), sessionAttributes: \(Swift.String(describing: sessionAttributes)), sessionId: \(Swift.String(describing: sessionId)), slotToElicit: \(Swift.String(describing: slotToElicit)), slots: \(Swift.String(describing: slots)), activeContexts: \"CONTENT_REDACTED\", encodedInputTranscript: \"CONTENT_REDACTED\", encodedMessage: \"CONTENT_REDACTED\", message: \"CONTENT_REDACTED\")"}
}

public struct PostTextInput {
    /// A list of contexts active for the request. A context can be activated when a previous intent is fulfilled, or by including the context in the request, If you don't specify a list of contexts, Amazon Lex will use the current list of contexts for the session. If you specify an empty list, all contexts for the session are cleared.
    public var activeContexts: [LexRuntimeClientTypes.ActiveContext]?
    /// The alias of the Amazon Lex bot.
    /// This member is required.
    public var botAlias: Swift.String?
    /// The name of the Amazon Lex bot.
    /// This member is required.
    public var botName: Swift.String?
    /// The text that the user entered (Amazon Lex interprets this text).
    /// This member is required.
    public var inputText: Swift.String?
    /// Request-specific information passed between Amazon Lex and a client application. The namespace x-amz-lex: is reserved for special attributes. Don't create any request attributes with the prefix x-amz-lex:. For more information, see [Setting Request Attributes](https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-request-attribs).
    public var requestAttributes: [Swift.String: Swift.String]?
    /// Application-specific information passed between Amazon Lex and a client application. For more information, see [Setting Session Attributes](https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-session-attribs).
    public var sessionAttributes: [Swift.String: Swift.String]?
    /// The ID of the client application user. Amazon Lex uses this to identify a user's conversation with your bot. At runtime, each request must contain the userID field. To decide the user ID to use for your application, consider the following factors.
    ///
    /// * The userID field must not contain any personally identifiable information of the user, for example, name, personal identification numbers, or other end user personal information.
    ///
    /// * If you want a user to start a conversation on one device and continue on another device, use a user-specific identifier.
    ///
    /// * If you want the same user to be able to have two independent conversations on two different devices, choose a device-specific identifier.
    ///
    /// * A user can't have two independent conversations with two different versions of the same bot. For example, a user can't have a conversation with the PROD and BETA versions of the same bot. If you anticipate that a user will need to have conversation with two different versions, for example, while testing, include the bot alias in the user ID to separate the two conversations.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        activeContexts: [LexRuntimeClientTypes.ActiveContext]? = nil,
        botAlias: Swift.String? = nil,
        botName: Swift.String? = nil,
        inputText: Swift.String? = nil,
        requestAttributes: [Swift.String: Swift.String]? = nil,
        sessionAttributes: [Swift.String: Swift.String]? = nil,
        userId: Swift.String? = nil
    )
    {
        self.activeContexts = activeContexts
        self.botAlias = botAlias
        self.botName = botName
        self.inputText = inputText
        self.requestAttributes = requestAttributes
        self.sessionAttributes = sessionAttributes
        self.userId = userId
    }
}

extension PostTextInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PostTextInput(botAlias: \(Swift.String(describing: botAlias)), botName: \(Swift.String(describing: botName)), userId: \(Swift.String(describing: userId)), activeContexts: \"CONTENT_REDACTED\", inputText: \"CONTENT_REDACTED\", requestAttributes: \"CONTENT_REDACTED\", sessionAttributes: \"CONTENT_REDACTED\")"}
}

extension LexRuntimeClientTypes {
    /// Provides a score that indicates the confidence that Amazon Lex has that an intent is the one that satisfies the user's intent.
    public struct IntentConfidence {
        /// A score that indicates how confident Amazon Lex is that an intent satisfies the user's intent. Ranges between 0.00 and 1.00. Higher scores indicate higher confidence.
        public var score: Swift.Double

        public init(
            score: Swift.Double = 0.0
        )
        {
            self.score = score
        }
    }

}

extension LexRuntimeClientTypes {
    /// An intent that Amazon Lex suggests satisfies the user's intent. Includes the name of the intent, the confidence that Amazon Lex has that the user's intent is satisfied, and the slots defined for the intent.
    public struct PredictedIntent {
        /// The name of the intent that Amazon Lex suggests satisfies the user's intent.
        public var intentName: Swift.String?
        /// Indicates how confident Amazon Lex is that an intent satisfies the user's intent.
        public var nluIntentConfidence: LexRuntimeClientTypes.IntentConfidence?
        /// The slot and slot values associated with the predicted intent.
        public var slots: [Swift.String: Swift.String]?

        public init(
            intentName: Swift.String? = nil,
            nluIntentConfidence: LexRuntimeClientTypes.IntentConfidence? = nil,
            slots: [Swift.String: Swift.String]? = nil
        )
        {
            self.intentName = intentName
            self.nluIntentConfidence = nluIntentConfidence
            self.slots = slots
        }
    }

}

extension LexRuntimeClientTypes.PredictedIntent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PredictedIntent(intentName: \(Swift.String(describing: intentName)), nluIntentConfidence: \(Swift.String(describing: nluIntentConfidence)), slots: \"CONTENT_REDACTED\")"}
}

extension LexRuntimeClientTypes {

    public enum ContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case generic
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentType] {
            return [
                .generic
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .generic: return "application/vnd.amazonaws.card.generic"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension LexRuntimeClientTypes {
    /// Represents an option to be shown on the client platform (Facebook, Slack, etc.)
    public struct Button {
        /// Text that is visible to the user on the button.
        /// This member is required.
        public var text: Swift.String?
        /// The value sent to Amazon Lex when a user chooses the button. For example, consider button text "NYC." When the user chooses the button, the value sent can be "New York City."
        /// This member is required.
        public var value: Swift.String?

        public init(
            text: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.text = text
            self.value = value
        }
    }

}

extension LexRuntimeClientTypes {
    /// Represents an option rendered to the user when a prompt is shown. It could be an image, a button, a link, or text.
    public struct GenericAttachment {
        /// The URL of an attachment to the response card.
        public var attachmentLinkUrl: Swift.String?
        /// The list of options to show to the user.
        public var buttons: [LexRuntimeClientTypes.Button]?
        /// The URL of an image that is displayed to the user.
        public var imageUrl: Swift.String?
        /// The subtitle shown below the title.
        public var subTitle: Swift.String?
        /// The title of the option.
        public var title: Swift.String?

        public init(
            attachmentLinkUrl: Swift.String? = nil,
            buttons: [LexRuntimeClientTypes.Button]? = nil,
            imageUrl: Swift.String? = nil,
            subTitle: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.attachmentLinkUrl = attachmentLinkUrl
            self.buttons = buttons
            self.imageUrl = imageUrl
            self.subTitle = subTitle
            self.title = title
        }
    }

}

extension LexRuntimeClientTypes {
    /// If you configure a response card when creating your bots, Amazon Lex substitutes the session attributes and slot values that are available, and then returns it. The response card can also come from a Lambda function ( dialogCodeHook and fulfillmentActivity on an intent).
    public struct ResponseCard {
        /// The content type of the response.
        public var contentType: LexRuntimeClientTypes.ContentType?
        /// An array of attachment objects representing options.
        public var genericAttachments: [LexRuntimeClientTypes.GenericAttachment]?
        /// The version of the response card format.
        public var version: Swift.String?

        public init(
            contentType: LexRuntimeClientTypes.ContentType? = nil,
            genericAttachments: [LexRuntimeClientTypes.GenericAttachment]? = nil,
            version: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.genericAttachments = genericAttachments
            self.version = version
        }
    }

}

extension LexRuntimeClientTypes {
    /// The sentiment expressed in an utterance. When the bot is configured to send utterances to Amazon Comprehend for sentiment analysis, this field structure contains the result of the analysis.
    public struct SentimentResponse {
        /// The inferred sentiment that Amazon Comprehend has the highest confidence in.
        public var sentimentLabel: Swift.String?
        /// The likelihood that the sentiment was correctly inferred.
        public var sentimentScore: Swift.String?

        public init(
            sentimentLabel: Swift.String? = nil,
            sentimentScore: Swift.String? = nil
        )
        {
            self.sentimentLabel = sentimentLabel
            self.sentimentScore = sentimentScore
        }
    }

}

public struct PostTextOutput {
    /// A list of active contexts for the session. A context can be set when an intent is fulfilled or by calling the PostContent, PostText, or PutSession operation. You can use a context to control the intents that can follow up an intent, or to modify the operation of your application.
    public var activeContexts: [LexRuntimeClientTypes.ActiveContext]?
    /// One to four alternative intents that may be applicable to the user's intent. Each alternative includes a score that indicates how confident Amazon Lex is that the intent matches the user's intent. The intents are sorted by the confidence score.
    public var alternativeIntents: [LexRuntimeClientTypes.PredictedIntent]?
    /// The version of the bot that responded to the conversation. You can use this information to help determine if one version of a bot is performing better than another version.
    public var botVersion: Swift.String?
    /// Identifies the current state of the user interaction. Amazon Lex returns one of the following values as dialogState. The client can optionally use this information to customize the user interface.
    ///
    /// * ElicitIntent - Amazon Lex wants to elicit user intent. For example, a user might utter an intent ("I want to order a pizza"). If Amazon Lex cannot infer the user intent from this utterance, it will return this dialogState.
    ///
    /// * ConfirmIntent - Amazon Lex is expecting a "yes" or "no" response. For example, Amazon Lex wants user confirmation before fulfilling an intent. Instead of a simple "yes" or "no," a user might respond with additional information. For example, "yes, but make it thick crust pizza" or "no, I want to order a drink". Amazon Lex can process such additional information (in these examples, update the crust type slot value, or change intent from OrderPizza to OrderDrink).
    ///
    /// * ElicitSlot - Amazon Lex is expecting a slot value for the current intent. For example, suppose that in the response Amazon Lex sends this message: "What size pizza would you like?". A user might reply with the slot value (e.g., "medium"). The user might also provide additional information in the response (e.g., "medium thick crust pizza"). Amazon Lex can process such additional information appropriately.
    ///
    /// * Fulfilled - Conveys that the Lambda function configured for the intent has successfully fulfilled the intent.
    ///
    /// * ReadyForFulfillment - Conveys that the client has to fulfill the intent.
    ///
    /// * Failed - Conveys that the conversation with the user failed. This can happen for various reasons including that the user did not provide an appropriate response to prompts from the service (you can configure how many times Amazon Lex can prompt a user for specific information), or the Lambda function failed to fulfill the intent.
    public var dialogState: LexRuntimeClientTypes.DialogState?
    /// The current user intent that Amazon Lex is aware of.
    public var intentName: Swift.String?
    /// The message to convey to the user. The message can come from the bot's configuration or from a Lambda function. If the intent is not configured with a Lambda function, or if the Lambda function returned Delegate as the dialogAction.type its response, Amazon Lex decides on the next course of action and selects an appropriate message from the bot's configuration based on the current interaction context. For example, if Amazon Lex isn't able to understand user input, it uses a clarification prompt message. When you create an intent you can assign messages to groups. When messages are assigned to groups Amazon Lex returns one message from each group in the response. The message field is an escaped JSON string containing the messages. For more information about the structure of the JSON string returned, see [msg-prompts-formats]. If the Lambda function returns a message, Amazon Lex passes it to the client in its response.
    public var message: Swift.String?
    /// The format of the response message. One of the following values:
    ///
    /// * PlainText - The message contains plain UTF-8 text.
    ///
    /// * CustomPayload - The message is a custom format defined by the Lambda function.
    ///
    /// * SSML - The message contains text formatted for voice output.
    ///
    /// * Composite - The message contains an escaped JSON object containing one or more messages from the groups that messages were assigned to when the intent was created.
    public var messageFormat: LexRuntimeClientTypes.MessageFormatType?
    /// Provides a score that indicates how confident Amazon Lex is that the returned intent is the one that matches the user's intent. The score is between 0.0 and 1.0. For more information, see [Confidence Scores](https://docs.aws.amazon.com/lex/latest/dg/confidence-scores.html). The score is a relative score, not an absolute score. The score may change based on improvements to Amazon Lex.
    public var nluIntentConfidence: LexRuntimeClientTypes.IntentConfidence?
    /// Represents the options that the user has to respond to the current prompt. Response Card can come from the bot configuration (in the Amazon Lex console, choose the settings button next to a slot) or from a code hook (Lambda function).
    public var responseCard: LexRuntimeClientTypes.ResponseCard?
    /// The sentiment expressed in and utterance. When the bot is configured to send utterances to Amazon Comprehend for sentiment analysis, this field contains the result of the analysis.
    public var sentimentResponse: LexRuntimeClientTypes.SentimentResponse?
    /// A map of key-value pairs representing the session-specific context information.
    public var sessionAttributes: [Swift.String: Swift.String]?
    /// A unique identifier for the session.
    public var sessionId: Swift.String?
    /// If the dialogState value is ElicitSlot, returns the name of the slot for which Amazon Lex is eliciting a value.
    public var slotToElicit: Swift.String?
    /// The intent slots that Amazon Lex detected from the user input in the conversation. Amazon Lex creates a resolution list containing likely values for a slot. The value that it returns is determined by the valueSelectionStrategy selected when the slot type was created or updated. If valueSelectionStrategy is set to ORIGINAL_VALUE, the value provided by the user is returned, if the user value is similar to the slot values. If valueSelectionStrategy is set to TOP_RESOLUTION Amazon Lex returns the first value in the resolution list or, if there is no resolution list, null. If you don't specify a valueSelectionStrategy, the default is ORIGINAL_VALUE.
    public var slots: [Swift.String: Swift.String]?

    public init(
        activeContexts: [LexRuntimeClientTypes.ActiveContext]? = nil,
        alternativeIntents: [LexRuntimeClientTypes.PredictedIntent]? = nil,
        botVersion: Swift.String? = nil,
        dialogState: LexRuntimeClientTypes.DialogState? = nil,
        intentName: Swift.String? = nil,
        message: Swift.String? = nil,
        messageFormat: LexRuntimeClientTypes.MessageFormatType? = nil,
        nluIntentConfidence: LexRuntimeClientTypes.IntentConfidence? = nil,
        responseCard: LexRuntimeClientTypes.ResponseCard? = nil,
        sentimentResponse: LexRuntimeClientTypes.SentimentResponse? = nil,
        sessionAttributes: [Swift.String: Swift.String]? = nil,
        sessionId: Swift.String? = nil,
        slotToElicit: Swift.String? = nil,
        slots: [Swift.String: Swift.String]? = nil
    )
    {
        self.activeContexts = activeContexts
        self.alternativeIntents = alternativeIntents
        self.botVersion = botVersion
        self.dialogState = dialogState
        self.intentName = intentName
        self.message = message
        self.messageFormat = messageFormat
        self.nluIntentConfidence = nluIntentConfidence
        self.responseCard = responseCard
        self.sentimentResponse = sentimentResponse
        self.sessionAttributes = sessionAttributes
        self.sessionId = sessionId
        self.slotToElicit = slotToElicit
        self.slots = slots
    }
}

extension PostTextOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PostTextOutput(alternativeIntents: \(Swift.String(describing: alternativeIntents)), botVersion: \(Swift.String(describing: botVersion)), dialogState: \(Swift.String(describing: dialogState)), intentName: \(Swift.String(describing: intentName)), messageFormat: \(Swift.String(describing: messageFormat)), nluIntentConfidence: \(Swift.String(describing: nluIntentConfidence)), responseCard: \(Swift.String(describing: responseCard)), sentimentResponse: \(Swift.String(describing: sentimentResponse)), sessionId: \(Swift.String(describing: sessionId)), slotToElicit: \(Swift.String(describing: slotToElicit)), activeContexts: \"CONTENT_REDACTED\", message: \"CONTENT_REDACTED\", sessionAttributes: \"CONTENT_REDACTED\", slots: \"CONTENT_REDACTED\")"}
}

public struct PutSessionInput {
    /// The message that Amazon Lex returns in the response can be either text or speech based depending on the value of this field.
    ///
    /// * If the value is text/plain; charset=utf-8, Amazon Lex returns text in the response.
    ///
    /// * If the value begins with audio/, Amazon Lex returns speech in the response. Amazon Lex uses Amazon Polly to generate the speech in the configuration that you specify. For example, if you specify audio/mpeg as the value, Amazon Lex returns speech in the MPEG format.
    ///
    /// * If the value is audio/pcm, the speech is returned as audio/pcm in 16-bit, little endian format.
    ///
    /// * The following are the accepted values:
    ///
    /// * audio/mpeg
    ///
    /// * audio/ogg
    ///
    /// * audio/pcm
    ///
    /// * audio/* (defaults to mpeg)
    ///
    /// * text/plain; charset=utf-8
    public var accept: Swift.String?
    /// A list of contexts active for the request. A context can be activated when a previous intent is fulfilled, or by including the context in the request, If you don't specify a list of contexts, Amazon Lex will use the current list of contexts for the session. If you specify an empty list, all contexts for the session are cleared.
    public var activeContexts: [LexRuntimeClientTypes.ActiveContext]?
    /// The alias in use for the bot that contains the session data.
    /// This member is required.
    public var botAlias: Swift.String?
    /// The name of the bot that contains the session data.
    /// This member is required.
    public var botName: Swift.String?
    /// Sets the next action that the bot should take to fulfill the conversation.
    public var dialogAction: LexRuntimeClientTypes.DialogAction?
    /// A summary of the recent intents for the bot. You can use the intent summary view to set a checkpoint label on an intent and modify attributes of intents. You can also use it to remove or add intent summary objects to the list. An intent that you modify or add to the list must make sense for the bot. For example, the intent name must be valid for the bot. You must provide valid values for:
    ///
    /// * intentName
    ///
    /// * slot names
    ///
    /// * slotToElict
    ///
    ///
    /// If you send the recentIntentSummaryView parameter in a PutSession request, the contents of the new summary view replaces the old summary view. For example, if a GetSession request returns three intents in the summary view and you call PutSession with one intent in the summary view, the next call to GetSession will only return one intent.
    public var recentIntentSummaryView: [LexRuntimeClientTypes.IntentSummary]?
    /// Map of key/value pairs representing the session-specific context information. It contains application information passed between Amazon Lex and a client application.
    public var sessionAttributes: [Swift.String: Swift.String]?
    /// The ID of the client application user. Amazon Lex uses this to identify a user's conversation with your bot.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        accept: Swift.String? = nil,
        activeContexts: [LexRuntimeClientTypes.ActiveContext]? = nil,
        botAlias: Swift.String? = nil,
        botName: Swift.String? = nil,
        dialogAction: LexRuntimeClientTypes.DialogAction? = nil,
        recentIntentSummaryView: [LexRuntimeClientTypes.IntentSummary]? = nil,
        sessionAttributes: [Swift.String: Swift.String]? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accept = accept
        self.activeContexts = activeContexts
        self.botAlias = botAlias
        self.botName = botName
        self.dialogAction = dialogAction
        self.recentIntentSummaryView = recentIntentSummaryView
        self.sessionAttributes = sessionAttributes
        self.userId = userId
    }
}

extension PutSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSessionInput(accept: \(Swift.String(describing: accept)), botAlias: \(Swift.String(describing: botAlias)), botName: \(Swift.String(describing: botName)), dialogAction: \(Swift.String(describing: dialogAction)), recentIntentSummaryView: \(Swift.String(describing: recentIntentSummaryView)), userId: \(Swift.String(describing: userId)), activeContexts: \"CONTENT_REDACTED\", sessionAttributes: \"CONTENT_REDACTED\")"}
}

public struct PutSessionOutput {
    /// A list of active contexts for the session.
    public var activeContexts: Swift.String?
    /// The audio version of the message to convey to the user.
    public var audioStream: Smithy.ByteStream?
    /// Content type as specified in the Accept HTTP header in the request.
    public var contentType: Swift.String?
    /// * ConfirmIntent - Amazon Lex is expecting a "yes" or "no" response to confirm the intent before fulfilling an intent.
    ///
    /// * ElicitIntent - Amazon Lex wants to elicit the user's intent.
    ///
    /// * ElicitSlot - Amazon Lex is expecting the value of a slot for the current intent.
    ///
    /// * Failed - Conveys that the conversation with the user has failed. This can happen for various reasons, including the user does not provide an appropriate response to prompts from the service, or if the Lambda function fails to fulfill the intent.
    ///
    /// * Fulfilled - Conveys that the Lambda function has sucessfully fulfilled the intent.
    ///
    /// * ReadyForFulfillment - Conveys that the client has to fulfill the intent.
    public var dialogState: LexRuntimeClientTypes.DialogState?
    /// The next message that should be presented to the user. The encodedMessage field is base-64 encoded. You must decode the field before you can use the value.
    public var encodedMessage: Swift.String?
    /// The name of the current intent.
    public var intentName: Swift.String?
    /// The next message that should be presented to the user. You can only use this field in the de-DE, en-AU, en-GB, en-US, es-419, es-ES, es-US, fr-CA, fr-FR, and it-IT locales. In all other locales, the message field is null. You should use the encodedMessage field instead.
    @available(*, deprecated, message: "The message field is deprecated, use the encodedMessage field instead. The message field is available only in the de-DE, en-AU, en-GB, en-US, es-419, es-ES, es-US, fr-CA, fr-FR and it-IT locales.")
    public var message: Swift.String?
    /// The format of the response message. One of the following values:
    ///
    /// * PlainText - The message contains plain UTF-8 text.
    ///
    /// * CustomPayload - The message is a custom format for the client.
    ///
    /// * SSML - The message contains text formatted for voice output.
    ///
    /// * Composite - The message contains an escaped JSON object containing one or more messages from the groups that messages were assigned to when the intent was created.
    public var messageFormat: LexRuntimeClientTypes.MessageFormatType?
    /// Map of key/value pairs representing session-specific context information.
    public var sessionAttributes: Swift.String?
    /// A unique identifier for the session.
    public var sessionId: Swift.String?
    /// If the dialogState is ElicitSlot, returns the name of the slot for which Amazon Lex is eliciting a value.
    public var slotToElicit: Swift.String?
    /// Map of zero or more intent slots Amazon Lex detected from the user input during the conversation. Amazon Lex creates a resolution list containing likely values for a slot. The value that it returns is determined by the valueSelectionStrategy selected when the slot type was created or updated. If valueSelectionStrategy is set to ORIGINAL_VALUE, the value provided by the user is returned, if the user value is similar to the slot values. If valueSelectionStrategy is set to TOP_RESOLUTION Amazon Lex returns the first value in the resolution list or, if there is no resolution list, null. If you don't specify a valueSelectionStrategy the default is ORIGINAL_VALUE.
    public var slots: Swift.String?

    public init(
        activeContexts: Swift.String? = nil,
        audioStream: Smithy.ByteStream? = Smithy.ByteStream.data(Foundation.Data("".utf8)),
        contentType: Swift.String? = nil,
        dialogState: LexRuntimeClientTypes.DialogState? = nil,
        encodedMessage: Swift.String? = nil,
        intentName: Swift.String? = nil,
        message: Swift.String? = nil,
        messageFormat: LexRuntimeClientTypes.MessageFormatType? = nil,
        sessionAttributes: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        slotToElicit: Swift.String? = nil,
        slots: Swift.String? = nil
    )
    {
        self.activeContexts = activeContexts
        self.audioStream = audioStream
        self.contentType = contentType
        self.dialogState = dialogState
        self.encodedMessage = encodedMessage
        self.intentName = intentName
        self.message = message
        self.messageFormat = messageFormat
        self.sessionAttributes = sessionAttributes
        self.sessionId = sessionId
        self.slotToElicit = slotToElicit
        self.slots = slots
    }
}

extension PutSessionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSessionOutput(audioStream: \(Swift.String(describing: audioStream)), contentType: \(Swift.String(describing: contentType)), dialogState: \(Swift.String(describing: dialogState)), intentName: \(Swift.String(describing: intentName)), messageFormat: \(Swift.String(describing: messageFormat)), sessionAttributes: \(Swift.String(describing: sessionAttributes)), sessionId: \(Swift.String(describing: sessionId)), slotToElicit: \(Swift.String(describing: slotToElicit)), slots: \(Swift.String(describing: slots)), activeContexts: \"CONTENT_REDACTED\", encodedMessage: \"CONTENT_REDACTED\", message: \"CONTENT_REDACTED\")"}
}

extension DeleteSessionInput {

    static func urlPathProvider(_ value: DeleteSessionInput) -> Swift.String? {
        guard let botName = value.botName else {
            return nil
        }
        guard let botAlias = value.botAlias else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/bot/\(botName.urlPercentEncoding())/alias/\(botAlias.urlPercentEncoding())/user/\(userId.urlPercentEncoding())/session"
    }
}

extension GetSessionInput {

    static func urlPathProvider(_ value: GetSessionInput) -> Swift.String? {
        guard let botName = value.botName else {
            return nil
        }
        guard let botAlias = value.botAlias else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/bot/\(botName.urlPercentEncoding())/alias/\(botAlias.urlPercentEncoding())/user/\(userId.urlPercentEncoding())/session"
    }
}

extension GetSessionInput {

    static func queryItemProvider(_ value: GetSessionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let checkpointLabelFilter = value.checkpointLabelFilter {
            let checkpointLabelFilterQueryItem = Smithy.URIQueryItem(name: "checkpointLabelFilter".urlPercentEncoding(), value: Swift.String(checkpointLabelFilter).urlPercentEncoding())
            items.append(checkpointLabelFilterQueryItem)
        }
        return items
    }
}

extension PostContentInput {

    static func urlPathProvider(_ value: PostContentInput) -> Swift.String? {
        guard let botName = value.botName else {
            return nil
        }
        guard let botAlias = value.botAlias else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/bot/\(botName.urlPercentEncoding())/alias/\(botAlias.urlPercentEncoding())/user/\(userId.urlPercentEncoding())/content"
    }
}

extension PostContentInput {

    static func headerProvider(_ value: PostContentInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let accept = value.accept {
            items.add(SmithyHTTPAPI.Header(name: "Accept", value: Swift.String(accept)))
        }
        if let activeContexts = value.activeContexts {
            do {
                let base64EncodedValue = try activeContexts.base64EncodedString()
                items.add(SmithyHTTPAPI.Header(name: "x-amz-lex-active-contexts", value: Swift.String(base64EncodedValue)))
            } catch {
            }
        }
        if let contentType = value.contentType {
            items.add(SmithyHTTPAPI.Header(name: "Content-Type", value: Swift.String(contentType)))
        }
        if let requestAttributes = value.requestAttributes {
            do {
                let base64EncodedValue = try requestAttributes.base64EncodedString()
                items.add(SmithyHTTPAPI.Header(name: "x-amz-lex-request-attributes", value: Swift.String(base64EncodedValue)))
            } catch {
            }
        }
        if let sessionAttributes = value.sessionAttributes {
            do {
                let base64EncodedValue = try sessionAttributes.base64EncodedString()
                items.add(SmithyHTTPAPI.Header(name: "x-amz-lex-session-attributes", value: Swift.String(base64EncodedValue)))
            } catch {
            }
        }
        return items
    }
}

extension PostTextInput {

    static func urlPathProvider(_ value: PostTextInput) -> Swift.String? {
        guard let botName = value.botName else {
            return nil
        }
        guard let botAlias = value.botAlias else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/bot/\(botName.urlPercentEncoding())/alias/\(botAlias.urlPercentEncoding())/user/\(userId.urlPercentEncoding())/text"
    }
}

extension PutSessionInput {

    static func urlPathProvider(_ value: PutSessionInput) -> Swift.String? {
        guard let botName = value.botName else {
            return nil
        }
        guard let botAlias = value.botAlias else {
            return nil
        }
        guard let userId = value.userId else {
            return nil
        }
        return "/bot/\(botName.urlPercentEncoding())/alias/\(botAlias.urlPercentEncoding())/user/\(userId.urlPercentEncoding())/session"
    }
}

extension PutSessionInput {

    static func headerProvider(_ value: PutSessionInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let accept = value.accept {
            items.add(SmithyHTTPAPI.Header(name: "Accept", value: Swift.String(accept)))
        }
        return items
    }
}

extension PostContentInput {

    static func write(value: PostContentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputStream"].write(value.inputStream)
    }
}

extension PostTextInput {

    static func write(value: PostTextInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["activeContexts"].writeList(value.activeContexts, memberWritingClosure: LexRuntimeClientTypes.ActiveContext.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["inputText"].write(value.inputText)
        try writer["requestAttributes"].writeMap(value.requestAttributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["sessionAttributes"].writeMap(value.sessionAttributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PutSessionInput {

    static func write(value: PutSessionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["activeContexts"].writeList(value.activeContexts, memberWritingClosure: LexRuntimeClientTypes.ActiveContext.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["dialogAction"].write(value.dialogAction, with: LexRuntimeClientTypes.DialogAction.write(value:to:))
        try writer["recentIntentSummaryView"].writeList(value.recentIntentSummaryView, memberWritingClosure: LexRuntimeClientTypes.IntentSummary.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["sessionAttributes"].writeMap(value.sessionAttributes, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension DeleteSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteSessionOutput()
        value.botAlias = try reader["botAlias"].readIfPresent()
        value.botName = try reader["botName"].readIfPresent()
        value.sessionId = try reader["sessionId"].readIfPresent()
        value.userId = try reader["userId"].readIfPresent()
        return value
    }
}

extension GetSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSessionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSessionOutput()
        value.activeContexts = try reader["activeContexts"].readListIfPresent(memberReadingClosure: LexRuntimeClientTypes.ActiveContext.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dialogAction = try reader["dialogAction"].readIfPresent(with: LexRuntimeClientTypes.DialogAction.read(from:))
        value.recentIntentSummaryView = try reader["recentIntentSummaryView"].readListIfPresent(memberReadingClosure: LexRuntimeClientTypes.IntentSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.sessionAttributes = try reader["sessionAttributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.sessionId = try reader["sessionId"].readIfPresent()
        return value
    }
}

extension PostContentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PostContentOutput {
        var value = PostContentOutput()
        if let activeContextsHeaderValue = httpResponse.headers.value(for: "x-amz-lex-active-contexts") {
            value.activeContexts = try activeContextsHeaderValue.base64DecodedString()
        }
        if let alternativeIntentsHeaderValue = httpResponse.headers.value(for: "x-amz-lex-alternative-intents") {
            value.alternativeIntents = try alternativeIntentsHeaderValue.base64DecodedString()
        }
        if let botVersionHeaderValue = httpResponse.headers.value(for: "x-amz-lex-bot-version") {
            value.botVersion = botVersionHeaderValue
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        if let dialogStateHeaderValue = httpResponse.headers.value(for: "x-amz-lex-dialog-state") {
            value.dialogState = LexRuntimeClientTypes.DialogState(rawValue: dialogStateHeaderValue)
        }
        if let encodedInputTranscriptHeaderValue = httpResponse.headers.value(for: "x-amz-lex-encoded-input-transcript") {
            value.encodedInputTranscript = encodedInputTranscriptHeaderValue
        }
        if let encodedMessageHeaderValue = httpResponse.headers.value(for: "x-amz-lex-encoded-message") {
            value.encodedMessage = encodedMessageHeaderValue
        }
        if let inputTranscriptHeaderValue = httpResponse.headers.value(for: "x-amz-lex-input-transcript") {
            value.inputTranscript = inputTranscriptHeaderValue
        }
        if let intentNameHeaderValue = httpResponse.headers.value(for: "x-amz-lex-intent-name") {
            value.intentName = intentNameHeaderValue
        }
        if let messageHeaderValue = httpResponse.headers.value(for: "x-amz-lex-message") {
            value.message = messageHeaderValue
        }
        if let messageFormatHeaderValue = httpResponse.headers.value(for: "x-amz-lex-message-format") {
            value.messageFormat = LexRuntimeClientTypes.MessageFormatType(rawValue: messageFormatHeaderValue)
        }
        if let nluIntentConfidenceHeaderValue = httpResponse.headers.value(for: "x-amz-lex-nlu-intent-confidence") {
            value.nluIntentConfidence = try nluIntentConfidenceHeaderValue.base64DecodedString()
        }
        if let sentimentResponseHeaderValue = httpResponse.headers.value(for: "x-amz-lex-sentiment") {
            value.sentimentResponse = sentimentResponseHeaderValue
        }
        if let sessionAttributesHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-attributes") {
            value.sessionAttributes = try sessionAttributesHeaderValue.base64DecodedString()
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-id") {
            value.sessionId = sessionIdHeaderValue
        }
        if let slotToElicitHeaderValue = httpResponse.headers.value(for: "x-amz-lex-slot-to-elicit") {
            value.slotToElicit = slotToElicitHeaderValue
        }
        if let slotsHeaderValue = httpResponse.headers.value(for: "x-amz-lex-slots") {
            value.slots = try slotsHeaderValue.base64DecodedString()
        }
        switch httpResponse.body {
        case .data(let data):
            value.audioStream = .data(data)
        case .stream(let stream):
            value.audioStream = .stream(stream)
        case .noStream:
            value.audioStream = nil
        }
        return value
    }
}

extension PostTextOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PostTextOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PostTextOutput()
        value.activeContexts = try reader["activeContexts"].readListIfPresent(memberReadingClosure: LexRuntimeClientTypes.ActiveContext.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.alternativeIntents = try reader["alternativeIntents"].readListIfPresent(memberReadingClosure: LexRuntimeClientTypes.PredictedIntent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.botVersion = try reader["botVersion"].readIfPresent()
        value.dialogState = try reader["dialogState"].readIfPresent()
        value.intentName = try reader["intentName"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        value.messageFormat = try reader["messageFormat"].readIfPresent()
        value.nluIntentConfidence = try reader["nluIntentConfidence"].readIfPresent(with: LexRuntimeClientTypes.IntentConfidence.read(from:))
        value.responseCard = try reader["responseCard"].readIfPresent(with: LexRuntimeClientTypes.ResponseCard.read(from:))
        value.sentimentResponse = try reader["sentimentResponse"].readIfPresent(with: LexRuntimeClientTypes.SentimentResponse.read(from:))
        value.sessionAttributes = try reader["sessionAttributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.sessionId = try reader["sessionId"].readIfPresent()
        value.slotToElicit = try reader["slotToElicit"].readIfPresent()
        value.slots = try reader["slots"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PutSessionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutSessionOutput {
        var value = PutSessionOutput()
        if let activeContextsHeaderValue = httpResponse.headers.value(for: "x-amz-lex-active-contexts") {
            value.activeContexts = try activeContextsHeaderValue.base64DecodedString()
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            value.contentType = contentTypeHeaderValue
        }
        if let dialogStateHeaderValue = httpResponse.headers.value(for: "x-amz-lex-dialog-state") {
            value.dialogState = LexRuntimeClientTypes.DialogState(rawValue: dialogStateHeaderValue)
        }
        if let encodedMessageHeaderValue = httpResponse.headers.value(for: "x-amz-lex-encoded-message") {
            value.encodedMessage = encodedMessageHeaderValue
        }
        if let intentNameHeaderValue = httpResponse.headers.value(for: "x-amz-lex-intent-name") {
            value.intentName = intentNameHeaderValue
        }
        if let messageHeaderValue = httpResponse.headers.value(for: "x-amz-lex-message") {
            value.message = messageHeaderValue
        }
        if let messageFormatHeaderValue = httpResponse.headers.value(for: "x-amz-lex-message-format") {
            value.messageFormat = LexRuntimeClientTypes.MessageFormatType(rawValue: messageFormatHeaderValue)
        }
        if let sessionAttributesHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-attributes") {
            value.sessionAttributes = try sessionAttributesHeaderValue.base64DecodedString()
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-id") {
            value.sessionId = sessionIdHeaderValue
        }
        if let slotToElicitHeaderValue = httpResponse.headers.value(for: "x-amz-lex-slot-to-elicit") {
            value.slotToElicit = slotToElicitHeaderValue
        }
        if let slotsHeaderValue = httpResponse.headers.value(for: "x-amz-lex-slots") {
            value.slots = try slotsHeaderValue.base64DecodedString()
        }
        switch httpResponse.body {
        case .data(let data):
            value.audioStream = .data(data)
        case .stream(let stream):
            value.audioStream = .stream(stream)
        case .noStream:
            value.audioStream = nil
        }
        return value
    }
}

enum DeleteSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PostContentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadGatewayException": return try BadGatewayException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DependencyFailedException": return try DependencyFailedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "LoopDetectedException": return try LoopDetectedException.makeError(baseError: baseError)
            case "NotAcceptableException": return try NotAcceptableException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "RequestTimeoutException": return try RequestTimeoutException.makeError(baseError: baseError)
            case "UnsupportedMediaTypeException": return try UnsupportedMediaTypeException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PostTextOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadGatewayException": return try BadGatewayException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DependencyFailedException": return try DependencyFailedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "LoopDetectedException": return try LoopDetectedException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutSessionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadGatewayException": return try BadGatewayException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "DependencyFailedException": return try DependencyFailedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "NotAcceptableException": return try NotAcceptableException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalFailureException {
        let reader = baseError.errorBodyReader
        var value = InternalFailureException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = LimitExceededException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = retryAfterSecondsHeaderValue
        }
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnsupportedMediaTypeException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnsupportedMediaTypeException {
        let reader = baseError.errorBodyReader
        var value = UnsupportedMediaTypeException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DependencyFailedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DependencyFailedException {
        let reader = baseError.errorBodyReader
        var value = DependencyFailedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LoopDetectedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LoopDetectedException {
        let reader = baseError.errorBodyReader
        var value = LoopDetectedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RequestTimeoutException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RequestTimeoutException {
        let reader = baseError.errorBodyReader
        var value = RequestTimeoutException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotAcceptableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotAcceptableException {
        let reader = baseError.errorBodyReader
        var value = NotAcceptableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadGatewayException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadGatewayException {
        let reader = baseError.errorBodyReader
        var value = BadGatewayException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LexRuntimeClientTypes.IntentSummary {

    static func write(value: LexRuntimeClientTypes.IntentSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["checkpointLabel"].write(value.checkpointLabel)
        try writer["confirmationStatus"].write(value.confirmationStatus)
        try writer["dialogActionType"].write(value.dialogActionType)
        try writer["fulfillmentState"].write(value.fulfillmentState)
        try writer["intentName"].write(value.intentName)
        try writer["slotToElicit"].write(value.slotToElicit)
        try writer["slots"].writeMap(value.slots, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LexRuntimeClientTypes.IntentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LexRuntimeClientTypes.IntentSummary()
        value.intentName = try reader["intentName"].readIfPresent()
        value.checkpointLabel = try reader["checkpointLabel"].readIfPresent()
        value.slots = try reader["slots"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.confirmationStatus = try reader["confirmationStatus"].readIfPresent()
        value.dialogActionType = try reader["dialogActionType"].readIfPresent() ?? .sdkUnknown("")
        value.fulfillmentState = try reader["fulfillmentState"].readIfPresent()
        value.slotToElicit = try reader["slotToElicit"].readIfPresent()
        return value
    }
}

extension LexRuntimeClientTypes.DialogAction {

    static func write(value: LexRuntimeClientTypes.DialogAction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fulfillmentState"].write(value.fulfillmentState)
        try writer["intentName"].write(value.intentName)
        try writer["message"].write(value.message)
        try writer["messageFormat"].write(value.messageFormat)
        try writer["slotToElicit"].write(value.slotToElicit)
        try writer["slots"].writeMap(value.slots, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LexRuntimeClientTypes.DialogAction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LexRuntimeClientTypes.DialogAction()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.intentName = try reader["intentName"].readIfPresent()
        value.slots = try reader["slots"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.slotToElicit = try reader["slotToElicit"].readIfPresent()
        value.fulfillmentState = try reader["fulfillmentState"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        value.messageFormat = try reader["messageFormat"].readIfPresent()
        return value
    }
}

extension LexRuntimeClientTypes.ActiveContext {

    static func write(value: LexRuntimeClientTypes.ActiveContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["timeToLive"].write(value.timeToLive, with: LexRuntimeClientTypes.ActiveContextTimeToLive.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LexRuntimeClientTypes.ActiveContext {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LexRuntimeClientTypes.ActiveContext()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.timeToLive = try reader["timeToLive"].readIfPresent(with: LexRuntimeClientTypes.ActiveContextTimeToLive.read(from:))
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension LexRuntimeClientTypes.ActiveContextTimeToLive {

    static func write(value: LexRuntimeClientTypes.ActiveContextTimeToLive?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["timeToLiveInSeconds"].write(value.timeToLiveInSeconds)
        try writer["turnsToLive"].write(value.turnsToLive)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> LexRuntimeClientTypes.ActiveContextTimeToLive {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LexRuntimeClientTypes.ActiveContextTimeToLive()
        value.timeToLiveInSeconds = try reader["timeToLiveInSeconds"].readIfPresent()
        value.turnsToLive = try reader["turnsToLive"].readIfPresent()
        return value
    }
}

extension LexRuntimeClientTypes.IntentConfidence {

    static func read(from reader: SmithyJSON.Reader) throws -> LexRuntimeClientTypes.IntentConfidence {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LexRuntimeClientTypes.IntentConfidence()
        value.score = try reader["score"].readIfPresent() ?? 0
        return value
    }
}

extension LexRuntimeClientTypes.PredictedIntent {

    static func read(from reader: SmithyJSON.Reader) throws -> LexRuntimeClientTypes.PredictedIntent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LexRuntimeClientTypes.PredictedIntent()
        value.intentName = try reader["intentName"].readIfPresent()
        value.nluIntentConfidence = try reader["nluIntentConfidence"].readIfPresent(with: LexRuntimeClientTypes.IntentConfidence.read(from:))
        value.slots = try reader["slots"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension LexRuntimeClientTypes.SentimentResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> LexRuntimeClientTypes.SentimentResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LexRuntimeClientTypes.SentimentResponse()
        value.sentimentLabel = try reader["sentimentLabel"].readIfPresent()
        value.sentimentScore = try reader["sentimentScore"].readIfPresent()
        return value
    }
}

extension LexRuntimeClientTypes.ResponseCard {

    static func read(from reader: SmithyJSON.Reader) throws -> LexRuntimeClientTypes.ResponseCard {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LexRuntimeClientTypes.ResponseCard()
        value.version = try reader["version"].readIfPresent()
        value.contentType = try reader["contentType"].readIfPresent()
        value.genericAttachments = try reader["genericAttachments"].readListIfPresent(memberReadingClosure: LexRuntimeClientTypes.GenericAttachment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LexRuntimeClientTypes.GenericAttachment {

    static func read(from reader: SmithyJSON.Reader) throws -> LexRuntimeClientTypes.GenericAttachment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LexRuntimeClientTypes.GenericAttachment()
        value.title = try reader["title"].readIfPresent()
        value.subTitle = try reader["subTitle"].readIfPresent()
        value.attachmentLinkUrl = try reader["attachmentLinkUrl"].readIfPresent()
        value.imageUrl = try reader["imageUrl"].readIfPresent()
        value.buttons = try reader["buttons"].readListIfPresent(memberReadingClosure: LexRuntimeClientTypes.Button.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension LexRuntimeClientTypes.Button {

    static func read(from reader: SmithyJSON.Reader) throws -> LexRuntimeClientTypes.Button {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = LexRuntimeClientTypes.Button()
        value.text = try reader["text"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

public enum LexRuntimeClientTypes {}
