// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension LexRuntimeClientTypes.ActiveContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case parameters
        case timeToLive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, activeContextParametersMap0) in parameters {
                try parametersContainer.encode(activeContextParametersMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timeToLive = self.timeToLive {
            try encodeContainer.encode(timeToLive, forKey: .timeToLive)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let timeToLiveDecoded = try containerValues.decodeIfPresent(LexRuntimeClientTypes.ActiveContextTimeToLive.self, forKey: .timeToLive)
        timeToLive = timeToLiveDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, text0) in parametersContainer {
                if let text0 = text0 {
                    parametersDecoded0?[key0] = text0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension LexRuntimeClientTypes {
    /// A context is a variable that contains information about the current state of the conversation between a user and Amazon Lex. Context can be set automatically by Amazon Lex when an intent is fulfilled, or it can be set at runtime using the PutContent, PutText, or PutSession operation.
    public struct ActiveContext: Swift.Equatable {
        /// The name of the context.
        /// This member is required.
        public var name: Swift.String?
        /// State variables for the current context. You can use these values as default values for slots in subsequent events.
        /// This member is required.
        public var parameters: [Swift.String:Swift.String]?
        /// The length of time or number of turns that a context remains active.
        /// This member is required.
        public var timeToLive: LexRuntimeClientTypes.ActiveContextTimeToLive?

        public init (
            name: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            timeToLive: LexRuntimeClientTypes.ActiveContextTimeToLive? = nil
        )
        {
            self.name = name
            self.parameters = parameters
            self.timeToLive = timeToLive
        }
    }

}

extension LexRuntimeClientTypes.ActiveContextTimeToLive: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timeToLiveInSeconds
        case turnsToLive
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timeToLiveInSeconds = self.timeToLiveInSeconds {
            try encodeContainer.encode(timeToLiveInSeconds, forKey: .timeToLiveInSeconds)
        }
        if let turnsToLive = self.turnsToLive {
            try encodeContainer.encode(turnsToLive, forKey: .turnsToLive)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeToLiveInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeToLiveInSeconds)
        timeToLiveInSeconds = timeToLiveInSecondsDecoded
        let turnsToLiveDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .turnsToLive)
        turnsToLive = turnsToLiveDecoded
    }
}

extension LexRuntimeClientTypes {
    /// The length of time or number of turns that a context remains active.
    public struct ActiveContextTimeToLive: Swift.Equatable {
        /// The number of seconds that the context should be active after it is first sent in a PostContent or PostText response. You can set the value between 5 and 86,400 seconds (24 hours).
        public var timeToLiveInSeconds: Swift.Int?
        /// The number of conversation turns that the context should be active. A conversation turn is one PostContent or PostText request and the corresponding response from Amazon Lex.
        public var turnsToLive: Swift.Int?

        public init (
            timeToLiveInSeconds: Swift.Int? = nil,
            turnsToLive: Swift.Int? = nil
        )
        {
            self.timeToLiveInSeconds = timeToLiveInSeconds
            self.turnsToLive = turnsToLive
        }
    }

}

extension BadGatewayException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BadGatewayExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Either the Amazon Lex bot is still building, or one of the dependent services (Amazon Polly, AWS Lambda) failed with an internal service error.
public struct BadGatewayException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadGatewayExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadGatewayExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Request validation failed, there is no usable message in the context, or the bot build failed, is still in progress, or contains unbuilt changes.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeClientTypes.Button: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension LexRuntimeClientTypes {
    /// Represents an option to be shown on the client platform (Facebook, Slack, etc.)
    public struct Button: Swift.Equatable {
        /// Text that is visible to the user on the button.
        /// This member is required.
        public var text: Swift.String?
        /// The value sent to Amazon Lex when a user chooses the button. For example, consider button text "NYC." When the user chooses the button, the value sent can be "New York City."
        /// This member is required.
        public var value: Swift.String?

        public init (
            text: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.text = text
            self.value = value
        }
    }

}

extension LexRuntimeClientTypes {
    public enum ConfirmationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case confirmed
        case denied
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfirmationStatus] {
            return [
                .confirmed,
                .denied,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .confirmed: return "Confirmed"
            case .denied: return "Denied"
            case .none: return "None"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfirmationStatus(rawValue: rawValue) ?? ConfirmationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Two clients are using the same AWS account, Amazon Lex bot, and user ID.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeClientTypes {
    public enum ContentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case generic
        case sdkUnknown(Swift.String)

        public static var allCases: [ContentType] {
            return [
                .generic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .generic: return "application/vnd.amazonaws.card.generic"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ContentType(rawValue: rawValue) ?? ContentType.sdkUnknown(rawValue)
        }
    }
}

extension DeleteSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botName = botName else {
            return nil
        }
        guard let botAlias = botAlias else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/bot/\(botName.urlPercentEncoding())/alias/\(botAlias.urlPercentEncoding())/user/\(userId.urlPercentEncoding())/session"
    }
}

public struct DeleteSessionInput: Swift.Equatable {
    /// The alias in use for the bot that contains the session data.
    /// This member is required.
    public var botAlias: Swift.String?
    /// The name of the bot that contains the session data.
    /// This member is required.
    public var botName: Swift.String?
    /// The identifier of the user associated with the session data.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        botAlias: Swift.String? = nil,
        botName: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.botAlias = botAlias
        self.botName = botName
        self.userId = userId
    }
}

struct DeleteSessionInputBody: Swift.Equatable {
}

extension DeleteSessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSessionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.botAlias = output.botAlias
            self.botName = output.botName
            self.sessionId = output.sessionId
            self.userId = output.userId
        } else {
            self.botAlias = nil
            self.botName = nil
            self.sessionId = nil
            self.userId = nil
        }
    }
}

public struct DeleteSessionOutputResponse: Swift.Equatable {
    /// The alias in use for the bot associated with the session data.
    public var botAlias: Swift.String?
    /// The name of the bot associated with the session data.
    public var botName: Swift.String?
    /// The unique identifier for the session.
    public var sessionId: Swift.String?
    /// The ID of the client application user.
    public var userId: Swift.String?

    public init (
        botAlias: Swift.String? = nil,
        botName: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.botAlias = botAlias
        self.botName = botName
        self.sessionId = sessionId
        self.userId = userId
    }
}

struct DeleteSessionOutputResponseBody: Swift.Equatable {
    let botName: Swift.String?
    let botAlias: Swift.String?
    let userId: Swift.String?
    let sessionId: Swift.String?
}

extension DeleteSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case botAlias
        case botName
        case sessionId
        case userId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let botNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botName)
        botName = botNameDecoded
        let botAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botAlias)
        botAlias = botAliasDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
    }
}

extension DependencyFailedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DependencyFailedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One of the dependencies, such as AWS Lambda or Amazon Polly, threw an exception. For example,
///
/// * If Amazon Lex does not have sufficient permissions to call a Lambda function.
///
/// * If a Lambda function takes longer than 30 seconds to execute.
///
/// * If a fulfillment Lambda function returns a Delegate dialog action without removing any slot values.
public struct DependencyFailedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DependencyFailedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DependencyFailedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeClientTypes.DialogAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fulfillmentState
        case intentName
        case message
        case messageFormat
        case slotToElicit
        case slots
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fulfillmentState = self.fulfillmentState {
            try encodeContainer.encode(fulfillmentState.rawValue, forKey: .fulfillmentState)
        }
        if let intentName = self.intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let messageFormat = self.messageFormat {
            try encodeContainer.encode(messageFormat.rawValue, forKey: .messageFormat)
        }
        if let slotToElicit = self.slotToElicit {
            try encodeContainer.encode(slotToElicit, forKey: .slotToElicit)
        }
        if let slots = slots {
            var slotsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .slots)
            for (dictKey0, stringMap0) in slots {
                try slotsContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(LexRuntimeClientTypes.DialogActionType.self, forKey: .type)
        type = typeDecoded
        let intentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let slotsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .slots)
        var slotsDecoded0: [Swift.String:Swift.String]? = nil
        if let slotsContainer = slotsContainer {
            slotsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in slotsContainer {
                if let string0 = string0 {
                    slotsDecoded0?[key0] = string0
                }
            }
        }
        slots = slotsDecoded0
        let slotToElicitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotToElicit)
        slotToElicit = slotToElicitDecoded
        let fulfillmentStateDecoded = try containerValues.decodeIfPresent(LexRuntimeClientTypes.FulfillmentState.self, forKey: .fulfillmentState)
        fulfillmentState = fulfillmentStateDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let messageFormatDecoded = try containerValues.decodeIfPresent(LexRuntimeClientTypes.MessageFormatType.self, forKey: .messageFormat)
        messageFormat = messageFormatDecoded
    }
}

extension LexRuntimeClientTypes.DialogAction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DialogAction(fulfillmentState: \(Swift.String(describing: fulfillmentState)), intentName: \(Swift.String(describing: intentName)), messageFormat: \(Swift.String(describing: messageFormat)), slotToElicit: \(Swift.String(describing: slotToElicit)), type: \(Swift.String(describing: type)), message: \"CONTENT_REDACTED\", slots: \"CONTENT_REDACTED\")"}
}

extension LexRuntimeClientTypes {
    /// Describes the next action that the bot should take in its interaction with the user and provides information about the context in which the action takes place. Use the DialogAction data type to set the interaction to a specific state, or to return the interaction to a previous state.
    public struct DialogAction: Swift.Equatable {
        /// The fulfillment state of the intent. The possible values are:
        ///
        /// * Failed - The Lambda function associated with the intent failed to fulfill the intent.
        ///
        /// * Fulfilled - The intent has fulfilled by the Lambda function associated with the intent.
        ///
        /// * ReadyForFulfillment - All of the information necessary for the intent is present and the intent ready to be fulfilled by the client application.
        public var fulfillmentState: LexRuntimeClientTypes.FulfillmentState?
        /// The name of the intent.
        public var intentName: Swift.String?
        /// The message that should be shown to the user. If you don't specify a message, Amazon Lex will use the message configured for the intent.
        public var message: Swift.String?
        /// * PlainText - The message contains plain UTF-8 text.
        ///
        /// * CustomPayload - The message is a custom format for the client.
        ///
        /// * SSML - The message contains text formatted for voice output.
        ///
        /// * Composite - The message contains an escaped JSON object containing one or more messages. For more information, see [Message Groups](https://docs.aws.amazon.com/lex/latest/dg/howitworks-manage-prompts.html).
        public var messageFormat: LexRuntimeClientTypes.MessageFormatType?
        /// The name of the slot that should be elicited from the user.
        public var slotToElicit: Swift.String?
        /// Map of the slots that have been gathered and their values.
        public var slots: [Swift.String:Swift.String]?
        /// The next action that the bot should take in its interaction with the user. The possible values are:
        ///
        /// * ConfirmIntent - The next action is asking the user if the intent is complete and ready to be fulfilled. This is a yes/no question such as "Place the order?"
        ///
        /// * Close - Indicates that the there will not be a response from the user. For example, the statement "Your order has been placed" does not require a response.
        ///
        /// * Delegate - The next action is determined by Amazon Lex.
        ///
        /// * ElicitIntent - The next action is to determine the intent that the user wants to fulfill.
        ///
        /// * ElicitSlot - The next action is to elicit a slot value from the user.
        /// This member is required.
        public var type: LexRuntimeClientTypes.DialogActionType?

        public init (
            fulfillmentState: LexRuntimeClientTypes.FulfillmentState? = nil,
            intentName: Swift.String? = nil,
            message: Swift.String? = nil,
            messageFormat: LexRuntimeClientTypes.MessageFormatType? = nil,
            slotToElicit: Swift.String? = nil,
            slots: [Swift.String:Swift.String]? = nil,
            type: LexRuntimeClientTypes.DialogActionType? = nil
        )
        {
            self.fulfillmentState = fulfillmentState
            self.intentName = intentName
            self.message = message
            self.messageFormat = messageFormat
            self.slotToElicit = slotToElicit
            self.slots = slots
            self.type = type
        }
    }

}

extension LexRuntimeClientTypes {
    public enum DialogActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case close
        case confirmIntent
        case delegate
        case elicitIntent
        case elicitSlot
        case sdkUnknown(Swift.String)

        public static var allCases: [DialogActionType] {
            return [
                .close,
                .confirmIntent,
                .delegate,
                .elicitIntent,
                .elicitSlot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .close: return "Close"
            case .confirmIntent: return "ConfirmIntent"
            case .delegate: return "Delegate"
            case .elicitIntent: return "ElicitIntent"
            case .elicitSlot: return "ElicitSlot"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DialogActionType(rawValue: rawValue) ?? DialogActionType.sdkUnknown(rawValue)
        }
    }
}

extension LexRuntimeClientTypes {
    public enum DialogState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case confirmIntent
        case elicitIntent
        case elicitSlot
        case failed
        case fulfilled
        case readyForFulfillment
        case sdkUnknown(Swift.String)

        public static var allCases: [DialogState] {
            return [
                .confirmIntent,
                .elicitIntent,
                .elicitSlot,
                .failed,
                .fulfilled,
                .readyForFulfillment,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .confirmIntent: return "ConfirmIntent"
            case .elicitIntent: return "ElicitIntent"
            case .elicitSlot: return "ElicitSlot"
            case .failed: return "Failed"
            case .fulfilled: return "Fulfilled"
            case .readyForFulfillment: return "ReadyForFulfillment"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DialogState(rawValue: rawValue) ?? DialogState.sdkUnknown(rawValue)
        }
    }
}

extension LexRuntimeClientTypes {
    public enum FulfillmentState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case fulfilled
        case readyForFulfillment
        case sdkUnknown(Swift.String)

        public static var allCases: [FulfillmentState] {
            return [
                .failed,
                .fulfilled,
                .readyForFulfillment,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "Failed"
            case .fulfilled: return "Fulfilled"
            case .readyForFulfillment: return "ReadyForFulfillment"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FulfillmentState(rawValue: rawValue) ?? FulfillmentState.sdkUnknown(rawValue)
        }
    }
}

extension LexRuntimeClientTypes.GenericAttachment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentLinkUrl
        case buttons
        case imageUrl
        case subTitle
        case title
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentLinkUrl = self.attachmentLinkUrl {
            try encodeContainer.encode(attachmentLinkUrl, forKey: .attachmentLinkUrl)
        }
        if let buttons = buttons {
            var buttonsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .buttons)
            for button0 in buttons {
                try buttonsContainer.encode(button0)
            }
        }
        if let imageUrl = self.imageUrl {
            try encodeContainer.encode(imageUrl, forKey: .imageUrl)
        }
        if let subTitle = self.subTitle {
            try encodeContainer.encode(subTitle, forKey: .subTitle)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let subTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subTitle)
        subTitle = subTitleDecoded
        let attachmentLinkUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentLinkUrl)
        attachmentLinkUrl = attachmentLinkUrlDecoded
        let imageUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageUrl)
        imageUrl = imageUrlDecoded
        let buttonsContainer = try containerValues.decodeIfPresent([LexRuntimeClientTypes.Button?].self, forKey: .buttons)
        var buttonsDecoded0:[LexRuntimeClientTypes.Button]? = nil
        if let buttonsContainer = buttonsContainer {
            buttonsDecoded0 = [LexRuntimeClientTypes.Button]()
            for structure0 in buttonsContainer {
                if let structure0 = structure0 {
                    buttonsDecoded0?.append(structure0)
                }
            }
        }
        buttons = buttonsDecoded0
    }
}

extension LexRuntimeClientTypes {
    /// Represents an option rendered to the user when a prompt is shown. It could be an image, a button, a link, or text.
    public struct GenericAttachment: Swift.Equatable {
        /// The URL of an attachment to the response card.
        public var attachmentLinkUrl: Swift.String?
        /// The list of options to show to the user.
        public var buttons: [LexRuntimeClientTypes.Button]?
        /// The URL of an image that is displayed to the user.
        public var imageUrl: Swift.String?
        /// The subtitle shown below the title.
        public var subTitle: Swift.String?
        /// The title of the option.
        public var title: Swift.String?

        public init (
            attachmentLinkUrl: Swift.String? = nil,
            buttons: [LexRuntimeClientTypes.Button]? = nil,
            imageUrl: Swift.String? = nil,
            subTitle: Swift.String? = nil,
            title: Swift.String? = nil
        )
        {
            self.attachmentLinkUrl = attachmentLinkUrl
            self.buttons = buttons
            self.imageUrl = imageUrl
            self.subTitle = subTitle
            self.title = title
        }
    }

}

extension GetSessionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let checkpointLabelFilter = checkpointLabelFilter {
                let checkpointLabelFilterQueryItem = ClientRuntime.URLQueryItem(name: "checkpointLabelFilter".urlPercentEncoding(), value: Swift.String(checkpointLabelFilter).urlPercentEncoding())
                items.append(checkpointLabelFilterQueryItem)
            }
            return items
        }
    }
}

extension GetSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botName = botName else {
            return nil
        }
        guard let botAlias = botAlias else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/bot/\(botName.urlPercentEncoding())/alias/\(botAlias.urlPercentEncoding())/user/\(userId.urlPercentEncoding())/session"
    }
}

public struct GetSessionInput: Swift.Equatable {
    /// The alias in use for the bot that contains the session data.
    /// This member is required.
    public var botAlias: Swift.String?
    /// The name of the bot that contains the session data.
    /// This member is required.
    public var botName: Swift.String?
    /// A string used to filter the intents returned in the recentIntentSummaryView structure. When you specify a filter, only intents with their checkpointLabel field set to that string are returned.
    public var checkpointLabelFilter: Swift.String?
    /// The ID of the client application user. Amazon Lex uses this to identify a user's conversation with your bot.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        botAlias: Swift.String? = nil,
        botName: Swift.String? = nil,
        checkpointLabelFilter: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.botAlias = botAlias
        self.botName = botName
        self.checkpointLabelFilter = checkpointLabelFilter
        self.userId = userId
    }
}

struct GetSessionInputBody: Swift.Equatable {
}

extension GetSessionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSessionOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetSessionOutputResponse(dialogAction: \(Swift.String(describing: dialogAction)), recentIntentSummaryView: \(Swift.String(describing: recentIntentSummaryView)), sessionId: \(Swift.String(describing: sessionId)), activeContexts: \"CONTENT_REDACTED\", sessionAttributes: \"CONTENT_REDACTED\")"}
}

extension GetSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSessionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activeContexts = output.activeContexts
            self.dialogAction = output.dialogAction
            self.recentIntentSummaryView = output.recentIntentSummaryView
            self.sessionAttributes = output.sessionAttributes
            self.sessionId = output.sessionId
        } else {
            self.activeContexts = nil
            self.dialogAction = nil
            self.recentIntentSummaryView = nil
            self.sessionAttributes = nil
            self.sessionId = nil
        }
    }
}

public struct GetSessionOutputResponse: Swift.Equatable {
    /// A list of active contexts for the session. A context can be set when an intent is fulfilled or by calling the PostContent, PostText, or PutSession operation. You can use a context to control the intents that can follow up an intent, or to modify the operation of your application.
    public var activeContexts: [LexRuntimeClientTypes.ActiveContext]?
    /// Describes the current state of the bot.
    public var dialogAction: LexRuntimeClientTypes.DialogAction?
    /// An array of information about the intents used in the session. The array can contain a maximum of three summaries. If more than three intents are used in the session, the recentIntentSummaryView operation contains information about the last three intents used. If you set the checkpointLabelFilter parameter in the request, the array contains only the intents with the specified label.
    public var recentIntentSummaryView: [LexRuntimeClientTypes.IntentSummary]?
    /// Map of key/value pairs representing the session-specific context information. It contains application information passed between Amazon Lex and a client application.
    public var sessionAttributes: [Swift.String:Swift.String]?
    /// A unique identifier for the session.
    public var sessionId: Swift.String?

    public init (
        activeContexts: [LexRuntimeClientTypes.ActiveContext]? = nil,
        dialogAction: LexRuntimeClientTypes.DialogAction? = nil,
        recentIntentSummaryView: [LexRuntimeClientTypes.IntentSummary]? = nil,
        sessionAttributes: [Swift.String:Swift.String]? = nil,
        sessionId: Swift.String? = nil
    )
    {
        self.activeContexts = activeContexts
        self.dialogAction = dialogAction
        self.recentIntentSummaryView = recentIntentSummaryView
        self.sessionAttributes = sessionAttributes
        self.sessionId = sessionId
    }
}

struct GetSessionOutputResponseBody: Swift.Equatable {
    let recentIntentSummaryView: [LexRuntimeClientTypes.IntentSummary]?
    let sessionAttributes: [Swift.String:Swift.String]?
    let sessionId: Swift.String?
    let dialogAction: LexRuntimeClientTypes.DialogAction?
    let activeContexts: [LexRuntimeClientTypes.ActiveContext]?
}

extension GetSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeContexts
        case dialogAction
        case recentIntentSummaryView
        case sessionAttributes
        case sessionId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recentIntentSummaryViewContainer = try containerValues.decodeIfPresent([LexRuntimeClientTypes.IntentSummary?].self, forKey: .recentIntentSummaryView)
        var recentIntentSummaryViewDecoded0:[LexRuntimeClientTypes.IntentSummary]? = nil
        if let recentIntentSummaryViewContainer = recentIntentSummaryViewContainer {
            recentIntentSummaryViewDecoded0 = [LexRuntimeClientTypes.IntentSummary]()
            for structure0 in recentIntentSummaryViewContainer {
                if let structure0 = structure0 {
                    recentIntentSummaryViewDecoded0?.append(structure0)
                }
            }
        }
        recentIntentSummaryView = recentIntentSummaryViewDecoded0
        let sessionAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sessionAttributes)
        var sessionAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let sessionAttributesContainer = sessionAttributesContainer {
            sessionAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in sessionAttributesContainer {
                if let string0 = string0 {
                    sessionAttributesDecoded0?[key0] = string0
                }
            }
        }
        sessionAttributes = sessionAttributesDecoded0
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let dialogActionDecoded = try containerValues.decodeIfPresent(LexRuntimeClientTypes.DialogAction.self, forKey: .dialogAction)
        dialogAction = dialogActionDecoded
        let activeContextsContainer = try containerValues.decodeIfPresent([LexRuntimeClientTypes.ActiveContext?].self, forKey: .activeContexts)
        var activeContextsDecoded0:[LexRuntimeClientTypes.ActiveContext]? = nil
        if let activeContextsContainer = activeContextsContainer {
            activeContextsDecoded0 = [LexRuntimeClientTypes.ActiveContext]()
            for structure0 in activeContextsContainer {
                if let structure0 = structure0 {
                    activeContextsDecoded0?.append(structure0)
                }
            }
        }
        activeContexts = activeContextsDecoded0
    }
}

extension LexRuntimeClientTypes.IntentConfidence: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case score
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if score != 0.0 {
            try encodeContainer.encode(score, forKey: .score)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .score) ?? 0.0
        score = scoreDecoded
    }
}

extension LexRuntimeClientTypes {
    /// Provides a score that indicates the confidence that Amazon Lex has that an intent is the one that satisfies the user's intent.
    public struct IntentConfidence: Swift.Equatable {
        /// A score that indicates how confident Amazon Lex is that an intent satisfies the user's intent. Ranges between 0.00 and 1.00. Higher scores indicate higher confidence.
        public var score: Swift.Double

        public init (
            score: Swift.Double = 0.0
        )
        {
            self.score = score
        }
    }

}

extension LexRuntimeClientTypes.IntentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkpointLabel
        case confirmationStatus
        case dialogActionType
        case fulfillmentState
        case intentName
        case slotToElicit
        case slots
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let checkpointLabel = self.checkpointLabel {
            try encodeContainer.encode(checkpointLabel, forKey: .checkpointLabel)
        }
        if let confirmationStatus = self.confirmationStatus {
            try encodeContainer.encode(confirmationStatus.rawValue, forKey: .confirmationStatus)
        }
        if let dialogActionType = self.dialogActionType {
            try encodeContainer.encode(dialogActionType.rawValue, forKey: .dialogActionType)
        }
        if let fulfillmentState = self.fulfillmentState {
            try encodeContainer.encode(fulfillmentState.rawValue, forKey: .fulfillmentState)
        }
        if let intentName = self.intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
        if let slotToElicit = self.slotToElicit {
            try encodeContainer.encode(slotToElicit, forKey: .slotToElicit)
        }
        if let slots = slots {
            var slotsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .slots)
            for (dictKey0, stringMap0) in slots {
                try slotsContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let checkpointLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkpointLabel)
        checkpointLabel = checkpointLabelDecoded
        let slotsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .slots)
        var slotsDecoded0: [Swift.String:Swift.String]? = nil
        if let slotsContainer = slotsContainer {
            slotsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in slotsContainer {
                if let string0 = string0 {
                    slotsDecoded0?[key0] = string0
                }
            }
        }
        slots = slotsDecoded0
        let confirmationStatusDecoded = try containerValues.decodeIfPresent(LexRuntimeClientTypes.ConfirmationStatus.self, forKey: .confirmationStatus)
        confirmationStatus = confirmationStatusDecoded
        let dialogActionTypeDecoded = try containerValues.decodeIfPresent(LexRuntimeClientTypes.DialogActionType.self, forKey: .dialogActionType)
        dialogActionType = dialogActionTypeDecoded
        let fulfillmentStateDecoded = try containerValues.decodeIfPresent(LexRuntimeClientTypes.FulfillmentState.self, forKey: .fulfillmentState)
        fulfillmentState = fulfillmentStateDecoded
        let slotToElicitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotToElicit)
        slotToElicit = slotToElicitDecoded
    }
}

extension LexRuntimeClientTypes.IntentSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "IntentSummary(checkpointLabel: \(Swift.String(describing: checkpointLabel)), confirmationStatus: \(Swift.String(describing: confirmationStatus)), dialogActionType: \(Swift.String(describing: dialogActionType)), fulfillmentState: \(Swift.String(describing: fulfillmentState)), intentName: \(Swift.String(describing: intentName)), slotToElicit: \(Swift.String(describing: slotToElicit)), slots: \"CONTENT_REDACTED\")"}
}

extension LexRuntimeClientTypes {
    /// Provides information about the state of an intent. You can use this information to get the current state of an intent so that you can process the intent, or so that you can return the intent to its previous state.
    public struct IntentSummary: Swift.Equatable {
        /// A user-defined label that identifies a particular intent. You can use this label to return to a previous intent. Use the checkpointLabelFilter parameter of the GetSessionRequest operation to filter the intents returned by the operation to those with only the specified label.
        public var checkpointLabel: Swift.String?
        /// The status of the intent after the user responds to the confirmation prompt. If the user confirms the intent, Amazon Lex sets this field to Confirmed. If the user denies the intent, Amazon Lex sets this value to Denied. The possible values are:
        ///
        /// * Confirmed - The user has responded "Yes" to the confirmation prompt, confirming that the intent is complete and that it is ready to be fulfilled.
        ///
        /// * Denied - The user has responded "No" to the confirmation prompt.
        ///
        /// * None - The user has never been prompted for confirmation; or, the user was prompted but did not confirm or deny the prompt.
        public var confirmationStatus: LexRuntimeClientTypes.ConfirmationStatus?
        /// The next action that the bot should take in its interaction with the user. The possible values are:
        ///
        /// * ConfirmIntent - The next action is asking the user if the intent is complete and ready to be fulfilled. This is a yes/no question such as "Place the order?"
        ///
        /// * Close - Indicates that the there will not be a response from the user. For example, the statement "Your order has been placed" does not require a response.
        ///
        /// * ElicitIntent - The next action is to determine the intent that the user wants to fulfill.
        ///
        /// * ElicitSlot - The next action is to elicit a slot value from the user.
        /// This member is required.
        public var dialogActionType: LexRuntimeClientTypes.DialogActionType?
        /// The fulfillment state of the intent. The possible values are:
        ///
        /// * Failed - The Lambda function associated with the intent failed to fulfill the intent.
        ///
        /// * Fulfilled - The intent has fulfilled by the Lambda function associated with the intent.
        ///
        /// * ReadyForFulfillment - All of the information necessary for the intent is present and the intent ready to be fulfilled by the client application.
        public var fulfillmentState: LexRuntimeClientTypes.FulfillmentState?
        /// The name of the intent.
        public var intentName: Swift.String?
        /// The next slot to elicit from the user. If there is not slot to elicit, the field is blank.
        public var slotToElicit: Swift.String?
        /// Map of the slots that have been gathered and their values.
        public var slots: [Swift.String:Swift.String]?

        public init (
            checkpointLabel: Swift.String? = nil,
            confirmationStatus: LexRuntimeClientTypes.ConfirmationStatus? = nil,
            dialogActionType: LexRuntimeClientTypes.DialogActionType? = nil,
            fulfillmentState: LexRuntimeClientTypes.FulfillmentState? = nil,
            intentName: Swift.String? = nil,
            slotToElicit: Swift.String? = nil,
            slots: [Swift.String:Swift.String]? = nil
        )
        {
            self.checkpointLabel = checkpointLabel
            self.confirmationStatus = confirmationStatus
            self.dialogActionType = dialogActionType
            self.fulfillmentState = fulfillmentState
            self.intentName = intentName
            self.slotToElicit = slotToElicit
            self.slots = slots
        }
    }

}

extension InternalFailureException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Internal service error. Retry the call.
public struct InternalFailureException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.retryAfterSeconds = nil
        }
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Exceeded a limit.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var retryAfterSeconds: Swift.String?

    public init (
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil
    )
    {
        self.message = message
        self.retryAfterSeconds = retryAfterSeconds
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LoopDetectedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LoopDetectedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception is not used.
public struct LoopDetectedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LoopDetectedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LoopDetectedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeClientTypes {
    public enum MessageFormatType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case composite
        case customPayload
        case plainText
        case ssml
        case sdkUnknown(Swift.String)

        public static var allCases: [MessageFormatType] {
            return [
                .composite,
                .customPayload,
                .plainText,
                .ssml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .composite: return "Composite"
            case .customPayload: return "CustomPayload"
            case .plainText: return "PlainText"
            case .ssml: return "SSML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MessageFormatType(rawValue: rawValue) ?? MessageFormatType.sdkUnknown(rawValue)
        }
    }
}

extension NotAcceptableException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotAcceptableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The accept header in the request does not have a valid value.
public struct NotAcceptableException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotAcceptableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotAcceptableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The resource (such as the Amazon Lex bot or an alias) that is referred to is not found.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

public struct PostContentInputBodyMiddleware: ClientRuntime.Middleware {
    public let id: Swift.String = "PostContentInputBodyMiddleware"

    public init() {}

    public func handle<H>(context: Context,
                  input: ClientRuntime.SerializeStepInput<PostContentInput>,
                  next: H) async throws -> ClientRuntime.OperationOutput<PostContentOutputResponse>
    where H: Handler,
    Self.MInput == H.Input,
    Self.MOutput == H.Output,
    Self.Context == H.Context
    {
        if let inputStream = input.operationInput.inputStream {
            let inputStreamdata = inputStream
            let inputStreambody = ClientRuntime.HttpBody.stream(inputStreamdata)
            input.builder.withBody(inputStreambody)
        }
        return try await next.handle(context: context, input: input)
    }

    public typealias MInput = ClientRuntime.SerializeStepInput<PostContentInput>
    public typealias MOutput = ClientRuntime.OperationOutput<PostContentOutputResponse>
    public typealias Context = ClientRuntime.HttpContext
}

extension PostContentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PostContentInput(accept: \(Swift.String(describing: accept)), botAlias: \(Swift.String(describing: botAlias)), botName: \(Swift.String(describing: botName)), contentType: \(Swift.String(describing: contentType)), inputStream: \(Swift.String(describing: inputStream)), userId: \(Swift.String(describing: userId)), activeContexts: \"CONTENT_REDACTED\", requestAttributes: \"CONTENT_REDACTED\", sessionAttributes: \"CONTENT_REDACTED\")"}
}

extension PostContentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputStream
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inputStream = self.inputStream {
            try encodeContainer.encode(inputStream.toBytes().getData(), forKey: .inputStream)
        }
    }
}

extension PostContentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accept = accept {
            items.add(Header(name: "Accept", value: Swift.String(accept)))
        }
        if let activeContexts = activeContexts {
            do {
                let base64EncodedValue = try activeContexts.base64EncodedString()
                items.add(Header(name: "x-amz-lex-active-contexts", value: Swift.String(base64EncodedValue)))
            } catch let err {
            }
        }
        if let contentType = contentType {
            items.add(Header(name: "Content-Type", value: Swift.String(contentType)))
        }
        if let requestAttributes = requestAttributes {
            do {
                let base64EncodedValue = try requestAttributes.base64EncodedString()
                items.add(Header(name: "x-amz-lex-request-attributes", value: Swift.String(base64EncodedValue)))
            } catch let err {
            }
        }
        if let sessionAttributes = sessionAttributes {
            do {
                let base64EncodedValue = try sessionAttributes.base64EncodedString()
                items.add(Header(name: "x-amz-lex-session-attributes", value: Swift.String(base64EncodedValue)))
            } catch let err {
            }
        }
        return items
    }
}

extension PostContentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botName = botName else {
            return nil
        }
        guard let botAlias = botAlias else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/bot/\(botName.urlPercentEncoding())/alias/\(botAlias.urlPercentEncoding())/user/\(userId.urlPercentEncoding())/content"
    }
}

public struct PostContentInput: Swift.Equatable {
    /// You pass this value as the Accept HTTP header. The message Amazon Lex returns in the response can be either text or speech based on the Accept HTTP header value in the request.
    ///
    /// * If the value is text/plain; charset=utf-8, Amazon Lex returns text in the response.
    ///
    /// * If the value begins with audio/, Amazon Lex returns speech in the response. Amazon Lex uses Amazon Polly to generate the speech (using the configuration you specified in the Accept header). For example, if you specify audio/mpeg as the value, Amazon Lex returns speech in the MPEG format.
    ///
    /// * If the value is audio/pcm, the speech returned is audio/pcm in 16-bit, little endian format.
    ///
    /// * The following are the accepted values:
    ///
    /// * audio/mpeg
    ///
    /// * audio/ogg
    ///
    /// * audio/pcm
    ///
    /// * text/plain; charset=utf-8
    ///
    /// * audio/* (defaults to mpeg)
    public var accept: Swift.String?
    /// A list of contexts active for the request. A context can be activated when a previous intent is fulfilled, or by including the context in the request, If you don't specify a list of contexts, Amazon Lex will use the current list of contexts for the session. If you specify an empty list, all contexts for the session are cleared.
    public var activeContexts: Swift.String?
    /// Alias of the Amazon Lex bot.
    /// This member is required.
    public var botAlias: Swift.String?
    /// Name of the Amazon Lex bot.
    /// This member is required.
    public var botName: Swift.String?
    /// You pass this value as the Content-Type HTTP header. Indicates the audio format or text. The header value must start with one of the following prefixes:
    ///
    /// * PCM format, audio data must be in little-endian byte order.
    ///
    /// * audio/l16; rate=16000; channels=1
    ///
    /// * audio/x-l16; sample-rate=16000; channel-count=1
    ///
    /// * audio/lpcm; sample-rate=8000; sample-size-bits=16; channel-count=1; is-big-endian=false
    ///
    ///
    ///
    ///
    /// * Opus format
    ///
    /// * audio/x-cbr-opus-with-preamble; preamble-size=0; bit-rate=256000; frame-size-milliseconds=4
    ///
    ///
    ///
    ///
    /// * Text format
    ///
    /// * text/plain; charset=utf-8
    /// This member is required.
    public var contentType: Swift.String?
    /// User input in PCM or Opus audio format or text format as described in the Content-Type HTTP header. You can stream audio data to Amazon Lex or you can create a local buffer that captures all of the audio data before sending. In general, you get better performance if you stream audio data rather than buffering the data locally.
    /// This member is required.
    public var inputStream: ClientRuntime.ByteStream?
    /// You pass this value as the x-amz-lex-request-attributes HTTP header. Request-specific information passed between Amazon Lex and a client application. The value must be a JSON serialized and base64 encoded map with string keys and values. The total size of the requestAttributes and sessionAttributes headers is limited to 12 KB. The namespace x-amz-lex: is reserved for special attributes. Don't create any request attributes with the prefix x-amz-lex:. For more information, see [Setting Request Attributes](https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-request-attribs).
    public var requestAttributes: Swift.String?
    /// You pass this value as the x-amz-lex-session-attributes HTTP header. Application-specific information passed between Amazon Lex and a client application. The value must be a JSON serialized and base64 encoded map with string keys and values. The total size of the sessionAttributes and requestAttributes headers is limited to 12 KB. For more information, see [Setting Session Attributes](https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-session-attribs).
    public var sessionAttributes: Swift.String?
    /// The ID of the client application user. Amazon Lex uses this to identify a user's conversation with your bot. At runtime, each request must contain the userID field. To decide the user ID to use for your application, consider the following factors.
    ///
    /// * The userID field must not contain any personally identifiable information of the user, for example, name, personal identification numbers, or other end user personal information.
    ///
    /// * If you want a user to start a conversation on one device and continue on another device, use a user-specific identifier.
    ///
    /// * If you want the same user to be able to have two independent conversations on two different devices, choose a device-specific identifier.
    ///
    /// * A user can't have two independent conversations with two different versions of the same bot. For example, a user can't have a conversation with the PROD and BETA versions of the same bot. If you anticipate that a user will need to have conversation with two different versions, for example, while testing, include the bot alias in the user ID to separate the two conversations.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        accept: Swift.String? = nil,
        activeContexts: Swift.String? = nil,
        botAlias: Swift.String? = nil,
        botName: Swift.String? = nil,
        contentType: Swift.String? = nil,
        inputStream: ClientRuntime.ByteStream? = nil,
        requestAttributes: Swift.String? = nil,
        sessionAttributes: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accept = accept
        self.activeContexts = activeContexts
        self.botAlias = botAlias
        self.botName = botName
        self.contentType = contentType
        self.inputStream = inputStream
        self.requestAttributes = requestAttributes
        self.sessionAttributes = sessionAttributes
        self.userId = userId
    }
}

struct PostContentInputBody: Swift.Equatable {
    let inputStream: ClientRuntime.ByteStream?
}

extension PostContentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inputStream
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputStreamDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .inputStream)
        inputStream = inputStreamDecoded
    }
}

extension PostContentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PostContentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadGatewayException" : self = .badGatewayException(try BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyFailedException" : self = .dependencyFailedException(try DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoopDetectedException" : self = .loopDetectedException(try LoopDetectedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAcceptableException" : self = .notAcceptableException(try NotAcceptableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "RequestTimeoutException" : self = .requestTimeoutException(try RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedMediaTypeException" : self = .unsupportedMediaTypeException(try UnsupportedMediaTypeException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PostContentOutputError: Swift.Error, Swift.Equatable {
    case badGatewayException(BadGatewayException)
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case dependencyFailedException(DependencyFailedException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case loopDetectedException(LoopDetectedException)
    case notAcceptableException(NotAcceptableException)
    case notFoundException(NotFoundException)
    case requestTimeoutException(RequestTimeoutException)
    case unsupportedMediaTypeException(UnsupportedMediaTypeException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PostContentOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PostContentOutputResponse(alternativeIntents: \(Swift.String(describing: alternativeIntents)), audioStream: \(Swift.String(describing: audioStream)), botVersion: \(Swift.String(describing: botVersion)), contentType: \(Swift.String(describing: contentType)), dialogState: \(Swift.String(describing: dialogState)), inputTranscript: \(Swift.String(describing: inputTranscript)), intentName: \(Swift.String(describing: intentName)), messageFormat: \(Swift.String(describing: messageFormat)), nluIntentConfidence: \(Swift.String(describing: nluIntentConfidence)), sentimentResponse: \(Swift.String(describing: sentimentResponse)), sessionAttributes: \(Swift.String(describing: sessionAttributes)), sessionId: \(Swift.String(describing: sessionId)), slotToElicit: \(Swift.String(describing: slotToElicit)), slots: \(Swift.String(describing: slots)), activeContexts: \"CONTENT_REDACTED\", encodedInputTranscript: \"CONTENT_REDACTED\", encodedMessage: \"CONTENT_REDACTED\", message: \"CONTENT_REDACTED\")"}
}

extension PostContentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let activeContextsHeaderValue = httpResponse.headers.value(for: "x-amz-lex-active-contexts") {
            self.activeContexts = try activeContextsHeaderValue.base64DecodedString()
        } else {
            self.activeContexts = nil
        }
        if let alternativeIntentsHeaderValue = httpResponse.headers.value(for: "x-amz-lex-alternative-intents") {
            self.alternativeIntents = try alternativeIntentsHeaderValue.base64DecodedString()
        } else {
            self.alternativeIntents = nil
        }
        if let botVersionHeaderValue = httpResponse.headers.value(for: "x-amz-lex-bot-version") {
            self.botVersion = botVersionHeaderValue
        } else {
            self.botVersion = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let dialogStateHeaderValue = httpResponse.headers.value(for: "x-amz-lex-dialog-state") {
            self.dialogState = LexRuntimeClientTypes.DialogState(rawValue: dialogStateHeaderValue)
        } else {
            self.dialogState = nil
        }
        if let encodedInputTranscriptHeaderValue = httpResponse.headers.value(for: "x-amz-lex-encoded-input-transcript") {
            self.encodedInputTranscript = encodedInputTranscriptHeaderValue
        } else {
            self.encodedInputTranscript = nil
        }
        if let encodedMessageHeaderValue = httpResponse.headers.value(for: "x-amz-lex-encoded-message") {
            self.encodedMessage = encodedMessageHeaderValue
        } else {
            self.encodedMessage = nil
        }
        if let inputTranscriptHeaderValue = httpResponse.headers.value(for: "x-amz-lex-input-transcript") {
            self.inputTranscript = inputTranscriptHeaderValue
        } else {
            self.inputTranscript = nil
        }
        if let intentNameHeaderValue = httpResponse.headers.value(for: "x-amz-lex-intent-name") {
            self.intentName = intentNameHeaderValue
        } else {
            self.intentName = nil
        }
        if let messageHeaderValue = httpResponse.headers.value(for: "x-amz-lex-message") {
            self.message = messageHeaderValue
        } else {
            self.message = nil
        }
        if let messageFormatHeaderValue = httpResponse.headers.value(for: "x-amz-lex-message-format") {
            self.messageFormat = LexRuntimeClientTypes.MessageFormatType(rawValue: messageFormatHeaderValue)
        } else {
            self.messageFormat = nil
        }
        if let nluIntentConfidenceHeaderValue = httpResponse.headers.value(for: "x-amz-lex-nlu-intent-confidence") {
            self.nluIntentConfidence = try nluIntentConfidenceHeaderValue.base64DecodedString()
        } else {
            self.nluIntentConfidence = nil
        }
        if let sentimentResponseHeaderValue = httpResponse.headers.value(for: "x-amz-lex-sentiment") {
            self.sentimentResponse = sentimentResponseHeaderValue
        } else {
            self.sentimentResponse = nil
        }
        if let sessionAttributesHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-attributes") {
            self.sessionAttributes = try sessionAttributesHeaderValue.base64DecodedString()
        } else {
            self.sessionAttributes = nil
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-id") {
            self.sessionId = sessionIdHeaderValue
        } else {
            self.sessionId = nil
        }
        if let slotToElicitHeaderValue = httpResponse.headers.value(for: "x-amz-lex-slot-to-elicit") {
            self.slotToElicit = slotToElicitHeaderValue
        } else {
            self.slotToElicit = nil
        }
        if let slotsHeaderValue = httpResponse.headers.value(for: "x-amz-lex-slots") {
            self.slots = try slotsHeaderValue.base64DecodedString()
        } else {
            self.slots = nil
        }
        if let data = httpResponse.body.toBytes()?.getData() {
            self.audioStream = ByteStream.from(data: data)
        } else {
            self.audioStream = nil
        }
    }
}

public struct PostContentOutputResponse: Swift.Equatable {
    /// A list of active contexts for the session. A context can be set when an intent is fulfilled or by calling the PostContent, PostText, or PutSession operation. You can use a context to control the intents that can follow up an intent, or to modify the operation of your application.
    public var activeContexts: Swift.String?
    /// One to four alternative intents that may be applicable to the user's intent. Each alternative includes a score that indicates how confident Amazon Lex is that the intent matches the user's intent. The intents are sorted by the confidence score.
    public var alternativeIntents: Swift.String?
    /// The prompt (or statement) to convey to the user. This is based on the bot configuration and context. For example, if Amazon Lex did not understand the user intent, it sends the clarificationPrompt configured for the bot. If the intent requires confirmation before taking the fulfillment action, it sends the confirmationPrompt. Another example: Suppose that the Lambda function successfully fulfilled the intent, and sent a message to convey to the user. Then Amazon Lex sends that message in the response.
    public var audioStream: ClientRuntime.ByteStream?
    /// The version of the bot that responded to the conversation. You can use this information to help determine if one version of a bot is performing better than another version.
    public var botVersion: Swift.String?
    /// Content type as specified in the Accept HTTP header in the request.
    public var contentType: Swift.String?
    /// Identifies the current state of the user interaction. Amazon Lex returns one of the following values as dialogState. The client can optionally use this information to customize the user interface.
    ///
    /// * ElicitIntent - Amazon Lex wants to elicit the user's intent. Consider the following examples: For example, a user might utter an intent ("I want to order a pizza"). If Amazon Lex cannot infer the user intent from this utterance, it will return this dialog state.
    ///
    /// * ConfirmIntent - Amazon Lex is expecting a "yes" or "no" response. For example, Amazon Lex wants user confirmation before fulfilling an intent. Instead of a simple "yes" or "no" response, a user might respond with additional information. For example, "yes, but make it a thick crust pizza" or "no, I want to order a drink." Amazon Lex can process such additional information (in these examples, update the crust type slot or change the intent from OrderPizza to OrderDrink).
    ///
    /// * ElicitSlot - Amazon Lex is expecting the value of a slot for the current intent. For example, suppose that in the response Amazon Lex sends this message: "What size pizza would you like?". A user might reply with the slot value (e.g., "medium"). The user might also provide additional information in the response (e.g., "medium thick crust pizza"). Amazon Lex can process such additional information appropriately.
    ///
    /// * Fulfilled - Conveys that the Lambda function has successfully fulfilled the intent.
    ///
    /// * ReadyForFulfillment - Conveys that the client has to fulfill the request.
    ///
    /// * Failed - Conveys that the conversation with the user failed. This can happen for various reasons, including that the user does not provide an appropriate response to prompts from the service (you can configure how many times Amazon Lex can prompt a user for specific information), or if the Lambda function fails to fulfill the intent.
    public var dialogState: LexRuntimeClientTypes.DialogState?
    /// The text used to process the request. If the input was an audio stream, the encodedInputTranscript field contains the text extracted from the audio stream. This is the text that is actually processed to recognize intents and slot values. You can use this information to determine if Amazon Lex is correctly processing the audio that you send. The encodedInputTranscript field is base-64 encoded. You must decode the field before you can use the value.
    public var encodedInputTranscript: Swift.String?
    /// The message to convey to the user. The message can come from the bot's configuration or from a Lambda function. If the intent is not configured with a Lambda function, or if the Lambda function returned Delegate as the dialogAction.type in its response, Amazon Lex decides on the next course of action and selects an appropriate message from the bot's configuration based on the current interaction context. For example, if Amazon Lex isn't able to understand user input, it uses a clarification prompt message. When you create an intent you can assign messages to groups. When messages are assigned to groups Amazon Lex returns one message from each group in the response. The message field is an escaped JSON string containing the messages. For more information about the structure of the JSON string returned, see [msg-prompts-formats]. If the Lambda function returns a message, Amazon Lex passes it to the client in its response. The encodedMessage field is base-64 encoded. You must decode the field before you can use the value.
    public var encodedMessage: Swift.String?
    /// The text used to process the request. You can use this field only in the de-DE, en-AU, en-GB, en-US, es-419, es-ES, es-US, fr-CA, fr-FR, and it-IT locales. In all other locales, the inputTranscript field is null. You should use the encodedInputTranscript field instead. If the input was an audio stream, the inputTranscript field contains the text extracted from the audio stream. This is the text that is actually processed to recognize intents and slot values. You can use this information to determine if Amazon Lex is correctly processing the audio that you send.
    @available(*, deprecated, message: "The inputTranscript field is deprecated, use the encodedInputTranscript field instead. The inputTranscript field is available only in the de-DE, en-AU, en-GB, en-US, es-419, es-ES, es-US, fr-CA, fr-FR and it-IT locales.")
    public var inputTranscript: Swift.String?
    /// Current user intent that Amazon Lex is aware of.
    public var intentName: Swift.String?
    /// You can only use this field in the de-DE, en-AU, en-GB, en-US, es-419, es-ES, es-US, fr-CA, fr-FR, and it-IT locales. In all other locales, the message field is null. You should use the encodedMessage field instead. The message to convey to the user. The message can come from the bot's configuration or from a Lambda function. If the intent is not configured with a Lambda function, or if the Lambda function returned Delegate as the dialogAction.type in its response, Amazon Lex decides on the next course of action and selects an appropriate message from the bot's configuration based on the current interaction context. For example, if Amazon Lex isn't able to understand user input, it uses a clarification prompt message. When you create an intent you can assign messages to groups. When messages are assigned to groups Amazon Lex returns one message from each group in the response. The message field is an escaped JSON string containing the messages. For more information about the structure of the JSON string returned, see [msg-prompts-formats]. If the Lambda function returns a message, Amazon Lex passes it to the client in its response.
    @available(*, deprecated, message: "The message field is deprecated, use the encodedMessage field instead. The message field is available only in the de-DE, en-AU, en-GB, en-US, es-419, es-ES, es-US, fr-CA, fr-FR and it-IT locales.")
    public var message: Swift.String?
    /// The format of the response message. One of the following values:
    ///
    /// * PlainText - The message contains plain UTF-8 text.
    ///
    /// * CustomPayload - The message is a custom format for the client.
    ///
    /// * SSML - The message contains text formatted for voice output.
    ///
    /// * Composite - The message contains an escaped JSON object containing one or more messages from the groups that messages were assigned to when the intent was created.
    public var messageFormat: LexRuntimeClientTypes.MessageFormatType?
    /// Provides a score that indicates how confident Amazon Lex is that the returned intent is the one that matches the user's intent. The score is between 0.0 and 1.0. The score is a relative score, not an absolute score. The score may change based on improvements to Amazon Lex.
    public var nluIntentConfidence: Swift.String?
    /// The sentiment expressed in an utterance. When the bot is configured to send utterances to Amazon Comprehend for sentiment analysis, this field contains the result of the analysis.
    public var sentimentResponse: Swift.String?
    /// Map of key/value pairs representing the session-specific context information.
    public var sessionAttributes: Swift.String?
    /// The unique identifier for the session.
    public var sessionId: Swift.String?
    /// If the dialogState value is ElicitSlot, returns the name of the slot for which Amazon Lex is eliciting a value.
    public var slotToElicit: Swift.String?
    /// Map of zero or more intent slots (name/value pairs) Amazon Lex detected from the user input during the conversation. The field is base-64 encoded. Amazon Lex creates a resolution list containing likely values for a slot. The value that it returns is determined by the valueSelectionStrategy selected when the slot type was created or updated. If valueSelectionStrategy is set to ORIGINAL_VALUE, the value provided by the user is returned, if the user value is similar to the slot values. If valueSelectionStrategy is set to TOP_RESOLUTION Amazon Lex returns the first value in the resolution list or, if there is no resolution list, null. If you don't specify a valueSelectionStrategy, the default is ORIGINAL_VALUE.
    public var slots: Swift.String?

    public init (
        activeContexts: Swift.String? = nil,
        alternativeIntents: Swift.String? = nil,
        audioStream: ClientRuntime.ByteStream? = nil,
        botVersion: Swift.String? = nil,
        contentType: Swift.String? = nil,
        dialogState: LexRuntimeClientTypes.DialogState? = nil,
        encodedInputTranscript: Swift.String? = nil,
        encodedMessage: Swift.String? = nil,
        inputTranscript: Swift.String? = nil,
        intentName: Swift.String? = nil,
        message: Swift.String? = nil,
        messageFormat: LexRuntimeClientTypes.MessageFormatType? = nil,
        nluIntentConfidence: Swift.String? = nil,
        sentimentResponse: Swift.String? = nil,
        sessionAttributes: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        slotToElicit: Swift.String? = nil,
        slots: Swift.String? = nil
    )
    {
        self.activeContexts = activeContexts
        self.alternativeIntents = alternativeIntents
        self.audioStream = audioStream
        self.botVersion = botVersion
        self.contentType = contentType
        self.dialogState = dialogState
        self.encodedInputTranscript = encodedInputTranscript
        self.encodedMessage = encodedMessage
        self.inputTranscript = inputTranscript
        self.intentName = intentName
        self.message = message
        self.messageFormat = messageFormat
        self.nluIntentConfidence = nluIntentConfidence
        self.sentimentResponse = sentimentResponse
        self.sessionAttributes = sessionAttributes
        self.sessionId = sessionId
        self.slotToElicit = slotToElicit
        self.slots = slots
    }
}

struct PostContentOutputResponseBody: Swift.Equatable {
    let audioStream: ClientRuntime.ByteStream?
}

extension PostContentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioStream
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioStreamDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .audioStream)
        audioStream = audioStreamDecoded
    }
}

extension PostTextInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PostTextInput(botAlias: \(Swift.String(describing: botAlias)), botName: \(Swift.String(describing: botName)), userId: \(Swift.String(describing: userId)), activeContexts: \"CONTENT_REDACTED\", inputText: \"CONTENT_REDACTED\", requestAttributes: \"CONTENT_REDACTED\", sessionAttributes: \"CONTENT_REDACTED\")"}
}

extension PostTextInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeContexts
        case inputText
        case requestAttributes
        case sessionAttributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeContexts = activeContexts {
            var activeContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .activeContexts)
            for activecontext0 in activeContexts {
                try activeContextsContainer.encode(activecontext0)
            }
        }
        if let inputText = self.inputText {
            try encodeContainer.encode(inputText, forKey: .inputText)
        }
        if let requestAttributes = requestAttributes {
            var requestAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .requestAttributes)
            for (dictKey0, stringMap0) in requestAttributes {
                try requestAttributesContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sessionAttributes = sessionAttributes {
            var sessionAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sessionAttributes)
            for (dictKey0, stringMap0) in sessionAttributes {
                try sessionAttributesContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension PostTextInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botName = botName else {
            return nil
        }
        guard let botAlias = botAlias else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/bot/\(botName.urlPercentEncoding())/alias/\(botAlias.urlPercentEncoding())/user/\(userId.urlPercentEncoding())/text"
    }
}

public struct PostTextInput: Swift.Equatable {
    /// A list of contexts active for the request. A context can be activated when a previous intent is fulfilled, or by including the context in the request, If you don't specify a list of contexts, Amazon Lex will use the current list of contexts for the session. If you specify an empty list, all contexts for the session are cleared.
    public var activeContexts: [LexRuntimeClientTypes.ActiveContext]?
    /// The alias of the Amazon Lex bot.
    /// This member is required.
    public var botAlias: Swift.String?
    /// The name of the Amazon Lex bot.
    /// This member is required.
    public var botName: Swift.String?
    /// The text that the user entered (Amazon Lex interprets this text).
    /// This member is required.
    public var inputText: Swift.String?
    /// Request-specific information passed between Amazon Lex and a client application. The namespace x-amz-lex: is reserved for special attributes. Don't create any request attributes with the prefix x-amz-lex:. For more information, see [Setting Request Attributes](https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-request-attribs).
    public var requestAttributes: [Swift.String:Swift.String]?
    /// Application-specific information passed between Amazon Lex and a client application. For more information, see [Setting Session Attributes](https://docs.aws.amazon.com/lex/latest/dg/context-mgmt.html#context-mgmt-session-attribs).
    public var sessionAttributes: [Swift.String:Swift.String]?
    /// The ID of the client application user. Amazon Lex uses this to identify a user's conversation with your bot. At runtime, each request must contain the userID field. To decide the user ID to use for your application, consider the following factors.
    ///
    /// * The userID field must not contain any personally identifiable information of the user, for example, name, personal identification numbers, or other end user personal information.
    ///
    /// * If you want a user to start a conversation on one device and continue on another device, use a user-specific identifier.
    ///
    /// * If you want the same user to be able to have two independent conversations on two different devices, choose a device-specific identifier.
    ///
    /// * A user can't have two independent conversations with two different versions of the same bot. For example, a user can't have a conversation with the PROD and BETA versions of the same bot. If you anticipate that a user will need to have conversation with two different versions, for example, while testing, include the bot alias in the user ID to separate the two conversations.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        activeContexts: [LexRuntimeClientTypes.ActiveContext]? = nil,
        botAlias: Swift.String? = nil,
        botName: Swift.String? = nil,
        inputText: Swift.String? = nil,
        requestAttributes: [Swift.String:Swift.String]? = nil,
        sessionAttributes: [Swift.String:Swift.String]? = nil,
        userId: Swift.String? = nil
    )
    {
        self.activeContexts = activeContexts
        self.botAlias = botAlias
        self.botName = botName
        self.inputText = inputText
        self.requestAttributes = requestAttributes
        self.sessionAttributes = sessionAttributes
        self.userId = userId
    }
}

struct PostTextInputBody: Swift.Equatable {
    let sessionAttributes: [Swift.String:Swift.String]?
    let requestAttributes: [Swift.String:Swift.String]?
    let inputText: Swift.String?
    let activeContexts: [LexRuntimeClientTypes.ActiveContext]?
}

extension PostTextInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeContexts
        case inputText
        case requestAttributes
        case sessionAttributes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sessionAttributes)
        var sessionAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let sessionAttributesContainer = sessionAttributesContainer {
            sessionAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in sessionAttributesContainer {
                if let string0 = string0 {
                    sessionAttributesDecoded0?[key0] = string0
                }
            }
        }
        sessionAttributes = sessionAttributesDecoded0
        let requestAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .requestAttributes)
        var requestAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let requestAttributesContainer = requestAttributesContainer {
            requestAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in requestAttributesContainer {
                if let string0 = string0 {
                    requestAttributesDecoded0?[key0] = string0
                }
            }
        }
        requestAttributes = requestAttributesDecoded0
        let inputTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputText)
        inputText = inputTextDecoded
        let activeContextsContainer = try containerValues.decodeIfPresent([LexRuntimeClientTypes.ActiveContext?].self, forKey: .activeContexts)
        var activeContextsDecoded0:[LexRuntimeClientTypes.ActiveContext]? = nil
        if let activeContextsContainer = activeContextsContainer {
            activeContextsDecoded0 = [LexRuntimeClientTypes.ActiveContext]()
            for structure0 in activeContextsContainer {
                if let structure0 = structure0 {
                    activeContextsDecoded0?.append(structure0)
                }
            }
        }
        activeContexts = activeContextsDecoded0
    }
}

extension PostTextOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PostTextOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadGatewayException" : self = .badGatewayException(try BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyFailedException" : self = .dependencyFailedException(try DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LoopDetectedException" : self = .loopDetectedException(try LoopDetectedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PostTextOutputError: Swift.Error, Swift.Equatable {
    case badGatewayException(BadGatewayException)
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case dependencyFailedException(DependencyFailedException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case loopDetectedException(LoopDetectedException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PostTextOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PostTextOutputResponse(alternativeIntents: \(Swift.String(describing: alternativeIntents)), botVersion: \(Swift.String(describing: botVersion)), dialogState: \(Swift.String(describing: dialogState)), intentName: \(Swift.String(describing: intentName)), messageFormat: \(Swift.String(describing: messageFormat)), nluIntentConfidence: \(Swift.String(describing: nluIntentConfidence)), responseCard: \(Swift.String(describing: responseCard)), sentimentResponse: \(Swift.String(describing: sentimentResponse)), sessionId: \(Swift.String(describing: sessionId)), slotToElicit: \(Swift.String(describing: slotToElicit)), activeContexts: \"CONTENT_REDACTED\", message: \"CONTENT_REDACTED\", sessionAttributes: \"CONTENT_REDACTED\", slots: \"CONTENT_REDACTED\")"}
}

extension PostTextOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: PostTextOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activeContexts = output.activeContexts
            self.alternativeIntents = output.alternativeIntents
            self.botVersion = output.botVersion
            self.dialogState = output.dialogState
            self.intentName = output.intentName
            self.message = output.message
            self.messageFormat = output.messageFormat
            self.nluIntentConfidence = output.nluIntentConfidence
            self.responseCard = output.responseCard
            self.sentimentResponse = output.sentimentResponse
            self.sessionAttributes = output.sessionAttributes
            self.sessionId = output.sessionId
            self.slotToElicit = output.slotToElicit
            self.slots = output.slots
        } else {
            self.activeContexts = nil
            self.alternativeIntents = nil
            self.botVersion = nil
            self.dialogState = nil
            self.intentName = nil
            self.message = nil
            self.messageFormat = nil
            self.nluIntentConfidence = nil
            self.responseCard = nil
            self.sentimentResponse = nil
            self.sessionAttributes = nil
            self.sessionId = nil
            self.slotToElicit = nil
            self.slots = nil
        }
    }
}

public struct PostTextOutputResponse: Swift.Equatable {
    /// A list of active contexts for the session. A context can be set when an intent is fulfilled or by calling the PostContent, PostText, or PutSession operation. You can use a context to control the intents that can follow up an intent, or to modify the operation of your application.
    public var activeContexts: [LexRuntimeClientTypes.ActiveContext]?
    /// One to four alternative intents that may be applicable to the user's intent. Each alternative includes a score that indicates how confident Amazon Lex is that the intent matches the user's intent. The intents are sorted by the confidence score.
    public var alternativeIntents: [LexRuntimeClientTypes.PredictedIntent]?
    /// The version of the bot that responded to the conversation. You can use this information to help determine if one version of a bot is performing better than another version.
    public var botVersion: Swift.String?
    /// Identifies the current state of the user interaction. Amazon Lex returns one of the following values as dialogState. The client can optionally use this information to customize the user interface.
    ///
    /// * ElicitIntent - Amazon Lex wants to elicit user intent. For example, a user might utter an intent ("I want to order a pizza"). If Amazon Lex cannot infer the user intent from this utterance, it will return this dialogState.
    ///
    /// * ConfirmIntent - Amazon Lex is expecting a "yes" or "no" response. For example, Amazon Lex wants user confirmation before fulfilling an intent. Instead of a simple "yes" or "no," a user might respond with additional information. For example, "yes, but make it thick crust pizza" or "no, I want to order a drink". Amazon Lex can process such additional information (in these examples, update the crust type slot value, or change intent from OrderPizza to OrderDrink).
    ///
    /// * ElicitSlot - Amazon Lex is expecting a slot value for the current intent. For example, suppose that in the response Amazon Lex sends this message: "What size pizza would you like?". A user might reply with the slot value (e.g., "medium"). The user might also provide additional information in the response (e.g., "medium thick crust pizza"). Amazon Lex can process such additional information appropriately.
    ///
    /// * Fulfilled - Conveys that the Lambda function configured for the intent has successfully fulfilled the intent.
    ///
    /// * ReadyForFulfillment - Conveys that the client has to fulfill the intent.
    ///
    /// * Failed - Conveys that the conversation with the user failed. This can happen for various reasons including that the user did not provide an appropriate response to prompts from the service (you can configure how many times Amazon Lex can prompt a user for specific information), or the Lambda function failed to fulfill the intent.
    public var dialogState: LexRuntimeClientTypes.DialogState?
    /// The current user intent that Amazon Lex is aware of.
    public var intentName: Swift.String?
    /// The message to convey to the user. The message can come from the bot's configuration or from a Lambda function. If the intent is not configured with a Lambda function, or if the Lambda function returned Delegate as the dialogAction.type its response, Amazon Lex decides on the next course of action and selects an appropriate message from the bot's configuration based on the current interaction context. For example, if Amazon Lex isn't able to understand user input, it uses a clarification prompt message. When you create an intent you can assign messages to groups. When messages are assigned to groups Amazon Lex returns one message from each group in the response. The message field is an escaped JSON string containing the messages. For more information about the structure of the JSON string returned, see [msg-prompts-formats]. If the Lambda function returns a message, Amazon Lex passes it to the client in its response.
    public var message: Swift.String?
    /// The format of the response message. One of the following values:
    ///
    /// * PlainText - The message contains plain UTF-8 text.
    ///
    /// * CustomPayload - The message is a custom format defined by the Lambda function.
    ///
    /// * SSML - The message contains text formatted for voice output.
    ///
    /// * Composite - The message contains an escaped JSON object containing one or more messages from the groups that messages were assigned to when the intent was created.
    public var messageFormat: LexRuntimeClientTypes.MessageFormatType?
    /// Provides a score that indicates how confident Amazon Lex is that the returned intent is the one that matches the user's intent. The score is between 0.0 and 1.0. For more information, see [Confidence Scores](https://docs.aws.amazon.com/lex/latest/dg/confidence-scores.html). The score is a relative score, not an absolute score. The score may change based on improvements to Amazon Lex.
    public var nluIntentConfidence: LexRuntimeClientTypes.IntentConfidence?
    /// Represents the options that the user has to respond to the current prompt. Response Card can come from the bot configuration (in the Amazon Lex console, choose the settings button next to a slot) or from a code hook (Lambda function).
    public var responseCard: LexRuntimeClientTypes.ResponseCard?
    /// The sentiment expressed in and utterance. When the bot is configured to send utterances to Amazon Comprehend for sentiment analysis, this field contains the result of the analysis.
    public var sentimentResponse: LexRuntimeClientTypes.SentimentResponse?
    /// A map of key-value pairs representing the session-specific context information.
    public var sessionAttributes: [Swift.String:Swift.String]?
    /// A unique identifier for the session.
    public var sessionId: Swift.String?
    /// If the dialogState value is ElicitSlot, returns the name of the slot for which Amazon Lex is eliciting a value.
    public var slotToElicit: Swift.String?
    /// The intent slots that Amazon Lex detected from the user input in the conversation. Amazon Lex creates a resolution list containing likely values for a slot. The value that it returns is determined by the valueSelectionStrategy selected when the slot type was created or updated. If valueSelectionStrategy is set to ORIGINAL_VALUE, the value provided by the user is returned, if the user value is similar to the slot values. If valueSelectionStrategy is set to TOP_RESOLUTION Amazon Lex returns the first value in the resolution list or, if there is no resolution list, null. If you don't specify a valueSelectionStrategy, the default is ORIGINAL_VALUE.
    public var slots: [Swift.String:Swift.String]?

    public init (
        activeContexts: [LexRuntimeClientTypes.ActiveContext]? = nil,
        alternativeIntents: [LexRuntimeClientTypes.PredictedIntent]? = nil,
        botVersion: Swift.String? = nil,
        dialogState: LexRuntimeClientTypes.DialogState? = nil,
        intentName: Swift.String? = nil,
        message: Swift.String? = nil,
        messageFormat: LexRuntimeClientTypes.MessageFormatType? = nil,
        nluIntentConfidence: LexRuntimeClientTypes.IntentConfidence? = nil,
        responseCard: LexRuntimeClientTypes.ResponseCard? = nil,
        sentimentResponse: LexRuntimeClientTypes.SentimentResponse? = nil,
        sessionAttributes: [Swift.String:Swift.String]? = nil,
        sessionId: Swift.String? = nil,
        slotToElicit: Swift.String? = nil,
        slots: [Swift.String:Swift.String]? = nil
    )
    {
        self.activeContexts = activeContexts
        self.alternativeIntents = alternativeIntents
        self.botVersion = botVersion
        self.dialogState = dialogState
        self.intentName = intentName
        self.message = message
        self.messageFormat = messageFormat
        self.nluIntentConfidence = nluIntentConfidence
        self.responseCard = responseCard
        self.sentimentResponse = sentimentResponse
        self.sessionAttributes = sessionAttributes
        self.sessionId = sessionId
        self.slotToElicit = slotToElicit
        self.slots = slots
    }
}

struct PostTextOutputResponseBody: Swift.Equatable {
    let intentName: Swift.String?
    let nluIntentConfidence: LexRuntimeClientTypes.IntentConfidence?
    let alternativeIntents: [LexRuntimeClientTypes.PredictedIntent]?
    let slots: [Swift.String:Swift.String]?
    let sessionAttributes: [Swift.String:Swift.String]?
    let message: Swift.String?
    let sentimentResponse: LexRuntimeClientTypes.SentimentResponse?
    let messageFormat: LexRuntimeClientTypes.MessageFormatType?
    let dialogState: LexRuntimeClientTypes.DialogState?
    let slotToElicit: Swift.String?
    let responseCard: LexRuntimeClientTypes.ResponseCard?
    let sessionId: Swift.String?
    let botVersion: Swift.String?
    let activeContexts: [LexRuntimeClientTypes.ActiveContext]?
}

extension PostTextOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeContexts
        case alternativeIntents
        case botVersion
        case dialogState
        case intentName
        case message
        case messageFormat
        case nluIntentConfidence
        case responseCard
        case sentimentResponse
        case sessionAttributes
        case sessionId
        case slotToElicit
        case slots
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let nluIntentConfidenceDecoded = try containerValues.decodeIfPresent(LexRuntimeClientTypes.IntentConfidence.self, forKey: .nluIntentConfidence)
        nluIntentConfidence = nluIntentConfidenceDecoded
        let alternativeIntentsContainer = try containerValues.decodeIfPresent([LexRuntimeClientTypes.PredictedIntent?].self, forKey: .alternativeIntents)
        var alternativeIntentsDecoded0:[LexRuntimeClientTypes.PredictedIntent]? = nil
        if let alternativeIntentsContainer = alternativeIntentsContainer {
            alternativeIntentsDecoded0 = [LexRuntimeClientTypes.PredictedIntent]()
            for structure0 in alternativeIntentsContainer {
                if let structure0 = structure0 {
                    alternativeIntentsDecoded0?.append(structure0)
                }
            }
        }
        alternativeIntents = alternativeIntentsDecoded0
        let slotsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .slots)
        var slotsDecoded0: [Swift.String:Swift.String]? = nil
        if let slotsContainer = slotsContainer {
            slotsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in slotsContainer {
                if let string0 = string0 {
                    slotsDecoded0?[key0] = string0
                }
            }
        }
        slots = slotsDecoded0
        let sessionAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sessionAttributes)
        var sessionAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let sessionAttributesContainer = sessionAttributesContainer {
            sessionAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in sessionAttributesContainer {
                if let string0 = string0 {
                    sessionAttributesDecoded0?[key0] = string0
                }
            }
        }
        sessionAttributes = sessionAttributesDecoded0
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let sentimentResponseDecoded = try containerValues.decodeIfPresent(LexRuntimeClientTypes.SentimentResponse.self, forKey: .sentimentResponse)
        sentimentResponse = sentimentResponseDecoded
        let messageFormatDecoded = try containerValues.decodeIfPresent(LexRuntimeClientTypes.MessageFormatType.self, forKey: .messageFormat)
        messageFormat = messageFormatDecoded
        let dialogStateDecoded = try containerValues.decodeIfPresent(LexRuntimeClientTypes.DialogState.self, forKey: .dialogState)
        dialogState = dialogStateDecoded
        let slotToElicitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .slotToElicit)
        slotToElicit = slotToElicitDecoded
        let responseCardDecoded = try containerValues.decodeIfPresent(LexRuntimeClientTypes.ResponseCard.self, forKey: .responseCard)
        responseCard = responseCardDecoded
        let sessionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionId)
        sessionId = sessionIdDecoded
        let botVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .botVersion)
        botVersion = botVersionDecoded
        let activeContextsContainer = try containerValues.decodeIfPresent([LexRuntimeClientTypes.ActiveContext?].self, forKey: .activeContexts)
        var activeContextsDecoded0:[LexRuntimeClientTypes.ActiveContext]? = nil
        if let activeContextsContainer = activeContextsContainer {
            activeContextsDecoded0 = [LexRuntimeClientTypes.ActiveContext]()
            for structure0 in activeContextsContainer {
                if let structure0 = structure0 {
                    activeContextsDecoded0?.append(structure0)
                }
            }
        }
        activeContexts = activeContextsDecoded0
    }
}

extension LexRuntimeClientTypes.PredictedIntent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case intentName
        case nluIntentConfidence
        case slots
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let intentName = self.intentName {
            try encodeContainer.encode(intentName, forKey: .intentName)
        }
        if let nluIntentConfidence = self.nluIntentConfidence {
            try encodeContainer.encode(nluIntentConfidence, forKey: .nluIntentConfidence)
        }
        if let slots = slots {
            var slotsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .slots)
            for (dictKey0, stringMap0) in slots {
                try slotsContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .intentName)
        intentName = intentNameDecoded
        let nluIntentConfidenceDecoded = try containerValues.decodeIfPresent(LexRuntimeClientTypes.IntentConfidence.self, forKey: .nluIntentConfidence)
        nluIntentConfidence = nluIntentConfidenceDecoded
        let slotsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .slots)
        var slotsDecoded0: [Swift.String:Swift.String]? = nil
        if let slotsContainer = slotsContainer {
            slotsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in slotsContainer {
                if let string0 = string0 {
                    slotsDecoded0?[key0] = string0
                }
            }
        }
        slots = slotsDecoded0
    }
}

extension LexRuntimeClientTypes.PredictedIntent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PredictedIntent(intentName: \(Swift.String(describing: intentName)), nluIntentConfidence: \(Swift.String(describing: nluIntentConfidence)), slots: \"CONTENT_REDACTED\")"}
}

extension LexRuntimeClientTypes {
    /// An intent that Amazon Lex suggests satisfies the user's intent. Includes the name of the intent, the confidence that Amazon Lex has that the user's intent is satisfied, and the slots defined for the intent.
    public struct PredictedIntent: Swift.Equatable {
        /// The name of the intent that Amazon Lex suggests satisfies the user's intent.
        public var intentName: Swift.String?
        /// Indicates how confident Amazon Lex is that an intent satisfies the user's intent.
        public var nluIntentConfidence: LexRuntimeClientTypes.IntentConfidence?
        /// The slot and slot values associated with the predicted intent.
        public var slots: [Swift.String:Swift.String]?

        public init (
            intentName: Swift.String? = nil,
            nluIntentConfidence: LexRuntimeClientTypes.IntentConfidence? = nil,
            slots: [Swift.String:Swift.String]? = nil
        )
        {
            self.intentName = intentName
            self.nluIntentConfidence = nluIntentConfidence
            self.slots = slots
        }
    }

}

extension PutSessionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSessionInput(accept: \(Swift.String(describing: accept)), botAlias: \(Swift.String(describing: botAlias)), botName: \(Swift.String(describing: botName)), dialogAction: \(Swift.String(describing: dialogAction)), recentIntentSummaryView: \(Swift.String(describing: recentIntentSummaryView)), userId: \(Swift.String(describing: userId)), activeContexts: \"CONTENT_REDACTED\", sessionAttributes: \"CONTENT_REDACTED\")"}
}

extension PutSessionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeContexts
        case dialogAction
        case recentIntentSummaryView
        case sessionAttributes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeContexts = activeContexts {
            var activeContextsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .activeContexts)
            for activecontext0 in activeContexts {
                try activeContextsContainer.encode(activecontext0)
            }
        }
        if let dialogAction = self.dialogAction {
            try encodeContainer.encode(dialogAction, forKey: .dialogAction)
        }
        if let recentIntentSummaryView = recentIntentSummaryView {
            var recentIntentSummaryViewContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recentIntentSummaryView)
            for intentsummary0 in recentIntentSummaryView {
                try recentIntentSummaryViewContainer.encode(intentsummary0)
            }
        }
        if let sessionAttributes = sessionAttributes {
            var sessionAttributesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sessionAttributes)
            for (dictKey0, stringMap0) in sessionAttributes {
                try sessionAttributesContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension PutSessionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let accept = accept {
            items.add(Header(name: "Accept", value: Swift.String(accept)))
        }
        return items
    }
}

extension PutSessionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let botName = botName else {
            return nil
        }
        guard let botAlias = botAlias else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/bot/\(botName.urlPercentEncoding())/alias/\(botAlias.urlPercentEncoding())/user/\(userId.urlPercentEncoding())/session"
    }
}

public struct PutSessionInput: Swift.Equatable {
    /// The message that Amazon Lex returns in the response can be either text or speech based depending on the value of this field.
    ///
    /// * If the value is text/plain; charset=utf-8, Amazon Lex returns text in the response.
    ///
    /// * If the value begins with audio/, Amazon Lex returns speech in the response. Amazon Lex uses Amazon Polly to generate the speech in the configuration that you specify. For example, if you specify audio/mpeg as the value, Amazon Lex returns speech in the MPEG format.
    ///
    /// * If the value is audio/pcm, the speech is returned as audio/pcm in 16-bit, little endian format.
    ///
    /// * The following are the accepted values:
    ///
    /// * audio/mpeg
    ///
    /// * audio/ogg
    ///
    /// * audio/pcm
    ///
    /// * audio/* (defaults to mpeg)
    ///
    /// * text/plain; charset=utf-8
    public var accept: Swift.String?
    /// A list of contexts active for the request. A context can be activated when a previous intent is fulfilled, or by including the context in the request, If you don't specify a list of contexts, Amazon Lex will use the current list of contexts for the session. If you specify an empty list, all contexts for the session are cleared.
    public var activeContexts: [LexRuntimeClientTypes.ActiveContext]?
    /// The alias in use for the bot that contains the session data.
    /// This member is required.
    public var botAlias: Swift.String?
    /// The name of the bot that contains the session data.
    /// This member is required.
    public var botName: Swift.String?
    /// Sets the next action that the bot should take to fulfill the conversation.
    public var dialogAction: LexRuntimeClientTypes.DialogAction?
    /// A summary of the recent intents for the bot. You can use the intent summary view to set a checkpoint label on an intent and modify attributes of intents. You can also use it to remove or add intent summary objects to the list. An intent that you modify or add to the list must make sense for the bot. For example, the intent name must be valid for the bot. You must provide valid values for:
    ///
    /// * intentName
    ///
    /// * slot names
    ///
    /// * slotToElict
    ///
    ///
    /// If you send the recentIntentSummaryView parameter in a PutSession request, the contents of the new summary view replaces the old summary view. For example, if a GetSession request returns three intents in the summary view and you call PutSession with one intent in the summary view, the next call to GetSession will only return one intent.
    public var recentIntentSummaryView: [LexRuntimeClientTypes.IntentSummary]?
    /// Map of key/value pairs representing the session-specific context information. It contains application information passed between Amazon Lex and a client application.
    public var sessionAttributes: [Swift.String:Swift.String]?
    /// The ID of the client application user. Amazon Lex uses this to identify a user's conversation with your bot.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        accept: Swift.String? = nil,
        activeContexts: [LexRuntimeClientTypes.ActiveContext]? = nil,
        botAlias: Swift.String? = nil,
        botName: Swift.String? = nil,
        dialogAction: LexRuntimeClientTypes.DialogAction? = nil,
        recentIntentSummaryView: [LexRuntimeClientTypes.IntentSummary]? = nil,
        sessionAttributes: [Swift.String:Swift.String]? = nil,
        userId: Swift.String? = nil
    )
    {
        self.accept = accept
        self.activeContexts = activeContexts
        self.botAlias = botAlias
        self.botName = botName
        self.dialogAction = dialogAction
        self.recentIntentSummaryView = recentIntentSummaryView
        self.sessionAttributes = sessionAttributes
        self.userId = userId
    }
}

struct PutSessionInputBody: Swift.Equatable {
    let sessionAttributes: [Swift.String:Swift.String]?
    let dialogAction: LexRuntimeClientTypes.DialogAction?
    let recentIntentSummaryView: [LexRuntimeClientTypes.IntentSummary]?
    let activeContexts: [LexRuntimeClientTypes.ActiveContext]?
}

extension PutSessionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeContexts
        case dialogAction
        case recentIntentSummaryView
        case sessionAttributes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sessionAttributesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sessionAttributes)
        var sessionAttributesDecoded0: [Swift.String:Swift.String]? = nil
        if let sessionAttributesContainer = sessionAttributesContainer {
            sessionAttributesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in sessionAttributesContainer {
                if let string0 = string0 {
                    sessionAttributesDecoded0?[key0] = string0
                }
            }
        }
        sessionAttributes = sessionAttributesDecoded0
        let dialogActionDecoded = try containerValues.decodeIfPresent(LexRuntimeClientTypes.DialogAction.self, forKey: .dialogAction)
        dialogAction = dialogActionDecoded
        let recentIntentSummaryViewContainer = try containerValues.decodeIfPresent([LexRuntimeClientTypes.IntentSummary?].self, forKey: .recentIntentSummaryView)
        var recentIntentSummaryViewDecoded0:[LexRuntimeClientTypes.IntentSummary]? = nil
        if let recentIntentSummaryViewContainer = recentIntentSummaryViewContainer {
            recentIntentSummaryViewDecoded0 = [LexRuntimeClientTypes.IntentSummary]()
            for structure0 in recentIntentSummaryViewContainer {
                if let structure0 = structure0 {
                    recentIntentSummaryViewDecoded0?.append(structure0)
                }
            }
        }
        recentIntentSummaryView = recentIntentSummaryViewDecoded0
        let activeContextsContainer = try containerValues.decodeIfPresent([LexRuntimeClientTypes.ActiveContext?].self, forKey: .activeContexts)
        var activeContextsDecoded0:[LexRuntimeClientTypes.ActiveContext]? = nil
        if let activeContextsContainer = activeContextsContainer {
            activeContextsDecoded0 = [LexRuntimeClientTypes.ActiveContext]()
            for structure0 in activeContextsContainer {
                if let structure0 = structure0 {
                    activeContextsDecoded0?.append(structure0)
                }
            }
        }
        activeContexts = activeContextsDecoded0
    }
}

extension PutSessionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutSessionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadGatewayException" : self = .badGatewayException(try BadGatewayException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DependencyFailedException" : self = .dependencyFailedException(try DependencyFailedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalFailureException" : self = .internalFailureException(try InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAcceptableException" : self = .notAcceptableException(try NotAcceptableException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutSessionOutputError: Swift.Error, Swift.Equatable {
    case badGatewayException(BadGatewayException)
    case badRequestException(BadRequestException)
    case conflictException(ConflictException)
    case dependencyFailedException(DependencyFailedException)
    case internalFailureException(InternalFailureException)
    case limitExceededException(LimitExceededException)
    case notAcceptableException(NotAcceptableException)
    case notFoundException(NotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutSessionOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutSessionOutputResponse(audioStream: \(Swift.String(describing: audioStream)), contentType: \(Swift.String(describing: contentType)), dialogState: \(Swift.String(describing: dialogState)), intentName: \(Swift.String(describing: intentName)), messageFormat: \(Swift.String(describing: messageFormat)), sessionAttributes: \(Swift.String(describing: sessionAttributes)), sessionId: \(Swift.String(describing: sessionId)), slotToElicit: \(Swift.String(describing: slotToElicit)), slots: \(Swift.String(describing: slots)), activeContexts: \"CONTENT_REDACTED\", encodedMessage: \"CONTENT_REDACTED\", message: \"CONTENT_REDACTED\")"}
}

extension PutSessionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if let activeContextsHeaderValue = httpResponse.headers.value(for: "x-amz-lex-active-contexts") {
            self.activeContexts = try activeContextsHeaderValue.base64DecodedString()
        } else {
            self.activeContexts = nil
        }
        if let contentTypeHeaderValue = httpResponse.headers.value(for: "Content-Type") {
            self.contentType = contentTypeHeaderValue
        } else {
            self.contentType = nil
        }
        if let dialogStateHeaderValue = httpResponse.headers.value(for: "x-amz-lex-dialog-state") {
            self.dialogState = LexRuntimeClientTypes.DialogState(rawValue: dialogStateHeaderValue)
        } else {
            self.dialogState = nil
        }
        if let encodedMessageHeaderValue = httpResponse.headers.value(for: "x-amz-lex-encoded-message") {
            self.encodedMessage = encodedMessageHeaderValue
        } else {
            self.encodedMessage = nil
        }
        if let intentNameHeaderValue = httpResponse.headers.value(for: "x-amz-lex-intent-name") {
            self.intentName = intentNameHeaderValue
        } else {
            self.intentName = nil
        }
        if let messageHeaderValue = httpResponse.headers.value(for: "x-amz-lex-message") {
            self.message = messageHeaderValue
        } else {
            self.message = nil
        }
        if let messageFormatHeaderValue = httpResponse.headers.value(for: "x-amz-lex-message-format") {
            self.messageFormat = LexRuntimeClientTypes.MessageFormatType(rawValue: messageFormatHeaderValue)
        } else {
            self.messageFormat = nil
        }
        if let sessionAttributesHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-attributes") {
            self.sessionAttributes = try sessionAttributesHeaderValue.base64DecodedString()
        } else {
            self.sessionAttributes = nil
        }
        if let sessionIdHeaderValue = httpResponse.headers.value(for: "x-amz-lex-session-id") {
            self.sessionId = sessionIdHeaderValue
        } else {
            self.sessionId = nil
        }
        if let slotToElicitHeaderValue = httpResponse.headers.value(for: "x-amz-lex-slot-to-elicit") {
            self.slotToElicit = slotToElicitHeaderValue
        } else {
            self.slotToElicit = nil
        }
        if let slotsHeaderValue = httpResponse.headers.value(for: "x-amz-lex-slots") {
            self.slots = try slotsHeaderValue.base64DecodedString()
        } else {
            self.slots = nil
        }
        if let data = httpResponse.body.toBytes()?.getData() {
            self.audioStream = ByteStream.from(data: data)
        } else {
            self.audioStream = nil
        }
    }
}

public struct PutSessionOutputResponse: Swift.Equatable {
    /// A list of active contexts for the session.
    public var activeContexts: Swift.String?
    /// The audio version of the message to convey to the user.
    public var audioStream: ClientRuntime.ByteStream?
    /// Content type as specified in the Accept HTTP header in the request.
    public var contentType: Swift.String?
    /// * ConfirmIntent - Amazon Lex is expecting a "yes" or "no" response to confirm the intent before fulfilling an intent.
    ///
    /// * ElicitIntent - Amazon Lex wants to elicit the user's intent.
    ///
    /// * ElicitSlot - Amazon Lex is expecting the value of a slot for the current intent.
    ///
    /// * Failed - Conveys that the conversation with the user has failed. This can happen for various reasons, including the user does not provide an appropriate response to prompts from the service, or if the Lambda function fails to fulfill the intent.
    ///
    /// * Fulfilled - Conveys that the Lambda function has sucessfully fulfilled the intent.
    ///
    /// * ReadyForFulfillment - Conveys that the client has to fulfill the intent.
    public var dialogState: LexRuntimeClientTypes.DialogState?
    /// The next message that should be presented to the user. The encodedMessage field is base-64 encoded. You must decode the field before you can use the value.
    public var encodedMessage: Swift.String?
    /// The name of the current intent.
    public var intentName: Swift.String?
    /// The next message that should be presented to the user. You can only use this field in the de-DE, en-AU, en-GB, en-US, es-419, es-ES, es-US, fr-CA, fr-FR, and it-IT locales. In all other locales, the message field is null. You should use the encodedMessage field instead.
    @available(*, deprecated, message: "The message field is deprecated, use the encodedMessage field instead. The message field is available only in the de-DE, en-AU, en-GB, en-US, es-419, es-ES, es-US, fr-CA, fr-FR and it-IT locales.")
    public var message: Swift.String?
    /// The format of the response message. One of the following values:
    ///
    /// * PlainText - The message contains plain UTF-8 text.
    ///
    /// * CustomPayload - The message is a custom format for the client.
    ///
    /// * SSML - The message contains text formatted for voice output.
    ///
    /// * Composite - The message contains an escaped JSON object containing one or more messages from the groups that messages were assigned to when the intent was created.
    public var messageFormat: LexRuntimeClientTypes.MessageFormatType?
    /// Map of key/value pairs representing session-specific context information.
    public var sessionAttributes: Swift.String?
    /// A unique identifier for the session.
    public var sessionId: Swift.String?
    /// If the dialogState is ElicitSlot, returns the name of the slot for which Amazon Lex is eliciting a value.
    public var slotToElicit: Swift.String?
    /// Map of zero or more intent slots Amazon Lex detected from the user input during the conversation. Amazon Lex creates a resolution list containing likely values for a slot. The value that it returns is determined by the valueSelectionStrategy selected when the slot type was created or updated. If valueSelectionStrategy is set to ORIGINAL_VALUE, the value provided by the user is returned, if the user value is similar to the slot values. If valueSelectionStrategy is set to TOP_RESOLUTION Amazon Lex returns the first value in the resolution list or, if there is no resolution list, null. If you don't specify a valueSelectionStrategy the default is ORIGINAL_VALUE.
    public var slots: Swift.String?

    public init (
        activeContexts: Swift.String? = nil,
        audioStream: ClientRuntime.ByteStream? = nil,
        contentType: Swift.String? = nil,
        dialogState: LexRuntimeClientTypes.DialogState? = nil,
        encodedMessage: Swift.String? = nil,
        intentName: Swift.String? = nil,
        message: Swift.String? = nil,
        messageFormat: LexRuntimeClientTypes.MessageFormatType? = nil,
        sessionAttributes: Swift.String? = nil,
        sessionId: Swift.String? = nil,
        slotToElicit: Swift.String? = nil,
        slots: Swift.String? = nil
    )
    {
        self.activeContexts = activeContexts
        self.audioStream = audioStream
        self.contentType = contentType
        self.dialogState = dialogState
        self.encodedMessage = encodedMessage
        self.intentName = intentName
        self.message = message
        self.messageFormat = messageFormat
        self.sessionAttributes = sessionAttributes
        self.sessionId = sessionId
        self.slotToElicit = slotToElicit
        self.slots = slots
    }
}

struct PutSessionOutputResponseBody: Swift.Equatable {
    let audioStream: ClientRuntime.ByteStream?
}

extension PutSessionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case audioStream
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let audioStreamDecoded = try containerValues.decodeIfPresent(ClientRuntime.ByteStream.self, forKey: .audioStream)
        audioStream = audioStreamDecoded
    }
}

extension RequestTimeoutException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RequestTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input speech is too long.
public struct RequestTimeoutException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct RequestTimeoutExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RequestTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LexRuntimeClientTypes.ResponseCard: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contentType
        case genericAttachments
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType.rawValue, forKey: .contentType)
        }
        if let genericAttachments = genericAttachments {
            var genericAttachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .genericAttachments)
            for genericattachment0 in genericAttachments {
                try genericAttachmentsContainer.encode(genericattachment0)
            }
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(LexRuntimeClientTypes.ContentType.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let genericAttachmentsContainer = try containerValues.decodeIfPresent([LexRuntimeClientTypes.GenericAttachment?].self, forKey: .genericAttachments)
        var genericAttachmentsDecoded0:[LexRuntimeClientTypes.GenericAttachment]? = nil
        if let genericAttachmentsContainer = genericAttachmentsContainer {
            genericAttachmentsDecoded0 = [LexRuntimeClientTypes.GenericAttachment]()
            for structure0 in genericAttachmentsContainer {
                if let structure0 = structure0 {
                    genericAttachmentsDecoded0?.append(structure0)
                }
            }
        }
        genericAttachments = genericAttachmentsDecoded0
    }
}

extension LexRuntimeClientTypes {
    /// If you configure a response card when creating your bots, Amazon Lex substitutes the session attributes and slot values that are available, and then returns it. The response card can also come from a Lambda function ( dialogCodeHook and fulfillmentActivity on an intent).
    public struct ResponseCard: Swift.Equatable {
        /// The content type of the response.
        public var contentType: LexRuntimeClientTypes.ContentType?
        /// An array of attachment objects representing options.
        public var genericAttachments: [LexRuntimeClientTypes.GenericAttachment]?
        /// The version of the response card format.
        public var version: Swift.String?

        public init (
            contentType: LexRuntimeClientTypes.ContentType? = nil,
            genericAttachments: [LexRuntimeClientTypes.GenericAttachment]? = nil,
            version: Swift.String? = nil
        )
        {
            self.contentType = contentType
            self.genericAttachments = genericAttachments
            self.version = version
        }
    }

}

extension LexRuntimeClientTypes.SentimentResponse: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sentimentLabel
        case sentimentScore
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sentimentLabel = self.sentimentLabel {
            try encodeContainer.encode(sentimentLabel, forKey: .sentimentLabel)
        }
        if let sentimentScore = self.sentimentScore {
            try encodeContainer.encode(sentimentScore, forKey: .sentimentScore)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sentimentLabelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sentimentLabel)
        sentimentLabel = sentimentLabelDecoded
        let sentimentScoreDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sentimentScore)
        sentimentScore = sentimentScoreDecoded
    }
}

extension LexRuntimeClientTypes {
    /// The sentiment expressed in an utterance. When the bot is configured to send utterances to Amazon Comprehend for sentiment analysis, this field structure contains the result of the analysis.
    public struct SentimentResponse: Swift.Equatable {
        /// The inferred sentiment that Amazon Comprehend has the highest confidence in.
        public var sentimentLabel: Swift.String?
        /// The likelihood that the sentiment was correctly inferred.
        public var sentimentScore: Swift.String?

        public init (
            sentimentLabel: Swift.String? = nil,
            sentimentScore: Swift.String? = nil
        )
        {
            self.sentimentLabel = sentimentLabel
            self.sentimentScore = sentimentScore
        }
    }

}

extension UnsupportedMediaTypeException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnsupportedMediaTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Content-Type header (PostContent API) has an invalid value.
public struct UnsupportedMediaTypeException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedMediaTypeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedMediaTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
