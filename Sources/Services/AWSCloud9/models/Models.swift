// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.className = output.className
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.className = nil
            self.properties.code = 0
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The target request is invalid.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var className: Swift.String? = nil
        public internal(set) var code: Swift.Int = 0
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        className: Swift.String? = nil,
        code: Swift.Int = 0,
        message: Swift.String? = nil
    )
    {
        self.properties.className = className
        self.properties.code = code
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let className: Swift.String?
    let code: Swift.Int
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case className
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let classNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .className)
        className = classNameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .code) ?? 0
        code = codeDecoded
    }
}

extension ConcurrentAccessException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConcurrentAccessExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.className = output.className
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.className = nil
            self.properties.code = 0
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A concurrent access issue occurred.
public struct ConcurrentAccessException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var className: Swift.String? = nil
        public internal(set) var code: Swift.Int = 0
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentAccessException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        className: Swift.String? = nil,
        code: Swift.Int = 0,
        message: Swift.String? = nil
    )
    {
        self.properties.className = className
        self.properties.code = code
        self.properties.message = message
    }
}

struct ConcurrentAccessExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let className: Swift.String?
    let code: Swift.Int
}

extension ConcurrentAccessExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case className
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let classNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .className)
        className = classNameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .code) ?? 0
        code = codeDecoded
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.className = output.className
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.className = nil
            self.properties.code = 0
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A conflict occurred.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var className: Swift.String? = nil
        public internal(set) var code: Swift.Int = 0
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        className: Swift.String? = nil,
        code: Swift.Int = 0,
        message: Swift.String? = nil
    )
    {
        self.properties.className = className
        self.properties.code = code
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let className: Swift.String?
    let code: Swift.Int
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case className
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let classNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .className)
        className = classNameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .code) ?? 0
        code = codeDecoded
    }
}

extension Cloud9ClientTypes {
    public enum ConnectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connectSsh
        case connectSsm
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionType] {
            return [
                .connectSsh,
                .connectSsm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connectSsh: return "CONNECT_SSH"
            case .connectSsm: return "CONNECT_SSM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionType(rawValue: rawValue) ?? ConnectionType.sdkUnknown(rawValue)
        }
    }
}

extension CreateEnvironmentEC2Input: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentEC2Input(automaticStopTimeMinutes: \(Swift.String(describing: automaticStopTimeMinutes)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), connectionType: \(Swift.String(describing: connectionType)), dryRun: \(Swift.String(describing: dryRun)), imageId: \(Swift.String(describing: imageId)), instanceType: \(Swift.String(describing: instanceType)), name: \(Swift.String(describing: name)), ownerArn: \(Swift.String(describing: ownerArn)), subnetId: \(Swift.String(describing: subnetId)), description: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension CreateEnvironmentEC2Input: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticStopTimeMinutes
        case clientRequestToken
        case connectionType
        case description
        case dryRun
        case imageId
        case instanceType
        case name
        case ownerArn
        case subnetId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let automaticStopTimeMinutes = self.automaticStopTimeMinutes {
            try encodeContainer.encode(automaticStopTimeMinutes, forKey: .automaticStopTimeMinutes)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let connectionType = self.connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let dryRun = self.dryRun {
            try encodeContainer.encode(dryRun, forKey: .dryRun)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerArn = self.ownerArn {
            try encodeContainer.encode(ownerArn, forKey: .ownerArn)
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateEnvironmentEC2Input: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateEnvironmentEC2Input: Swift.Equatable {
    /// The number of minutes until the running instance is shut down after the environment has last been used.
    public var automaticStopTimeMinutes: Swift.Int?
    /// A unique, case-sensitive string that helps Cloud9 to ensure this operation completes no more than one time. For more information, see [Client Tokens](https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Run_Instance_Idempotency.html) in the Amazon EC2 API Reference.
    public var clientRequestToken: Swift.String?
    /// The connection type used for connecting to an Amazon EC2 environment. Valid values are CONNECT_SSH (default) and CONNECT_SSM (connected through Amazon EC2 Systems Manager). For more information, see [Accessing no-ingress EC2 instances with Amazon EC2 Systems Manager](https://docs.aws.amazon.com/cloud9/latest/user-guide/ec2-ssm.html) in the Cloud9 User Guide.
    public var connectionType: Cloud9ClientTypes.ConnectionType?
    /// The description of the environment to create.
    public var description: Swift.String?
    /// Checks whether you have the required permissions for the action, without actually making the request, and provides an error response. If you have the required permissions, the error response is DryRunOperation. Otherwise, it is UnauthorizedOperation.
    public var dryRun: Swift.Bool?
    /// The identifier for the Amazon Machine Image (AMI) that's used to create the EC2 instance. To choose an AMI for the instance, you must specify a valid AMI alias or a valid Amazon EC2 Systems Manager (SSM) path. The default Amazon Linux AMI is currently used if the parameter isn't explicitly assigned a value in the request. Because Amazon Linux AMI has ended standard support as of December 31, 2020, we recommend you choose Amazon Linux 2, which includes long term support through 2023. From December 31, 2023, the parameter for Amazon Linux will no longer be available when you specify an AMI for your instance. Amazon Linux 2 will then become the default AMI, which is used to launch your instance if no parameter is explicitly defined. Since Ubuntu 18.04 has ended standard support as of May 31, 2023, we recommend you choose Ubuntu 22.04. AMI aliases
    ///
    /// * Amazon Linux (default): amazonlinux-1-x86_64
    ///
    /// * Amazon Linux 2: amazonlinux-2-x86_64
    ///
    /// * Ubuntu 18.04: ubuntu-18.04-x86_64
    ///
    /// * Ubuntu 22.04: ubuntu-22.04-x86_64
    ///
    ///
    /// SSM paths
    ///
    /// * Amazon Linux (default): resolve:ssm:/aws/service/cloud9/amis/amazonlinux-1-x86_64
    ///
    /// * Amazon Linux 2: resolve:ssm:/aws/service/cloud9/amis/amazonlinux-2-x86_64
    ///
    /// * Ubuntu 18.04: resolve:ssm:/aws/service/cloud9/amis/ubuntu-18.04-x86_64
    ///
    /// * Ubuntu 22.04: resolve:ssm:/aws/service/cloud9/amis/ubuntu-22.04-x86_64
    public var imageId: Swift.String?
    /// The type of instance to connect to the environment (for example, t2.micro).
    /// This member is required.
    public var instanceType: Swift.String?
    /// The name of the environment to create. This name is visible to other IAM users in the same Amazon Web Services account.
    /// This member is required.
    public var name: Swift.String?
    /// The Amazon Resource Name (ARN) of the environment owner. This ARN can be the ARN of any IAM principal. If this value is not specified, the ARN defaults to this environment's creator.
    public var ownerArn: Swift.String?
    /// The ID of the subnet in Amazon VPC that Cloud9 will use to communicate with the Amazon EC2 instance.
    public var subnetId: Swift.String?
    /// An array of key-value pairs that will be associated with the new Cloud9 development environment.
    public var tags: [Cloud9ClientTypes.Tag]?

    public init(
        automaticStopTimeMinutes: Swift.Int? = nil,
        clientRequestToken: Swift.String? = nil,
        connectionType: Cloud9ClientTypes.ConnectionType? = nil,
        description: Swift.String? = nil,
        dryRun: Swift.Bool? = nil,
        imageId: Swift.String? = nil,
        instanceType: Swift.String? = nil,
        name: Swift.String? = nil,
        ownerArn: Swift.String? = nil,
        subnetId: Swift.String? = nil,
        tags: [Cloud9ClientTypes.Tag]? = nil
    )
    {
        self.automaticStopTimeMinutes = automaticStopTimeMinutes
        self.clientRequestToken = clientRequestToken
        self.connectionType = connectionType
        self.description = description
        self.dryRun = dryRun
        self.imageId = imageId
        self.instanceType = instanceType
        self.name = name
        self.ownerArn = ownerArn
        self.subnetId = subnetId
        self.tags = tags
    }
}

struct CreateEnvironmentEC2InputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let clientRequestToken: Swift.String?
    let instanceType: Swift.String?
    let subnetId: Swift.String?
    let imageId: Swift.String?
    let automaticStopTimeMinutes: Swift.Int?
    let ownerArn: Swift.String?
    let tags: [Cloud9ClientTypes.Tag]?
    let connectionType: Cloud9ClientTypes.ConnectionType?
    let dryRun: Swift.Bool?
}

extension CreateEnvironmentEC2InputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case automaticStopTimeMinutes
        case clientRequestToken
        case connectionType
        case description
        case dryRun
        case imageId
        case instanceType
        case name
        case ownerArn
        case subnetId
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let automaticStopTimeMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .automaticStopTimeMinutes)
        automaticStopTimeMinutes = automaticStopTimeMinutesDecoded
        let ownerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerArn)
        ownerArn = ownerArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Cloud9ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[Cloud9ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Cloud9ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let connectionTypeDecoded = try containerValues.decodeIfPresent(Cloud9ClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let dryRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .dryRun)
        dryRun = dryRunDecoded
    }
}

extension CreateEnvironmentEC2Output: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEnvironmentEC2OutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentId = output.environmentId
        } else {
            self.environmentId = nil
        }
    }
}

public struct CreateEnvironmentEC2Output: Swift.Equatable {
    /// The ID of the environment that was created.
    public var environmentId: Swift.String?

    public init(
        environmentId: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

struct CreateEnvironmentEC2OutputBody: Swift.Equatable {
    let environmentId: Swift.String?
}

extension CreateEnvironmentEC2OutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
    }
}

enum CreateEnvironmentEC2OutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateEnvironmentMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
        case permissions
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let permissions = self.permissions {
            try encodeContainer.encode(permissions.rawValue, forKey: .permissions)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension CreateEnvironmentMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateEnvironmentMembershipInput: Swift.Equatable {
    /// The ID of the environment that contains the environment member you want to add.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The type of environment member permissions you want to associate with this environment member. Available values include:
    ///
    /// * read-only: Has read-only access to the environment.
    ///
    /// * read-write: Has read-write access to the environment.
    /// This member is required.
    public var permissions: Cloud9ClientTypes.MemberPermissions?
    /// The Amazon Resource Name (ARN) of the environment member you want to add.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        permissions: Cloud9ClientTypes.MemberPermissions? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.permissions = permissions
        self.userArn = userArn
    }
}

struct CreateEnvironmentMembershipInputBody: Swift.Equatable {
    let environmentId: Swift.String?
    let userArn: Swift.String?
    let permissions: Cloud9ClientTypes.MemberPermissions?
}

extension CreateEnvironmentMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
        case permissions
        case userArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let permissionsDecoded = try containerValues.decodeIfPresent(Cloud9ClientTypes.MemberPermissions.self, forKey: .permissions)
        permissions = permissionsDecoded
    }
}

extension CreateEnvironmentMembershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEnvironmentMembershipOutputBody = try responseDecoder.decode(responseBody: data)
            self.membership = output.membership
        } else {
            self.membership = nil
        }
    }
}

public struct CreateEnvironmentMembershipOutput: Swift.Equatable {
    /// Information about the environment member that was added.
    /// This member is required.
    public var membership: Cloud9ClientTypes.EnvironmentMember?

    public init(
        membership: Cloud9ClientTypes.EnvironmentMember? = nil
    )
    {
        self.membership = membership
    }
}

struct CreateEnvironmentMembershipOutputBody: Swift.Equatable {
    let membership: Cloud9ClientTypes.EnvironmentMember?
}

extension CreateEnvironmentMembershipOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case membership
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membershipDecoded = try containerValues.decodeIfPresent(Cloud9ClientTypes.EnvironmentMember.self, forKey: .membership)
        membership = membershipDecoded
    }
}

enum CreateEnvironmentMembershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
    }
}

extension DeleteEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEnvironmentInput: Swift.Equatable {
    /// The ID of the environment to delete.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        environmentId: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

struct DeleteEnvironmentInputBody: Swift.Equatable {
    let environmentId: Swift.String?
}

extension DeleteEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
    }
}

extension DeleteEnvironmentMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension DeleteEnvironmentMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteEnvironmentMembershipInput: Swift.Equatable {
    /// The ID of the environment to delete the environment member from.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The Amazon Resource Name (ARN) of the environment member to delete from the environment.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.userArn = userArn
    }
}

struct DeleteEnvironmentMembershipInputBody: Swift.Equatable {
    let environmentId: Swift.String?
    let userArn: Swift.String?
}

extension DeleteEnvironmentMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
        case userArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension DeleteEnvironmentMembershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEnvironmentMembershipOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEnvironmentMembershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEnvironmentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEnvironmentMembershipsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
        case maxResults
        case nextToken
        case permissions
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissions = permissions {
            var permissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .permissions)
            for permissions0 in permissions {
                try permissionsContainer.encode(permissions0.rawValue)
            }
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension DescribeEnvironmentMembershipsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEnvironmentMembershipsInput: Swift.Equatable {
    /// The ID of the environment to get environment member information about.
    public var environmentId: Swift.String?
    /// The maximum number of environment members to get information about.
    public var maxResults: Swift.Int?
    /// During a previous call, if there are more than 25 items in the list, only the first 25 items are returned, along with a unique string called a next token. To get the next batch of items in the list, call this operation again, adding the next token to the call. To get all of the items in the list, keep calling this operation with each subsequent next token that is returned, until no more next tokens are returned.
    public var nextToken: Swift.String?
    /// The type of environment member permissions to get information about. Available values include:
    ///
    /// * owner: Owns the environment.
    ///
    /// * read-only: Has read-only access to the environment.
    ///
    /// * read-write: Has read-write access to the environment.
    ///
    ///
    /// If no value is specified, information about all environment members are returned.
    public var permissions: [Cloud9ClientTypes.Permissions]?
    /// The Amazon Resource Name (ARN) of an individual environment member to get information about. If no value is specified, information about all environment members are returned.
    public var userArn: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissions: [Cloud9ClientTypes.Permissions]? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissions = permissions
        self.userArn = userArn
    }
}

struct DescribeEnvironmentMembershipsInputBody: Swift.Equatable {
    let userArn: Swift.String?
    let environmentId: Swift.String?
    let permissions: [Cloud9ClientTypes.Permissions]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeEnvironmentMembershipsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
        case maxResults
        case nextToken
        case permissions
        case userArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let permissionsContainer = try containerValues.decodeIfPresent([Cloud9ClientTypes.Permissions?].self, forKey: .permissions)
        var permissionsDecoded0:[Cloud9ClientTypes.Permissions]? = nil
        if let permissionsContainer = permissionsContainer {
            permissionsDecoded0 = [Cloud9ClientTypes.Permissions]()
            for enum0 in permissionsContainer {
                if let enum0 = enum0 {
                    permissionsDecoded0?.append(enum0)
                }
            }
        }
        permissions = permissionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeEnvironmentMembershipsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEnvironmentMembershipsOutputBody = try responseDecoder.decode(responseBody: data)
            self.memberships = output.memberships
            self.nextToken = output.nextToken
        } else {
            self.memberships = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEnvironmentMembershipsOutput: Swift.Equatable {
    /// Information about the environment members for the environment.
    public var memberships: [Cloud9ClientTypes.EnvironmentMember]?
    /// If there are more than 25 items in the list, only the first 25 items are returned, along with a unique string called a next token. To get the next batch of items in the list, call this operation again, adding the next token to the call.
    public var nextToken: Swift.String?

    public init(
        memberships: [Cloud9ClientTypes.EnvironmentMember]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.memberships = memberships
        self.nextToken = nextToken
    }
}

struct DescribeEnvironmentMembershipsOutputBody: Swift.Equatable {
    let memberships: [Cloud9ClientTypes.EnvironmentMember]?
    let nextToken: Swift.String?
}

extension DescribeEnvironmentMembershipsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberships
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membershipsContainer = try containerValues.decodeIfPresent([Cloud9ClientTypes.EnvironmentMember?].self, forKey: .memberships)
        var membershipsDecoded0:[Cloud9ClientTypes.EnvironmentMember]? = nil
        if let membershipsContainer = membershipsContainer {
            membershipsDecoded0 = [Cloud9ClientTypes.EnvironmentMember]()
            for structure0 in membershipsContainer {
                if let structure0 = structure0 {
                    membershipsDecoded0?.append(structure0)
                }
            }
        }
        memberships = membershipsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeEnvironmentMembershipsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEnvironmentStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
    }
}

extension DescribeEnvironmentStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEnvironmentStatusInput: Swift.Equatable {
    /// The ID of the environment to get status information about.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        environmentId: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
    }
}

struct DescribeEnvironmentStatusInputBody: Swift.Equatable {
    let environmentId: Swift.String?
}

extension DescribeEnvironmentStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
    }
}

extension DescribeEnvironmentStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEnvironmentStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.status = output.status
        } else {
            self.message = nil
            self.status = nil
        }
    }
}

public struct DescribeEnvironmentStatusOutput: Swift.Equatable {
    /// Any informational message about the status of the environment.
    /// This member is required.
    public var message: Swift.String?
    /// The status of the environment. Available values include:
    ///
    /// * connecting: The environment is connecting.
    ///
    /// * creating: The environment is being created.
    ///
    /// * deleting: The environment is being deleted.
    ///
    /// * error: The environment is in an error state.
    ///
    /// * ready: The environment is ready.
    ///
    /// * stopped: The environment is stopped.
    ///
    /// * stopping: The environment is stopping.
    /// This member is required.
    public var status: Cloud9ClientTypes.EnvironmentStatus?

    public init(
        message: Swift.String? = nil,
        status: Cloud9ClientTypes.EnvironmentStatus? = nil
    )
    {
        self.message = message
        self.status = status
    }
}

struct DescribeEnvironmentStatusOutputBody: Swift.Equatable {
    let status: Cloud9ClientTypes.EnvironmentStatus?
    let message: Swift.String?
}

extension DescribeEnvironmentStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Cloud9ClientTypes.EnvironmentStatus.self, forKey: .status)
        status = statusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

enum DescribeEnvironmentStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEnvironmentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentIds = environmentIds {
            var environmentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .environmentIds)
            for environmentid0 in environmentIds {
                try environmentIdsContainer.encode(environmentid0)
            }
        }
    }
}

extension DescribeEnvironmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEnvironmentsInput: Swift.Equatable {
    /// The IDs of individual environments to get information about.
    /// This member is required.
    public var environmentIds: [Swift.String]?

    public init(
        environmentIds: [Swift.String]? = nil
    )
    {
        self.environmentIds = environmentIds
    }
}

struct DescribeEnvironmentsInputBody: Swift.Equatable {
    let environmentIds: [Swift.String]?
}

extension DescribeEnvironmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .environmentIds)
        var environmentIdsDecoded0:[Swift.String]? = nil
        if let environmentIdsContainer = environmentIdsContainer {
            environmentIdsDecoded0 = [Swift.String]()
            for string0 in environmentIdsContainer {
                if let string0 = string0 {
                    environmentIdsDecoded0?.append(string0)
                }
            }
        }
        environmentIds = environmentIdsDecoded0
    }
}

extension DescribeEnvironmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEnvironmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.environments = output.environments
        } else {
            self.environments = nil
        }
    }
}

public struct DescribeEnvironmentsOutput: Swift.Equatable {
    /// Information about the environments that are returned.
    public var environments: [Cloud9ClientTypes.Environment]?

    public init(
        environments: [Cloud9ClientTypes.Environment]? = nil
    )
    {
        self.environments = environments
    }
}

struct DescribeEnvironmentsOutputBody: Swift.Equatable {
    let environments: [Cloud9ClientTypes.Environment]?
}

extension DescribeEnvironmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environments
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentsContainer = try containerValues.decodeIfPresent([Cloud9ClientTypes.Environment?].self, forKey: .environments)
        var environmentsDecoded0:[Cloud9ClientTypes.Environment]? = nil
        if let environmentsContainer = environmentsContainer {
            environmentsDecoded0 = [Cloud9ClientTypes.Environment]()
            for structure0 in environmentsContainer {
                if let structure0 = structure0 {
                    environmentsDecoded0?.append(structure0)
                }
            }
        }
        environments = environmentsDecoded0
    }
}

enum DescribeEnvironmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Cloud9ClientTypes.Environment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case connectionType
        case description
        case id
        case lifecycle
        case managedCredentialsStatus
        case name
        case ownerArn
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let connectionType = self.connectionType {
            try encodeContainer.encode(connectionType.rawValue, forKey: .connectionType)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lifecycle = self.lifecycle {
            try encodeContainer.encode(lifecycle, forKey: .lifecycle)
        }
        if let managedCredentialsStatus = self.managedCredentialsStatus {
            try encodeContainer.encode(managedCredentialsStatus.rawValue, forKey: .managedCredentialsStatus)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerArn = self.ownerArn {
            try encodeContainer.encode(ownerArn, forKey: .ownerArn)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Cloud9ClientTypes.EnvironmentType.self, forKey: .type)
        type = typeDecoded
        let connectionTypeDecoded = try containerValues.decodeIfPresent(Cloud9ClientTypes.ConnectionType.self, forKey: .connectionType)
        connectionType = connectionTypeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let ownerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerArn)
        ownerArn = ownerArnDecoded
        let lifecycleDecoded = try containerValues.decodeIfPresent(Cloud9ClientTypes.EnvironmentLifecycle.self, forKey: .lifecycle)
        lifecycle = lifecycleDecoded
        let managedCredentialsStatusDecoded = try containerValues.decodeIfPresent(Cloud9ClientTypes.ManagedCredentialsStatus.self, forKey: .managedCredentialsStatus)
        managedCredentialsStatus = managedCredentialsStatusDecoded
    }
}

extension Cloud9ClientTypes.Environment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Environment(arn: \(Swift.String(describing: arn)), connectionType: \(Swift.String(describing: connectionType)), id: \(Swift.String(describing: id)), lifecycle: \(Swift.String(describing: lifecycle)), managedCredentialsStatus: \(Swift.String(describing: managedCredentialsStatus)), name: \(Swift.String(describing: name)), ownerArn: \(Swift.String(describing: ownerArn)), type: \(Swift.String(describing: type)), description: \"CONTENT_REDACTED\")"}
}

extension Cloud9ClientTypes {
    /// Information about an Cloud9 development environment.
    public struct Environment: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the environment.
        /// This member is required.
        public var arn: Swift.String?
        /// The connection type used for connecting to an Amazon EC2 environment. CONNECT_SSH is selected by default.
        public var connectionType: Cloud9ClientTypes.ConnectionType?
        /// The description for the environment.
        public var description: Swift.String?
        /// The ID of the environment.
        public var id: Swift.String?
        /// The state of the environment in its creation or deletion lifecycle.
        public var lifecycle: Cloud9ClientTypes.EnvironmentLifecycle?
        /// Describes the status of Amazon Web Services managed temporary credentials for the Cloud9 environment. Available values are:
        ///
        /// * ENABLED_ON_CREATE
        ///
        /// * ENABLED_BY_OWNER
        ///
        /// * DISABLED_BY_DEFAULT
        ///
        /// * DISABLED_BY_OWNER
        ///
        /// * DISABLED_BY_COLLABORATOR
        ///
        /// * PENDING_REMOVAL_BY_COLLABORATOR
        ///
        /// * PENDING_REMOVAL_BY_OWNER
        ///
        /// * FAILED_REMOVAL_BY_COLLABORATOR
        ///
        /// * ENABLED_BY_OWNER
        ///
        /// * DISABLED_BY_DEFAULT
        public var managedCredentialsStatus: Cloud9ClientTypes.ManagedCredentialsStatus?
        /// The name of the environment.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the environment owner.
        /// This member is required.
        public var ownerArn: Swift.String?
        /// The type of environment. Valid values include the following:
        ///
        /// * ec2: An Amazon Elastic Compute Cloud (Amazon EC2) instance connects to the environment.
        ///
        /// * ssh: Your own server connects to the environment.
        /// This member is required.
        public var type: Cloud9ClientTypes.EnvironmentType?

        public init(
            arn: Swift.String? = nil,
            connectionType: Cloud9ClientTypes.ConnectionType? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lifecycle: Cloud9ClientTypes.EnvironmentLifecycle? = nil,
            managedCredentialsStatus: Cloud9ClientTypes.ManagedCredentialsStatus? = nil,
            name: Swift.String? = nil,
            ownerArn: Swift.String? = nil,
            type: Cloud9ClientTypes.EnvironmentType? = nil
        )
        {
            self.arn = arn
            self.connectionType = connectionType
            self.description = description
            self.id = id
            self.lifecycle = lifecycle
            self.managedCredentialsStatus = managedCredentialsStatus
            self.name = name
            self.ownerArn = ownerArn
            self.type = type
        }
    }

}

extension Cloud9ClientTypes.EnvironmentLifecycle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureResource
        case reason
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureResource = self.failureResource {
            try encodeContainer.encode(failureResource, forKey: .failureResource)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(Cloud9ClientTypes.EnvironmentLifecycleStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
        let failureResourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureResource)
        failureResource = failureResourceDecoded
    }
}

extension Cloud9ClientTypes {
    /// Information about the current creation or deletion lifecycle state of an Cloud9 development environment.
    public struct EnvironmentLifecycle: Swift.Equatable {
        /// If the environment failed to delete, the Amazon Resource Name (ARN) of the related Amazon Web Services resource.
        public var failureResource: Swift.String?
        /// Any informational message about the lifecycle state of the environment.
        public var reason: Swift.String?
        /// The current creation or deletion lifecycle state of the environment.
        ///
        /// * CREATING: The environment is in the process of being created.
        ///
        /// * CREATED: The environment was successfully created.
        ///
        /// * CREATE_FAILED: The environment failed to be created.
        ///
        /// * DELETING: The environment is in the process of being deleted.
        ///
        /// * DELETE_FAILED: The environment failed to delete.
        public var status: Cloud9ClientTypes.EnvironmentLifecycleStatus?

        public init(
            failureResource: Swift.String? = nil,
            reason: Swift.String? = nil,
            status: Cloud9ClientTypes.EnvironmentLifecycleStatus? = nil
        )
        {
            self.failureResource = failureResource
            self.reason = reason
            self.status = status
        }
    }

}

extension Cloud9ClientTypes {
    public enum EnvironmentLifecycleStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case created
        case createFailed
        case creating
        case deleteFailed
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentLifecycleStatus] {
            return [
                .created,
                .createFailed,
                .creating,
                .deleteFailed,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentLifecycleStatus(rawValue: rawValue) ?? EnvironmentLifecycleStatus.sdkUnknown(rawValue)
        }
    }
}

extension Cloud9ClientTypes.EnvironmentMember: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
        case lastAccess
        case permissions
        case userArn
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let lastAccess = self.lastAccess {
            try encodeContainer.encodeTimestamp(lastAccess, format: .epochSeconds, forKey: .lastAccess)
        }
        if let permissions = self.permissions {
            try encodeContainer.encode(permissions.rawValue, forKey: .permissions)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsDecoded = try containerValues.decodeIfPresent(Cloud9ClientTypes.Permissions.self, forKey: .permissions)
        permissions = permissionsDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let lastAccessDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAccess)
        lastAccess = lastAccessDecoded
    }
}

extension Cloud9ClientTypes {
    /// Information about an environment member for an Cloud9 development environment.
    public struct EnvironmentMember: Swift.Equatable {
        /// The ID of the environment for the environment member.
        /// This member is required.
        public var environmentId: Swift.String?
        /// The time, expressed in epoch time format, when the environment member last opened the environment.
        public var lastAccess: ClientRuntime.Date?
        /// The type of environment member permissions associated with this environment member. Available values include:
        ///
        /// * owner: Owns the environment.
        ///
        /// * read-only: Has read-only access to the environment.
        ///
        /// * read-write: Has read-write access to the environment.
        /// This member is required.
        public var permissions: Cloud9ClientTypes.Permissions?
        /// The Amazon Resource Name (ARN) of the environment member.
        /// This member is required.
        public var userArn: Swift.String?
        /// The user ID in Identity and Access Management (IAM) of the environment member.
        /// This member is required.
        public var userId: Swift.String?

        public init(
            environmentId: Swift.String? = nil,
            lastAccess: ClientRuntime.Date? = nil,
            permissions: Cloud9ClientTypes.Permissions? = nil,
            userArn: Swift.String? = nil,
            userId: Swift.String? = nil
        )
        {
            self.environmentId = environmentId
            self.lastAccess = lastAccess
            self.permissions = permissions
            self.userArn = userArn
            self.userId = userId
        }
    }

}

extension Cloud9ClientTypes {
    public enum EnvironmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connecting
        case creating
        case deleting
        case error
        case ready
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentStatus] {
            return [
                .connecting,
                .creating,
                .deleting,
                .error,
                .ready,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connecting: return "connecting"
            case .creating: return "creating"
            case .deleting: return "deleting"
            case .error: return "error"
            case .ready: return "ready"
            case .stopped: return "stopped"
            case .stopping: return "stopping"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentStatus(rawValue: rawValue) ?? EnvironmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension Cloud9ClientTypes {
    public enum EnvironmentType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2
        case ssh
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentType] {
            return [
                .ec2,
                .ssh,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2: return "ec2"
            case .ssh: return "ssh"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentType(rawValue: rawValue) ?? EnvironmentType.sdkUnknown(rawValue)
        }
    }
}

extension ForbiddenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.className = output.className
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.className = nil
            self.properties.code = 0
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An access permissions issue occurred.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var className: Swift.String? = nil
        public internal(set) var code: Swift.Int = 0
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        className: Swift.String? = nil,
        code: Swift.Int = 0,
        message: Swift.String? = nil
    )
    {
        self.properties.className = className
        self.properties.code = code
        self.properties.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let className: Swift.String?
    let code: Swift.Int
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case className
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let classNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .className)
        className = classNameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .code) ?? 0
        code = codeDecoded
    }
}

extension InternalServerErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.className = output.className
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.className = nil
            self.properties.code = 0
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal server error occurred.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var className: Swift.String? = nil
        public internal(set) var code: Swift.Int = 0
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        className: Swift.String? = nil,
        code: Swift.Int = 0,
        message: Swift.String? = nil
    )
    {
        self.properties.className = className
        self.properties.code = code
        self.properties.message = message
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let className: Swift.String?
    let code: Swift.Int
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case className
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let classNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .className)
        className = classNameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .code) ?? 0
        code = codeDecoded
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.className = output.className
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.className = nil
            self.properties.code = 0
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A service limit was exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var className: Swift.String? = nil
        public internal(set) var code: Swift.Int = 0
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        className: Swift.String? = nil,
        code: Swift.Int = 0,
        message: Swift.String? = nil
    )
    {
        self.properties.className = className
        self.properties.code = code
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let className: Swift.String?
    let code: Swift.Int
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case className
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let classNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .className)
        className = classNameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .code) ?? 0
        code = codeDecoded
    }
}

extension ListEnvironmentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEnvironmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListEnvironmentsInput: Swift.Equatable {
    /// The maximum number of environments to get identifiers for.
    public var maxResults: Swift.Int?
    /// During a previous call, if there are more than 25 items in the list, only the first 25 items are returned, along with a unique string called a next token. To get the next batch of items in the list, call this operation again, adding the next token to the call. To get all of the items in the list, keep calling this operation with each subsequent next token that is returned, until no more next tokens are returned.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListEnvironmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListEnvironmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnvironmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.environmentIds = output.environmentIds
            self.nextToken = output.nextToken
        } else {
            self.environmentIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentsOutput: Swift.Equatable {
    /// The list of environment identifiers.
    public var environmentIds: [Swift.String]?
    /// If there are more than 25 items in the list, only the first 25 items are returned, along with a unique string called a next token. To get the next batch of items in the list, call this operation again, adding the next token to the call.
    public var nextToken: Swift.String?

    public init(
        environmentIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environmentIds = environmentIds
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let environmentIds: [Swift.String]?
}

extension ListEnvironmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentIds
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let environmentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .environmentIds)
        var environmentIdsDecoded0:[Swift.String]? = nil
        if let environmentIdsContainer = environmentIdsContainer {
            environmentIdsDecoded0 = [Swift.String]()
            for string0 in environmentIdsContainer {
                if let string0 = string0 {
                    environmentIdsDecoded0?.append(string0)
                }
            }
        }
        environmentIds = environmentIdsDecoded0
    }
}

enum ListEnvironmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Cloud9 development environment to get the tags for.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutput(tags: \"CONTENT_REDACTED\")"}
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The list of tags associated with the Cloud9 development environment.
    public var tags: [Cloud9ClientTypes.Tag]?

    public init(
        tags: [Cloud9ClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Cloud9ClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Cloud9ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[Cloud9ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Cloud9ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension Cloud9ClientTypes {
    public enum ManagedCredentialsAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disable
        case enable
        case sdkUnknown(Swift.String)

        public static var allCases: [ManagedCredentialsAction] {
            return [
                .disable,
                .enable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disable: return "DISABLE"
            case .enable: return "ENABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ManagedCredentialsAction(rawValue: rawValue) ?? ManagedCredentialsAction.sdkUnknown(rawValue)
        }
    }
}

extension Cloud9ClientTypes {
    public enum ManagedCredentialsStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabledByCollaborator
        case disabledByDefault
        case disabledByOwner
        case enabledByOwner
        case enabledOnCreate
        case failedRemovalByCollaborator
        case failedRemovalByOwner
        case pendingRemovalByCollaborator
        case pendingRemovalByOwner
        case pendingStartRemovalByCollaborator
        case pendingStartRemovalByOwner
        case sdkUnknown(Swift.String)

        public static var allCases: [ManagedCredentialsStatus] {
            return [
                .disabledByCollaborator,
                .disabledByDefault,
                .disabledByOwner,
                .enabledByOwner,
                .enabledOnCreate,
                .failedRemovalByCollaborator,
                .failedRemovalByOwner,
                .pendingRemovalByCollaborator,
                .pendingRemovalByOwner,
                .pendingStartRemovalByCollaborator,
                .pendingStartRemovalByOwner,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabledByCollaborator: return "DISABLED_BY_COLLABORATOR"
            case .disabledByDefault: return "DISABLED_BY_DEFAULT"
            case .disabledByOwner: return "DISABLED_BY_OWNER"
            case .enabledByOwner: return "ENABLED_BY_OWNER"
            case .enabledOnCreate: return "ENABLED_ON_CREATE"
            case .failedRemovalByCollaborator: return "FAILED_REMOVAL_BY_COLLABORATOR"
            case .failedRemovalByOwner: return "FAILED_REMOVAL_BY_OWNER"
            case .pendingRemovalByCollaborator: return "PENDING_REMOVAL_BY_COLLABORATOR"
            case .pendingRemovalByOwner: return "PENDING_REMOVAL_BY_OWNER"
            case .pendingStartRemovalByCollaborator: return "PENDING_START_REMOVAL_BY_COLLABORATOR"
            case .pendingStartRemovalByOwner: return "PENDING_START_REMOVAL_BY_OWNER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ManagedCredentialsStatus(rawValue: rawValue) ?? ManagedCredentialsStatus.sdkUnknown(rawValue)
        }
    }
}

extension Cloud9ClientTypes {
    public enum MemberPermissions: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case readOnly
        case readWrite
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberPermissions] {
            return [
                .readOnly,
                .readWrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .readOnly: return "read-only"
            case .readWrite: return "read-write"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MemberPermissions(rawValue: rawValue) ?? MemberPermissions.sdkUnknown(rawValue)
        }
    }
}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.className = output.className
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.className = nil
            self.properties.code = 0
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The target resource cannot be found.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var className: Swift.String? = nil
        public internal(set) var code: Swift.Int = 0
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        className: Swift.String? = nil,
        code: Swift.Int = 0,
        message: Swift.String? = nil
    )
    {
        self.properties.className = className
        self.properties.code = code
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let className: Swift.String?
    let code: Swift.Int
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case className
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let classNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .className)
        className = classNameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .code) ?? 0
        code = codeDecoded
    }
}

extension Cloud9ClientTypes {
    public enum Permissions: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case owner
        case readOnly
        case readWrite
        case sdkUnknown(Swift.String)

        public static var allCases: [Permissions] {
            return [
                .owner,
                .readOnly,
                .readWrite,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .owner: return "owner"
            case .readOnly: return "read-only"
            case .readWrite: return "read-write"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Permissions(rawValue: rawValue) ?? Permissions.sdkUnknown(rawValue)
        }
    }
}

extension Cloud9ClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension Cloud9ClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension Cloud9ClientTypes {
    /// Metadata that is associated with Amazon Web Services resources. In particular, a name-value pair that can be associated with an Cloud9 development environment. There are two types of tags: user tags and system tags. A user tag is created by the user. A system tag is automatically created by Amazon Web Services services. A system tag is prefixed with "aws:" and cannot be modified by the user.
    public struct Tag: Swift.Equatable {
        /// The name part of a tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value part of a tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tags: \"CONTENT_REDACTED\")"}
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Cloud9 development environment to add tags to.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The list of tags to add to the given Cloud9 development environment.
    /// This member is required.
    public var tags: [Cloud9ClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [Cloud9ClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [Cloud9ClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Cloud9ClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[Cloud9ClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Cloud9ClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentAccessException": return try await ConcurrentAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TooManyRequestsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyRequestsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.className = output.className
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.className = nil
            self.properties.code = 0
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Too many service requests were made over the given time period.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var className: Swift.String? = nil
        public internal(set) var code: Swift.Int = 0
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        className: Swift.String? = nil,
        code: Swift.Int = 0,
        message: Swift.String? = nil
    )
    {
        self.properties.className = className
        self.properties.code = code
        self.properties.message = message
    }
}

struct TooManyRequestsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let className: Swift.String?
    let code: Swift.Int
}

extension TooManyRequestsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case className
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let classNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .className)
        className = classNameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .code) ?? 0
        code = codeDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceARN: \(Swift.String(describing: resourceARN)), tagKeys: \"CONTENT_REDACTED\")"}
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Cloud9 development environment to remove tags from.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag names of the tags to remove from the given Cloud9 development environment.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConcurrentAccessException": return try await ConcurrentAccessException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentInput(environmentId: \(Swift.String(describing: environmentId)), managedCredentialsAction: \(Swift.String(describing: managedCredentialsAction)), name: \(Swift.String(describing: name)), description: \"CONTENT_REDACTED\")"}
}

extension UpdateEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case environmentId
        case managedCredentialsAction
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let managedCredentialsAction = self.managedCredentialsAction {
            try encodeContainer.encode(managedCredentialsAction.rawValue, forKey: .managedCredentialsAction)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateEnvironmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateEnvironmentInput: Swift.Equatable {
    /// Any new or replacement description for the environment.
    public var description: Swift.String?
    /// The ID of the environment to change settings.
    /// This member is required.
    public var environmentId: Swift.String?
    /// Allows the environment owner to turn on or turn off the Amazon Web Services managed temporary credentials for an Cloud9 environment by using one of the following values:
    ///
    /// * ENABLE
    ///
    /// * DISABLE
    ///
    ///
    /// Only the environment owner can change the status of managed temporary credentials. An AccessDeniedException is thrown if an attempt to turn on or turn off managed temporary credentials is made by an account that's not the environment owner.
    public var managedCredentialsAction: Cloud9ClientTypes.ManagedCredentialsAction?
    /// A replacement name for the environment.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        managedCredentialsAction: Cloud9ClientTypes.ManagedCredentialsAction? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.environmentId = environmentId
        self.managedCredentialsAction = managedCredentialsAction
        self.name = name
    }
}

struct UpdateEnvironmentInputBody: Swift.Equatable {
    let environmentId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let managedCredentialsAction: Cloud9ClientTypes.ManagedCredentialsAction?
}

extension UpdateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case environmentId
        case managedCredentialsAction
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let managedCredentialsActionDecoded = try containerValues.decodeIfPresent(Cloud9ClientTypes.ManagedCredentialsAction.self, forKey: .managedCredentialsAction)
        managedCredentialsAction = managedCredentialsActionDecoded
    }
}

extension UpdateEnvironmentMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
        case permissions
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let permissions = self.permissions {
            try encodeContainer.encode(permissions.rawValue, forKey: .permissions)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }
}

extension UpdateEnvironmentMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateEnvironmentMembershipInput: Swift.Equatable {
    /// The ID of the environment for the environment member whose settings you want to change.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The replacement type of environment member permissions you want to associate with this environment member. Available values include:
    ///
    /// * read-only: Has read-only access to the environment.
    ///
    /// * read-write: Has read-write access to the environment.
    /// This member is required.
    public var permissions: Cloud9ClientTypes.MemberPermissions?
    /// The Amazon Resource Name (ARN) of the environment member whose settings you want to change.
    /// This member is required.
    public var userArn: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        permissions: Cloud9ClientTypes.MemberPermissions? = nil,
        userArn: Swift.String? = nil
    )
    {
        self.environmentId = environmentId
        self.permissions = permissions
        self.userArn = userArn
    }
}

struct UpdateEnvironmentMembershipInputBody: Swift.Equatable {
    let environmentId: Swift.String?
    let userArn: Swift.String?
    let permissions: Cloud9ClientTypes.MemberPermissions?
}

extension UpdateEnvironmentMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environmentId
        case permissions
        case userArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
        let permissionsDecoded = try containerValues.decodeIfPresent(Cloud9ClientTypes.MemberPermissions.self, forKey: .permissions)
        permissions = permissionsDecoded
    }
}

extension UpdateEnvironmentMembershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEnvironmentMembershipOutputBody = try responseDecoder.decode(responseBody: data)
            self.membership = output.membership
        } else {
            self.membership = nil
        }
    }
}

public struct UpdateEnvironmentMembershipOutput: Swift.Equatable {
    /// Information about the environment member whose settings were changed.
    public var membership: Cloud9ClientTypes.EnvironmentMember?

    public init(
        membership: Cloud9ClientTypes.EnvironmentMember? = nil
    )
    {
        self.membership = membership
    }
}

struct UpdateEnvironmentMembershipOutputBody: Swift.Equatable {
    let membership: Cloud9ClientTypes.EnvironmentMember?
}

extension UpdateEnvironmentMembershipOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case membership
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membershipDecoded = try containerValues.decodeIfPresent(Cloud9ClientTypes.EnvironmentMember.self, forKey: .membership)
        membership = membershipDecoded
    }
}

enum UpdateEnvironmentMembershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateEnvironmentOutput: Swift.Equatable {

    public init() { }
}

enum UpdateEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyRequestsException": return try await TooManyRequestsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
