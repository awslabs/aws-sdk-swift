//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct AcceptEngagementInvitationOutput: Swift.Sendable {

    public init() { }
}

public struct AssignOpportunityOutput: Swift.Sendable {

    public init() { }
}

public struct AssociateOpportunityOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteResourceSnapshotJobOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateOpportunityOutput: Swift.Sendable {

    public init() { }
}

public struct RejectEngagementInvitationOutput: Swift.Sendable {

    public init() { }
}

public struct StartResourceSnapshotJobOutput: Swift.Sendable {

    public init() { }
}

public struct StopResourceSnapshotJobOutput: Swift.Sendable {

    public init() { }
}

public struct SubmitOpportunityOutput: Swift.Sendable {

    public init() { }
}

extension PartnerCentralSellingClientTypes {

    public enum AccessDeniedExceptionErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case incompatibleBenefitAwsPartnerState
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessDeniedExceptionErrorCode] {
            return [
                .incompatibleBenefitAwsPartnerState
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .incompatibleBenefitAwsPartnerState: return "INCOMPATIBLE_BENEFIT_AWS_PARTNER_STATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// This error occurs when you don't have permission to perform the requested action. You don’t have access to this action or resource. Review IAM policies or contact your AWS administrator for assistance.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
        /// The reason why access was denied for the requested operation.
        public internal(set) var reason: PartnerCentralSellingClientTypes.AccessDeniedExceptionErrorCode? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: PartnerCentralSellingClientTypes.AccessDeniedExceptionErrorCode? = nil
    ) {
        self.properties.message = message
        self.properties.reason = reason
    }
}

/// This error occurs when the request can’t be processed due to a conflict with the target resource's current state, which could result from updating or deleting the resource. Suggested action: Fetch the latest state of the resource, verify the state, and retry the request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This error occurs when the specified resource can’t be found or doesn't exist. Resource ID and type might be incorrect. Suggested action: This is usually a transient error. Retry after the provided retry delay or a short interval. If the problem persists, contact AWS support.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This error occurs when the specified resource can't be found. The resource might not exist, or isn't visible with the current credentials. Suggested action: Verify that the resource ID is correct and the resource is in the expected AWS region. Check IAM permissions for accessing the resource.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// This error occurs when there are too many requests sent. Review the provided quotas and adapt your usage to avoid throttling. This error occurs when there are too many requests sent. Review the provided [Quotas](https://docs.aws.amazon.com/partner-central/latest/selling-api/quotas.html) and retry after the provided delay.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension PartnerCentralSellingClientTypes {

    public enum ValidationExceptionErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actionNotPermitted
        case duplicateKeyValue
        case invalidEnumValue
        case invalidResourceState
        case invalidStringFormat
        case invalidValue
        case notEnoughValues
        case requiredFieldMissing
        case tooManyValues
        case valueOutOfRange
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionErrorCode] {
            return [
                .actionNotPermitted,
                .duplicateKeyValue,
                .invalidEnumValue,
                .invalidResourceState,
                .invalidStringFormat,
                .invalidValue,
                .notEnoughValues,
                .requiredFieldMissing,
                .tooManyValues,
                .valueOutOfRange
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actionNotPermitted: return "ACTION_NOT_PERMITTED"
            case .duplicateKeyValue: return "DUPLICATE_KEY_VALUE"
            case .invalidEnumValue: return "INVALID_ENUM_VALUE"
            case .invalidResourceState: return "INVALID_RESOURCE_STATE"
            case .invalidStringFormat: return "INVALID_STRING_FORMAT"
            case .invalidValue: return "INVALID_VALUE"
            case .notEnoughValues: return "NOT_ENOUGH_VALUES"
            case .requiredFieldMissing: return "REQUIRED_FIELD_MISSING"
            case .tooManyValues: return "TOO_MANY_VALUES"
            case .valueOutOfRange: return "VALUE_OUT_OF_RANGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Indicates an invalid value for a field.
    ///
    /// * REQUIRED_FIELD_MISSING: The request is missing a required field. Fix: Verify your request payload includes all required fields.
    ///
    /// * INVALID_ENUM_VALUE: The enum field value isn't an accepted values. Fix: Check the documentation for the list of valid enum values, and update your request with a valid value.
    ///
    /// * INVALID_STRING_FORMAT: The string format is invalid. Fix: Confirm that the string is in the expected format (For example: email address, date).
    ///
    /// * INVALID_VALUE: The value isn't valid. Fix: Confirm that the value meets the expected criteria and is within the allowable range or set.
    ///
    /// * TOO_MANY_VALUES: There are too many values in a field that expects fewer entries. Fix: Reduce the number of values to match the expected limit.
    ///
    /// * NOT_ENOUGH_VALUES: There are not enough values in a field that expects more entries. Fix: Increase the number of values to match the expected threshold.
    ///
    /// * ACTION_NOT_PERMITTED: The action isn't permitted due to current state or permissions. Fix: Verify that the action is appropriate for the current state, and that you have the necessary permissions to perform it.
    ///
    /// * DUPLICATE_KEY_VALUE: The value in a field duplicates a value that must be unique. Fix: Verify that the value is unique and doesn't duplicate an existing value in the system.
    public struct ValidationExceptionError: Swift.Sendable {
        /// Specifies the error code for the invalid field value.
        /// This member is required.
        public var code: PartnerCentralSellingClientTypes.ValidationExceptionErrorCode?
        /// Specifies the field name with the invalid value.
        public var fieldName: Swift.String?
        /// Specifies the detailed error message for the invalid field value.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: PartnerCentralSellingClientTypes.ValidationExceptionErrorCode? = nil,
            fieldName: Swift.String? = nil,
            message: Swift.String? = nil
        ) {
            self.code = code
            self.fieldName = fieldName
            self.message = message
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case businessValidationFailed
        case requestValidationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .businessValidationFailed,
                .requestValidationFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .businessValidationFailed: return "BUSINESS_VALIDATION_FAILED"
            case .requestValidationFailed: return "REQUEST_VALIDATION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the constraints specified by the service or business validation rules. Suggested action: Review the error message, including the failed fields and reasons, to correct the request payload.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A list of issues that were discovered in the submitted request or the resource state.
        public internal(set) var errorList: [PartnerCentralSellingClientTypes.ValidationExceptionError]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The primary reason for this validation exception to occur.
        ///
        /// * REQUEST_VALIDATION_FAILED: The request format is not valid. Fix: Verify your request payload includes all required fields, uses correct data types and string formats.
        ///
        /// * BUSINESS_VALIDATION_FAILED: The requested change doesn't pass the business validation rules. Fix: Check that your change aligns with the business rules defined by AWS Partner Central.
        /// This member is required.
        public internal(set) var reason: PartnerCentralSellingClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorList: [PartnerCentralSellingClientTypes.ValidationExceptionError]? = nil,
        message: Swift.String? = nil,
        reason: PartnerCentralSellingClientTypes.ValidationExceptionReason? = nil
    ) {
        self.properties.errorList = errorList
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct AcceptEngagementInvitationInput: Swift.Sendable {
    /// The CatalogType parameter specifies the catalog associated with the engagement invitation. Accepted values are AWS and Sandbox, which determine the environment in which the engagement invitation is managed.
    /// This member is required.
    public var catalog: Swift.String?
    /// The Identifier parameter in the AcceptEngagementInvitationRequest specifies the unique identifier of the EngagementInvitation to be accepted. Providing the correct identifier ensures that the intended invitation is accepted.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
    }
}

extension PartnerCentralSellingClientTypes {

    public enum CountryCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ad
        case ae
        case af
        case ag
        case ai
        case al
        case am
        case an
        case ao
        case aq
        case ar
        case `as`
        case at
        case au
        case aw
        case ax
        case az
        case ba
        case bb
        case bd
        case be
        case bf
        case bg
        case bh
        case bi
        case bj
        case bl
        case bm
        case bn
        case bo
        case bq
        case br
        case bs
        case bt
        case bv
        case bw
        case by
        case bz
        case ca
        case cc
        case cd
        case cf
        case cg
        case ch
        case ci
        case ck
        case cl
        case cm
        case cn
        case co
        case cr
        case cu
        case cv
        case cw
        case cx
        case cy
        case cz
        case de
        case dj
        case dk
        case dm
        case `do`
        case dz
        case ec
        case ee
        case eg
        case eh
        case er
        case es
        case et
        case fi
        case fj
        case fk
        case fm
        case fo
        case fr
        case ga
        case gb
        case gd
        case ge
        case gf
        case gg
        case gh
        case gi
        case gl
        case gm
        case gn
        case gp
        case gq
        case gr
        case gs
        case gt
        case gu
        case gw
        case gy
        case hk
        case hm
        case hn
        case hr
        case ht
        case hu
        case id
        case ie
        case il
        case im
        case `in`
        case io
        case iq
        case ir
        case `is`
        case it
        case je
        case jm
        case jo
        case jp
        case ke
        case kg
        case kh
        case ki
        case km
        case kn
        case kr
        case kw
        case ky
        case kz
        case la
        case lb
        case lc
        case li
        case lk
        case lr
        case ls
        case lt
        case lu
        case lv
        case ly
        case ma
        case mc
        case md
        case me
        case mf
        case mg
        case mh
        case mk
        case ml
        case mm
        case mn
        case mo
        case mp
        case mq
        case mr
        case ms
        case mt
        case mu
        case mv
        case mw
        case mx
        case my
        case mz
        case na
        case nc
        case ne
        case nf
        case ng
        case ni
        case nl
        case no
        case np
        case nr
        case nu
        case nz
        case om
        case pa
        case pe
        case pf
        case pg
        case ph
        case pk
        case pl
        case pm
        case pn
        case pr
        case ps
        case pt
        case pw
        case py
        case qa
        case re
        case ro
        case rs
        case ru
        case rw
        case sa
        case sb
        case sc
        case sd
        case se
        case sg
        case sh
        case si
        case sj
        case sk
        case sl
        case sm
        case sn
        case so
        case sr
        case ss
        case st
        case sv
        case sx
        case sy
        case sz
        case tc
        case td
        case tf
        case tg
        case th
        case tj
        case tk
        case tl
        case tm
        case tn
        case to
        case tr
        case tt
        case tv
        case tw
        case tz
        case ua
        case ug
        case um
        case us
        case uy
        case uz
        case va
        case vc
        case ve
        case vg
        case vi
        case vn
        case vu
        case wf
        case ws
        case ye
        case yt
        case za
        case zm
        case zw
        case sdkUnknown(Swift.String)

        public static var allCases: [CountryCode] {
            return [
                .ad,
                .ae,
                .af,
                .ag,
                .ai,
                .al,
                .am,
                .an,
                .ao,
                .aq,
                .ar,
                .as,
                .at,
                .au,
                .aw,
                .ax,
                .az,
                .ba,
                .bb,
                .bd,
                .be,
                .bf,
                .bg,
                .bh,
                .bi,
                .bj,
                .bl,
                .bm,
                .bn,
                .bo,
                .bq,
                .br,
                .bs,
                .bt,
                .bv,
                .bw,
                .by,
                .bz,
                .ca,
                .cc,
                .cd,
                .cf,
                .cg,
                .ch,
                .ci,
                .ck,
                .cl,
                .cm,
                .cn,
                .co,
                .cr,
                .cu,
                .cv,
                .cw,
                .cx,
                .cy,
                .cz,
                .de,
                .dj,
                .dk,
                .dm,
                .do,
                .dz,
                .ec,
                .ee,
                .eg,
                .eh,
                .er,
                .es,
                .et,
                .fi,
                .fj,
                .fk,
                .fm,
                .fo,
                .fr,
                .ga,
                .gb,
                .gd,
                .ge,
                .gf,
                .gg,
                .gh,
                .gi,
                .gl,
                .gm,
                .gn,
                .gp,
                .gq,
                .gr,
                .gs,
                .gt,
                .gu,
                .gw,
                .gy,
                .hk,
                .hm,
                .hn,
                .hr,
                .ht,
                .hu,
                .id,
                .ie,
                .il,
                .im,
                .in,
                .io,
                .iq,
                .ir,
                .is,
                .it,
                .je,
                .jm,
                .jo,
                .jp,
                .ke,
                .kg,
                .kh,
                .ki,
                .km,
                .kn,
                .kr,
                .kw,
                .ky,
                .kz,
                .la,
                .lb,
                .lc,
                .li,
                .lk,
                .lr,
                .ls,
                .lt,
                .lu,
                .lv,
                .ly,
                .ma,
                .mc,
                .md,
                .me,
                .mf,
                .mg,
                .mh,
                .mk,
                .ml,
                .mm,
                .mn,
                .mo,
                .mp,
                .mq,
                .mr,
                .ms,
                .mt,
                .mu,
                .mv,
                .mw,
                .mx,
                .my,
                .mz,
                .na,
                .nc,
                .ne,
                .nf,
                .ng,
                .ni,
                .nl,
                .no,
                .np,
                .nr,
                .nu,
                .nz,
                .om,
                .pa,
                .pe,
                .pf,
                .pg,
                .ph,
                .pk,
                .pl,
                .pm,
                .pn,
                .pr,
                .ps,
                .pt,
                .pw,
                .py,
                .qa,
                .re,
                .ro,
                .rs,
                .ru,
                .rw,
                .sa,
                .sb,
                .sc,
                .sd,
                .se,
                .sg,
                .sh,
                .si,
                .sj,
                .sk,
                .sl,
                .sm,
                .sn,
                .so,
                .sr,
                .ss,
                .st,
                .sv,
                .sx,
                .sy,
                .sz,
                .tc,
                .td,
                .tf,
                .tg,
                .th,
                .tj,
                .tk,
                .tl,
                .tm,
                .tn,
                .to,
                .tr,
                .tt,
                .tv,
                .tw,
                .tz,
                .ua,
                .ug,
                .um,
                .us,
                .uy,
                .uz,
                .va,
                .vc,
                .ve,
                .vg,
                .vi,
                .vn,
                .vu,
                .wf,
                .ws,
                .ye,
                .yt,
                .za,
                .zm,
                .zw
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ad: return "AD"
            case .ae: return "AE"
            case .af: return "AF"
            case .ag: return "AG"
            case .ai: return "AI"
            case .al: return "AL"
            case .am: return "AM"
            case .an: return "AN"
            case .ao: return "AO"
            case .aq: return "AQ"
            case .ar: return "AR"
            case .as: return "AS"
            case .at: return "AT"
            case .au: return "AU"
            case .aw: return "AW"
            case .ax: return "AX"
            case .az: return "AZ"
            case .ba: return "BA"
            case .bb: return "BB"
            case .bd: return "BD"
            case .be: return "BE"
            case .bf: return "BF"
            case .bg: return "BG"
            case .bh: return "BH"
            case .bi: return "BI"
            case .bj: return "BJ"
            case .bl: return "BL"
            case .bm: return "BM"
            case .bn: return "BN"
            case .bo: return "BO"
            case .bq: return "BQ"
            case .br: return "BR"
            case .bs: return "BS"
            case .bt: return "BT"
            case .bv: return "BV"
            case .bw: return "BW"
            case .by: return "BY"
            case .bz: return "BZ"
            case .ca: return "CA"
            case .cc: return "CC"
            case .cd: return "CD"
            case .cf: return "CF"
            case .cg: return "CG"
            case .ch: return "CH"
            case .ci: return "CI"
            case .ck: return "CK"
            case .cl: return "CL"
            case .cm: return "CM"
            case .cn: return "CN"
            case .co: return "CO"
            case .cr: return "CR"
            case .cu: return "CU"
            case .cv: return "CV"
            case .cw: return "CW"
            case .cx: return "CX"
            case .cy: return "CY"
            case .cz: return "CZ"
            case .de: return "DE"
            case .dj: return "DJ"
            case .dk: return "DK"
            case .dm: return "DM"
            case .do: return "DO"
            case .dz: return "DZ"
            case .ec: return "EC"
            case .ee: return "EE"
            case .eg: return "EG"
            case .eh: return "EH"
            case .er: return "ER"
            case .es: return "ES"
            case .et: return "ET"
            case .fi: return "FI"
            case .fj: return "FJ"
            case .fk: return "FK"
            case .fm: return "FM"
            case .fo: return "FO"
            case .fr: return "FR"
            case .ga: return "GA"
            case .gb: return "GB"
            case .gd: return "GD"
            case .ge: return "GE"
            case .gf: return "GF"
            case .gg: return "GG"
            case .gh: return "GH"
            case .gi: return "GI"
            case .gl: return "GL"
            case .gm: return "GM"
            case .gn: return "GN"
            case .gp: return "GP"
            case .gq: return "GQ"
            case .gr: return "GR"
            case .gs: return "GS"
            case .gt: return "GT"
            case .gu: return "GU"
            case .gw: return "GW"
            case .gy: return "GY"
            case .hk: return "HK"
            case .hm: return "HM"
            case .hn: return "HN"
            case .hr: return "HR"
            case .ht: return "HT"
            case .hu: return "HU"
            case .id: return "ID"
            case .ie: return "IE"
            case .il: return "IL"
            case .im: return "IM"
            case .in: return "IN"
            case .io: return "IO"
            case .iq: return "IQ"
            case .ir: return "IR"
            case .is: return "IS"
            case .it: return "IT"
            case .je: return "JE"
            case .jm: return "JM"
            case .jo: return "JO"
            case .jp: return "JP"
            case .ke: return "KE"
            case .kg: return "KG"
            case .kh: return "KH"
            case .ki: return "KI"
            case .km: return "KM"
            case .kn: return "KN"
            case .kr: return "KR"
            case .kw: return "KW"
            case .ky: return "KY"
            case .kz: return "KZ"
            case .la: return "LA"
            case .lb: return "LB"
            case .lc: return "LC"
            case .li: return "LI"
            case .lk: return "LK"
            case .lr: return "LR"
            case .ls: return "LS"
            case .lt: return "LT"
            case .lu: return "LU"
            case .lv: return "LV"
            case .ly: return "LY"
            case .ma: return "MA"
            case .mc: return "MC"
            case .md: return "MD"
            case .me: return "ME"
            case .mf: return "MF"
            case .mg: return "MG"
            case .mh: return "MH"
            case .mk: return "MK"
            case .ml: return "ML"
            case .mm: return "MM"
            case .mn: return "MN"
            case .mo: return "MO"
            case .mp: return "MP"
            case .mq: return "MQ"
            case .mr: return "MR"
            case .ms: return "MS"
            case .mt: return "MT"
            case .mu: return "MU"
            case .mv: return "MV"
            case .mw: return "MW"
            case .mx: return "MX"
            case .my: return "MY"
            case .mz: return "MZ"
            case .na: return "NA"
            case .nc: return "NC"
            case .ne: return "NE"
            case .nf: return "NF"
            case .ng: return "NG"
            case .ni: return "NI"
            case .nl: return "NL"
            case .no: return "NO"
            case .np: return "NP"
            case .nr: return "NR"
            case .nu: return "NU"
            case .nz: return "NZ"
            case .om: return "OM"
            case .pa: return "PA"
            case .pe: return "PE"
            case .pf: return "PF"
            case .pg: return "PG"
            case .ph: return "PH"
            case .pk: return "PK"
            case .pl: return "PL"
            case .pm: return "PM"
            case .pn: return "PN"
            case .pr: return "PR"
            case .ps: return "PS"
            case .pt: return "PT"
            case .pw: return "PW"
            case .py: return "PY"
            case .qa: return "QA"
            case .re: return "RE"
            case .ro: return "RO"
            case .rs: return "RS"
            case .ru: return "RU"
            case .rw: return "RW"
            case .sa: return "SA"
            case .sb: return "SB"
            case .sc: return "SC"
            case .sd: return "SD"
            case .se: return "SE"
            case .sg: return "SG"
            case .sh: return "SH"
            case .si: return "SI"
            case .sj: return "SJ"
            case .sk: return "SK"
            case .sl: return "SL"
            case .sm: return "SM"
            case .sn: return "SN"
            case .so: return "SO"
            case .sr: return "SR"
            case .ss: return "SS"
            case .st: return "ST"
            case .sv: return "SV"
            case .sx: return "SX"
            case .sy: return "SY"
            case .sz: return "SZ"
            case .tc: return "TC"
            case .td: return "TD"
            case .tf: return "TF"
            case .tg: return "TG"
            case .th: return "TH"
            case .tj: return "TJ"
            case .tk: return "TK"
            case .tl: return "TL"
            case .tm: return "TM"
            case .tn: return "TN"
            case .to: return "TO"
            case .tr: return "TR"
            case .tt: return "TT"
            case .tv: return "TV"
            case .tw: return "TW"
            case .tz: return "TZ"
            case .ua: return "UA"
            case .ug: return "UG"
            case .um: return "UM"
            case .us: return "US"
            case .uy: return "UY"
            case .uz: return "UZ"
            case .va: return "VA"
            case .vc: return "VC"
            case .ve: return "VE"
            case .vg: return "VG"
            case .vi: return "VI"
            case .vn: return "VN"
            case .vu: return "VU"
            case .wf: return "WF"
            case .ws: return "WS"
            case .ye: return "YE"
            case .yt: return "YT"
            case .za: return "ZA"
            case .zm: return "ZM"
            case .zw: return "ZW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Specifies the end Customer's address details associated with the Opportunity.
    public struct Address: Swift.Sendable {
        /// Specifies the end Customer's city associated with the Opportunity.
        public var city: Swift.String?
        /// Specifies the end Customer's country associated with the Opportunity.
        public var countryCode: PartnerCentralSellingClientTypes.CountryCode?
        /// Specifies the end Customer's postal code associated with the Opportunity.
        public var postalCode: Swift.String?
        /// Specifies the end Customer's state or region associated with the Opportunity. Valid values: Alabama | Alaska | American Samoa | Arizona | Arkansas | California | Colorado | Connecticut | Delaware | Dist. of Columbia | Federated States of Micronesia | Florida | Georgia | Guam | Hawaii | Idaho | Illinois | Indiana | Iowa | Kansas | Kentucky | Louisiana | Maine | Marshall Islands | Maryland | Massachusetts | Michigan | Minnesota | Mississippi | Missouri | Montana | Nebraska | Nevada | New Hampshire | New Jersey | New Mexico | New York | North Carolina | North Dakota | Northern Mariana Islands | Ohio | Oklahoma | Oregon | Palau | Pennsylvania | Puerto Rico | Rhode Island | South Carolina | South Dakota | Tennessee | Texas | Utah | Vermont | Virginia | Virgin Islands | Washington | West Virginia | Wisconsin | Wyoming | APO/AE | AFO/FPO | FPO, AP
        public var stateOrRegion: Swift.String?
        /// Specifies the end Customer's street address associated with the Opportunity.
        public var streetAddress: Swift.String?

        public init(
            city: Swift.String? = nil,
            countryCode: PartnerCentralSellingClientTypes.CountryCode? = nil,
            postalCode: Swift.String? = nil,
            stateOrRegion: Swift.String? = nil,
            streetAddress: Swift.String? = nil
        ) {
            self.city = city
            self.countryCode = countryCode
            self.postalCode = postalCode
            self.stateOrRegion = stateOrRegion
            self.streetAddress = streetAddress
        }
    }
}

extension PartnerCentralSellingClientTypes.Address: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Address(city: \"CONTENT_REDACTED\", countryCode: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", stateOrRegion: \"CONTENT_REDACTED\", streetAddress: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    public enum Industry: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aerospaceSatellite
        case agriculture
        case automotive
        case computersElectronics
        case consumerGoods
        case education
        case energyOilGas
        case energyPowerUtilities
        case financialServices
        case gaming
        case government
        case healthcare
        case hospitality
        case lifeSciences
        case manufacturing
        case marketingAdvertising
        case mediaEntertainment
        case mining
        case nonProfitOrganization
        case other
        case professionalServices
        case realestateConstruction
        case retail
        case softwareInternet
        case telecommunications
        case transportationLogistics
        case travel
        case wholesaleDistribution
        case sdkUnknown(Swift.String)

        public static var allCases: [Industry] {
            return [
                .aerospaceSatellite,
                .agriculture,
                .automotive,
                .computersElectronics,
                .consumerGoods,
                .education,
                .energyOilGas,
                .energyPowerUtilities,
                .financialServices,
                .gaming,
                .government,
                .healthcare,
                .hospitality,
                .lifeSciences,
                .manufacturing,
                .marketingAdvertising,
                .mediaEntertainment,
                .mining,
                .nonProfitOrganization,
                .other,
                .professionalServices,
                .realestateConstruction,
                .retail,
                .softwareInternet,
                .telecommunications,
                .transportationLogistics,
                .travel,
                .wholesaleDistribution
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aerospaceSatellite: return "Aerospace"
            case .agriculture: return "Agriculture"
            case .automotive: return "Automotive"
            case .computersElectronics: return "Computers and Electronics"
            case .consumerGoods: return "Consumer Goods"
            case .education: return "Education"
            case .energyOilGas: return "Energy - Oil and Gas"
            case .energyPowerUtilities: return "Energy - Power and Utilities"
            case .financialServices: return "Financial Services"
            case .gaming: return "Gaming"
            case .government: return "Government"
            case .healthcare: return "Healthcare"
            case .hospitality: return "Hospitality"
            case .lifeSciences: return "Life Sciences"
            case .manufacturing: return "Manufacturing"
            case .marketingAdvertising: return "Marketing and Advertising"
            case .mediaEntertainment: return "Media and Entertainment"
            case .mining: return "Mining"
            case .nonProfitOrganization: return "Non-Profit Organization"
            case .other: return "Other"
            case .professionalServices: return "Professional Services"
            case .realestateConstruction: return "Real Estate and Construction"
            case .retail: return "Retail"
            case .softwareInternet: return "Software and Internet"
            case .telecommunications: return "Telecommunications"
            case .transportationLogistics: return "Transportation and Logistics"
            case .travel: return "Travel"
            case .wholesaleDistribution: return "Wholesale and Distribution"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Specifies the Customer's account details associated with the Opportunity.
    public struct Account: Swift.Sendable {
        /// Specifies the end Customer's address details associated with the Opportunity.
        public var address: PartnerCentralSellingClientTypes.Address?
        /// Specifies the Customer Amazon Web Services account ID associated with the Opportunity.
        public var awsAccountId: Swift.String?
        /// Specifies the end Customer's company name associated with the Opportunity.
        /// This member is required.
        public var companyName: Swift.String?
        /// Indicates the Customer DUNS number, if available.
        public var duns: Swift.String?
        /// Specifies the industry the end Customer belongs to that's associated with the Opportunity. It refers to the category or sector where the customer's business operates. This is a required field.
        public var industry: PartnerCentralSellingClientTypes.Industry?
        /// Specifies the end Customer's industry associated with the Opportunity, when the selected value in the Industry field is Other.
        public var otherIndustry: Swift.String?
        /// Specifies the end customer's company website URL associated with the Opportunity. This value is crucial to map the customer within the Amazon Web Services CRM system. This field is required in all cases except when the opportunity is related to national security.
        public var websiteUrl: Swift.String?

        public init(
            address: PartnerCentralSellingClientTypes.Address? = nil,
            awsAccountId: Swift.String? = nil,
            companyName: Swift.String? = nil,
            duns: Swift.String? = nil,
            industry: PartnerCentralSellingClientTypes.Industry? = nil,
            otherIndustry: Swift.String? = nil,
            websiteUrl: Swift.String? = nil
        ) {
            self.address = address
            self.awsAccountId = awsAccountId
            self.companyName = companyName
            self.duns = duns
            self.industry = industry
            self.otherIndustry = otherIndustry
            self.websiteUrl = websiteUrl
        }
    }
}

extension PartnerCentralSellingClientTypes.Account: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Account(address: \(Swift.String(describing: address)), industry: \(Swift.String(describing: industry)), otherIndustry: \(Swift.String(describing: otherIndustry)), awsAccountId: \"CONTENT_REDACTED\", companyName: \"CONTENT_REDACTED\", duns: \"CONTENT_REDACTED\", websiteUrl: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// Contains the account details of the partner who received the Engagement Invitation, including the AWS account ID and company name.
    public struct AccountReceiver: Swift.Sendable {
        /// Represents the alias of the partner account receiving the Engagement Invitation, making it easier to identify and track the recipient in reports or logs.
        public var alias: Swift.String?
        /// Indicates the AWS account ID of the partner who received the Engagement Invitation. This is a unique identifier for managing engagements with specific AWS accounts.
        /// This member is required.
        public var awsAccountId: Swift.String?

        public init(
            alias: Swift.String? = nil,
            awsAccountId: Swift.String? = nil
        ) {
            self.alias = alias
            self.awsAccountId = awsAccountId
        }
    }
}

extension PartnerCentralSellingClientTypes.AccountReceiver: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccountReceiver(alias: \"CONTENT_REDACTED\", awsAccountId: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// An object that contains an Address object's subset of fields.
    public struct AddressSummary: Swift.Sendable {
        /// Specifies the end Customer's city associated with the Opportunity.
        public var city: Swift.String?
        /// Specifies the end Customer's country associated with the Opportunity.
        public var countryCode: PartnerCentralSellingClientTypes.CountryCode?
        /// Specifies the end Customer's postal code associated with the Opportunity.
        public var postalCode: Swift.String?
        /// Specifies the end Customer's state or region associated with the Opportunity. Valid values: Alabama | Alaska | American Samoa | Arizona | Arkansas | California | Colorado | Connecticut | Delaware | Dist. of Columbia | Federated States of Micronesia | Florida | Georgia | Guam | Hawaii | Idaho | Illinois | Indiana | Iowa | Kansas | Kentucky | Louisiana | Maine | Marshall Islands | Maryland | Massachusetts | Michigan | Minnesota | Mississippi | Missouri | Montana | Nebraska | Nevada | New Hampshire | New Jersey | New Mexico | New York | North Carolina | North Dakota | Northern Mariana Islands | Ohio | Oklahoma | Oregon | Palau | Pennsylvania | Puerto Rico | Rhode Island | South Carolina | South Dakota | Tennessee | Texas | Utah | Vermont | Virginia | Virgin Islands | Washington | West Virginia | Wisconsin | Wyoming | APO/AE | AFO/FPO | FPO, AP
        public var stateOrRegion: Swift.String?

        public init(
            city: Swift.String? = nil,
            countryCode: PartnerCentralSellingClientTypes.CountryCode? = nil,
            postalCode: Swift.String? = nil,
            stateOrRegion: Swift.String? = nil
        ) {
            self.city = city
            self.countryCode = countryCode
            self.postalCode = postalCode
            self.stateOrRegion = stateOrRegion
        }
    }
}

extension PartnerCentralSellingClientTypes.AddressSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AddressSummary(city: \"CONTENT_REDACTED\", countryCode: \"CONTENT_REDACTED\", postalCode: \"CONTENT_REDACTED\", stateOrRegion: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// An object that contains an Account's subset of fields.
    public struct AccountSummary: Swift.Sendable {
        /// Specifies the end Customer's address details associated with the Opportunity.
        public var address: PartnerCentralSellingClientTypes.AddressSummary?
        /// Specifies the end Customer's company name associated with the Opportunity.
        /// This member is required.
        public var companyName: Swift.String?
        /// Specifies which industry the end Customer belongs to associated with the Opportunity. It refers to the category or sector that the customer's business operates in. To submit a value outside the picklist, use Other. Conditionally mandatory if Other is selected for Industry Vertical in LOVs.
        public var industry: PartnerCentralSellingClientTypes.Industry?
        /// Specifies the end Customer's industry associated with the  Opportunity, when the selected value in the Industry field is Other. This field is relevant when the customer's industry doesn't fall under the predefined picklist values and requires a custom description.
        public var otherIndustry: Swift.String?
        /// Specifies the end customer's company website URL associated with the Opportunity. This value is crucial to map the customer within the Amazon Web Services CRM system.
        public var websiteUrl: Swift.String?

        public init(
            address: PartnerCentralSellingClientTypes.AddressSummary? = nil,
            companyName: Swift.String? = nil,
            industry: PartnerCentralSellingClientTypes.Industry? = nil,
            otherIndustry: Swift.String? = nil,
            websiteUrl: Swift.String? = nil
        ) {
            self.address = address
            self.companyName = companyName
            self.industry = industry
            self.otherIndustry = otherIndustry
            self.websiteUrl = websiteUrl
        }
    }
}

extension PartnerCentralSellingClientTypes.AccountSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccountSummary(address: \(Swift.String(describing: address)), industry: \(Swift.String(describing: industry)), otherIndustry: \(Swift.String(describing: otherIndustry)), companyName: \"CONTENT_REDACTED\", websiteUrl: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// Represents the contact details of the individual assigned to manage the opportunity within the partner organization. This helps to ensure that there is a point of contact for the opportunity's progress.
    public struct AssigneeContact: Swift.Sendable {
        /// Specifies the business title of the assignee managing the opportunity. This helps clarify the individual's role and responsibilities within the organization. Use the value PartnerAccountManager to update details of the opportunity owner.
        /// This member is required.
        public var businessTitle: Swift.String?
        /// Provides the email address of the assignee. This email is used for communications and notifications related to the opportunity.
        /// This member is required.
        public var email: Swift.String?
        /// Specifies the first name of the assignee managing the opportunity. The system automatically retrieves this value from the user profile by referencing the associated email address.
        /// This member is required.
        public var firstName: Swift.String?
        /// Specifies the last name of the assignee managing the opportunity. The system automatically retrieves this value from the user profile by referencing the associated email address.
        /// This member is required.
        public var lastName: Swift.String?
        /// Specifies the contact phone number of the assignee responsible for the opportunity or engagement. This field enables direct communication for time-sensitive matters and facilitates coordination between AWS and partner teams.
        public var phone: Swift.String?

        public init(
            businessTitle: Swift.String? = nil,
            email: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            phone: Swift.String? = nil
        ) {
            self.businessTitle = businessTitle
            self.email = email
            self.firstName = firstName
            self.lastName = lastName
            self.phone = phone
        }
    }
}

extension PartnerCentralSellingClientTypes.AssigneeContact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssigneeContact(businessTitle: \"CONTENT_REDACTED\", email: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

public struct AssignOpportunityInput: Swift.Sendable {
    /// Specifies the user or team member responsible for managing the assigned opportunity. This field identifies the Assignee based on the partner's internal team structure. Ensure that the email address is associated with a registered user in your Partner Central account.
    /// This member is required.
    public var assignee: PartnerCentralSellingClientTypes.AssigneeContact?
    /// Specifies the catalog associated with the request. This field takes a string value from a predefined list: AWS or Sandbox. The catalog determines which environment the opportunity is assigned in. Use AWS to assign real opportunities in the Amazon Web Services catalog, and Sandbox for testing in secure, isolated environments.
    /// This member is required.
    public var catalog: Swift.String?
    /// Requires the Opportunity's unique identifier when you want to assign it to another user. Provide the correct identifier so the intended opportunity is reassigned.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        assignee: PartnerCentralSellingClientTypes.AssigneeContact? = nil,
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.assignee = assignee
        self.catalog = catalog
        self.identifier = identifier
    }
}

extension PartnerCentralSellingClientTypes {

    public enum RelatedEntityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsMarketplaceOffers
        case awsMarketplaceOfferSets
        case awsProducts
        case solutions
        case sdkUnknown(Swift.String)

        public static var allCases: [RelatedEntityType] {
            return [
                .awsMarketplaceOffers,
                .awsMarketplaceOfferSets,
                .awsProducts,
                .solutions
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsMarketplaceOffers: return "AwsMarketplaceOffers"
            case .awsMarketplaceOfferSets: return "AwsMarketplaceOfferSets"
            case .awsProducts: return "AwsProducts"
            case .solutions: return "Solutions"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct AssociateOpportunityInput: Swift.Sendable {
    /// Specifies the catalog associated with the request. This field takes a string value from a predefined list: AWS or Sandbox. The catalog determines which environment the opportunity association is made in. Use AWS to associate opportunities in the Amazon Web Services catalog, and Sandbox for testing in secure, isolated environments.
    /// This member is required.
    public var catalog: Swift.String?
    /// Requires the Opportunity's unique identifier when you want to associate it with a related entity. Provide the correct identifier so the intended opportunity is updated with the association.
    /// This member is required.
    public var opportunityIdentifier: Swift.String?
    /// Requires the related entity's unique identifier when you want to associate it with the  Opportunity. For Amazon Web Services Marketplace entities, provide the Amazon Resource Name (ARN). Use the [ Amazon Web Services Marketplace API](https://docs.aws.amazon.com/marketplace-catalog/latest/api-reference/welcome.html) to obtain the ARN.
    /// This member is required.
    public var relatedEntityIdentifier: Swift.String?
    /// Specifies the entity type that you're associating with the  Opportunity. This helps to categorize and properly process the association.
    /// This member is required.
    public var relatedEntityType: PartnerCentralSellingClientTypes.RelatedEntityType?

    public init(
        catalog: Swift.String? = nil,
        opportunityIdentifier: Swift.String? = nil,
        relatedEntityIdentifier: Swift.String? = nil,
        relatedEntityType: PartnerCentralSellingClientTypes.RelatedEntityType? = nil
    ) {
        self.catalog = catalog
        self.opportunityIdentifier = opportunityIdentifier
        self.relatedEntityIdentifier = relatedEntityIdentifier
        self.relatedEntityType = relatedEntityType
    }
}

extension PartnerCentralSellingClientTypes {

    public enum AwsClosedLostReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case administrative
        case businessAssociateAgreement
        case companyAcquiredDissolved
        case competitiveOffering
        case customerDataRequirement
        case customerDeficiency
        case customerExperience
        case delayCancellationOfProject
        case duplicate
        case duplicateOpportunity
        case executiveBlocker
        case failedVetting
        case featureLimitation
        case financialCommercial
        case insufficientAmazonValue
        case insufficientAwsValue
        case internationalConstraints
        case legalTaxRegulatory
        case legalTermsAndConditions
        case lostToCompetitor
        case lostToCompetitorGoogle
        case lostToCompetitorMicrosoft
        case lostToCompetitorOther
        case lostToCompetitorRackspace
        case lostToCompetitorSoftlayer
        case lostToCompetitorVmware
        case notCommittedToAws
        case noCustomerReference
        case noIntegrationResources
        case noOpportunity
        case noPerceivedValueOfMp
        case noResponse
        case noUpdate
        case onPremisesDeployment
        case other
        case otherDetailsInDescription
        case partnerGap
        case pastDue
        case peopleRelationshipGovernance
        case platformTechnologyLimitation
        case preferenceForCompetitor
        case price
        case productNotOnAws
        case productTechnology
        case securityCompliance
        case selfService
        case technicalLimitations
        case termSheetImpasse
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsClosedLostReason] {
            return [
                .administrative,
                .businessAssociateAgreement,
                .companyAcquiredDissolved,
                .competitiveOffering,
                .customerDataRequirement,
                .customerDeficiency,
                .customerExperience,
                .delayCancellationOfProject,
                .duplicate,
                .duplicateOpportunity,
                .executiveBlocker,
                .failedVetting,
                .featureLimitation,
                .financialCommercial,
                .insufficientAmazonValue,
                .insufficientAwsValue,
                .internationalConstraints,
                .legalTaxRegulatory,
                .legalTermsAndConditions,
                .lostToCompetitor,
                .lostToCompetitorGoogle,
                .lostToCompetitorMicrosoft,
                .lostToCompetitorOther,
                .lostToCompetitorRackspace,
                .lostToCompetitorSoftlayer,
                .lostToCompetitorVmware,
                .notCommittedToAws,
                .noCustomerReference,
                .noIntegrationResources,
                .noOpportunity,
                .noPerceivedValueOfMp,
                .noResponse,
                .noUpdate,
                .onPremisesDeployment,
                .other,
                .otherDetailsInDescription,
                .partnerGap,
                .pastDue,
                .peopleRelationshipGovernance,
                .platformTechnologyLimitation,
                .preferenceForCompetitor,
                .price,
                .productNotOnAws,
                .productTechnology,
                .securityCompliance,
                .selfService,
                .technicalLimitations,
                .termSheetImpasse
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .administrative: return "Administrative"
            case .businessAssociateAgreement: return "Business Associate Agreement"
            case .companyAcquiredDissolved: return "Company Acquired/Dissolved"
            case .competitiveOffering: return "Competitive Offering"
            case .customerDataRequirement: return "Customer Data Requirement"
            case .customerDeficiency: return "Customer Deficiency"
            case .customerExperience: return "Customer Experience"
            case .delayCancellationOfProject: return "Delay / Cancellation of Project"
            case .duplicate: return "Duplicate"
            case .duplicateOpportunity: return "Duplicate Opportunity"
            case .executiveBlocker: return "Executive Blocker"
            case .failedVetting: return "Failed Vetting"
            case .featureLimitation: return "Feature Limitation"
            case .financialCommercial: return "Financial/Commercial"
            case .insufficientAmazonValue: return "Insufficient Amazon Value"
            case .insufficientAwsValue: return "Insufficient AWS Value"
            case .internationalConstraints: return "International Constraints"
            case .legalTaxRegulatory: return "Legal / Tax / Regulatory"
            case .legalTermsAndConditions: return "Legal Terms and Conditions"
            case .lostToCompetitor: return "Lost to Competitor"
            case .lostToCompetitorGoogle: return "Lost to Competitor - Google"
            case .lostToCompetitorMicrosoft: return "Lost to Competitor - Microsoft"
            case .lostToCompetitorOther: return "Lost to Competitor - Other"
            case .lostToCompetitorRackspace: return "Lost to Competitor - Rackspace"
            case .lostToCompetitorSoftlayer: return "Lost to Competitor - SoftLayer"
            case .lostToCompetitorVmware: return "Lost to Competitor - VMWare"
            case .notCommittedToAws: return "Not Committed to AWS"
            case .noCustomerReference: return "No Customer Reference"
            case .noIntegrationResources: return "No Integration Resources"
            case .noOpportunity: return "No Opportunity"
            case .noPerceivedValueOfMp: return "No Perceived Value of MP"
            case .noResponse: return "No Response"
            case .noUpdate: return "No Update"
            case .onPremisesDeployment: return "On Premises Deployment"
            case .other: return "Other"
            case .otherDetailsInDescription: return "Other (Details in Description)"
            case .partnerGap: return "Partner Gap"
            case .pastDue: return "Past Due"
            case .peopleRelationshipGovernance: return "People/Relationship/Governance"
            case .platformTechnologyLimitation: return "Platform Technology Limitation"
            case .preferenceForCompetitor: return "Preference for Competitor"
            case .price: return "Price"
            case .productNotOnAws: return "Product Not on AWS"
            case .productTechnology: return "Product/Technology"
            case .securityCompliance: return "Security / Compliance"
            case .selfService: return "Self-Service"
            case .technicalLimitations: return "Technical Limitations"
            case .termSheetImpasse: return "Term Sheet Impasse"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum AwsFundingUsed: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case no
        case yes
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsFundingUsed] {
            return [
                .no,
                .yes
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .no: return "No"
            case .yes: return "Yes"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum AwsMemberBusinessTitle: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsAccountOwner
        case awsSalesRep
        case isvsm
        case pdm
        case psm
        case wwpspdm
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsMemberBusinessTitle] {
            return [
                .awsAccountOwner,
                .awsSalesRep,
                .isvsm,
                .pdm,
                .psm,
                .wwpspdm
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsAccountOwner: return "AWSAccountOwner"
            case .awsSalesRep: return "AWSSalesRep"
            case .isvsm: return "ISVSM"
            case .pdm: return "PDM"
            case .psm: return "PSM"
            case .wwpspdm: return "WWPSPDM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// An object that contains a Customer Partner's contact details.
    public struct Contact: Swift.Sendable {
        /// The partner contact's title (job title or role) associated with the Opportunity. BusinessTitle supports either PartnerAccountManager or OpportunityOwner.
        public var businessTitle: Swift.String?
        /// The contact's email address associated with the Opportunity.
        public var email: Swift.String?
        /// The contact's first name associated with the Opportunity.
        public var firstName: Swift.String?
        /// The contact's last name associated with the Opportunity.
        public var lastName: Swift.String?
        /// The contact's phone number associated with the Opportunity.
        public var phone: Swift.String?

        public init(
            businessTitle: Swift.String? = nil,
            email: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            phone: Swift.String? = nil
        ) {
            self.businessTitle = businessTitle
            self.email = email
            self.firstName = firstName
            self.lastName = lastName
            self.phone = phone
        }
    }
}

extension PartnerCentralSellingClientTypes.Contact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Contact(businessTitle: \"CONTENT_REDACTED\", email: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// Represents the customer associated with the AWS opportunity. This field captures key details about the customer that are necessary for managing the opportunity.
    public struct AwsOpportunityCustomer: Swift.Sendable {
        /// Provides a list of customer contacts involved in the opportunity. These contacts may include decision makers, influencers, and other stakeholders within the customer's organization.
        public var contacts: [PartnerCentralSellingClientTypes.Contact]?

        public init(
            contacts: [PartnerCentralSellingClientTypes.Contact]? = nil
        ) {
            self.contacts = contacts
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Specific optimization strategies partners can implement to reduce costs.
    public struct AwsProductOptimization: Swift.Sendable {
        /// Human-readable explanation of the optimization strategy.
        /// This member is required.
        public var description: Swift.String?
        /// Quantified cost savings achievable by implementing this optimization.
        /// This member is required.
        public var savingsAmount: Swift.String?

        public init(
            description: Swift.String? = nil,
            savingsAmount: Swift.String? = nil
        ) {
            self.description = description
            self.savingsAmount = savingsAmount
        }
    }
}

extension PartnerCentralSellingClientTypes.AwsProductOptimization: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AwsProductOptimization(description: \(Swift.String(describing: description)), savingsAmount: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// List of AWS services with program eligibility indicators (MAP, modernization pathways), cost estimates, and optimization recommendations.
    public struct AwsProductDetails: Swift.Sendable {
        /// Baseline service cost before optimizations.
        public var amount: Swift.String?
        /// List of program and pathway categories this product is eligible for.
        /// This member is required.
        public var categories: [Swift.String]?
        /// List of specific optimization recommendations for this product.
        /// This member is required.
        public var optimizations: [PartnerCentralSellingClientTypes.AwsProductOptimization]?
        /// Service cost after applying optimizations.
        public var optimizedAmount: Swift.String?
        /// Service-specific cost reduction through optimizations.
        public var potentialSavingsAmount: Swift.String?
        /// AWS Partner Central product identifier used for opportunity association.
        /// This member is required.
        public var productCode: Swift.String?
        /// Pricing Calculator service code.
        public var serviceCode: Swift.String?

        public init(
            amount: Swift.String? = nil,
            categories: [Swift.String]? = nil,
            optimizations: [PartnerCentralSellingClientTypes.AwsProductOptimization]? = nil,
            optimizedAmount: Swift.String? = nil,
            potentialSavingsAmount: Swift.String? = nil,
            productCode: Swift.String? = nil,
            serviceCode: Swift.String? = nil
        ) {
            self.amount = amount
            self.categories = categories
            self.optimizations = optimizations
            self.optimizedAmount = optimizedAmount
            self.potentialSavingsAmount = potentialSavingsAmount
            self.productCode = productCode
            self.serviceCode = serviceCode
        }
    }
}

extension PartnerCentralSellingClientTypes.AwsProductDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AwsProductDetails(categories: \(Swift.String(describing: categories)), optimizations: \(Swift.String(describing: optimizations)), productCode: \(Swift.String(describing: productCode)), serviceCode: \(Swift.String(describing: serviceCode)), amount: \"CONTENT_REDACTED\", optimizedAmount: \"CONTENT_REDACTED\", potentialSavingsAmount: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    public enum CurrencyCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aed
        case afn
        case all
        case amd
        case ang
        case aoa
        case ars
        case aud
        case awg
        case azn
        case bam
        case bbd
        case bdt
        case bgn
        case bhd
        case bif
        case bmd
        case bnd
        case bob
        case bov
        case brl
        case bsd
        case btn
        case bwp
        case byn
        case bzd
        case cad
        case cdf
        case che
        case chf
        case chw
        case clf
        case clp
        case cny
        case cop
        case cou
        case crc
        case cuc
        case cup
        case cve
        case czk
        case djf
        case dkk
        case dop
        case dzd
        case egp
        case ern
        case etb
        case eur
        case fjd
        case fkp
        case gbp
        case gel
        case ghs
        case gip
        case gmd
        case gnf
        case gtq
        case gyd
        case hkd
        case hnl
        case hrk
        case htg
        case huf
        case idr
        case ils
        case inr
        case iqd
        case irr
        case isk
        case jmd
        case jod
        case jpy
        case kes
        case kgs
        case khr
        case kmf
        case kpw
        case krw
        case kwd
        case kyd
        case kzt
        case lak
        case lbp
        case lkr
        case lrd
        case lsl
        case lyd
        case mad
        case mdl
        case mga
        case mkd
        case mmk
        case mnt
        case mop
        case mru
        case mur
        case mvr
        case mwk
        case mxn
        case mxv
        case myr
        case mzn
        case nad
        case ngn
        case nio
        case nok
        case npr
        case nzd
        case omr
        case pab
        case pen
        case pgk
        case php
        case pkr
        case pln
        case pyg
        case qar
        case ron
        case rsd
        case rub
        case rwf
        case sar
        case sbd
        case scr
        case sdg
        case sek
        case sgd
        case shp
        case sll
        case sos
        case srd
        case ssp
        case stn
        case svc
        case syp
        case szl
        case thb
        case tjs
        case tmt
        case tnd
        case top
        case `try`
        case ttd
        case twd
        case tzs
        case uah
        case ugx
        case usd
        case usn
        case uyi
        case uyu
        case uzs
        case vef
        case vnd
        case vuv
        case wst
        case xaf
        case xcd
        case xdr
        case xof
        case xpf
        case xsu
        case xua
        case yer
        case zar
        case zmw
        case zwl
        case sdkUnknown(Swift.String)

        public static var allCases: [CurrencyCode] {
            return [
                .aed,
                .afn,
                .all,
                .amd,
                .ang,
                .aoa,
                .ars,
                .aud,
                .awg,
                .azn,
                .bam,
                .bbd,
                .bdt,
                .bgn,
                .bhd,
                .bif,
                .bmd,
                .bnd,
                .bob,
                .bov,
                .brl,
                .bsd,
                .btn,
                .bwp,
                .byn,
                .bzd,
                .cad,
                .cdf,
                .che,
                .chf,
                .chw,
                .clf,
                .clp,
                .cny,
                .cop,
                .cou,
                .crc,
                .cuc,
                .cup,
                .cve,
                .czk,
                .djf,
                .dkk,
                .dop,
                .dzd,
                .egp,
                .ern,
                .etb,
                .eur,
                .fjd,
                .fkp,
                .gbp,
                .gel,
                .ghs,
                .gip,
                .gmd,
                .gnf,
                .gtq,
                .gyd,
                .hkd,
                .hnl,
                .hrk,
                .htg,
                .huf,
                .idr,
                .ils,
                .inr,
                .iqd,
                .irr,
                .isk,
                .jmd,
                .jod,
                .jpy,
                .kes,
                .kgs,
                .khr,
                .kmf,
                .kpw,
                .krw,
                .kwd,
                .kyd,
                .kzt,
                .lak,
                .lbp,
                .lkr,
                .lrd,
                .lsl,
                .lyd,
                .mad,
                .mdl,
                .mga,
                .mkd,
                .mmk,
                .mnt,
                .mop,
                .mru,
                .mur,
                .mvr,
                .mwk,
                .mxn,
                .mxv,
                .myr,
                .mzn,
                .nad,
                .ngn,
                .nio,
                .nok,
                .npr,
                .nzd,
                .omr,
                .pab,
                .pen,
                .pgk,
                .php,
                .pkr,
                .pln,
                .pyg,
                .qar,
                .ron,
                .rsd,
                .rub,
                .rwf,
                .sar,
                .sbd,
                .scr,
                .sdg,
                .sek,
                .sgd,
                .shp,
                .sll,
                .sos,
                .srd,
                .ssp,
                .stn,
                .svc,
                .syp,
                .szl,
                .thb,
                .tjs,
                .tmt,
                .tnd,
                .top,
                .try,
                .ttd,
                .twd,
                .tzs,
                .uah,
                .ugx,
                .usd,
                .usn,
                .uyi,
                .uyu,
                .uzs,
                .vef,
                .vnd,
                .vuv,
                .wst,
                .xaf,
                .xcd,
                .xdr,
                .xof,
                .xpf,
                .xsu,
                .xua,
                .yer,
                .zar,
                .zmw,
                .zwl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aed: return "AED"
            case .afn: return "AFN"
            case .all: return "ALL"
            case .amd: return "AMD"
            case .ang: return "ANG"
            case .aoa: return "AOA"
            case .ars: return "ARS"
            case .aud: return "AUD"
            case .awg: return "AWG"
            case .azn: return "AZN"
            case .bam: return "BAM"
            case .bbd: return "BBD"
            case .bdt: return "BDT"
            case .bgn: return "BGN"
            case .bhd: return "BHD"
            case .bif: return "BIF"
            case .bmd: return "BMD"
            case .bnd: return "BND"
            case .bob: return "BOB"
            case .bov: return "BOV"
            case .brl: return "BRL"
            case .bsd: return "BSD"
            case .btn: return "BTN"
            case .bwp: return "BWP"
            case .byn: return "BYN"
            case .bzd: return "BZD"
            case .cad: return "CAD"
            case .cdf: return "CDF"
            case .che: return "CHE"
            case .chf: return "CHF"
            case .chw: return "CHW"
            case .clf: return "CLF"
            case .clp: return "CLP"
            case .cny: return "CNY"
            case .cop: return "COP"
            case .cou: return "COU"
            case .crc: return "CRC"
            case .cuc: return "CUC"
            case .cup: return "CUP"
            case .cve: return "CVE"
            case .czk: return "CZK"
            case .djf: return "DJF"
            case .dkk: return "DKK"
            case .dop: return "DOP"
            case .dzd: return "DZD"
            case .egp: return "EGP"
            case .ern: return "ERN"
            case .etb: return "ETB"
            case .eur: return "EUR"
            case .fjd: return "FJD"
            case .fkp: return "FKP"
            case .gbp: return "GBP"
            case .gel: return "GEL"
            case .ghs: return "GHS"
            case .gip: return "GIP"
            case .gmd: return "GMD"
            case .gnf: return "GNF"
            case .gtq: return "GTQ"
            case .gyd: return "GYD"
            case .hkd: return "HKD"
            case .hnl: return "HNL"
            case .hrk: return "HRK"
            case .htg: return "HTG"
            case .huf: return "HUF"
            case .idr: return "IDR"
            case .ils: return "ILS"
            case .inr: return "INR"
            case .iqd: return "IQD"
            case .irr: return "IRR"
            case .isk: return "ISK"
            case .jmd: return "JMD"
            case .jod: return "JOD"
            case .jpy: return "JPY"
            case .kes: return "KES"
            case .kgs: return "KGS"
            case .khr: return "KHR"
            case .kmf: return "KMF"
            case .kpw: return "KPW"
            case .krw: return "KRW"
            case .kwd: return "KWD"
            case .kyd: return "KYD"
            case .kzt: return "KZT"
            case .lak: return "LAK"
            case .lbp: return "LBP"
            case .lkr: return "LKR"
            case .lrd: return "LRD"
            case .lsl: return "LSL"
            case .lyd: return "LYD"
            case .mad: return "MAD"
            case .mdl: return "MDL"
            case .mga: return "MGA"
            case .mkd: return "MKD"
            case .mmk: return "MMK"
            case .mnt: return "MNT"
            case .mop: return "MOP"
            case .mru: return "MRU"
            case .mur: return "MUR"
            case .mvr: return "MVR"
            case .mwk: return "MWK"
            case .mxn: return "MXN"
            case .mxv: return "MXV"
            case .myr: return "MYR"
            case .mzn: return "MZN"
            case .nad: return "NAD"
            case .ngn: return "NGN"
            case .nio: return "NIO"
            case .nok: return "NOK"
            case .npr: return "NPR"
            case .nzd: return "NZD"
            case .omr: return "OMR"
            case .pab: return "PAB"
            case .pen: return "PEN"
            case .pgk: return "PGK"
            case .php: return "PHP"
            case .pkr: return "PKR"
            case .pln: return "PLN"
            case .pyg: return "PYG"
            case .qar: return "QAR"
            case .ron: return "RON"
            case .rsd: return "RSD"
            case .rub: return "RUB"
            case .rwf: return "RWF"
            case .sar: return "SAR"
            case .sbd: return "SBD"
            case .scr: return "SCR"
            case .sdg: return "SDG"
            case .sek: return "SEK"
            case .sgd: return "SGD"
            case .shp: return "SHP"
            case .sll: return "SLL"
            case .sos: return "SOS"
            case .srd: return "SRD"
            case .ssp: return "SSP"
            case .stn: return "STN"
            case .svc: return "SVC"
            case .syp: return "SYP"
            case .szl: return "SZL"
            case .thb: return "THB"
            case .tjs: return "TJS"
            case .tmt: return "TMT"
            case .tnd: return "TND"
            case .top: return "TOP"
            case .try: return "TRY"
            case .ttd: return "TTD"
            case .twd: return "TWD"
            case .tzs: return "TZS"
            case .uah: return "UAH"
            case .ugx: return "UGX"
            case .usd: return "USD"
            case .usn: return "USN"
            case .uyi: return "UYI"
            case .uyu: return "UYU"
            case .uzs: return "UZS"
            case .vef: return "VEF"
            case .vnd: return "VND"
            case .vuv: return "VUV"
            case .wst: return "WST"
            case .xaf: return "XAF"
            case .xcd: return "XCD"
            case .xdr: return "XDR"
            case .xof: return "XOF"
            case .xpf: return "XPF"
            case .xsu: return "XSU"
            case .xua: return "XUA"
            case .yer: return "YER"
            case .zar: return "ZAR"
            case .zmw: return "ZMW"
            case .zwl: return "ZWL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum PaymentFrequency: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case monthly
        case sdkUnknown(Swift.String)

        public static var allCases: [PaymentFrequency] {
            return [
                .monthly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .monthly: return "Monthly"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Comprehensive spend analysis for a single source (AWS or Partner) including total amounts, optimization savings, program category breakdowns, and detailed product-level insights.
    public struct AwsProductInsights: Swift.Sendable {
        /// Product-level details including costs and optimization recommendations.
        /// This member is required.
        public var awsProducts: [PartnerCentralSellingClientTypes.AwsProductDetails]?
        /// ISO 4217 currency code.
        /// This member is required.
        public var currencyCode: PartnerCentralSellingClientTypes.CurrencyCode?
        /// Time period for spend amounts.
        /// This member is required.
        public var frequency: PartnerCentralSellingClientTypes.PaymentFrequency?
        /// Total estimated spend for this source before optimizations.
        public var totalAmount: Swift.String?
        /// Spend amounts mapped to AWS programs and modernization pathways.
        /// This member is required.
        public var totalAmountByCategory: [Swift.String: Swift.String]?
        /// Total estimated spend after applying recommended optimizations.
        public var totalOptimizedAmount: Swift.String?
        /// Quantified savings achievable through implementing optimizations.
        public var totalPotentialSavingsAmount: Swift.String?

        public init(
            awsProducts: [PartnerCentralSellingClientTypes.AwsProductDetails]? = nil,
            currencyCode: PartnerCentralSellingClientTypes.CurrencyCode? = nil,
            frequency: PartnerCentralSellingClientTypes.PaymentFrequency? = nil,
            totalAmount: Swift.String? = nil,
            totalAmountByCategory: [Swift.String: Swift.String]? = nil,
            totalOptimizedAmount: Swift.String? = nil,
            totalPotentialSavingsAmount: Swift.String? = nil
        ) {
            self.awsProducts = awsProducts
            self.currencyCode = currencyCode
            self.frequency = frequency
            self.totalAmount = totalAmount
            self.totalAmountByCategory = totalAmountByCategory
            self.totalOptimizedAmount = totalOptimizedAmount
            self.totalPotentialSavingsAmount = totalPotentialSavingsAmount
        }
    }
}

extension PartnerCentralSellingClientTypes.AwsProductInsights: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AwsProductInsights(awsProducts: \(Swift.String(describing: awsProducts)), frequency: \(Swift.String(describing: frequency)), currencyCode: \"CONTENT_REDACTED\", totalAmount: \"CONTENT_REDACTED\", totalAmountByCategory: [keys: \(Swift.String(describing: totalAmountByCategory?.keys)), values: \"CONTENT_REDACTED\"], totalOptimizedAmount: \"CONTENT_REDACTED\", totalPotentialSavingsAmount: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// Source-separated spend insights that provide independent analysis for AWS recommendations and partner estimates.
    public struct AwsProductsSpendInsightsBySource: Swift.Sendable {
        /// AI-generated insights including recommended products from AWS.
        public var aws: PartnerCentralSellingClientTypes.AwsProductInsights?
        /// Partner-sourced insights derived from Pricing Calculator URLs.
        public var partner: PartnerCentralSellingClientTypes.AwsProductInsights?

        public init(
            aws: PartnerCentralSellingClientTypes.AwsProductInsights? = nil,
            partner: PartnerCentralSellingClientTypes.AwsProductInsights? = nil
        ) {
            self.aws = aws
            self.partner = partner
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum EngagementScore: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [EngagementScore] {
            return [
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "High"
            case .low: return "Low"
            case .medium: return "Medium"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Contains insights provided by AWS for the opportunity, offering recommendations and analysis that can help the partner optimize their engagement and strategy.
    public struct AwsOpportunityInsights: Swift.Sendable {
        /// Source-separated spend insights that provide independent analysis for AWS recommendations and partner estimates.
        public var awsProductsSpendInsightsBySource: PartnerCentralSellingClientTypes.AwsProductsSpendInsightsBySource?
        /// Represents a score assigned by AWS to indicate the level of engagement and potential success for the opportunity. This score helps partners prioritize their efforts.
        public var engagementScore: PartnerCentralSellingClientTypes.EngagementScore?
        /// Provides recommendations from AWS on the next best actions to take in order to move the opportunity forward and increase the likelihood of success.
        public var nextBestActions: Swift.String?

        public init(
            awsProductsSpendInsightsBySource: PartnerCentralSellingClientTypes.AwsProductsSpendInsightsBySource? = nil,
            engagementScore: PartnerCentralSellingClientTypes.EngagementScore? = nil,
            nextBestActions: Swift.String? = nil
        ) {
            self.awsProductsSpendInsightsBySource = awsProductsSpendInsightsBySource
            self.engagementScore = engagementScore
            self.nextBestActions = nextBestActions
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Tracks the history of next steps associated with the opportunity. This field captures the actions planned for the future and their timeline.
    public struct ProfileNextStepsHistory: Swift.Sendable {
        /// Indicates the date and time when a particular next step was recorded or planned. This helps in managing the timeline for the opportunity.
        /// This member is required.
        public var time: Foundation.Date?
        /// Represents the details of the next step recorded, such as follow-up actions or decisions made. This field helps in tracking progress and ensuring alignment with project goals.
        /// This member is required.
        public var value: Swift.String?

        public init(
            time: Foundation.Date? = nil,
            value: Swift.String? = nil
        ) {
            self.time = time
            self.value = value
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum AwsOpportunityStage: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case buildingIntegration
        case businessValidation
        case closedIncomplete
        case closedLost
        case committed
        case completed
        case contractNegotiation
        case deferredToPartner
        case engaged
        case evaluating
        case identified
        case inProgress
        case launched
        case notStarted
        case onboarding
        case onHold
        case prospect
        case qualified
        case qualify
        case research
        case sellerEngaged
        case sellerRegistered
        case technicalValidation
        case termSheetNegotiation
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsOpportunityStage] {
            return [
                .buildingIntegration,
                .businessValidation,
                .closedIncomplete,
                .closedLost,
                .committed,
                .completed,
                .contractNegotiation,
                .deferredToPartner,
                .engaged,
                .evaluating,
                .identified,
                .inProgress,
                .launched,
                .notStarted,
                .onboarding,
                .onHold,
                .prospect,
                .qualified,
                .qualify,
                .research,
                .sellerEngaged,
                .sellerRegistered,
                .technicalValidation,
                .termSheetNegotiation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .buildingIntegration: return "Building Integration"
            case .businessValidation: return "Business Validation"
            case .closedIncomplete: return "Closed Incomplete"
            case .closedLost: return "Closed Lost"
            case .committed: return "Committed"
            case .completed: return "Completed"
            case .contractNegotiation: return "Contract Negotiation"
            case .deferredToPartner: return "Deferred to Partner"
            case .engaged: return "Engaged"
            case .evaluating: return "Evaluating"
            case .identified: return "Identified"
            case .inProgress: return "In Progress"
            case .launched: return "Launched"
            case .notStarted: return "Not Started"
            case .onboarding: return "Onboarding"
            case .onHold: return "On-hold"
            case .prospect: return "Prospect"
            case .qualified: return "Qualified"
            case .qualify: return "Qualify"
            case .research: return "Research"
            case .sellerEngaged: return "Seller Engaged"
            case .sellerRegistered: return "Seller Registered"
            case .technicalValidation: return "Technical Validation"
            case .termSheetNegotiation: return "Term Sheet Negotiation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Tracks the lifecycle of the AWS opportunity, including stages such as qualification, validation, and closure. This field helps partners understand the current status and progression of the opportunity.
    public struct AwsOpportunityLifeCycle: Swift.Sendable {
        /// Indicates the reason why an opportunity was marked as Closed Lost. This helps in understanding the context behind the lost opportunity and aids in refining future strategies.
        public var closedLostReason: PartnerCentralSellingClientTypes.AwsClosedLostReason?
        /// Specifies the immediate next steps required to progress the opportunity. These steps are based on AWS guidance and the current stage of the opportunity.
        public var nextSteps: Swift.String?
        /// Provides a historical log of previous next steps that were taken to move the opportunity forward. This helps in tracking the decision-making process and identifying any delays or obstacles encountered.
        public var nextStepsHistory: [PartnerCentralSellingClientTypes.ProfileNextStepsHistory]?
        /// Represents the current stage of the opportunity in its lifecycle, such as Qualification, Validation, or Closed Won. This helps in understanding the opportunity's progress.
        public var stage: PartnerCentralSellingClientTypes.AwsOpportunityStage?
        /// Indicates the expected date by which the opportunity is projected to close. This field helps in planning resources and timelines for both the partner and AWS.
        public var targetCloseDate: Swift.String?

        public init(
            closedLostReason: PartnerCentralSellingClientTypes.AwsClosedLostReason? = nil,
            nextSteps: Swift.String? = nil,
            nextStepsHistory: [PartnerCentralSellingClientTypes.ProfileNextStepsHistory]? = nil,
            stage: PartnerCentralSellingClientTypes.AwsOpportunityStage? = nil,
            targetCloseDate: Swift.String? = nil
        ) {
            self.closedLostReason = closedLostReason
            self.nextSteps = nextSteps
            self.nextStepsHistory = nextStepsHistory
            self.stage = stage
            self.targetCloseDate = targetCloseDate
        }
    }
}

extension PartnerCentralSellingClientTypes.AwsOpportunityLifeCycle: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AwsOpportunityLifeCycle(closedLostReason: \(Swift.String(describing: closedLostReason)), nextStepsHistory: \(Swift.String(describing: nextStepsHistory)), stage: \(Swift.String(describing: stage)), targetCloseDate: \(Swift.String(describing: targetCloseDate)), nextSteps: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    public enum AwsPartition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsEusc
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsPartition] {
            return [
                .awsEusc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsEusc: return "aws-eusc"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Provides an estimate of the revenue that the partner is expected to generate from the opportunity. This information helps partners assess the financial value of the project.
    public struct ExpectedCustomerSpend: Swift.Sendable {
        /// Represents the estimated monthly revenue that the partner expects to earn from the opportunity. This helps in forecasting financial returns.
        public var amount: Swift.String?
        /// Indicates the currency in which the revenue estimate is provided. This helps in understanding the financial impact across different markets.
        /// This member is required.
        public var currencyCode: PartnerCentralSellingClientTypes.CurrencyCode?
        /// A URL providing additional information or context about the spend estimation.
        public var estimationUrl: Swift.String?
        /// Indicates how frequently the customer is expected to spend the projected amount. Only the value Monthly is allowed for the Frequency field, representing recurring monthly spend.
        /// This member is required.
        public var frequency: PartnerCentralSellingClientTypes.PaymentFrequency?
        /// Specifies the name of the partner company that is expected to generate revenue from the opportunity. This field helps track the partner’s involvement in the opportunity. This field only accepts the value AWS. If any other value is provided, the system will automatically set it to AWS.
        /// This member is required.
        public var targetCompany: Swift.String?

        public init(
            amount: Swift.String? = "",
            currencyCode: PartnerCentralSellingClientTypes.CurrencyCode? = nil,
            estimationUrl: Swift.String? = nil,
            frequency: PartnerCentralSellingClientTypes.PaymentFrequency? = nil,
            targetCompany: Swift.String? = nil
        ) {
            self.amount = amount
            self.currencyCode = currencyCode
            self.estimationUrl = estimationUrl
            self.frequency = frequency
            self.targetCompany = targetCompany
        }
    }
}

extension PartnerCentralSellingClientTypes.ExpectedCustomerSpend: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ExpectedCustomerSpend(estimationUrl: \(Swift.String(describing: estimationUrl)), frequency: \(Swift.String(describing: frequency)), targetCompany: \(Swift.String(describing: targetCompany)), amount: \"CONTENT_REDACTED\", currencyCode: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// Captures details about the project associated with the opportunity, including objectives, scope, and customer requirements.
    public struct AwsOpportunityProject: Swift.Sendable {
        /// AWS partition where the opportunity will be deployed. Possible values: aws-eusc for AWS European Sovereign Cloud, null for all other partitions.
        public var awsPartition: PartnerCentralSellingClientTypes.AwsPartition?
        /// Indicates the expected spending by the customer over the course of the project. This value helps partners and AWS estimate the financial impact of the opportunity. Use the [AWS Pricing Calculator](https://calculator.aws/#/) to create an estimate of the customer’s total spend. If only annual recurring revenue (ARR) is available, distribute it across 12 months to provide an average monthly value.
        public var expectedCustomerSpend: [PartnerCentralSellingClientTypes.ExpectedCustomerSpend]?

        public init(
            awsPartition: PartnerCentralSellingClientTypes.AwsPartition? = nil,
            expectedCustomerSpend: [PartnerCentralSellingClientTypes.ExpectedCustomerSpend]? = nil
        ) {
            self.awsPartition = awsPartition
            self.expectedCustomerSpend = expectedCustomerSpend
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Represents other entities related to the AWS opportunity, such as AWS products, partner solutions, and marketplace offers. These associations help build a complete picture of the solution being sold.
    public struct AwsOpportunityRelatedEntities: Swift.Sendable {
        /// Specifies the AWS products associated with the opportunity. This field helps track the specific products that are part of the proposed solution.
        public var awsProducts: [Swift.String]?
        /// Specifies the partner solutions related to the opportunity. These solutions represent the partner's offerings that are being positioned as part of the overall AWS opportunity.
        public var solutions: [Swift.String]?

        public init(
            awsProducts: [Swift.String]? = nil,
            solutions: [Swift.String]? = nil
        ) {
            self.awsProducts = awsProducts
            self.solutions = solutions
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum SalesInvolvementType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case coSell
        case forVisibilityOnly
        case sdkUnknown(Swift.String)

        public static var allCases: [SalesInvolvementType] {
            return [
                .coSell,
                .forVisibilityOnly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .coSell: return "Co-Sell"
            case .forVisibilityOnly: return "For Visibility Only"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum InvolvementTypeChangeReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case changeInDealInformation
        case customerRequested
        case expansionOpportunity
        case riskMitigation
        case technicalComplexity
        case sdkUnknown(Swift.String)

        public static var allCases: [InvolvementTypeChangeReason] {
            return [
                .changeInDealInformation,
                .customerRequested,
                .expansionOpportunity,
                .riskMitigation,
                .technicalComplexity
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .changeInDealInformation: return "Change in Deal Information"
            case .customerRequested: return "Customer Requested"
            case .expansionOpportunity: return "Expansion Opportunity"
            case .riskMitigation: return "Risk Mitigation"
            case .technicalComplexity: return "Technical Complexity"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Represents an Amazon Web Services team member for the engagement. This structure includes details such as name, email, and business title.
    public struct AwsTeamMember: Swift.Sendable {
        /// Specifies the Amazon Web Services team member's business title and indicates their organizational role.
        public var businessTitle: PartnerCentralSellingClientTypes.AwsMemberBusinessTitle?
        /// Provides the Amazon Web Services team member's email address.
        public var email: Swift.String?
        /// Provides the Amazon Web Services team member's first name.
        public var firstName: Swift.String?
        /// Provides the Amazon Web Services team member's last name.
        public var lastName: Swift.String?

        public init(
            businessTitle: PartnerCentralSellingClientTypes.AwsMemberBusinessTitle? = nil,
            email: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil
        ) {
            self.businessTitle = businessTitle
            self.email = email
            self.firstName = firstName
            self.lastName = lastName
        }
    }
}

extension PartnerCentralSellingClientTypes.AwsTeamMember: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AwsTeamMember(businessTitle: \(Swift.String(describing: businessTitle)), email: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    public enum OpportunityOrigin: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsReferral
        case partnerReferral
        case sdkUnknown(Swift.String)

        public static var allCases: [OpportunityOrigin] {
            return [
                .awsReferral,
                .partnerReferral
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsReferral: return "AWS Referral"
            case .partnerReferral: return "Partner Referral"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum Visibility: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case full
        case limited
        case sdkUnknown(Swift.String)

        public static var allCases: [Visibility] {
            return [
                .full,
                .limited
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .full: return "Full"
            case .limited: return "Limited"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Provides a comprehensive view of AwsOpportunitySummaryFullView template.
    public struct AwsOpportunitySummaryFullView: Swift.Sendable {
        /// Represents the customer associated with the AWS opportunity. This field captures key details about the customer that are necessary for managing the opportunity.
        public var customer: PartnerCentralSellingClientTypes.AwsOpportunityCustomer?
        /// Contains insights provided by AWS for the opportunity, offering recommendations and analysis that can help the partner optimize their engagement and strategy.
        public var insights: PartnerCentralSellingClientTypes.AwsOpportunityInsights?
        /// Type of AWS involvement in the opportunity.
        public var involvementType: PartnerCentralSellingClientTypes.SalesInvolvementType?
        /// Reason for changes in AWS involvement type for the opportunity.
        public var involvementTypeChangeReason: PartnerCentralSellingClientTypes.InvolvementTypeChangeReason?
        /// Tracks the lifecycle of the AWS opportunity, including stages such as qualification, validation, and closure. This field helps partners understand the current status and progression of the opportunity.
        public var lifeCycle: PartnerCentralSellingClientTypes.AwsOpportunityLifeCycle?
        /// AWS team members involved in the opportunity.
        public var opportunityTeam: [PartnerCentralSellingClientTypes.AwsTeamMember]?
        /// Source origin of the AWS opportunity.
        public var origin: PartnerCentralSellingClientTypes.OpportunityOrigin?
        /// Captures details about the project associated with the opportunity, including objectives, scope, and customer requirements.
        public var project: PartnerCentralSellingClientTypes.AwsOpportunityProject?
        /// Represents other entities related to the AWS opportunity, such as AWS products, partner solutions, and marketplace offers. These associations help build a complete picture of the solution being sold.
        public var relatedEntityIds: PartnerCentralSellingClientTypes.AwsOpportunityRelatedEntities?
        /// Identifier of the related partner opportunity.
        public var relatedOpportunityId: Swift.String?
        /// Visibility level for the AWS opportunity.
        public var visibility: PartnerCentralSellingClientTypes.Visibility?

        public init(
            customer: PartnerCentralSellingClientTypes.AwsOpportunityCustomer? = nil,
            insights: PartnerCentralSellingClientTypes.AwsOpportunityInsights? = nil,
            involvementType: PartnerCentralSellingClientTypes.SalesInvolvementType? = nil,
            involvementTypeChangeReason: PartnerCentralSellingClientTypes.InvolvementTypeChangeReason? = nil,
            lifeCycle: PartnerCentralSellingClientTypes.AwsOpportunityLifeCycle? = nil,
            opportunityTeam: [PartnerCentralSellingClientTypes.AwsTeamMember]? = nil,
            origin: PartnerCentralSellingClientTypes.OpportunityOrigin? = nil,
            project: PartnerCentralSellingClientTypes.AwsOpportunityProject? = nil,
            relatedEntityIds: PartnerCentralSellingClientTypes.AwsOpportunityRelatedEntities? = nil,
            relatedOpportunityId: Swift.String? = nil,
            visibility: PartnerCentralSellingClientTypes.Visibility? = nil
        ) {
            self.customer = customer
            self.insights = insights
            self.involvementType = involvementType
            self.involvementTypeChangeReason = involvementTypeChangeReason
            self.lifeCycle = lifeCycle
            self.opportunityTeam = opportunityTeam
            self.origin = origin
            self.project = project
            self.relatedEntityIds = relatedEntityIds
            self.relatedOpportunityId = relatedOpportunityId
            self.visibility = visibility
        }
    }
}

/// This error occurs when the request would cause a service quota to be exceeded. Service quotas represent the maximum allowed use of a specific resource, and this error indicates that the request would surpass that limit. Suggested action: Review the [Quotas](https://docs.aws.amazon.com/partner-central/latest/selling-api/quotas.html) for the resource, and either reduce usage or request a quota increase.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension PartnerCentralSellingClientTypes {

    /// Contains details about the customer associated with the Engagement Invitation, including company information and industry.
    public struct EngagementCustomer: Swift.Sendable {
        /// Represents the name of the customer’s company associated with the Engagement Invitation. This field is used to identify the customer.
        /// This member is required.
        public var companyName: Swift.String?
        /// Indicates the country in which the customer’s company operates. This field is useful for understanding regional requirements or compliance needs.
        /// This member is required.
        public var countryCode: PartnerCentralSellingClientTypes.CountryCode?
        /// Specifies the industry to which the customer’s company belongs. This field helps categorize the opportunity based on the customer’s business sector.
        /// This member is required.
        public var industry: PartnerCentralSellingClientTypes.Industry?
        /// Provides the website URL of the customer’s company. This field helps partners verify the legitimacy and size of the customer organization.
        /// This member is required.
        public var websiteUrl: Swift.String?

        public init(
            companyName: Swift.String? = nil,
            countryCode: PartnerCentralSellingClientTypes.CountryCode? = nil,
            industry: PartnerCentralSellingClientTypes.Industry? = nil,
            websiteUrl: Swift.String? = nil
        ) {
            self.companyName = companyName
            self.countryCode = countryCode
            self.industry = industry
            self.websiteUrl = websiteUrl
        }
    }
}

extension PartnerCentralSellingClientTypes.EngagementCustomer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EngagementCustomer(industry: \(Swift.String(describing: industry)), companyName: \"CONTENT_REDACTED\", countryCode: \"CONTENT_REDACTED\", websiteUrl: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// Provides comprehensive details about a customer project associated with an Engagement. This may include information such as project goals, timelines, and specific customer requirements.
    public struct EngagementCustomerProjectDetails: Swift.Sendable {
        /// A description of the business problem the project aims to solve.
        /// This member is required.
        public var businessProblem: Swift.String?
        /// The target completion date for the customer's project.
        /// This member is required.
        public var targetCompletionDate: Swift.String?
        /// The title of the project.
        /// This member is required.
        public var title: Swift.String?

        public init(
            businessProblem: Swift.String? = nil,
            targetCompletionDate: Swift.String? = nil,
            title: Swift.String? = nil
        ) {
            self.businessProblem = businessProblem
            self.targetCompletionDate = targetCompletionDate
            self.title = title
        }
    }
}

extension PartnerCentralSellingClientTypes.EngagementCustomerProjectDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EngagementCustomerProjectDetails(targetCompletionDate: \(Swift.String(describing: targetCompletionDate)), title: \(Swift.String(describing: title)), businessProblem: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// The CustomerProjects structure in Engagements offers a flexible framework for managing customer-project relationships. It supports multiple customers per Engagement and multiple projects per customer, while also allowing for customers without projects and projects without specific customers. All Engagement members have full visibility of customers and their associated projects, enabling the capture of relevant context even when project details are not fully defined. This structure also facilitates targeted invitations, allowing partners to focus on specific customers and their business problems when sending Engagement invitations.
    public struct CustomerProjectsContext: Swift.Sendable {
        /// Contains details about the customer associated with the Engagement Invitation, including company information and industry.
        public var customer: PartnerCentralSellingClientTypes.EngagementCustomer?
        /// Information about the customer project associated with the Engagement.
        public var project: PartnerCentralSellingClientTypes.EngagementCustomerProjectDetails?

        public init(
            customer: PartnerCentralSellingClientTypes.EngagementCustomer? = nil,
            project: PartnerCentralSellingClientTypes.EngagementCustomerProjectDetails? = nil
        ) {
            self.customer = customer
            self.project = project
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum MarketSegment: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enterprise
        case large
        case medium
        case micro
        case small
        case sdkUnknown(Swift.String)

        public static var allCases: [MarketSegment] {
            return [
                .enterprise,
                .large,
                .medium,
                .micro,
                .small
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enterprise: return "Enterprise"
            case .large: return "Large"
            case .medium: return "Medium"
            case .micro: return "Micro"
            case .small: return "Small"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Contains detailed information about the customer associated with the lead, including company details, industry classification, and AWS maturity level. This information helps qualify and categorize the lead for appropriate engagement strategies.
    public struct LeadCustomer: Swift.Sendable {
        /// An object that contains an Address object's subset of fields.
        /// This member is required.
        public var address: PartnerCentralSellingClientTypes.AddressSummary?
        /// Indicates the customer's level of experience and adoption with AWS services. This assessment helps determine the appropriate engagement approach and solution complexity.
        public var awsMaturity: Swift.String?
        /// The name of the lead customer's company. This field is essential for identifying and tracking the customer organization associated with the lead.
        /// This member is required.
        public var companyName: Swift.String?
        /// Specifies the industry sector to which the lead customer's company belongs. This categorization helps in understanding the customer's business context and tailoring appropriate solutions.
        public var industry: PartnerCentralSellingClientTypes.Industry?
        /// Specifies the market segment classification of the lead customer, such as enterprise, mid-market, or small business. This segmentation helps in targeting appropriate solutions and engagement strategies.
        public var marketSegment: PartnerCentralSellingClientTypes.MarketSegment?
        /// The website URL of the lead customer's company. This provides additional context about the customer organization and helps verify company legitimacy and size.
        public var websiteUrl: Swift.String?

        public init(
            address: PartnerCentralSellingClientTypes.AddressSummary? = nil,
            awsMaturity: Swift.String? = nil,
            companyName: Swift.String? = nil,
            industry: PartnerCentralSellingClientTypes.Industry? = nil,
            marketSegment: PartnerCentralSellingClientTypes.MarketSegment? = nil,
            websiteUrl: Swift.String? = nil
        ) {
            self.address = address
            self.awsMaturity = awsMaturity
            self.companyName = companyName
            self.industry = industry
            self.marketSegment = marketSegment
            self.websiteUrl = websiteUrl
        }
    }
}

extension PartnerCentralSellingClientTypes.LeadCustomer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LeadCustomer(address: \(Swift.String(describing: address)), awsMaturity: \(Swift.String(describing: awsMaturity)), industry: \(Swift.String(describing: industry)), marketSegment: \(Swift.String(describing: marketSegment)), companyName: \"CONTENT_REDACTED\", websiteUrl: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// An object that contains a lead contact's details associated with the engagement. This provides contact information for individuals involved in lead-related activities.
    public struct LeadContact: Swift.Sendable {
        /// The lead contact's business title or job role associated with the engagement.
        /// This member is required.
        public var businessTitle: Swift.String?
        /// The lead contact's email address associated with the engagement.
        /// This member is required.
        public var email: Swift.String?
        /// The lead contact's first name associated with the engagement.
        /// This member is required.
        public var firstName: Swift.String?
        /// The lead contact's last name associated with the engagement.
        /// This member is required.
        public var lastName: Swift.String?
        /// The lead contact's phone number associated with the engagement.
        public var phone: Swift.String?

        public init(
            businessTitle: Swift.String? = nil,
            email: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            phone: Swift.String? = nil
        ) {
            self.businessTitle = businessTitle
            self.email = email
            self.firstName = firstName
            self.lastName = lastName
            self.phone = phone
        }
    }
}

extension PartnerCentralSellingClientTypes.LeadContact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LeadContact(businessTitle: \"CONTENT_REDACTED\", email: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// Represents a specific interaction or touchpoint with a lead customer. This structure captures details about communications, meetings, or other engagement activities that help track the lead's progression and engagement history.
    public struct LeadInteraction: Swift.Sendable {
        /// Describes the business problem or challenge that the customer discussed during the interaction. This information helps qualify the lead and identify appropriate solutions.
        public var businessProblem: Swift.String?
        /// Contains contact information for the customer representative involved in the lead interaction, including their name, title, and contact details.
        /// This member is required.
        public var contact: PartnerCentralSellingClientTypes.LeadContact?
        /// Describes the action taken by the customer during or as a result of the interaction, such as requesting information, scheduling a meeting, or expressing interest in a solution.
        /// This member is required.
        public var customerAction: Swift.String?
        /// The date and time when the lead interaction occurred, in ISO 8601 format (UTC). This timestamp helps track the chronology of lead engagement activities.
        public var interactionDate: Foundation.Date?
        /// The unique identifier of the specific source that generated the lead interaction. This ID provides traceability back to the original lead generation activity.
        /// This member is required.
        public var sourceId: Swift.String?
        /// The descriptive name of the source that generated the lead interaction, providing a human-readable identifier for the lead generation channel or activity.
        /// This member is required.
        public var sourceName: Swift.String?
        /// Specifies the type of source that generated the lead interaction, such as "Event", "Website", "Referral", or "Campaign". This categorization helps track lead generation effectiveness across different channels.
        /// This member is required.
        public var sourceType: Swift.String?
        /// Describes the specific use case or business scenario discussed during the lead interaction. This helps categorize the customer's interests and potential solutions.
        public var usecase: Swift.String?

        public init(
            businessProblem: Swift.String? = nil,
            contact: PartnerCentralSellingClientTypes.LeadContact? = nil,
            customerAction: Swift.String? = nil,
            interactionDate: Foundation.Date? = nil,
            sourceId: Swift.String? = nil,
            sourceName: Swift.String? = nil,
            sourceType: Swift.String? = nil,
            usecase: Swift.String? = nil
        ) {
            self.businessProblem = businessProblem
            self.contact = contact
            self.customerAction = customerAction
            self.interactionDate = interactionDate
            self.sourceId = sourceId
            self.sourceName = sourceName
            self.sourceType = sourceType
            self.usecase = usecase
        }
    }
}

extension PartnerCentralSellingClientTypes.LeadInteraction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LeadInteraction(contact: \(Swift.String(describing: contact)), customerAction: \(Swift.String(describing: customerAction)), interactionDate: \(Swift.String(describing: interactionDate)), sourceId: \(Swift.String(describing: sourceId)), sourceName: \(Swift.String(describing: sourceName)), sourceType: \(Swift.String(describing: sourceType)), usecase: \(Swift.String(describing: usecase)), businessProblem: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// Provides comprehensive details about a lead associated with an engagement. This structure contains information about lead qualification status, customer details, and interaction history to facilitate lead management and tracking within the engagement.
    public struct LeadContext: Swift.Sendable {
        /// Contains detailed information about the customer associated with the lead, including company information, contact details, and other relevant customer data.
        /// This member is required.
        public var customer: PartnerCentralSellingClientTypes.LeadCustomer?
        /// An array of interactions that have occurred with the lead, providing a history of communications, meetings, and other engagement activities related to the lead.
        /// This member is required.
        public var interactions: [PartnerCentralSellingClientTypes.LeadInteraction]?
        /// Indicates the current qualification status of the lead, such as whether it has been qualified, disqualified, or is still under evaluation. This helps track the lead's progression through the qualification process.
        public var qualificationStatus: Swift.String?

        public init(
            customer: PartnerCentralSellingClientTypes.LeadCustomer? = nil,
            interactions: [PartnerCentralSellingClientTypes.LeadInteraction]? = nil,
            qualificationStatus: Swift.String? = "Unqualified"
        ) {
            self.customer = customer
            self.interactions = interactions
            self.qualificationStatus = qualificationStatus
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Represents the payload of an Engagement context. The structure of this payload varies based on the context type specified in the EngagementContextDetails.
    public enum EngagementContextPayload: Swift.Sendable {
        /// Contains detailed information about a customer project when the context type is "CustomerProject". This field is present only when the Type in EngagementContextDetails is set to "CustomerProject".
        case customerproject(PartnerCentralSellingClientTypes.CustomerProjectsContext)
        /// Contains detailed information about a lead when the context type is "Lead". This field is present only when the Type in EngagementContextDetails is set to "Lead".
        case lead(PartnerCentralSellingClientTypes.LeadContext)
        case sdkUnknown(Swift.String)
    }
}

extension PartnerCentralSellingClientTypes {

    public enum EngagementContextType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customerProject
        case lead
        case sdkUnknown(Swift.String)

        public static var allCases: [EngagementContextType] {
            return [
                .customerProject,
                .lead
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customerProject: return "CustomerProject"
            case .lead: return "Lead"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateEngagementContextInput: Swift.Sendable {
    /// Specifies the catalog associated with the engagement context request. This field takes a string value from a predefined list: AWS or Sandbox. The catalog determines which environment the engagement context is created in. Use AWS to create contexts in the production environment, and Sandbox for testing in secure, isolated environments.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier provided by the client to ensure that the request is handled exactly once. This token helps prevent duplicate context creations and must not exceed sixty-four alphanumeric characters. Use a UUID or other unique string to ensure idempotency.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The unique identifier of the Engagement for which the context is being created. This parameter ensures the context is associated with the correct engagement and provides the necessary linkage between the engagement and its contextual information.
    /// This member is required.
    public var engagementIdentifier: Swift.String?
    /// Represents the payload of an Engagement context. The structure of this payload varies based on the context type specified in the EngagementContextDetails.
    /// This member is required.
    public var payload: PartnerCentralSellingClientTypes.EngagementContextPayload?
    /// Specifies the type of context being created for the engagement. This field determines the structure and content of the context payload. Valid values include CustomerProject for customer project-related contexts. The type field ensures that the context is properly categorized and processed according to its intended purpose.
    /// This member is required.
    public var type: PartnerCentralSellingClientTypes.EngagementContextType?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        engagementIdentifier: Swift.String? = nil,
        payload: PartnerCentralSellingClientTypes.EngagementContextPayload? = nil,
        type: PartnerCentralSellingClientTypes.EngagementContextType? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.engagementIdentifier = engagementIdentifier
        self.payload = payload
        self.type = type
    }
}

public struct CreateEngagementContextOutput: Swift.Sendable {
    /// The unique identifier assigned to the newly created engagement context. This ID can be used to reference the specific context within the engagement for future operations.
    public var contextId: Swift.String?
    /// The Amazon Resource Name (ARN) of the engagement to which the context was added. This globally unique identifier can be used for cross-service references and IAM policies.
    public var engagementArn: Swift.String?
    /// The unique identifier of the engagement to which the context was added. This ID confirms the successful association of the context with the specified engagement.
    public var engagementId: Swift.String?
    /// The timestamp indicating when the engagement was last modified as a result of adding the context, in ISO 8601 format (UTC). Example: "2023-05-01T20:37:46Z".
    public var engagementLastModifiedAt: Foundation.Date?

    public init(
        contextId: Swift.String? = nil,
        engagementArn: Swift.String? = nil,
        engagementId: Swift.String? = nil,
        engagementLastModifiedAt: Foundation.Date? = nil
    ) {
        self.contextId = contextId
        self.engagementArn = engagementArn
        self.engagementId = engagementId
        self.engagementLastModifiedAt = engagementLastModifiedAt
    }
}

extension PartnerCentralSellingClientTypes {

    /// Provides detailed context information for an Engagement. This structure allows for specifying the type of context and its associated payload.
    public struct EngagementContextDetails: Swift.Sendable {
        /// The unique identifier of the engagement context. This ID is used to reference and manage the specific context within the engagement.
        public var id: Swift.String?
        /// Contains the specific details of the Engagement context. The structure of this payload varies depending on the Type field.
        public var payload: PartnerCentralSellingClientTypes.EngagementContextPayload?
        /// Specifies the type of Engagement context. Valid values are "CustomerProject" or "Document", indicating whether the context relates to a customer project or a document respectively.
        /// This member is required.
        public var type: PartnerCentralSellingClientTypes.EngagementContextType?

        public init(
            id: Swift.String? = nil,
            payload: PartnerCentralSellingClientTypes.EngagementContextPayload? = nil,
            type: PartnerCentralSellingClientTypes.EngagementContextType? = nil
        ) {
            self.id = id
            self.payload = payload
            self.type = type
        }
    }
}

public struct CreateEngagementInput: Swift.Sendable {
    /// The CreateEngagementRequest$Catalog parameter specifies the catalog related to the engagement. Accepted values are AWS and Sandbox, which determine the environment in which the engagement is managed.
    /// This member is required.
    public var catalog: Swift.String?
    /// The CreateEngagementRequest$ClientToken parameter specifies a unique, case-sensitive identifier to ensure that the request is handled exactly once. The value must not exceed sixty-four alphanumeric characters.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The Contexts field is a required array of objects, with a maximum of 5 contexts allowed, specifying detailed information about customer projects associated with the Engagement. Each context object contains a Type field indicating the context type, which must be CustomerProject in this version, and a Payload field containing the CustomerProject details. The CustomerProject object is composed of two main components: Customer and Project. The Customer object includes information such as CompanyName, WebsiteUrl, Industry, and CountryCode, providing essential details about the customer. The Project object contains Title, BusinessProblem, and TargetCompletionDate, offering insights into the specific project associated with the customer. This structure allows comprehensive context to be included within the Engagement, facilitating effective collaboration between parties by providing relevant customer and project information.
    public var contexts: [PartnerCentralSellingClientTypes.EngagementContextDetails]?
    /// Provides a description of the Engagement.
    /// This member is required.
    public var description: Swift.String?
    /// Specifies the title of the Engagement.
    /// This member is required.
    public var title: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        contexts: [PartnerCentralSellingClientTypes.EngagementContextDetails]? = nil,
        description: Swift.String? = nil,
        title: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.contexts = contexts
        self.description = description
        self.title = title
    }
}

public struct CreateEngagementOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that identifies the engagement.
    public var arn: Swift.String?
    /// Unique identifier assigned to the newly created engagement.
    public var id: Swift.String?
    /// The timestamp indicating when the engagement was last modified, in ISO 8601 format (UTC). For newly created engagements, this value matches the creation timestamp. Example: "2023-05-01T20:37:46Z".
    public var modifiedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil,
        modifiedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.id = id
        self.modifiedAt = modifiedAt
    }
}

public struct GetEngagementInput: Swift.Sendable {
    /// Specifies the catalog related to the engagement request. Valid values are AWS and Sandbox.
    /// This member is required.
    public var catalog: Swift.String?
    /// Specifies the identifier of the Engagement record to retrieve.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
    }
}

public struct GetEngagementOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the engagement retrieved.
    public var arn: Swift.String?
    /// A list of context objects associated with the engagement. Each context provides additional information related to the Engagement, such as customer projects or documents.
    public var contexts: [PartnerCentralSellingClientTypes.EngagementContextDetails]?
    /// The date and time when the Engagement was created, presented in ISO 8601 format (UTC). For example: "2023-05-01T20:37:46Z". This timestamp helps track the lifecycle of the Engagement.
    public var createdAt: Foundation.Date?
    /// The AWS account ID of the user who originally created the engagement. This field helps in tracking the origin of the engagement.
    public var createdBy: Swift.String?
    /// A more detailed description of the engagement. This provides additional context or information about the engagement's purpose or scope.
    public var description: Swift.String?
    /// The unique resource identifier of the engagement retrieved.
    public var id: Swift.String?
    /// Specifies the current count of members participating in the Engagement. This count includes all active members regardless of their roles or permissions within the Engagement.
    public var memberCount: Swift.Int?
    /// The timestamp indicating when the engagement was last modified, in ISO 8601 format (UTC). Example: "2023-05-01T20:37:46Z". This helps track the most recent changes to the engagement.
    public var modifiedAt: Foundation.Date?
    /// The AWS account ID of the user who last modified the engagement. This field helps track who made the most recent changes to the engagement.
    public var modifiedBy: Swift.String?
    /// The title of the engagement. It provides a brief, descriptive name for the engagement that is meaningful and easily recognizable.
    public var title: Swift.String?

    public init(
        arn: Swift.String? = nil,
        contexts: [PartnerCentralSellingClientTypes.EngagementContextDetails]? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        description: Swift.String? = nil,
        id: Swift.String? = nil,
        memberCount: Swift.Int? = nil,
        modifiedAt: Foundation.Date? = nil,
        modifiedBy: Swift.String? = nil,
        title: Swift.String? = nil
    ) {
        self.arn = arn
        self.contexts = contexts
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.description = description
        self.id = id
        self.memberCount = memberCount
        self.modifiedAt = modifiedAt
        self.modifiedBy = modifiedBy
        self.title = title
    }
}

extension GetEngagementOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEngagementOutput(arn: \(Swift.String(describing: arn)), contexts: \(Swift.String(describing: contexts)), createdAt: \(Swift.String(describing: createdAt)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), memberCount: \(Swift.String(describing: memberCount)), modifiedAt: \(Swift.String(describing: modifiedAt)), title: \(Swift.String(describing: title)), createdBy: \"CONTENT_REDACTED\", modifiedBy: \"CONTENT_REDACTED\")"}
}

public struct ListEngagementMembersInput: Swift.Sendable {
    /// The catalog related to the request.
    /// This member is required.
    public var catalog: Swift.String?
    /// Identifier of the Engagement record to retrieve members from.
    /// This member is required.
    public var identifier: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil,
        maxResults: Swift.Int? = 5,
        nextToken: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension PartnerCentralSellingClientTypes {

    /// Engagement members are the participants in an Engagement, which is likely a collaborative project or business opportunity within the AWS partner network. Members can be different partner organizations or AWS accounts that are working together on a specific engagement. Each member is represented by their AWS Account ID, Company Name, and associated details. Members have a status within the Engagement (PENDING, ACCEPTED, REJECTED, or WITHDRAWN), indicating their current state of participation. Only existing members of an Engagement can view the list of other members. This implies a level of privacy and access control within the Engagement structure.
    public struct EngagementMember: Swift.Sendable {
        /// This is the unique identifier for the AWS account associated with the member organization. It's used for AWS-related operations and identity verification.
        public var accountId: Swift.String?
        /// The official name of the member's company or organization.
        public var companyName: Swift.String?
        /// The URL of the member company's website. This offers a way to find more information about the member organization and serves as an additional identifier.
        public var websiteUrl: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            companyName: Swift.String? = nil,
            websiteUrl: Swift.String? = nil
        ) {
            self.accountId = accountId
            self.companyName = companyName
            self.websiteUrl = websiteUrl
        }
    }
}

extension PartnerCentralSellingClientTypes.EngagementMember: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EngagementMember(websiteUrl: \(Swift.String(describing: websiteUrl)), accountId: \"CONTENT_REDACTED\", companyName: \"CONTENT_REDACTED\")"}
}

public struct ListEngagementMembersOutput: Swift.Sendable {
    /// Provides a list of engagement members.
    /// This member is required.
    public var engagementMemberList: [PartnerCentralSellingClientTypes.EngagementMember]?
    /// A pagination token used to retrieve the next set of results. If there are more results available than can be returned in a single response, this token will be present. Use this token in a subsequent request to retrieve the next page of results. If there are no more results, this value will be null.
    public var nextToken: Swift.String?

    public init(
        engagementMemberList: [PartnerCentralSellingClientTypes.EngagementMember]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.engagementMemberList = engagementMemberList
        self.nextToken = nextToken
    }
}

extension PartnerCentralSellingClientTypes {

    public enum EngagementSortName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createddate
        case sdkUnknown(Swift.String)

        public static var allCases: [EngagementSortName] {
            return [
                .createddate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createddate: return "CreatedDate"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum SortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Specifies the sorting parameters for listing Engagements.
    public struct EngagementSort: Swift.Sendable {
        /// The field by which to sort the results.
        /// This member is required.
        public var sortBy: PartnerCentralSellingClientTypes.EngagementSortName?
        /// The order in which to sort the results.
        /// This member is required.
        public var sortOrder: PartnerCentralSellingClientTypes.SortOrder?

        public init(
            sortBy: PartnerCentralSellingClientTypes.EngagementSortName? = nil,
            sortOrder: PartnerCentralSellingClientTypes.SortOrder? = nil
        ) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }
}

public struct ListEngagementsInput: Swift.Sendable {
    /// Specifies the catalog related to the request.
    /// This member is required.
    public var catalog: Swift.String?
    /// Filters engagements to include only those containing the specified context types, such as "CustomerProject" or "Lead". Use this to find engagements that have specific types of contextual information associated with them.
    public var contextTypes: [PartnerCentralSellingClientTypes.EngagementContextType]?
    /// A list of AWS account IDs. When specified, the response includes engagements created by these accounts. This filter is useful for finding engagements created by specific team members.
    public var createdBy: [Swift.String]?
    /// An array of strings representing engagement identifiers to retrieve.
    public var engagementIdentifier: [Swift.String]?
    /// Filters engagements to exclude those containing the specified context types. Use this to find engagements that do not have certain types of contextual information, helping to narrow results based on context exclusion criteria.
    public var excludeContextTypes: [PartnerCentralSellingClientTypes.EngagementContextType]?
    /// An array of strings representing AWS Account IDs. Use this to exclude engagements created by specific users.
    public var excludeCreatedBy: [Swift.String]?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. This value is returned from a previous call.
    public var nextToken: Swift.String?
    /// Specifies the sorting parameters for listing Engagements.
    public var sort: PartnerCentralSellingClientTypes.EngagementSort?

    public init(
        catalog: Swift.String? = nil,
        contextTypes: [PartnerCentralSellingClientTypes.EngagementContextType]? = nil,
        createdBy: [Swift.String]? = nil,
        engagementIdentifier: [Swift.String]? = nil,
        excludeContextTypes: [PartnerCentralSellingClientTypes.EngagementContextType]? = nil,
        excludeCreatedBy: [Swift.String]? = nil,
        maxResults: Swift.Int? = 20,
        nextToken: Swift.String? = nil,
        sort: PartnerCentralSellingClientTypes.EngagementSort? = nil
    ) {
        self.catalog = catalog
        self.contextTypes = contextTypes
        self.createdBy = createdBy
        self.engagementIdentifier = engagementIdentifier
        self.excludeContextTypes = excludeContextTypes
        self.excludeCreatedBy = excludeCreatedBy
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
    }
}

extension ListEngagementsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEngagementsInput(catalog: \(Swift.String(describing: catalog)), contextTypes: \(Swift.String(describing: contextTypes)), engagementIdentifier: \(Swift.String(describing: engagementIdentifier)), excludeContextTypes: \(Swift.String(describing: excludeContextTypes)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), sort: \(Swift.String(describing: sort)), createdBy: \"CONTENT_REDACTED\", excludeCreatedBy: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// An object that contains an Engagement's subset of fields.
    public struct EngagementSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the created Engagement.
        public var arn: Swift.String?
        /// An array of context types associated with the engagement, such as "CustomerProject" or "Lead". This provides a quick overview of the types of contexts included in the engagement.
        public var contextTypes: [PartnerCentralSellingClientTypes.EngagementContextType]?
        /// The date and time when the Engagement was created.
        public var createdAt: Foundation.Date?
        /// The AWS Account ID of the Engagement creator.
        public var createdBy: Swift.String?
        /// The unique identifier for the Engagement.
        public var id: Swift.String?
        /// The number of members in the Engagement.
        public var memberCount: Swift.Int?
        /// The timestamp indicating when the engagement was last modified, in ISO 8601 format (UTC). Example: "2023-05-01T20:37:46Z".
        public var modifiedAt: Foundation.Date?
        /// The AWS account ID of the user who last modified the engagement. This field helps track who made the most recent changes to the engagement.
        public var modifiedBy: Swift.String?
        /// The title of the Engagement.
        public var title: Swift.String?

        public init(
            arn: Swift.String? = nil,
            contextTypes: [PartnerCentralSellingClientTypes.EngagementContextType]? = nil,
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            id: Swift.String? = nil,
            memberCount: Swift.Int? = nil,
            modifiedAt: Foundation.Date? = nil,
            modifiedBy: Swift.String? = nil,
            title: Swift.String? = nil
        ) {
            self.arn = arn
            self.contextTypes = contextTypes
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.id = id
            self.memberCount = memberCount
            self.modifiedAt = modifiedAt
            self.modifiedBy = modifiedBy
            self.title = title
        }
    }
}

extension PartnerCentralSellingClientTypes.EngagementSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EngagementSummary(arn: \(Swift.String(describing: arn)), contextTypes: \(Swift.String(describing: contextTypes)), createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), memberCount: \(Swift.String(describing: memberCount)), modifiedAt: \(Swift.String(describing: modifiedAt)), title: \(Swift.String(describing: title)), createdBy: \"CONTENT_REDACTED\", modifiedBy: \"CONTENT_REDACTED\")"}
}

public struct ListEngagementsOutput: Swift.Sendable {
    /// An array of engagement summary objects.
    /// This member is required.
    public var engagementSummaryList: [PartnerCentralSellingClientTypes.EngagementSummary]?
    /// The token to retrieve the next set of results. This field will be null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        engagementSummaryList: [PartnerCentralSellingClientTypes.EngagementSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.engagementSummaryList = engagementSummaryList
        self.nextToken = nextToken
    }
}

extension PartnerCentralSellingClientTypes {

    public enum ListTasksSortName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case startTime
        case sdkUnknown(Swift.String)

        public static var allCases: [ListTasksSortName] {
            return [
                .startTime
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .startTime: return "StartTime"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Defines the sorting parameters for listing tasks. This structure allows for specifying the field to sort by and the order of sorting.
    public struct ListTasksSortBase: Swift.Sendable {
        /// Specifies the field by which the task list should be sorted.
        /// This member is required.
        public var sortBy: PartnerCentralSellingClientTypes.ListTasksSortName?
        /// Determines the order in which the sorted results are presented.
        /// This member is required.
        public var sortOrder: PartnerCentralSellingClientTypes.SortOrder?

        public init(
            sortBy: PartnerCentralSellingClientTypes.ListTasksSortName? = nil,
            sortOrder: PartnerCentralSellingClientTypes.SortOrder? = nil
        ) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum TaskStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [TaskStatus] {
            return [
                .complete,
                .failed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListEngagementByAcceptingInvitationTasksInput: Swift.Sendable {
    /// Specifies the catalog related to the request. Valid values are:
    ///
    /// * AWS: Retrieves the request from the production AWS environment.
    ///
    /// * Sandbox: Retrieves the request from a sandbox environment used for testing or development purposes.
    /// This member is required.
    public var catalog: Swift.String?
    /// Filters tasks by the identifiers of the engagement invitations they are processing.
    public var engagementInvitationIdentifier: [Swift.String]?
    /// Use this parameter to control the number of items returned in each request, which can be useful for performance tuning and managing large result sets.
    public var maxResults: Swift.Int?
    /// Use this parameter for pagination when the result set spans multiple pages. This value is obtained from the NextToken field in the response of a previous call to this API.
    public var nextToken: Swift.String?
    /// Filters tasks by the identifiers of the opportunities they created or are associated with.
    public var opportunityIdentifier: [Swift.String]?
    /// Specifies the sorting criteria for the returned results. This allows you to order the tasks based on specific attributes.
    public var sort: PartnerCentralSellingClientTypes.ListTasksSortBase?
    /// Filters tasks by their unique identifiers. Use this when you want to retrieve information about specific tasks.
    public var taskIdentifier: [Swift.String]?
    /// Filters the tasks based on their current status. This allows you to focus on tasks in specific states.
    public var taskStatus: [PartnerCentralSellingClientTypes.TaskStatus]?

    public init(
        catalog: Swift.String? = nil,
        engagementInvitationIdentifier: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        opportunityIdentifier: [Swift.String]? = nil,
        sort: PartnerCentralSellingClientTypes.ListTasksSortBase? = nil,
        taskIdentifier: [Swift.String]? = nil,
        taskStatus: [PartnerCentralSellingClientTypes.TaskStatus]? = nil
    ) {
        self.catalog = catalog
        self.engagementInvitationIdentifier = engagementInvitationIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.opportunityIdentifier = opportunityIdentifier
        self.sort = sort
        self.taskIdentifier = taskIdentifier
        self.taskStatus = taskStatus
    }
}

extension PartnerCentralSellingClientTypes {

    public enum ReasonCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contextNotFound
        case customerProjectContextNotPermitted
        case disqualifiedLeadNotPermitted
        case engagementAccessDenied
        case engagementConflict
        case engagementInvitationConflict
        case engagementValidationFailed
        case internalError
        case invitationAccessDenied
        case invitationValidationFailed
        case opportunityAccessDenied
        case opportunityConflict
        case opportunitySubmissionFailed
        case opportunityValidationFailed
        case requestThrottled
        case resourceSnapshotAccessDenied
        case resourceSnapshotConflict
        case resourceSnapshotJobAccessDenied
        case resourceSnapshotJobConflict
        case resourceSnapshotJobValidationFailed
        case resourceSnapshotValidationFailed
        case serviceQuotaExceeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ReasonCode] {
            return [
                .contextNotFound,
                .customerProjectContextNotPermitted,
                .disqualifiedLeadNotPermitted,
                .engagementAccessDenied,
                .engagementConflict,
                .engagementInvitationConflict,
                .engagementValidationFailed,
                .internalError,
                .invitationAccessDenied,
                .invitationValidationFailed,
                .opportunityAccessDenied,
                .opportunityConflict,
                .opportunitySubmissionFailed,
                .opportunityValidationFailed,
                .requestThrottled,
                .resourceSnapshotAccessDenied,
                .resourceSnapshotConflict,
                .resourceSnapshotJobAccessDenied,
                .resourceSnapshotJobConflict,
                .resourceSnapshotJobValidationFailed,
                .resourceSnapshotValidationFailed,
                .serviceQuotaExceeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contextNotFound: return "ContextNotFound"
            case .customerProjectContextNotPermitted: return "CustomerProjectContextNotPermitted"
            case .disqualifiedLeadNotPermitted: return "DisqualifiedLeadNotPermitted"
            case .engagementAccessDenied: return "EngagementAccessDenied"
            case .engagementConflict: return "EngagementConflict"
            case .engagementInvitationConflict: return "EngagementInvitationConflict"
            case .engagementValidationFailed: return "EngagementValidationFailed"
            case .internalError: return "InternalError"
            case .invitationAccessDenied: return "InvitationAccessDenied"
            case .invitationValidationFailed: return "InvitationValidationFailed"
            case .opportunityAccessDenied: return "OpportunityAccessDenied"
            case .opportunityConflict: return "OpportunityConflict"
            case .opportunitySubmissionFailed: return "OpportunitySubmissionFailed"
            case .opportunityValidationFailed: return "OpportunityValidationFailed"
            case .requestThrottled: return "RequestThrottled"
            case .resourceSnapshotAccessDenied: return "ResourceSnapshotAccessDenied"
            case .resourceSnapshotConflict: return "ResourceSnapshotConflict"
            case .resourceSnapshotJobAccessDenied: return "ResourceSnapshotJobAccessDenied"
            case .resourceSnapshotJobConflict: return "ResourceSnapshotJobConflict"
            case .resourceSnapshotJobValidationFailed: return "ResourceSnapshotJobValidationFailed"
            case .resourceSnapshotValidationFailed: return "ResourceSnapshotValidationFailed"
            case .serviceQuotaExceeded: return "ServiceQuotaExceeded"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Specifies a subset of fields associated with tasks related to accepting an engagement invitation.
    public struct ListEngagementByAcceptingInvitationTaskSummary: Swift.Sendable {
        /// The unique identifier of the engagement invitation that was accepted.
        public var engagementInvitationId: Swift.String?
        /// Detailed message describing the failure and possible recovery steps.
        public var message: Swift.String?
        /// Unique identifier of opportunity that was created.
        public var opportunityId: Swift.String?
        /// A code pointing to the specific reason for the failure.
        public var reasonCode: PartnerCentralSellingClientTypes.ReasonCode?
        /// Unique identifier of the resource snapshot job that was created.
        public var resourceSnapshotJobId: Swift.String?
        /// Task start timestamp.
        public var startTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) that uniquely identifies the task.
        public var taskArn: Swift.String?
        /// Unique identifier of the task.
        public var taskId: Swift.String?
        /// Status of the task.
        public var taskStatus: PartnerCentralSellingClientTypes.TaskStatus?

        public init(
            engagementInvitationId: Swift.String? = nil,
            message: Swift.String? = nil,
            opportunityId: Swift.String? = nil,
            reasonCode: PartnerCentralSellingClientTypes.ReasonCode? = nil,
            resourceSnapshotJobId: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            taskArn: Swift.String? = nil,
            taskId: Swift.String? = nil,
            taskStatus: PartnerCentralSellingClientTypes.TaskStatus? = nil
        ) {
            self.engagementInvitationId = engagementInvitationId
            self.message = message
            self.opportunityId = opportunityId
            self.reasonCode = reasonCode
            self.resourceSnapshotJobId = resourceSnapshotJobId
            self.startTime = startTime
            self.taskArn = taskArn
            self.taskId = taskId
            self.taskStatus = taskStatus
        }
    }
}

public struct ListEngagementByAcceptingInvitationTasksOutput: Swift.Sendable {
    /// A token used for pagination to retrieve the next page of results.If there are more results available, this field will contain a token that can be used in a subsequent API call to retrieve the next page. If there are no more results, this field will be null or an empty string.
    public var nextToken: Swift.String?
    /// An array of EngagementByAcceptingInvitationTaskSummary objects, each representing a task that matches the specified filters. The array may be empty if no tasks match the criteria.
    public var taskSummaries: [PartnerCentralSellingClientTypes.ListEngagementByAcceptingInvitationTaskSummary]?

    public init(
        nextToken: Swift.String? = nil,
        taskSummaries: [PartnerCentralSellingClientTypes.ListEngagementByAcceptingInvitationTaskSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.taskSummaries = taskSummaries
    }
}

extension PartnerCentralSellingClientTypes {

    /// The key-value pair assigned to a specified resource.
    public struct Tag: Swift.Sendable {
        /// The key in the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value in the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

public struct StartEngagementByAcceptingInvitationTaskInput: Swift.Sendable {
    /// Specifies the catalog related to the task. Use AWS for production engagements and Sandbox for testing scenarios.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier provided by the client that helps to ensure the idempotency of the request. This can be a random or meaningful string but must be unique for each request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Specifies the unique identifier of the EngagementInvitation to be accepted. Providing the correct identifier helps ensure that the correct engagement is processed.
    /// This member is required.
    public var identifier: Swift.String?
    /// A map of the key-value pairs of the tag or tags to assign.
    public var tags: [PartnerCentralSellingClientTypes.Tag]?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        identifier: Swift.String? = nil,
        tags: [PartnerCentralSellingClientTypes.Tag]? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.identifier = identifier
        self.tags = tags
    }
}

public struct StartEngagementByAcceptingInvitationTaskOutput: Swift.Sendable {
    /// Returns the identifier of the engagement invitation that was accepted and used to create the opportunity.
    public var engagementInvitationId: Swift.String?
    /// If the task fails, this field contains a detailed message describing the failure and possible recovery steps.
    public var message: Swift.String?
    /// Returns the original opportunity identifier passed in the request. This is the unique identifier for the opportunity.
    public var opportunityId: Swift.String?
    /// Indicates the reason for task failure using an enumerated code.
    public var reasonCode: PartnerCentralSellingClientTypes.ReasonCode?
    /// The identifier of the Resource Snapshot Job created as part of this task.
    public var resourceSnapshotJobId: Swift.String?
    /// The timestamp indicating when the task was initiated. The format follows RFC 3339 section 5.6.
    public var startTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the task, used for tracking and managing the task within AWS.
    public var taskArn: Swift.String?
    /// The unique identifier of the task, used to track the task’s progress.
    public var taskId: Swift.String?
    /// Indicates the current status of the task.
    public var taskStatus: PartnerCentralSellingClientTypes.TaskStatus?

    public init(
        engagementInvitationId: Swift.String? = nil,
        message: Swift.String? = nil,
        opportunityId: Swift.String? = nil,
        reasonCode: PartnerCentralSellingClientTypes.ReasonCode? = nil,
        resourceSnapshotJobId: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        taskArn: Swift.String? = nil,
        taskId: Swift.String? = nil,
        taskStatus: PartnerCentralSellingClientTypes.TaskStatus? = nil
    ) {
        self.engagementInvitationId = engagementInvitationId
        self.message = message
        self.opportunityId = opportunityId
        self.reasonCode = reasonCode
        self.resourceSnapshotJobId = resourceSnapshotJobId
        self.startTime = startTime
        self.taskArn = taskArn
        self.taskId = taskId
        self.taskStatus = taskStatus
    }
}

public struct ListEngagementFromOpportunityTasksInput: Swift.Sendable {
    /// Specifies the catalog related to the request. Valid values are:
    ///
    /// * AWS: Retrieves the request from the production AWS environment.
    ///
    /// * Sandbox: Retrieves the request from a sandbox environment used for testing or development purposes.
    /// This member is required.
    public var catalog: Swift.String?
    /// Filters tasks by the identifiers of the engagements they created or are associated with.
    public var engagementIdentifier: [Swift.String]?
    /// Specifies the maximum number of results to return in a single page of the response.Use this parameter to control the number of items returned in each request, which can be useful for performance tuning and managing large result sets.
    public var maxResults: Swift.Int?
    /// The token for requesting the next page of results. This value is obtained from the NextToken field in the response of a previous call to this API. Use this parameter for pagination when the result set spans multiple pages.
    public var nextToken: Swift.String?
    /// The identifier of the original opportunity associated with this task.
    public var opportunityIdentifier: [Swift.String]?
    /// Specifies the sorting criteria for the returned results. This allows you to order the tasks based on specific attributes.
    public var sort: PartnerCentralSellingClientTypes.ListTasksSortBase?
    /// Filters tasks by their unique identifiers. Use this when you want to retrieve information about specific tasks.
    public var taskIdentifier: [Swift.String]?
    /// Filters the tasks based on their current status. This allows you to focus on tasks in specific states.
    public var taskStatus: [PartnerCentralSellingClientTypes.TaskStatus]?

    public init(
        catalog: Swift.String? = nil,
        engagementIdentifier: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        opportunityIdentifier: [Swift.String]? = nil,
        sort: PartnerCentralSellingClientTypes.ListTasksSortBase? = nil,
        taskIdentifier: [Swift.String]? = nil,
        taskStatus: [PartnerCentralSellingClientTypes.TaskStatus]? = nil
    ) {
        self.catalog = catalog
        self.engagementIdentifier = engagementIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.opportunityIdentifier = opportunityIdentifier
        self.sort = sort
        self.taskIdentifier = taskIdentifier
        self.taskStatus = taskStatus
    }
}

extension PartnerCentralSellingClientTypes {

    /// Provides a summary of a task related to creating an engagement from an opportunity. This structure contains key information about the task's status, associated identifiers, and any failure details.
    public struct ListEngagementFromOpportunityTaskSummary: Swift.Sendable {
        /// The unique identifier of the engagement created as a result of the task. This field is populated when the task is completed successfully.
        public var engagementId: Swift.String?
        /// The unique identifier of the Engagement Invitation.
        public var engagementInvitationId: Swift.String?
        /// A detailed message providing additional information about the task, especially useful in case of failures. This field may contain error details or other relevant information about the task's execution
        public var message: Swift.String?
        /// The unique identifier of the original Opportunity from which the Engagement is being created. This field helps track the source of the Engagement creation task.
        public var opportunityId: Swift.String?
        /// A code indicating the specific reason for a task failure. This field is populated when the task status is FAILED and provides a categorized reason for the failure.
        public var reasonCode: PartnerCentralSellingClientTypes.ReasonCode?
        /// The identifier of the resource snapshot job associated with this task, if a snapshot was created as part of the Engagement creation process.
        public var resourceSnapshotJobId: Swift.String?
        /// The timestamp indicating when the task was initiated, in RFC 3339 5.6 date-time format.
        public var startTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) uniquely identifying this task within AWS. This ARN can be used for referencing the task in other AWS services or APIs.
        public var taskArn: Swift.String?
        /// A unique identifier for a specific task.
        public var taskId: Swift.String?
        /// The current status of the task.
        public var taskStatus: PartnerCentralSellingClientTypes.TaskStatus?

        public init(
            engagementId: Swift.String? = nil,
            engagementInvitationId: Swift.String? = nil,
            message: Swift.String? = nil,
            opportunityId: Swift.String? = nil,
            reasonCode: PartnerCentralSellingClientTypes.ReasonCode? = nil,
            resourceSnapshotJobId: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            taskArn: Swift.String? = nil,
            taskId: Swift.String? = nil,
            taskStatus: PartnerCentralSellingClientTypes.TaskStatus? = nil
        ) {
            self.engagementId = engagementId
            self.engagementInvitationId = engagementInvitationId
            self.message = message
            self.opportunityId = opportunityId
            self.reasonCode = reasonCode
            self.resourceSnapshotJobId = resourceSnapshotJobId
            self.startTime = startTime
            self.taskArn = taskArn
            self.taskId = taskId
            self.taskStatus = taskStatus
        }
    }
}

public struct ListEngagementFromOpportunityTasksOutput: Swift.Sendable {
    /// A token used for pagination to retrieve the next page of results. If there are more results available, this field will contain a token that can be used in a subsequent API call to retrieve the next page. If there are no more results, this field will be null or an empty string.
    public var nextToken: Swift.String?
    /// TaskSummaries An array of TaskSummary objects containing details about each task.
    public var taskSummaries: [PartnerCentralSellingClientTypes.ListEngagementFromOpportunityTaskSummary]?

    public init(
        nextToken: Swift.String? = nil,
        taskSummaries: [PartnerCentralSellingClientTypes.ListEngagementFromOpportunityTaskSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.taskSummaries = taskSummaries
    }
}

extension PartnerCentralSellingClientTypes {

    /// Indicates the level of AWS involvement in the opportunity. This field helps track AWS participation throughout the engagement, such as providing technical support, deal assistance, and sales support.
    public struct AwsSubmission: Swift.Sendable {
        /// Specifies the type of AWS involvement in the opportunity, such as coselling, deal support, or technical consultation. This helps categorize the nature of AWS participation.
        /// This member is required.
        public var involvementType: PartnerCentralSellingClientTypes.SalesInvolvementType?
        /// Determines who can view AWS involvement in the opportunity. Typically, this field is set to Full for most cases, but it may be restricted based on special program requirements or confidentiality needs.
        public var visibility: PartnerCentralSellingClientTypes.Visibility?

        public init(
            involvementType: PartnerCentralSellingClientTypes.SalesInvolvementType? = nil,
            visibility: PartnerCentralSellingClientTypes.Visibility? = nil
        ) {
            self.involvementType = involvementType
            self.visibility = visibility
        }
    }
}

public struct StartEngagementFromOpportunityTaskInput: Swift.Sendable {
    /// Indicates the level of AWS involvement in the opportunity. This field helps track AWS participation throughout the engagement, such as providing technical support, deal assistance, and sales support.
    /// This member is required.
    public var awsSubmission: PartnerCentralSellingClientTypes.AwsSubmission?
    /// Specifies the catalog in which the engagement is tracked. Acceptable values include AWS for production and Sandbox for testing environments.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique token provided by the client to help ensure the idempotency of the request. It helps prevent the same task from being performed multiple times.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The unique identifier of the opportunity from which the engagement task is to be initiated. This helps ensure that the task is applied to the correct opportunity.
    /// This member is required.
    public var identifier: Swift.String?
    /// A map of the key-value pairs of the tag or tags to assign.
    public var tags: [PartnerCentralSellingClientTypes.Tag]?

    public init(
        awsSubmission: PartnerCentralSellingClientTypes.AwsSubmission? = nil,
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        identifier: Swift.String? = nil,
        tags: [PartnerCentralSellingClientTypes.Tag]? = nil
    ) {
        self.awsSubmission = awsSubmission
        self.catalog = catalog
        self.clientToken = clientToken
        self.identifier = identifier
        self.tags = tags
    }
}

public struct StartEngagementFromOpportunityTaskOutput: Swift.Sendable {
    /// The identifier of the newly created Engagement. Only populated if TaskStatus is COMPLETE.
    public var engagementId: Swift.String?
    /// The identifier of the new Engagement invitation. Only populated if TaskStatus is COMPLETE.
    public var engagementInvitationId: Swift.String?
    /// If the task fails, this field contains a detailed message describing the failure and possible recovery steps.
    public var message: Swift.String?
    /// Returns the original opportunity identifier passed in the request, which is the unique identifier for the opportunity created in the partner’s system.
    public var opportunityId: Swift.String?
    /// Indicates the reason for task failure using an enumerated code.
    public var reasonCode: PartnerCentralSellingClientTypes.ReasonCode?
    /// The identifier of the resource snapshot job created to add the opportunity resource snapshot to the Engagement. Only populated if TaskStatus is COMPLETE
    public var resourceSnapshotJobId: Swift.String?
    /// The timestamp indicating when the task was initiated. The format follows RFC 3339 section 5.6.
    public var startTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the task, used for tracking and managing the task within AWS.
    public var taskArn: Swift.String?
    /// The unique identifier of the task, used to track the task’s progress. This value follows a specific pattern: ^oit-[0-9a-z]{13}$.
    public var taskId: Swift.String?
    /// Indicates the current status of the task. Valid values include IN_PROGRESS, COMPLETE, and FAILED.
    public var taskStatus: PartnerCentralSellingClientTypes.TaskStatus?

    public init(
        engagementId: Swift.String? = nil,
        engagementInvitationId: Swift.String? = nil,
        message: Swift.String? = nil,
        opportunityId: Swift.String? = nil,
        reasonCode: PartnerCentralSellingClientTypes.ReasonCode? = nil,
        resourceSnapshotJobId: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        taskArn: Swift.String? = nil,
        taskId: Swift.String? = nil,
        taskStatus: PartnerCentralSellingClientTypes.TaskStatus? = nil
    ) {
        self.engagementId = engagementId
        self.engagementInvitationId = engagementInvitationId
        self.message = message
        self.opportunityId = opportunityId
        self.reasonCode = reasonCode
        self.resourceSnapshotJobId = resourceSnapshotJobId
        self.startTime = startTime
        self.taskArn = taskArn
        self.taskId = taskId
        self.taskStatus = taskStatus
    }
}

extension PartnerCentralSellingClientTypes {

    /// Contains customer information included in a lead invitation payload. This structure provides essential details about the customer to help partners evaluate the lead opportunity and determine their interest in engagement.
    public struct LeadInvitationCustomer: Swift.Sendable {
        /// Indicates the customer's level of experience and adoption with AWS services. This assessment helps partners understand the customer's cloud maturity and tailor their engagement approach accordingly.
        public var awsMaturity: Swift.String?
        /// The name of the customer company associated with the lead invitation. This field identifies the target organization for the lead engagement opportunity.
        /// This member is required.
        public var companyName: Swift.String?
        /// The country code indicating the geographic location of the customer company. This information helps partners understand regional requirements and assess their ability to serve the customer effectively.
        /// This member is required.
        public var countryCode: PartnerCentralSellingClientTypes.CountryCode?
        /// Specifies the industry sector of the customer company associated with the lead invitation. This categorization helps partners understand the customer's business context and assess solution fit.
        public var industry: PartnerCentralSellingClientTypes.Industry?
        /// Specifies the market segment classification of the customer, such as enterprise, mid-market, or small business. This segmentation helps partners determine the appropriate solution complexity and engagement strategy.
        public var marketSegment: PartnerCentralSellingClientTypes.MarketSegment?
        /// The website URL of the customer company. This provides additional context about the customer organization and helps partners verify company details and assess business size and legitimacy.
        public var websiteUrl: Swift.String?

        public init(
            awsMaturity: Swift.String? = nil,
            companyName: Swift.String? = nil,
            countryCode: PartnerCentralSellingClientTypes.CountryCode? = nil,
            industry: PartnerCentralSellingClientTypes.Industry? = nil,
            marketSegment: PartnerCentralSellingClientTypes.MarketSegment? = nil,
            websiteUrl: Swift.String? = nil
        ) {
            self.awsMaturity = awsMaturity
            self.companyName = companyName
            self.countryCode = countryCode
            self.industry = industry
            self.marketSegment = marketSegment
            self.websiteUrl = websiteUrl
        }
    }
}

extension PartnerCentralSellingClientTypes.LeadInvitationCustomer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LeadInvitationCustomer(awsMaturity: \(Swift.String(describing: awsMaturity)), industry: \(Swift.String(describing: industry)), marketSegment: \(Swift.String(describing: marketSegment)), companyName: \"CONTENT_REDACTED\", countryCode: \"CONTENT_REDACTED\", websiteUrl: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// Represents interaction details included in a lead invitation payload. This structure provides context about how the lead was generated and the customer's engagement history to help partners assess the opportunity quality.
    public struct LeadInvitationInteraction: Swift.Sendable {
        /// The business title or job role of the customer contact involved in the lead interaction. This helps partners identify the decision-making level and engagement approach for the lead.
        /// This member is required.
        public var contactBusinessTitle: Swift.String?
        /// The unique identifier of the specific source that generated the lead interaction. This provides traceability to the original lead generation activity for reference and follow-up purposes.
        /// This member is required.
        public var sourceId: Swift.String?
        /// The descriptive name of the source that generated the lead interaction. This human-readable identifier helps partners understand the specific lead generation channel or campaign that created the opportunity.
        /// This member is required.
        public var sourceName: Swift.String?
        /// Specifies the type of source that generated the lead interaction, such as "Event", "Website", or "Campaign". This helps partners understand the lead generation channel and assess lead quality based on the source type.
        /// This member is required.
        public var sourceType: Swift.String?
        /// Describes the specific use case or business scenario associated with the lead interaction. This information helps partners understand the customer's interests and potential solution requirements.
        public var usecase: Swift.String?

        public init(
            contactBusinessTitle: Swift.String? = nil,
            sourceId: Swift.String? = nil,
            sourceName: Swift.String? = nil,
            sourceType: Swift.String? = nil,
            usecase: Swift.String? = nil
        ) {
            self.contactBusinessTitle = contactBusinessTitle
            self.sourceId = sourceId
            self.sourceName = sourceName
            self.sourceType = sourceType
            self.usecase = usecase
        }
    }
}

extension PartnerCentralSellingClientTypes.LeadInvitationInteraction: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LeadInvitationInteraction(sourceId: \(Swift.String(describing: sourceId)), sourceName: \(Swift.String(describing: sourceName)), sourceType: \(Swift.String(describing: sourceType)), usecase: \(Swift.String(describing: usecase)), contactBusinessTitle: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// Represents the data payload of an engagement invitation for a lead opportunity. This contains detailed information about the customer and interaction history that partners use to evaluate whether to accept the lead engagement invitation.
    public struct LeadInvitationPayload: Swift.Sendable {
        /// Contains information about the customer associated with the lead invitation. This data helps partners understand the customer's profile, industry, and business context to assess the lead opportunity.
        /// This member is required.
        public var customer: PartnerCentralSellingClientTypes.LeadInvitationCustomer?
        /// Describes the interaction details associated with the lead, including the source of the lead generation and customer engagement information. This context helps partners evaluate the lead quality and engagement approach.
        /// This member is required.
        public var interaction: PartnerCentralSellingClientTypes.LeadInvitationInteraction?

        public init(
            customer: PartnerCentralSellingClientTypes.LeadInvitationCustomer? = nil,
            interaction: PartnerCentralSellingClientTypes.LeadInvitationInteraction? = nil
        ) {
            self.customer = customer
            self.interaction = interaction
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Contains details about the project associated with the Engagement Invitation, including the business problem and expected outcomes.
    public struct ProjectDetails: Swift.Sendable {
        /// Describes the business problem that the project aims to solve. This information is crucial for understanding the project’s goals and objectives.
        /// This member is required.
        public var businessProblem: Swift.String?
        /// Contains revenue estimates for the partner related to the project. This field provides an idea of the financial potential of the opportunity for the partner.
        /// This member is required.
        public var expectedCustomerSpend: [PartnerCentralSellingClientTypes.ExpectedCustomerSpend]?
        /// Specifies the estimated date of project completion. This field helps track the project timeline and manage expectations.
        /// This member is required.
        public var targetCompletionDate: Swift.String?
        /// Specifies the title of the project. This title helps partners quickly identify and understand the focus of the project.
        /// This member is required.
        public var title: Swift.String?

        public init(
            businessProblem: Swift.String? = nil,
            expectedCustomerSpend: [PartnerCentralSellingClientTypes.ExpectedCustomerSpend]? = nil,
            targetCompletionDate: Swift.String? = nil,
            title: Swift.String? = nil
        ) {
            self.businessProblem = businessProblem
            self.expectedCustomerSpend = expectedCustomerSpend
            self.targetCompletionDate = targetCompletionDate
            self.title = title
        }
    }
}

extension PartnerCentralSellingClientTypes.ProjectDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProjectDetails(expectedCustomerSpend: \(Swift.String(describing: expectedCustomerSpend)), targetCompletionDate: \(Swift.String(describing: targetCompletionDate)), title: \(Swift.String(describing: title)), businessProblem: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    public enum ReceiverResponsibility: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case coSellFacilitator
        case distributor
        case facilitator
        case hardwarePartner
        case managedServiceProvider
        case reseller
        case servicesPartner
        case softwarePartner
        case trainingPartner
        case sdkUnknown(Swift.String)

        public static var allCases: [ReceiverResponsibility] {
            return [
                .coSellFacilitator,
                .distributor,
                .facilitator,
                .hardwarePartner,
                .managedServiceProvider,
                .reseller,
                .servicesPartner,
                .softwarePartner,
                .trainingPartner
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .coSellFacilitator: return "Co-Sell Facilitator"
            case .distributor: return "Distributor"
            case .facilitator: return "Facilitator"
            case .hardwarePartner: return "Hardware Partner"
            case .managedServiceProvider: return "Managed Service Provider"
            case .reseller: return "Reseller"
            case .servicesPartner: return "Services Partner"
            case .softwarePartner: return "Software Partner"
            case .trainingPartner: return "Training Partner"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// An object that contains the details of the sender-provided contact person for the EngagementInvitation.
    public struct SenderContact: Swift.Sendable {
        /// The sender-provided contact's title (job title or role) associated with the EngagementInvitation.
        public var businessTitle: Swift.String?
        /// The sender-provided contact's email address associated with the EngagementInvitation.
        /// This member is required.
        public var email: Swift.String?
        /// The sender-provided contact's last name associated with the EngagementInvitation.
        public var firstName: Swift.String?
        /// The sender-provided contact's first name associated with the EngagementInvitation.
        public var lastName: Swift.String?
        /// The sender-provided contact's phone number associated with the EngagementInvitation.
        public var phone: Swift.String?

        public init(
            businessTitle: Swift.String? = nil,
            email: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            phone: Swift.String? = nil
        ) {
            self.businessTitle = businessTitle
            self.email = email
            self.firstName = firstName
            self.lastName = lastName
            self.phone = phone
        }
    }
}

extension PartnerCentralSellingClientTypes.SenderContact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SenderContact(businessTitle: \"CONTENT_REDACTED\", email: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\", phone: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// Represents the data payload of an Engagement Invitation for a specific opportunity. This contains detailed information that partners use to evaluate the engagement.
    public struct OpportunityInvitationPayload: Swift.Sendable {
        /// Contains information about the customer related to the opportunity in the Engagement Invitation. This data helps partners understand the customer’s profile and requirements.
        /// This member is required.
        public var customer: PartnerCentralSellingClientTypes.EngagementCustomer?
        /// Describes the project details associated with the opportunity, including the customer’s needs and the scope of work expected to be performed.
        /// This member is required.
        public var project: PartnerCentralSellingClientTypes.ProjectDetails?
        /// Outlines the responsibilities or expectations of the receiver in the context of the invitation.
        /// This member is required.
        public var receiverResponsibilities: [PartnerCentralSellingClientTypes.ReceiverResponsibility]?
        /// Represents the contact details of the AWS representatives involved in sending the Engagement Invitation. These contacts are opportunity stakeholders.
        public var senderContacts: [PartnerCentralSellingClientTypes.SenderContact]?

        public init(
            customer: PartnerCentralSellingClientTypes.EngagementCustomer? = nil,
            project: PartnerCentralSellingClientTypes.ProjectDetails? = nil,
            receiverResponsibilities: [PartnerCentralSellingClientTypes.ReceiverResponsibility]? = nil,
            senderContacts: [PartnerCentralSellingClientTypes.SenderContact]? = nil
        ) {
            self.customer = customer
            self.project = project
            self.receiverResponsibilities = receiverResponsibilities
            self.senderContacts = senderContacts
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Contains the data payload associated with the Engagement Invitation. This payload includes essential details related to the AWS opportunity and is used by partners to evaluate whether to accept or reject the engagement.
    public enum Payload: Swift.Sendable {
        /// Specifies the details of the opportunity invitation within the Engagement Invitation payload. This data helps partners understand the context, scope, and expected involvement for the opportunity from AWS.
        case opportunityinvitation(PartnerCentralSellingClientTypes.OpportunityInvitationPayload)
        /// Specifies the details of the lead invitation within the Engagement Invitation payload. This data helps partners understand the lead context, customer information, and interaction history for the lead opportunity from AWS.
        case leadinvitation(PartnerCentralSellingClientTypes.LeadInvitationPayload)
        case sdkUnknown(Swift.String)
    }
}

extension PartnerCentralSellingClientTypes {

    /// Represents the entity that received the Engagement Invitation, including account and company details. This field is essential for tracking the partner who is being invited to collaborate.
    public enum Receiver: Swift.Sendable {
        /// Specifies the AWS account of the partner who received the Engagement Invitation. This field is used to track the invitation recipient within the AWS ecosystem.
        case account(PartnerCentralSellingClientTypes.AccountReceiver)
        case sdkUnknown(Swift.String)
    }
}

extension PartnerCentralSellingClientTypes {

    /// The Invitation structure represents an invitation exchanged between partners and AWS. It includes a message, receiver information, and a payload providing context for the invitation.
    public struct Invitation: Swift.Sendable {
        /// A message accompanying the invitation.
        /// This member is required.
        public var message: Swift.String?
        /// Contains the data payload associated with the Engagement Invitation. This payload includes essential details related to the AWS opportunity and is used by partners to evaluate whether to accept or reject the engagement.
        /// This member is required.
        public var payload: PartnerCentralSellingClientTypes.Payload?
        /// Represents the entity that received the Engagement Invitation, including account and company details. This field is essential for tracking the partner who is being invited to collaborate.
        /// This member is required.
        public var receiver: PartnerCentralSellingClientTypes.Receiver?

        public init(
            message: Swift.String? = nil,
            payload: PartnerCentralSellingClientTypes.Payload? = nil,
            receiver: PartnerCentralSellingClientTypes.Receiver? = nil
        ) {
            self.message = message
            self.payload = payload
            self.receiver = receiver
        }
    }
}

extension PartnerCentralSellingClientTypes.Invitation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Invitation(payload: \(Swift.String(describing: payload)), receiver: \(Swift.String(describing: receiver)), message: \"CONTENT_REDACTED\")"}
}

public struct CreateEngagementInvitationInput: Swift.Sendable {
    /// Specifies the catalog related to the engagement. Accepted values are AWS and Sandbox, which determine the environment in which the engagement is managed.
    /// This member is required.
    public var catalog: Swift.String?
    /// Specifies a unique, client-generated UUID to ensure that the request is handled exactly once. This token helps prevent duplicate invitation creations.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The unique identifier of the Engagement associated with the invitation. This parameter ensures the invitation is created within the correct Engagement context.
    /// This member is required.
    public var engagementIdentifier: Swift.String?
    /// The Invitation object all information necessary to initiate an engagement invitation to a partner. It contains a personalized message from the sender, the invitation's receiver, and a payload. The Payload can be the OpportunityInvitation, which includes detailed structures for sender contacts, partner responsibilities, customer information, and project details.
    /// This member is required.
    public var invitation: PartnerCentralSellingClientTypes.Invitation?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        engagementIdentifier: Swift.String? = nil,
        invitation: PartnerCentralSellingClientTypes.Invitation? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.engagementIdentifier = engagementIdentifier
        self.invitation = invitation
    }
}

public struct CreateEngagementInvitationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the engagement invitation.
    /// This member is required.
    public var arn: Swift.String?
    /// Unique identifier assigned to the newly created engagement invitation.
    /// This member is required.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    ) {
        self.arn = arn
        self.id = id
    }
}

public struct GetEngagementInvitationInput: Swift.Sendable {
    /// Specifies the catalog associated with the request. The field accepts values from the predefined set: AWS for live operations or Sandbox for testing environments.
    /// This member is required.
    public var catalog: Swift.String?
    /// Specifies the unique identifier for the retrieved engagement invitation.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
    }
}

extension PartnerCentralSellingClientTypes {

    /// The EngagementMemberSummary provides a snapshot of essential information about participants in an AWS Partner Central Engagement. This compact data structure encapsulates key details of each member, facilitating efficient collaboration and management within the Engagement.
    public struct EngagementMemberSummary: Swift.Sendable {
        /// The official name of the member's company or organization.
        public var companyName: Swift.String?
        /// The URL of the member company's website. This offers a way to find more information about the member organization and serves as an additional identifier.
        public var websiteUrl: Swift.String?

        public init(
            companyName: Swift.String? = nil,
            websiteUrl: Swift.String? = nil
        ) {
            self.companyName = companyName
            self.websiteUrl = websiteUrl
        }
    }
}

extension PartnerCentralSellingClientTypes.EngagementMemberSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EngagementMemberSummary(websiteUrl: \(Swift.String(describing: websiteUrl)), companyName: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    public enum EngagementInvitationPayloadType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case leadInvitation
        case opportunityInvitation
        case sdkUnknown(Swift.String)

        public static var allCases: [EngagementInvitationPayloadType] {
            return [
                .leadInvitation,
                .opportunityInvitation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .leadInvitation: return "LeadInvitation"
            case .opportunityInvitation: return "OpportunityInvitation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum InvitationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accepted
        case expired
        case pending
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [InvitationStatus] {
            return [
                .accepted,
                .expired,
                .pending,
                .rejected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "ACCEPTED"
            case .expired: return "EXPIRED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetEngagementInvitationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that identifies the engagement invitation.
    public var arn: Swift.String?
    /// Indicates the catalog from which the engagement invitation details are retrieved. This field helps in identifying the appropriate catalog (e.g., AWS or Sandbox) used in the request.
    /// This member is required.
    public var catalog: Swift.String?
    /// The description of the engagement associated with this invitation.
    public var engagementDescription: Swift.String?
    /// The identifier of the engagement associated with this invitation.This ID links the invitation to its corresponding engagement.
    public var engagementId: Swift.String?
    /// The title of the engagement invitation, summarizing the purpose or objectives of the opportunity shared by AWS.
    public var engagementTitle: Swift.String?
    /// A list of active members currently part of the Engagement. This array contains a maximum of 10 members, each represented by an object with the following properties.
    ///
    /// * CompanyName: The name of the member's company.
    ///
    /// * WebsiteUrl: The website URL of the member's company.
    public var existingMembers: [PartnerCentralSellingClientTypes.EngagementMemberSummary]?
    /// Indicates the date on which the engagement invitation will expire if not accepted by the partner.
    public var expirationDate: Foundation.Date?
    /// Unique identifier assigned to the engagement invitation being retrieved.
    /// This member is required.
    public var id: Swift.String?
    /// The date when the engagement invitation was sent to the partner.
    public var invitationDate: Foundation.Date?
    /// The message sent to the invited partner when the invitation was created.
    public var invitationMessage: Swift.String?
    /// Details of the engagement invitation payload, including specific data relevant to the invitation's contents, such as customer information and opportunity insights.
    public var payload: PartnerCentralSellingClientTypes.Payload?
    /// The type of payload contained in the engagement invitation, indicating what data or context the payload covers.
    public var payloadType: PartnerCentralSellingClientTypes.EngagementInvitationPayloadType?
    /// Information about the partner organization or team that received the engagement invitation, including contact details and identifiers.
    public var receiver: PartnerCentralSellingClientTypes.Receiver?
    /// If the engagement invitation was rejected, this field specifies the reason provided by the partner for the rejection.
    public var rejectionReason: Swift.String?
    /// Specifies the AWS Account ID of the sender, which identifies the AWS team responsible for sharing the engagement invitation.
    public var senderAwsAccountId: Swift.String?
    /// The name of the AWS organization or team that sent the engagement invitation.
    public var senderCompanyName: Swift.String?
    /// The current status of the engagement invitation.
    public var status: PartnerCentralSellingClientTypes.InvitationStatus?

    public init(
        arn: Swift.String? = nil,
        catalog: Swift.String? = nil,
        engagementDescription: Swift.String? = nil,
        engagementId: Swift.String? = nil,
        engagementTitle: Swift.String? = nil,
        existingMembers: [PartnerCentralSellingClientTypes.EngagementMemberSummary]? = nil,
        expirationDate: Foundation.Date? = nil,
        id: Swift.String? = nil,
        invitationDate: Foundation.Date? = nil,
        invitationMessage: Swift.String? = nil,
        payload: PartnerCentralSellingClientTypes.Payload? = nil,
        payloadType: PartnerCentralSellingClientTypes.EngagementInvitationPayloadType? = nil,
        receiver: PartnerCentralSellingClientTypes.Receiver? = nil,
        rejectionReason: Swift.String? = nil,
        senderAwsAccountId: Swift.String? = nil,
        senderCompanyName: Swift.String? = nil,
        status: PartnerCentralSellingClientTypes.InvitationStatus? = nil
    ) {
        self.arn = arn
        self.catalog = catalog
        self.engagementDescription = engagementDescription
        self.engagementId = engagementId
        self.engagementTitle = engagementTitle
        self.existingMembers = existingMembers
        self.expirationDate = expirationDate
        self.id = id
        self.invitationDate = invitationDate
        self.invitationMessage = invitationMessage
        self.payload = payload
        self.payloadType = payloadType
        self.receiver = receiver
        self.rejectionReason = rejectionReason
        self.senderAwsAccountId = senderAwsAccountId
        self.senderCompanyName = senderCompanyName
        self.status = status
    }
}

extension GetEngagementInvitationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetEngagementInvitationOutput(arn: \(Swift.String(describing: arn)), catalog: \(Swift.String(describing: catalog)), engagementDescription: \(Swift.String(describing: engagementDescription)), engagementId: \(Swift.String(describing: engagementId)), engagementTitle: \(Swift.String(describing: engagementTitle)), existingMembers: \(Swift.String(describing: existingMembers)), expirationDate: \(Swift.String(describing: expirationDate)), id: \(Swift.String(describing: id)), invitationDate: \(Swift.String(describing: invitationDate)), payload: \(Swift.String(describing: payload)), payloadType: \(Swift.String(describing: payloadType)), receiver: \(Swift.String(describing: receiver)), rejectionReason: \(Swift.String(describing: rejectionReason)), senderCompanyName: \(Swift.String(describing: senderCompanyName)), status: \(Swift.String(describing: status)), invitationMessage: \"CONTENT_REDACTED\", senderAwsAccountId: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    public enum ParticipantType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case receiver
        case sender
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantType] {
            return [
                .receiver,
                .sender
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .receiver: return "RECEIVER"
            case .sender: return "SENDER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum OpportunityEngagementInvitationSortName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case invitationDate
        case sdkUnknown(Swift.String)

        public static var allCases: [OpportunityEngagementInvitationSortName] {
            return [
                .invitationDate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .invitationDate: return "InvitationDate"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Defines sorting options for retrieving Engagement Invitations. Sorting can be done based on various criteria like the invitation date or status.
    public struct OpportunityEngagementInvitationSort: Swift.Sendable {
        /// Specifies the field by which the Engagement Invitations are sorted. Common values include InvitationDate and Status.
        /// This member is required.
        public var sortBy: PartnerCentralSellingClientTypes.OpportunityEngagementInvitationSortName?
        /// Defines the order in which the Engagement Invitations are sorted. The values can be ASC (ascending) or DESC (descending).
        /// This member is required.
        public var sortOrder: PartnerCentralSellingClientTypes.SortOrder?

        public init(
            sortBy: PartnerCentralSellingClientTypes.OpportunityEngagementInvitationSortName? = nil,
            sortOrder: PartnerCentralSellingClientTypes.SortOrder? = nil
        ) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }
}

public struct ListEngagementInvitationsInput: Swift.Sendable {
    /// Specifies the catalog from which to list the engagement invitations. Use AWS for production invitations or Sandbox for testing environments.
    /// This member is required.
    public var catalog: Swift.String?
    /// Retrieves a list of engagement invitation summaries based on specified filters. The ListEngagementInvitations operation allows you to view all invitations that you have sent or received. You must specify the ParticipantType to filter invitations where you are either the SENDER or the RECEIVER. Invitations will automatically expire if not accepted within 15 days.
    public var engagementIdentifier: [Swift.String]?
    /// Specifies the maximum number of engagement invitations to return in the response. If more results are available, a pagination token will be provided.
    public var maxResults: Swift.Int?
    /// A pagination token used to retrieve additional pages of results when the response to a previous request was truncated. Pass this token to continue listing invitations from where the previous call left off.
    public var nextToken: Swift.String?
    /// Specifies the type of participant for which to list engagement invitations. Identifies the role of the participant.
    /// This member is required.
    public var participantType: PartnerCentralSellingClientTypes.ParticipantType?
    /// Defines the type of payload associated with the engagement invitations to be listed. The attributes in this payload help decide on acceptance or rejection of the invitation.
    public var payloadType: [PartnerCentralSellingClientTypes.EngagementInvitationPayloadType]?
    /// List of sender AWS account IDs to filter the invitations.
    public var senderAwsAccountId: [Swift.String]?
    /// Specifies the sorting options for listing engagement invitations. Invitations can be sorted by fields such as InvitationDate or Status to help partners view results in their preferred order.
    public var sort: PartnerCentralSellingClientTypes.OpportunityEngagementInvitationSort?
    /// Status values to filter the invitations.
    public var status: [PartnerCentralSellingClientTypes.InvitationStatus]?

    public init(
        catalog: Swift.String? = nil,
        engagementIdentifier: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        participantType: PartnerCentralSellingClientTypes.ParticipantType? = nil,
        payloadType: [PartnerCentralSellingClientTypes.EngagementInvitationPayloadType]? = nil,
        senderAwsAccountId: [Swift.String]? = nil,
        sort: PartnerCentralSellingClientTypes.OpportunityEngagementInvitationSort? = nil,
        status: [PartnerCentralSellingClientTypes.InvitationStatus]? = nil
    ) {
        self.catalog = catalog
        self.engagementIdentifier = engagementIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.participantType = participantType
        self.payloadType = payloadType
        self.senderAwsAccountId = senderAwsAccountId
        self.sort = sort
        self.status = status
    }
}

extension ListEngagementInvitationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEngagementInvitationsInput(catalog: \(Swift.String(describing: catalog)), engagementIdentifier: \(Swift.String(describing: engagementIdentifier)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), participantType: \(Swift.String(describing: participantType)), payloadType: \(Swift.String(describing: payloadType)), sort: \(Swift.String(describing: sort)), status: \(Swift.String(describing: status)), senderAwsAccountId: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// Provides a summarized view of the Engagement Invitation, including details like the identifier, status, and sender. This summary helps partners track and manage AWS originated opportunities.
    public struct EngagementInvitationSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Engagement Invitation. The ARN is a unique identifier that allows partners to reference the invitation in their system and manage its lifecycle.
        public var arn: Swift.String?
        /// Specifies the catalog in which the Engagement Invitation resides. This can be either the AWS or Sandbox catalog, indicating whether the opportunity is live or being tested.
        /// This member is required.
        public var catalog: Swift.String?
        /// The identifier of the Engagement associated with this invitation. This links the invitation to its parent Engagement.
        public var engagementId: Swift.String?
        /// Provides a short title or description of the Engagement Invitation. This title helps partners quickly identify and differentiate between multiple engagement opportunities.
        public var engagementTitle: Swift.String?
        /// Indicates the date and time when the Engagement Invitation will expire. After this date, the invitation can no longer be accepted, and the opportunity will be unavailable to the partner.
        public var expirationDate: Foundation.Date?
        /// Represents the unique identifier of the Engagement Invitation. This identifier is used to track the invitation and to manage responses like acceptance or rejection.
        /// This member is required.
        public var id: Swift.String?
        /// Indicates the date when the Engagement Invitation was sent to the partner. This provides context for when the opportunity was shared and helps in tracking the timeline for engagement.
        public var invitationDate: Foundation.Date?
        /// Identifies the role of the caller in the engagement invitation.
        public var participantType: PartnerCentralSellingClientTypes.ParticipantType?
        /// Describes the type of payload associated with the Engagement Invitation, such as Opportunity or MarketplaceOffer. This helps partners understand the nature of the engagement request from AWS.
        public var payloadType: PartnerCentralSellingClientTypes.EngagementInvitationPayloadType?
        /// Specifies the partner company or individual that received the Engagement Invitation. This field is important for tracking who the invitation was sent to within the partner organization.
        public var receiver: PartnerCentralSellingClientTypes.Receiver?
        /// Specifies the AWS account ID of the sender who initiated the Engagement Invitation. This allows the partner to identify the AWS entity or representative responsible for sharing the opportunity.
        public var senderAwsAccountId: Swift.String?
        /// Indicates the name of the company or AWS division that sent the Engagement Invitation. This information is useful for partners to know which part of AWS is requesting engagement.
        public var senderCompanyName: Swift.String?
        /// Represents the current status of the Engagement Invitation, such as Pending, Accepted, or Rejected. The status helps track the progress and response to the invitation.
        public var status: PartnerCentralSellingClientTypes.InvitationStatus?

        public init(
            arn: Swift.String? = nil,
            catalog: Swift.String? = nil,
            engagementId: Swift.String? = nil,
            engagementTitle: Swift.String? = nil,
            expirationDate: Foundation.Date? = nil,
            id: Swift.String? = nil,
            invitationDate: Foundation.Date? = nil,
            participantType: PartnerCentralSellingClientTypes.ParticipantType? = nil,
            payloadType: PartnerCentralSellingClientTypes.EngagementInvitationPayloadType? = nil,
            receiver: PartnerCentralSellingClientTypes.Receiver? = nil,
            senderAwsAccountId: Swift.String? = nil,
            senderCompanyName: Swift.String? = nil,
            status: PartnerCentralSellingClientTypes.InvitationStatus? = nil
        ) {
            self.arn = arn
            self.catalog = catalog
            self.engagementId = engagementId
            self.engagementTitle = engagementTitle
            self.expirationDate = expirationDate
            self.id = id
            self.invitationDate = invitationDate
            self.participantType = participantType
            self.payloadType = payloadType
            self.receiver = receiver
            self.senderAwsAccountId = senderAwsAccountId
            self.senderCompanyName = senderCompanyName
            self.status = status
        }
    }
}

extension PartnerCentralSellingClientTypes.EngagementInvitationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EngagementInvitationSummary(arn: \(Swift.String(describing: arn)), catalog: \(Swift.String(describing: catalog)), engagementId: \(Swift.String(describing: engagementId)), engagementTitle: \(Swift.String(describing: engagementTitle)), expirationDate: \(Swift.String(describing: expirationDate)), id: \(Swift.String(describing: id)), invitationDate: \(Swift.String(describing: invitationDate)), participantType: \(Swift.String(describing: participantType)), payloadType: \(Swift.String(describing: payloadType)), receiver: \(Swift.String(describing: receiver)), senderCompanyName: \(Swift.String(describing: senderCompanyName)), status: \(Swift.String(describing: status)), senderAwsAccountId: \"CONTENT_REDACTED\")"}
}

public struct ListEngagementInvitationsOutput: Swift.Sendable {
    /// An array containing summaries of engagement invitations. Each summary includes information such as the invitation title, invitation date, and the current status of the invitation.
    public var engagementInvitationSummaries: [PartnerCentralSellingClientTypes.EngagementInvitationSummary]?
    /// A pagination token returned when there are more results available than can be returned in a single call. Use this token to retrieve additional pages of engagement invitation summaries.
    public var nextToken: Swift.String?

    public init(
        engagementInvitationSummaries: [PartnerCentralSellingClientTypes.EngagementInvitationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.engagementInvitationSummaries = engagementInvitationSummaries
        self.nextToken = nextToken
    }
}

public struct RejectEngagementInvitationInput: Swift.Sendable {
    /// This is the catalog that's associated with the engagement invitation. Acceptable values are AWS or Sandbox, and these values determine the environment in which the opportunity is managed.
    /// This member is required.
    public var catalog: Swift.String?
    /// This is the unique identifier of the rejected EngagementInvitation. Providing the correct identifier helps to ensure that the intended invitation is rejected.
    /// This member is required.
    public var identifier: Swift.String?
    /// This describes the reason for rejecting the engagement invitation, which helps AWS track usage patterns. Acceptable values include the following:
    ///
    /// * Customer problem unclear: The customer's problem isn't understood.
    ///
    /// * Next steps unclear: The next steps required to proceed aren't understood.
    ///
    /// * Unable to support: The partner is unable to provide support due to resource or capability constraints.
    ///
    /// * Duplicate of partner referral: The opportunity is a duplicate of an existing referral.
    ///
    /// * Other: Any reason not covered by other values.
    public var rejectionReason: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil,
        rejectionReason: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
        self.rejectionReason = rejectionReason
    }
}

public struct GetSellingSystemSettingsInput: Swift.Sendable {
    /// Specifies the catalog in which the settings are defined. Acceptable values include AWS for production and Sandbox for testing environments.
    /// This member is required.
    public var catalog: Swift.String?

    public init(
        catalog: Swift.String? = nil
    ) {
        self.catalog = catalog
    }
}

public struct GetSellingSystemSettingsOutput: Swift.Sendable {
    /// Specifies the catalog in which the settings are defined. Acceptable values include AWS for production and Sandbox for testing environments.
    /// This member is required.
    public var catalog: Swift.String?
    /// Specifies the ARN of the IAM Role used for resource snapshot job executions.
    public var resourceSnapshotJobRoleArn: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        resourceSnapshotJobRoleArn: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.resourceSnapshotJobRoleArn = resourceSnapshotJobRoleArn
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource for which you want to retrieve tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A map of the key-value pairs for the tag or tags assigned to the specified resource.
    /// This member is required.
    public var tags: [PartnerCentralSellingClientTypes.Tag]?

    public init(
        tags: [PartnerCentralSellingClientTypes.Tag]? = nil
    ) {
        self.tags = tags
    }
}

extension PartnerCentralSellingClientTypes {

    /// An object that contains the customer's Account and Contact.
    public struct Customer: Swift.Sendable {
        /// An object that contains the customer's account details.
        public var account: PartnerCentralSellingClientTypes.Account?
        /// Represents the contact details for individuals associated with the customer of the Opportunity. This field captures relevant contacts, including decision-makers, influencers, and technical stakeholders within the customer organization. These contacts are key to progressing the opportunity.
        public var contacts: [PartnerCentralSellingClientTypes.Contact]?

        public init(
            account: PartnerCentralSellingClientTypes.Account? = nil,
            contacts: [PartnerCentralSellingClientTypes.Contact]? = nil
        ) {
            self.account = account
            self.contacts = contacts
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum ClosedLostReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case customerDeficiency
        case customerExperience
        case delayCancellationOfProject
        case financialcommercial
        case legalTaxRegulatory
        case lostToCompetitorGoogle
        case lostToCompetitorMicrosoft
        case lostToCompetitorOther
        case lostToCompetitorSoftlayer
        case lostToCompetitorVmware
        case noOpportunity
        case onPremisesDeployment
        case other
        case partnerGap
        case peoplerelationshipgovernance
        case price
        case producttechnology
        case securityCompliance
        case technicalLimitations
        case sdkUnknown(Swift.String)

        public static var allCases: [ClosedLostReason] {
            return [
                .customerDeficiency,
                .customerExperience,
                .delayCancellationOfProject,
                .financialcommercial,
                .legalTaxRegulatory,
                .lostToCompetitorGoogle,
                .lostToCompetitorMicrosoft,
                .lostToCompetitorOther,
                .lostToCompetitorSoftlayer,
                .lostToCompetitorVmware,
                .noOpportunity,
                .onPremisesDeployment,
                .other,
                .partnerGap,
                .peoplerelationshipgovernance,
                .price,
                .producttechnology,
                .securityCompliance,
                .technicalLimitations
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .customerDeficiency: return "Customer Deficiency"
            case .customerExperience: return "Customer Experience"
            case .delayCancellationOfProject: return "Delay / Cancellation of Project"
            case .financialcommercial: return "Financial/Commercial"
            case .legalTaxRegulatory: return "Legal / Tax / Regulatory"
            case .lostToCompetitorGoogle: return "Lost to Competitor - Google"
            case .lostToCompetitorMicrosoft: return "Lost to Competitor - Microsoft"
            case .lostToCompetitorOther: return "Lost to Competitor - Other"
            case .lostToCompetitorSoftlayer: return "Lost to Competitor - SoftLayer"
            case .lostToCompetitorVmware: return "Lost to Competitor - VMWare"
            case .noOpportunity: return "No Opportunity"
            case .onPremisesDeployment: return "On Premises Deployment"
            case .other: return "Other"
            case .partnerGap: return "Partner Gap"
            case .peoplerelationshipgovernance: return "People/Relationship/Governance"
            case .price: return "Price"
            case .producttechnology: return "Product/Technology"
            case .securityCompliance: return "Security / Compliance"
            case .technicalLimitations: return "Technical Limitations"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Read-only; shows the last 50 values and change dates for the NextSteps field.
    public struct NextStepsHistory: Swift.Sendable {
        /// Indicates the step execution time.
        /// This member is required.
        public var time: Foundation.Date?
        /// Indicates the step's execution details.
        /// This member is required.
        public var value: Swift.String?

        public init(
            time: Foundation.Date? = nil,
            value: Swift.String? = nil
        ) {
            self.time = time
            self.value = value
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum ReviewStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actionRequired
        case approved
        case inReview
        case pendingSubmission
        case rejected
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [ReviewStatus] {
            return [
                .actionRequired,
                .approved,
                .inReview,
                .pendingSubmission,
                .rejected,
                .submitted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actionRequired: return "Action Required"
            case .approved: return "Approved"
            case .inReview: return "In review"
            case .pendingSubmission: return "Pending Submission"
            case .rejected: return "Rejected"
            case .submitted: return "Submitted"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum Stage: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case businessValidation
        case closedLost
        case committed
        case launched
        case prospect
        case qualified
        case technicalValidation
        case sdkUnknown(Swift.String)

        public static var allCases: [Stage] {
            return [
                .businessValidation,
                .closedLost,
                .committed,
                .launched,
                .prospect,
                .qualified,
                .technicalValidation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .businessValidation: return "Business Validation"
            case .closedLost: return "Closed Lost"
            case .committed: return "Committed"
            case .launched: return "Launched"
            case .prospect: return "Prospect"
            case .qualified: return "Qualified"
            case .technicalValidation: return "Technical Validation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// An object that contains the Opportunity lifecycle's details.
    public struct LifeCycle: Swift.Sendable {
        /// Specifies the reason code when an opportunity is marked as Closed Lost. When you select an appropriate reason code, you communicate the context for closing the Opportunity, and aid in accurate reports and analysis of opportunity outcomes. The possible values are:
        ///
        /// * Customer Deficiency: The customer lacked necessary resources or capabilities.
        ///
        /// * Delay/Cancellation of Project: The project was delayed or canceled.
        ///
        /// * Legal/Tax/Regulatory: Legal, tax, or regulatory issues prevented progress.
        ///
        /// * Lost to Competitor—Google: The opportunity was lost to Google.
        ///
        /// * Lost to Competitor—Microsoft: The opportunity was lost to Microsoft.
        ///
        /// * Lost to Competitor—SoftLayer: The opportunity was lost to SoftLayer.
        ///
        /// * Lost to Competitor—VMWare: The opportunity was lost to VMWare.
        ///
        /// * Lost to Competitor—Other: The opportunity was lost to a competitor not listed above.
        ///
        /// * No Opportunity: There was no opportunity to pursue.
        ///
        /// * On Premises Deployment: The customer chose an on-premises solution.
        ///
        /// * Partner Gap: The partner lacked necessary resources or capabilities.
        ///
        /// * Price: The price was not competitive or acceptable to the customer.
        ///
        /// * Security/Compliance: Security or compliance issues prevented progress.
        ///
        /// * Technical Limitations: Technical limitations prevented progress.
        ///
        /// * Customer Experience: Issues related to the customer's experience impacted the decision.
        ///
        /// * Other: Any reason not covered by the other values.
        ///
        /// * People/Relationship/Governance: Issues related to people, relationships, or governance.
        ///
        /// * Product/Technology: Issues related to the product or technology.
        ///
        /// * Financial/Commercial: Financial or commercial issues impacted the decision.
        public var closedLostReason: PartnerCentralSellingClientTypes.ClosedLostReason?
        /// Specifies the upcoming actions or tasks for the Opportunity. Use this field to communicate with Amazon Web Services about the next actions required for the Opportunity.
        public var nextSteps: Swift.String?
        /// Captures a chronological record of the next steps or actions planned or taken for the current opportunity, along with the timestamp.
        public var nextStepsHistory: [PartnerCentralSellingClientTypes.NextStepsHistory]?
        /// Contains detailed feedback from Amazon Web Services when requesting additional information from partners. Provides specific guidance on what partners need to provide or clarify for opportunity validation, complementing the ReviewStatusReason field.
        public var reviewComments: Swift.String?
        /// Indicates the review status of an opportunity referred by a partner. This field is read-only and only applicable for partner referrals. The possible values are:
        ///
        /// * Pending Submission: Not submitted for validation (editable).
        ///
        /// * Submitted: Submitted for validation, and Amazon Web Services hasn't reviewed it (read-only).
        ///
        /// * In Review: Amazon Web Services is validating (read-only).
        ///
        /// * Action Required: Issues that Amazon Web Services highlights need to be addressed. Partners should use the UpdateOpportunity API action to update the opportunity and helps to ensure that all required changes are made. Only the following fields are editable when the Lifecycle.ReviewStatus is Action Required:
        ///
        /// * Customer.Account.Address.City
        ///
        /// * Customer.Account.Address.CountryCode
        ///
        /// * Customer.Account.Address.PostalCode
        ///
        /// * Customer.Account.Address.StateOrRegion
        ///
        /// * Customer.Account.Address.StreetAddress
        ///
        /// * Customer.Account.WebsiteUrl
        ///
        /// * LifeCycle.TargetCloseDate
        ///
        /// * Project.ExpectedMonthlyAWSRevenue.Amount
        ///
        /// * Project.ExpectedMonthlyAWSRevenue.CurrencyCode
        ///
        /// * Project.CustomerBusinessProblem
        ///
        /// * PartnerOpportunityIdentifier
        ///
        ///
        /// After updates, the opportunity re-enters the validation phase. This process repeats until all issues are resolved, and the opportunity's Lifecycle.ReviewStatus is set to Approved or Rejected.
        ///
        /// * Approved: Validated and converted into the Amazon Web Services seller's pipeline (editable).
        ///
        /// * Rejected: Disqualified (read-only).
        public var reviewStatus: PartnerCentralSellingClientTypes.ReviewStatus?
        /// Code indicating the validation decision during the Amazon Web Services opportunity review. Applies when status is Rejected or Action Required. Used to document validation results for AWS Partner Referrals and indicate when additional information is needed from partners as part of the APN Customer Engagement (ACE) program.
        public var reviewStatusReason: Swift.String?
        /// Specifies the current stage of the Opportunity's lifecycle as it maps to Amazon Web Services stages from the current stage in the partner CRM. This field provides a translated value of the stage, and offers insight into the Opportunity's progression in the sales cycle, according to Amazon Web Services definitions. A lead and a prospect must be further matured to a Qualified opportunity before submission. Opportunities that were closed/lost before submission aren't suitable for submission. The descriptions of each sales stage are:
        ///
        /// * Prospect: Amazon Web Services identifies the opportunity. It can be active (Comes directly from the end customer through a lead) or latent (Your account team believes it exists based on research, account plans, sales plays).
        ///
        /// * Qualified: Your account team engaged with the customer to discuss viability and requirements. The customer agreed that the opportunity is real, of interest, and may solve business/technical needs.
        ///
        /// * Technical Validation: All parties understand the implementation plan.
        ///
        /// * Business Validation: Pricing was proposed, and all parties agree to the steps to close.
        ///
        /// * Committed: The customer signed the contract, but Amazon Web Services hasn't started billing.
        ///
        /// * Launched: The workload is complete, and Amazon Web Services has started billing.
        ///
        /// * Closed Lost: The opportunity is lost, and there are no steps to move forward.
        public var stage: PartnerCentralSellingClientTypes.Stage?
        /// Specifies the date when Amazon Web Services expects to start significant billing, when the project finishes, and when it moves into production. This field informs the Amazon Web Services seller about when the opportunity launches and starts to incur Amazon Web Services usage. Ensure the Target Close Date isn't in the past.
        public var targetCloseDate: Swift.String?

        public init(
            closedLostReason: PartnerCentralSellingClientTypes.ClosedLostReason? = nil,
            nextSteps: Swift.String? = nil,
            nextStepsHistory: [PartnerCentralSellingClientTypes.NextStepsHistory]? = nil,
            reviewComments: Swift.String? = nil,
            reviewStatus: PartnerCentralSellingClientTypes.ReviewStatus? = nil,
            reviewStatusReason: Swift.String? = nil,
            stage: PartnerCentralSellingClientTypes.Stage? = nil,
            targetCloseDate: Swift.String? = nil
        ) {
            self.closedLostReason = closedLostReason
            self.nextSteps = nextSteps
            self.nextStepsHistory = nextStepsHistory
            self.reviewComments = reviewComments
            self.reviewStatus = reviewStatus
            self.reviewStatusReason = reviewStatusReason
            self.stage = stage
            self.targetCloseDate = targetCloseDate
        }
    }
}

extension PartnerCentralSellingClientTypes.LifeCycle: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LifeCycle(closedLostReason: \(Swift.String(describing: closedLostReason)), nextStepsHistory: \(Swift.String(describing: nextStepsHistory)), reviewComments: \(Swift.String(describing: reviewComments)), reviewStatus: \(Swift.String(describing: reviewStatus)), reviewStatusReason: \(Swift.String(describing: reviewStatusReason)), stage: \(Swift.String(describing: stage)), targetCloseDate: \(Swift.String(describing: targetCloseDate)), nextSteps: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    public enum Channel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsMarketingCentral
        case contentSyndication
        case display
        case email
        case liveEvent
        case outOfHome
        case print
        case search
        case social
        case telemarketing
        case tv
        case video
        case virtualEvent
        case sdkUnknown(Swift.String)

        public static var allCases: [Channel] {
            return [
                .awsMarketingCentral,
                .contentSyndication,
                .display,
                .email,
                .liveEvent,
                .outOfHome,
                .print,
                .search,
                .social,
                .telemarketing,
                .tv,
                .video,
                .virtualEvent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsMarketingCentral: return "AWS Marketing Central"
            case .contentSyndication: return "Content Syndication"
            case .display: return "Display"
            case .email: return "Email"
            case .liveEvent: return "Live Event"
            case .outOfHome: return "Out Of Home (OOH)"
            case .print: return "Print"
            case .search: return "Search"
            case .social: return "Social"
            case .telemarketing: return "Telemarketing"
            case .tv: return "TV"
            case .video: return "Video"
            case .virtualEvent: return "Virtual Event"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum MarketingSource: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case marketingActivity
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [MarketingSource] {
            return [
                .marketingActivity,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .marketingActivity: return "Marketing Activity"
            case .none: return "None"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// An object that contains marketing details for the Opportunity.
    public struct Marketing: Swift.Sendable {
        /// Indicates if the Opportunity is a marketing development fund (MDF) funded activity.
        public var awsFundingUsed: PartnerCentralSellingClientTypes.AwsFundingUsed?
        /// Specifies the Opportunity marketing campaign code. The Amazon Web Services campaign code is a reference to specific marketing initiatives, promotions, or activities. This field captures the identifier used to track and categorize the Opportunity within marketing campaigns. If you don't have a campaign code, contact your Amazon Web Services point of contact to obtain one.
        public var campaignName: Swift.String?
        /// Specifies the Opportunity's channel that the marketing activity is associated with or was contacted through. This field provides information about the specific marketing channel that contributed to the generation of the lead or contact.
        public var channels: [PartnerCentralSellingClientTypes.Channel]?
        /// Indicates if the Opportunity was sourced from an Amazon Web Services marketing activity. Use the value Marketing Activity. Use None if it's not associated with an Amazon Web Services marketing activity. This field helps Amazon Web Services track the return on marketing investments and enables better distribution of marketing budgets among partners.
        public var source: PartnerCentralSellingClientTypes.MarketingSource?
        /// Specifies the marketing activity use case or purpose that led to the Opportunity's creation or contact. This field captures the context or marketing activity's execution's intention and the direct correlation to the generated opportunity or contact. Must be empty when Marketing.AWSFundingUsed = No. Valid values: AI/ML | Analytics | Application Integration | Blockchain | Business Applications | Cloud Financial Management | Compute | Containers | Customer Engagement | Databases | Developer Tools | End User Computing | Front End Web & Mobile | Game Tech | IoT | Management & Governance | Media Services | Migration & Transfer | Networking & Content Delivery | Quantum Technologies | Robotics | Satellite | Security | Serverless | Storage | VR & AR
        public var useCases: [Swift.String]?

        public init(
            awsFundingUsed: PartnerCentralSellingClientTypes.AwsFundingUsed? = nil,
            campaignName: Swift.String? = nil,
            channels: [PartnerCentralSellingClientTypes.Channel]? = nil,
            source: PartnerCentralSellingClientTypes.MarketingSource? = nil,
            useCases: [Swift.String]? = nil
        ) {
            self.awsFundingUsed = awsFundingUsed
            self.campaignName = campaignName
            self.channels = channels
            self.source = source
            self.useCases = useCases
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum NationalSecurity: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case no
        case yes
        case sdkUnknown(Swift.String)

        public static var allCases: [NationalSecurity] {
            return [
                .no,
                .yes
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .no: return "No"
            case .yes: return "Yes"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum OpportunityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case expansion
        case flatRenewal
        case netNewBusiness
        case sdkUnknown(Swift.String)

        public static var allCases: [OpportunityType] {
            return [
                .expansion,
                .flatRenewal,
                .netNewBusiness
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .expansion: return "Expansion"
            case .flatRenewal: return "Flat Renewal"
            case .netNewBusiness: return "Net New Business"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum PrimaryNeedFromAws: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case coSellArchitecturalValidation
        case coSellBusinessPresentation
        case coSellCompetitiveInformation
        case coSellDealSupport
        case coSellPricingAssistance
        case coSellSupportForPublicTenderRfx
        case coSellTechnicalConsultation
        case coSellTotalCostOfOwnershipEvaluation
        case sdkUnknown(Swift.String)

        public static var allCases: [PrimaryNeedFromAws] {
            return [
                .coSellArchitecturalValidation,
                .coSellBusinessPresentation,
                .coSellCompetitiveInformation,
                .coSellDealSupport,
                .coSellPricingAssistance,
                .coSellSupportForPublicTenderRfx,
                .coSellTechnicalConsultation,
                .coSellTotalCostOfOwnershipEvaluation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .coSellArchitecturalValidation: return "Co-Sell - Architectural Validation"
            case .coSellBusinessPresentation: return "Co-Sell - Business Presentation"
            case .coSellCompetitiveInformation: return "Co-Sell - Competitive Information"
            case .coSellDealSupport: return "Co-Sell - Deal Support"
            case .coSellPricingAssistance: return "Co-Sell - Pricing Assistance"
            case .coSellSupportForPublicTenderRfx: return "Co-Sell - Support for Public Tender / RFx"
            case .coSellTechnicalConsultation: return "Co-Sell - Technical Consultation"
            case .coSellTotalCostOfOwnershipEvaluation: return "Co-Sell - Total Cost of Ownership Evaluation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum CompetitorName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case akamai
        case alicloud
        case coLocation
        case googleCloudPlatform
        case ibmSoftlayer
        case microsoftAzure
        case noCompetition
        case onPrem
        case oracleCloud
        case other
        case otherCostOptimization
        case sdkUnknown(Swift.String)

        public static var allCases: [CompetitorName] {
            return [
                .akamai,
                .alicloud,
                .coLocation,
                .googleCloudPlatform,
                .ibmSoftlayer,
                .microsoftAzure,
                .noCompetition,
                .onPrem,
                .oracleCloud,
                .other,
                .otherCostOptimization
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .akamai: return "Akamai"
            case .alicloud: return "AliCloud"
            case .coLocation: return "Co-location"
            case .googleCloudPlatform: return "Google Cloud Platform"
            case .ibmSoftlayer: return "IBM Softlayer"
            case .microsoftAzure: return "Microsoft Azure"
            case .noCompetition: return "No Competition"
            case .onPrem: return "On-Prem"
            case .oracleCloud: return "Oracle Cloud"
            case .other: return "*Other"
            case .otherCostOptimization: return "Other- Cost Optimization"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum DeliveryModel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case byolOrAmi
        case managedServices
        case other
        case professionalServices
        case resell
        case saasOrPaas
        case sdkUnknown(Swift.String)

        public static var allCases: [DeliveryModel] {
            return [
                .byolOrAmi,
                .managedServices,
                .other,
                .professionalServices,
                .resell,
                .saasOrPaas
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .byolOrAmi: return "BYOL or AMI"
            case .managedServices: return "Managed Services"
            case .other: return "Other"
            case .professionalServices: return "Professional Services"
            case .resell: return "Resell"
            case .saasOrPaas: return "SaaS or PaaS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum SalesActivity: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agreedOnSolutionToBusinessProblem
        case completedActionPlan
        case conductedPocDemo
        case customerHasShownInterest
        case finalizedDeploymentNeeds
        case initializedDiscussionsWithCustomer
        case inEvaluationPlanningStage
        case sowSigned
        case sdkUnknown(Swift.String)

        public static var allCases: [SalesActivity] {
            return [
                .agreedOnSolutionToBusinessProblem,
                .completedActionPlan,
                .conductedPocDemo,
                .customerHasShownInterest,
                .finalizedDeploymentNeeds,
                .initializedDiscussionsWithCustomer,
                .inEvaluationPlanningStage,
                .sowSigned
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agreedOnSolutionToBusinessProblem: return "Agreed on solution to Business Problem"
            case .completedActionPlan: return "Completed Action Plan"
            case .conductedPocDemo: return "Conducted POC / Demo"
            case .customerHasShownInterest: return "Customer has shown interest in solution"
            case .finalizedDeploymentNeeds: return "Finalized Deployment Need"
            case .initializedDiscussionsWithCustomer: return "Initialized discussions with customer"
            case .inEvaluationPlanningStage: return "In evaluation / planning stage"
            case .sowSigned: return "SOW Signed"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// An object that contains the Opportunity's project details.
    public struct Project: Swift.Sendable {
        /// Captures additional comments or information for the Opportunity that weren't captured in other fields.
        public var additionalComments: Swift.String?
        /// Specifies the Amazon Partner Network (APN) program that influenced the Opportunity. APN programs refer to specific partner programs or initiatives that can impact the Opportunity. Valid values: APN Immersion Days | APN Solution Space | ATO (Authority to Operate) | AWS Marketplace Campaign | IS Immersion Day SFID Program | ISV Workload Migration | Migration Acceleration Program | P3 | Partner Launch Initiative | Partner Opportunity Acceleration Funded | The Next Smart | VMware Cloud on AWS | Well-Architected | Windows | Workspaces/AppStream Accelerator Program | WWPS NDPP
        public var apnPrograms: [Swift.String]?
        /// AWS partition where the opportunity will be deployed. Possible values: aws-eusc for AWS European Sovereign Cloud, null for all other partitions.
        public var awsPartition: PartnerCentralSellingClientTypes.AwsPartition?
        /// Name of the Opportunity's competitor (if any). Use Other to submit a value not in the picklist.
        public var competitorName: PartnerCentralSellingClientTypes.CompetitorName?
        /// Describes the problem the end customer has, and how the partner is helping. Utilize this field to provide a concise narrative that outlines the customer's business challenge or issue. Elaborate on how the partner's solution or offerings align to resolve the customer's business problem. Include relevant information about the partner's value proposition, unique selling points, and expertise to tackle the issue. Offer insights on how the proposed solution meets the customer's needs and provides value. Use concise language and precise descriptions to convey the context and significance of the Opportunity. The content in this field helps Amazon Web Services understand the nature of the Opportunity and the strategic fit of the partner's solution.
        public var customerBusinessProblem: Swift.String?
        /// Specifies the proposed solution focus or type of workload for the Opportunity. This field captures the primary use case or objective of the proposed solution, and provides context and clarity to the addressed workload. Valid values: AI Machine Learning and Analytics | Archiving | Big Data: Data Warehouse/Data Integration/ETL/Data Lake/BI | Blockchain | Business Applications: Mainframe Modernization | Business Applications & Contact Center | Business Applications & SAP Production | Centralized Operations Management | Cloud Management Tools | Cloud Management Tools & DevOps with Continuous Integration & Continuous Delivery (CICD) | Configuration, Compliance & Auditing | Connected Services | Containers & Serverless | Content Delivery & Edge Services | Database | Edge Computing/End User Computing | Energy | Enterprise Governance & Controls | Enterprise Resource Planning | Financial Services | Healthcare and Life Sciences | High Performance Computing | Hybrid Application Platform | Industrial Software | IOT | Manufacturing, Supply Chain and Operations | Media & High performance computing (HPC) | Migration/Database Migration | Monitoring, logging and performance | Monitoring & Observability | Networking | Outpost | SAP | Security & Compliance | Storage & Backup | Training | VMC | VMWare | Web development & DevOps
        public var customerUseCase: Swift.String?
        /// Specifies the deployment or consumption model for your solution or service in the Opportunity's context. You can select multiple options. Options' descriptions from the Delivery Model field are:
        ///
        /// * SaaS or PaaS: Your Amazon Web Services based solution deployed as SaaS or PaaS in your Amazon Web Services environment.
        ///
        /// * BYOL or AMI: Your Amazon Web Services based solution deployed as BYOL or AMI in the end customer's Amazon Web Services environment.
        ///
        /// * Managed Services: The end customer's Amazon Web Services business management (For example: Consulting, design, implementation, billing support, cost optimization, technical support).
        ///
        /// * Professional Services: Offerings to help enterprise end customers achieve specific business outcomes for enterprise cloud adoption (For example: Advisory or transformation planning).
        ///
        /// * Resell: Amazon Web Services accounts and billing management for your customers.
        ///
        /// * Other: Delivery model not described above.
        public var deliveryModels: [PartnerCentralSellingClientTypes.DeliveryModel]?
        /// Represents the estimated amount that the customer is expected to spend on AWS services related to the opportunity. This helps in evaluating the potential financial value of the opportunity for AWS.
        public var expectedCustomerSpend: [PartnerCentralSellingClientTypes.ExpectedCustomerSpend]?
        /// Only allowed when CompetitorNames has Other selected.
        public var otherCompetitorNames: Swift.String?
        /// Specifies the offered solution for the customer's business problem when the  RelatedEntityIdentifiers.Solutions field value is Other.
        public var otherSolutionDescription: Swift.String?
        /// Specifies the current opportunity's parent opportunity identifier.
        public var relatedOpportunityIdentifier: Swift.String?
        /// Specifies the Opportunity's sales activities conducted with the end customer. These activities help drive Amazon Web Services assignment priority. Valid values:
        ///
        /// * Initialized discussions with customer: Initial conversations with the customer to understand their needs and introduce your solution.
        ///
        /// * Customer has shown interest in solution: After initial discussions, the customer is interested in your solution.
        ///
        /// * Conducted POC/demo: You conducted a proof of concept (POC) or demonstration of the solution for the customer.
        ///
        /// * In evaluation/planning stage: The customer is evaluating the solution and planning potential implementation.
        ///
        /// * Agreed on solution to Business Problem: Both parties agree on how the solution addresses the customer's business problem.
        ///
        /// * Completed Action Plan: A detailed action plan is complete and outlines the steps for implementation.
        ///
        /// * Finalized Deployment Need: Both parties agree with and finalized the deployment needs.
        ///
        /// * SOW Signed: Both parties signed a statement of work (SOW), and formalize the agreement and detail the project scope and deliverables.
        public var salesActivities: [PartnerCentralSellingClientTypes.SalesActivity]?
        /// Specifies the Opportunity's title or name.
        public var title: Swift.String?

        public init(
            additionalComments: Swift.String? = nil,
            apnPrograms: [Swift.String]? = nil,
            awsPartition: PartnerCentralSellingClientTypes.AwsPartition? = nil,
            competitorName: PartnerCentralSellingClientTypes.CompetitorName? = nil,
            customerBusinessProblem: Swift.String? = nil,
            customerUseCase: Swift.String? = nil,
            deliveryModels: [PartnerCentralSellingClientTypes.DeliveryModel]? = nil,
            expectedCustomerSpend: [PartnerCentralSellingClientTypes.ExpectedCustomerSpend]? = nil,
            otherCompetitorNames: Swift.String? = nil,
            otherSolutionDescription: Swift.String? = nil,
            relatedOpportunityIdentifier: Swift.String? = nil,
            salesActivities: [PartnerCentralSellingClientTypes.SalesActivity]? = nil,
            title: Swift.String? = nil
        ) {
            self.additionalComments = additionalComments
            self.apnPrograms = apnPrograms
            self.awsPartition = awsPartition
            self.competitorName = competitorName
            self.customerBusinessProblem = customerBusinessProblem
            self.customerUseCase = customerUseCase
            self.deliveryModels = deliveryModels
            self.expectedCustomerSpend = expectedCustomerSpend
            self.otherCompetitorNames = otherCompetitorNames
            self.otherSolutionDescription = otherSolutionDescription
            self.relatedOpportunityIdentifier = relatedOpportunityIdentifier
            self.salesActivities = salesActivities
            self.title = title
        }
    }
}

extension PartnerCentralSellingClientTypes.Project: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Project(additionalComments: \(Swift.String(describing: additionalComments)), apnPrograms: \(Swift.String(describing: apnPrograms)), awsPartition: \(Swift.String(describing: awsPartition)), competitorName: \(Swift.String(describing: competitorName)), customerUseCase: \(Swift.String(describing: customerUseCase)), deliveryModels: \(Swift.String(describing: deliveryModels)), expectedCustomerSpend: \(Swift.String(describing: expectedCustomerSpend)), otherCompetitorNames: \(Swift.String(describing: otherCompetitorNames)), relatedOpportunityIdentifier: \(Swift.String(describing: relatedOpportunityIdentifier)), salesActivities: \(Swift.String(describing: salesActivities)), customerBusinessProblem: \"CONTENT_REDACTED\", otherSolutionDescription: \"CONTENT_REDACTED\", title: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    public enum RevenueModel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contract
        case payAsYouGo
        case subscription
        case sdkUnknown(Swift.String)

        public static var allCases: [RevenueModel] {
            return [
                .contract,
                .payAsYouGo,
                .subscription
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contract: return "Contract"
            case .payAsYouGo: return "Pay-as-you-go"
            case .subscription: return "Subscription"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Specifies payments details.
    public struct MonetaryValue: Swift.Sendable {
        /// Specifies the payment amount.
        /// This member is required.
        public var amount: Swift.String?
        /// Specifies the payment currency.
        /// This member is required.
        public var currencyCode: PartnerCentralSellingClientTypes.CurrencyCode?

        public init(
            amount: Swift.String? = nil,
            currencyCode: PartnerCentralSellingClientTypes.CurrencyCode? = nil
        ) {
            self.amount = amount
            self.currencyCode = currencyCode
        }
    }
}

extension PartnerCentralSellingClientTypes.MonetaryValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MonetaryValue(amount: \(Swift.String(describing: amount)), currencyCode: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// Specifies a customer's procurement terms details. Required only for partners in eligible programs.
    public struct SoftwareRevenue: Swift.Sendable {
        /// Specifies the customer's intended payment type agreement or procurement method to acquire the solution or service outlined in the Opportunity.
        public var deliveryModel: PartnerCentralSellingClientTypes.RevenueModel?
        /// Specifies the Opportunity's customer engagement start date for the contract's effectiveness.
        public var effectiveDate: Swift.String?
        /// Specifies the expiration date for the contract between the customer and Amazon Web Services partner. It signifies the termination date of the agreed-upon engagement period between both parties.
        public var expirationDate: Swift.String?
        /// Specifies the payment value (amount and currency).
        public var value: PartnerCentralSellingClientTypes.MonetaryValue?

        public init(
            deliveryModel: PartnerCentralSellingClientTypes.RevenueModel? = nil,
            effectiveDate: Swift.String? = nil,
            expirationDate: Swift.String? = nil,
            value: PartnerCentralSellingClientTypes.MonetaryValue? = nil
        ) {
            self.deliveryModel = deliveryModel
            self.effectiveDate = effectiveDate
            self.expirationDate = expirationDate
            self.value = value
        }
    }
}

public struct CreateOpportunityInput: Swift.Sendable {
    /// Specifies the catalog associated with the request. This field takes a string value from a predefined list: AWS or Sandbox. The catalog determines which environment the opportunity is created in. Use AWS to create opportunities in the Amazon Web Services catalog, and Sandbox for testing in secure, isolated environments.
    /// This member is required.
    public var catalog: Swift.String?
    /// Required to be unique, and should be unchanging, it can be randomly generated or a meaningful string. Default: None Best practice: To help ensure uniqueness and avoid conflicts, use a Universally Unique Identifier (UUID) as the ClientToken. You can use standard libraries from most programming languages to generate this. If you use the same client token, the API returns the following error: "Conflicting client token submitted for a new request body."
    /// This member is required.
    public var clientToken: Swift.String?
    /// Specifies customer details associated with the Opportunity.
    public var customer: PartnerCentralSellingClientTypes.Customer?
    /// An object that contains lifecycle details for the Opportunity.
    public var lifeCycle: PartnerCentralSellingClientTypes.LifeCycle?
    /// This object contains marketing details and is optional for an opportunity.
    public var marketing: PartnerCentralSellingClientTypes.Marketing?
    /// Indicates whether the Opportunity pertains to a national security project. This field must be set to true only when the customer's industry is Government. Additional privacy and security measures apply during the review and management process for opportunities marked as NationalSecurity.
    public var nationalSecurity: PartnerCentralSellingClientTypes.NationalSecurity?
    /// Represents the internal team handling the opportunity. Specify collaborating members of this opportunity who are within the partner's organization.
    public var opportunityTeam: [PartnerCentralSellingClientTypes.Contact]?
    /// Specifies the opportunity type as a renewal, new, or expansion. Opportunity types:
    ///
    /// * New opportunity: Represents a new business opportunity with a potential customer that's not previously engaged with your solutions or services.
    ///
    /// * Renewal opportunity: Represents an opportunity to renew an existing contract or subscription with a current customer, ensuring continuity of service.
    ///
    /// * Expansion opportunity: Represents an opportunity to expand the scope of an existing contract or subscription, either by adding new services or increasing the volume of existing services for a current customer.
    public var opportunityType: PartnerCentralSellingClientTypes.OpportunityType?
    /// Specifies the origin of the opportunity, indicating if it was sourced from Amazon Web Services or the partner. For all opportunities created with Catalog: AWS, this field must only be Partner Referral. However, when using Catalog: Sandbox, you can set this field to AWS Referral to simulate Amazon Web Services referral creation. This allows Amazon Web Services-originated flows testing in the sandbox catalog.
    public var origin: PartnerCentralSellingClientTypes.OpportunityOrigin?
    /// Specifies the opportunity's unique identifier in the partner's CRM system. This value is essential to track and reconcile because it's included in the outbound payload to the partner. This field allows partners to link an opportunity to their CRM, which helps to ensure seamless integration and accurate synchronization between the Partner Central API and the partner's internal systems.
    public var partnerOpportunityIdentifier: Swift.String?
    /// Identifies the type of support the partner needs from Amazon Web Services. Valid values:
    ///
    /// * Cosell—Architectural Validation: Confirmation from Amazon Web Services that the partner's proposed solution architecture is aligned with Amazon Web Services best practices and poses minimal architectural risks.
    ///
    /// * Cosell—Business Presentation: Request Amazon Web Services seller's participation in a joint customer presentation.
    ///
    /// * Cosell—Competitive Information: Access to Amazon Web Services competitive resources and support for the partner's proposed solution.
    ///
    /// * Cosell—Pricing Assistance: Connect with an Amazon Web Services seller for support situations where a partner may be receiving an upfront discount on a service (for example: EDP deals).
    ///
    /// * Cosell—Technical Consultation: Connect with an Amazon Web Services Solutions Architect to address the partner's questions about the proposed solution.
    ///
    /// * Cosell—Total Cost of Ownership Evaluation: Assistance with quoting different cost savings of proposed solutions on Amazon Web Services versus on-premises or a traditional hosting environment.
    ///
    /// * Cosell—Deal Support: Request Amazon Web Services seller's support to progress the opportunity (for example: joint customer call, strategic positioning).
    ///
    /// * Cosell—Support for Public Tender/RFx: Opportunity related to the public sector where the partner needs Amazon Web Services RFx support.
    public var primaryNeedsFromAws: [PartnerCentralSellingClientTypes.PrimaryNeedFromAws]?
    /// An object that contains project details for the Opportunity.
    public var project: PartnerCentralSellingClientTypes.Project?
    /// Specifies details of a customer's procurement terms. This is required only for partners in eligible programs.
    public var softwareRevenue: PartnerCentralSellingClientTypes.SoftwareRevenue?
    /// A map of the key-value pairs of the tag or tags to assign.
    public var tags: [PartnerCentralSellingClientTypes.Tag]?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        customer: PartnerCentralSellingClientTypes.Customer? = nil,
        lifeCycle: PartnerCentralSellingClientTypes.LifeCycle? = nil,
        marketing: PartnerCentralSellingClientTypes.Marketing? = nil,
        nationalSecurity: PartnerCentralSellingClientTypes.NationalSecurity? = nil,
        opportunityTeam: [PartnerCentralSellingClientTypes.Contact]? = nil,
        opportunityType: PartnerCentralSellingClientTypes.OpportunityType? = nil,
        origin: PartnerCentralSellingClientTypes.OpportunityOrigin? = nil,
        partnerOpportunityIdentifier: Swift.String? = nil,
        primaryNeedsFromAws: [PartnerCentralSellingClientTypes.PrimaryNeedFromAws]? = nil,
        project: PartnerCentralSellingClientTypes.Project? = nil,
        softwareRevenue: PartnerCentralSellingClientTypes.SoftwareRevenue? = nil,
        tags: [PartnerCentralSellingClientTypes.Tag]? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.customer = customer
        self.lifeCycle = lifeCycle
        self.marketing = marketing
        self.nationalSecurity = nationalSecurity
        self.opportunityTeam = opportunityTeam
        self.opportunityType = opportunityType
        self.origin = origin
        self.partnerOpportunityIdentifier = partnerOpportunityIdentifier
        self.primaryNeedsFromAws = primaryNeedsFromAws
        self.project = project
        self.softwareRevenue = softwareRevenue
        self.tags = tags
    }
}

public struct CreateOpportunityOutput: Swift.Sendable {
    /// Read-only, system-generated Opportunity unique identifier. Amazon Web Services creates this identifier, and it's used for all subsequent opportunity actions, such as updates, associations, and submissions. It helps to ensure that each opportunity is accurately tracked and managed.
    /// This member is required.
    public var id: Swift.String?
    /// DateTime when the opportunity was last modified. When the Opportunity is created, its value is CreatedDate.
    public var lastModifiedDate: Foundation.Date?
    /// Specifies the opportunity's unique identifier in the partner's CRM system. This value is essential to track and reconcile because it's included in the outbound payload sent back to the partner.
    public var partnerOpportunityIdentifier: Swift.String?

    public init(
        id: Swift.String? = nil,
        lastModifiedDate: Foundation.Date? = nil,
        partnerOpportunityIdentifier: Swift.String? = nil
    ) {
        self.id = id
        self.lastModifiedDate = lastModifiedDate
        self.partnerOpportunityIdentifier = partnerOpportunityIdentifier
    }
}

public struct DisassociateOpportunityInput: Swift.Sendable {
    /// Specifies the catalog associated with the request. This field takes a string value from a predefined list: AWS or Sandbox. The catalog determines which environment the opportunity disassociation is made in. Use AWS to disassociate opportunities in the Amazon Web Services catalog, and Sandbox for testing in secure, isolated environments.
    /// This member is required.
    public var catalog: Swift.String?
    /// The opportunity's unique identifier for when you want to disassociate it from related entities. This identifier helps to ensure that the correct opportunity is updated. Validation: Ensure that the provided identifier corresponds to an existing opportunity in the Amazon Web Services system because incorrect identifiers result in an error and no changes are made.
    /// This member is required.
    public var opportunityIdentifier: Swift.String?
    /// The related entity's identifier that you want to disassociate from the opportunity. Depending on the type of entity, this could be a simple identifier or an Amazon Resource Name (ARN) for entities managed through Amazon Web Services Marketplace. For Amazon Web Services Marketplace entities, use the Amazon Web Services Marketplace API to obtain the necessary ARNs. For guidance on retrieving these ARNs, see [ Amazon Web Services MarketplaceUsing the Amazon Web Services Marketplace Catalog API](https://docs.aws.amazon.com/marketplace-catalog/latest/api-reference/welcome.html). Validation: Ensure the identifier or ARN is valid and corresponds to an existing entity. An incorrect or invalid identifier results in an error.
    /// This member is required.
    public var relatedEntityIdentifier: Swift.String?
    /// The type of the entity that you're disassociating from the opportunity. When you specify the entity type, it helps the system correctly process the disassociation request to ensure that the right connections are removed. Examples of entity types include Partner Solution, Amazon Web Services product, and Amazon Web Services Marketplaceoffer. Ensure that the value matches one of the expected entity types. Validation: Provide a valid entity type to help ensure successful disassociation. An invalid or incorrect entity type results in an error.
    /// This member is required.
    public var relatedEntityType: PartnerCentralSellingClientTypes.RelatedEntityType?

    public init(
        catalog: Swift.String? = nil,
        opportunityIdentifier: Swift.String? = nil,
        relatedEntityIdentifier: Swift.String? = nil,
        relatedEntityType: PartnerCentralSellingClientTypes.RelatedEntityType? = nil
    ) {
        self.catalog = catalog
        self.opportunityIdentifier = opportunityIdentifier
        self.relatedEntityIdentifier = relatedEntityIdentifier
        self.relatedEntityType = relatedEntityType
    }
}

public struct GetAwsOpportunitySummaryInput: Swift.Sendable {
    /// Specifies the catalog in which the AWS Opportunity is located. Accepted values include AWS for production opportunities or Sandbox for testing purposes. The catalog determines which environment the opportunity data is pulled from.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier for the related partner opportunity. Use this field to correlate an AWS opportunity with its corresponding partner opportunity.
    /// This member is required.
    public var relatedOpportunityIdentifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        relatedOpportunityIdentifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.relatedOpportunityIdentifier = relatedOpportunityIdentifier
    }
}

public struct GetAwsOpportunitySummaryOutput: Swift.Sendable {
    /// Specifies the catalog in which the AWS Opportunity exists. This is the environment (e.g., AWS or Sandbox) where the opportunity is being managed.
    /// This member is required.
    public var catalog: Swift.String?
    /// Provides details about the customer associated with the AWS Opportunity, including account information, industry, and other customer data. These details help partners understand the business context of the opportunity.
    public var customer: PartnerCentralSellingClientTypes.AwsOpportunityCustomer?
    /// Provides insights into the AWS Opportunity, including engagement score and recommended actions that AWS suggests for the partner.
    public var insights: PartnerCentralSellingClientTypes.AwsOpportunityInsights?
    /// Specifies the type of involvement AWS has in the opportunity, such as direct cosell or advisory support. This field helps partners understand the role AWS plays in advancing the opportunity.
    public var involvementType: PartnerCentralSellingClientTypes.SalesInvolvementType?
    /// Provides a reason for any changes in the involvement type of AWS in the opportunity. This field is used to track why the level of AWS engagement has changed from For Visibility Only to Co-sell offering transparency into the partnership dynamics.
    public var involvementTypeChangeReason: PartnerCentralSellingClientTypes.InvolvementTypeChangeReason?
    /// Contains lifecycle information for the AWS Opportunity, including review status, stage, and target close date. This field is crucial for partners to monitor the progression of the opportunity.
    public var lifeCycle: PartnerCentralSellingClientTypes.AwsOpportunityLifeCycle?
    /// Details the AWS opportunity team, including members involved. This information helps partners know who from AWS is engaged and what their role is.
    public var opportunityTeam: [PartnerCentralSellingClientTypes.AwsTeamMember]?
    /// Specifies whether the AWS Opportunity originated from AWS or the partner. This helps distinguish between opportunities that were sourced by AWS and those referred by the partner.
    public var origin: PartnerCentralSellingClientTypes.OpportunityOrigin?
    /// Provides details about the project associated with the AWS Opportunity, including the customer’s business problem, expected outcomes, and project scope. This information is crucial for understanding the broader context of the opportunity.
    public var project: PartnerCentralSellingClientTypes.AwsOpportunityProject?
    /// Lists related entity identifiers, such as AWS products or partner solutions, associated with the AWS Opportunity. These identifiers provide additional context and help partners understand which AWS services are involved.
    public var relatedEntityIds: PartnerCentralSellingClientTypes.AwsOpportunityRelatedEntities?
    /// Provides the unique identifier of the related partner opportunity, allowing partners to link the AWS Opportunity to their corresponding opportunity in their CRM system.
    public var relatedOpportunityId: Swift.String?
    /// Defines the visibility level for the AWS Opportunity. Use Full visibility for most cases, while Limited visibility is reserved for special programs or sensitive opportunities.
    public var visibility: PartnerCentralSellingClientTypes.Visibility?

    public init(
        catalog: Swift.String? = nil,
        customer: PartnerCentralSellingClientTypes.AwsOpportunityCustomer? = nil,
        insights: PartnerCentralSellingClientTypes.AwsOpportunityInsights? = nil,
        involvementType: PartnerCentralSellingClientTypes.SalesInvolvementType? = nil,
        involvementTypeChangeReason: PartnerCentralSellingClientTypes.InvolvementTypeChangeReason? = nil,
        lifeCycle: PartnerCentralSellingClientTypes.AwsOpportunityLifeCycle? = nil,
        opportunityTeam: [PartnerCentralSellingClientTypes.AwsTeamMember]? = nil,
        origin: PartnerCentralSellingClientTypes.OpportunityOrigin? = nil,
        project: PartnerCentralSellingClientTypes.AwsOpportunityProject? = nil,
        relatedEntityIds: PartnerCentralSellingClientTypes.AwsOpportunityRelatedEntities? = nil,
        relatedOpportunityId: Swift.String? = nil,
        visibility: PartnerCentralSellingClientTypes.Visibility? = nil
    ) {
        self.catalog = catalog
        self.customer = customer
        self.insights = insights
        self.involvementType = involvementType
        self.involvementTypeChangeReason = involvementTypeChangeReason
        self.lifeCycle = lifeCycle
        self.opportunityTeam = opportunityTeam
        self.origin = origin
        self.project = project
        self.relatedEntityIds = relatedEntityIds
        self.relatedOpportunityId = relatedOpportunityId
        self.visibility = visibility
    }
}

public struct GetOpportunityInput: Swift.Sendable {
    /// Specifies the catalog associated with the request. This field takes a string value from a predefined list: AWS or Sandbox. The catalog determines which environment the opportunity is fetched from. Use AWS to retrieve opportunities in the Amazon Web Services catalog, and Sandbox to retrieve opportunities in a secure, isolated testing environment.
    /// This member is required.
    public var catalog: Swift.String?
    /// Read-only, system generated Opportunity unique identifier.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
    }
}

extension PartnerCentralSellingClientTypes {

    /// This field provides the associations' information for other entities with the opportunity. These entities include identifiers for AWSProducts, Partner Solutions, and AWSMarketplaceOffers.
    public struct RelatedEntityIdentifiers: Swift.Sendable {
        /// Enables the association of AWS Marketplace offer sets with the Opportunity. Offer sets allow grouping multiple related marketplace offers together for comprehensive solution packaging. Each value is an Amazon Resource Name (ARN) in this format: arn:aws:aws-marketplace:us-east-1:999999999999:AWSMarketplace/OfferSet/offerset-sampleOfferSet32.
        public var awsMarketplaceOfferSets: [Swift.String]?
        /// Takes one value per opportunity. Each value is an Amazon Resource Name (ARN), in this format: "offers": ["arn:aws:aws-marketplace:us-east-1:999999999999:AWSMarketplace/Offer/offer-sampleOffer32"]. Use the [ListEntities](https://docs.aws.amazon.com/marketplace-catalog/latest/api-reference/API_ListEntities.html) action in the Marketplace Catalog APIs for a list of offers in the associated Marketplace seller account.
        public var awsMarketplaceOffers: [Swift.String]?
        /// Enables the association of specific Amazon Web Services products with the Opportunity. Partners can indicate the relevant Amazon Web Services products for the Opportunity's solution and align with the customer's needs. Returns multiple values separated by commas. For example, "AWSProducts" : ["AmazonRedshift", "AWSAppFabric", "AWSCleanRooms"]. Use the file with the list of Amazon Web Services products hosted on GitHub: [ Amazon Web Services products](https://github.com/aws-samples/partner-crm-integration-samples/blob/main/resources/aws_products.json).
        public var awsProducts: [Swift.String]?
        /// Enables partner solutions or offerings' association with an opportunity. To associate a solution, provide the solution's unique identifier, which you can obtain with the ListSolutions operation. If the specific solution identifier is not available, you can use the value Other and provide details about the solution in the otherSolutionOffered field. But when the opportunity reaches the Committed stage or beyond, the Other value cannot be used, and a valid solution identifier must be provided. By associating the relevant solutions with the opportunity, you can communicate the offerings that are being considered or implemented to address the customer's business problem.
        public var solutions: [Swift.String]?

        public init(
            awsMarketplaceOfferSets: [Swift.String]? = nil,
            awsMarketplaceOffers: [Swift.String]? = nil,
            awsProducts: [Swift.String]? = nil,
            solutions: [Swift.String]? = nil
        ) {
            self.awsMarketplaceOfferSets = awsMarketplaceOfferSets
            self.awsMarketplaceOffers = awsMarketplaceOffers
            self.awsProducts = awsProducts
            self.solutions = solutions
        }
    }
}

public struct GetOpportunityOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the opportunity.
    public var arn: Swift.String?
    /// Specifies the catalog associated with the request. This field takes a string value from a predefined list: AWS or Sandbox. The catalog determines which environment the opportunity information is retrieved from. Use AWS to retrieve opportunities in the Amazon Web Services catalog, and Sandbox to retrieve opportunities in a secure and isolated testing environment.
    /// This member is required.
    public var catalog: Swift.String?
    /// DateTime when the Opportunity was last created.
    /// This member is required.
    public var createdDate: Foundation.Date?
    /// Specifies details of the customer associated with the Opportunity.
    public var customer: PartnerCentralSellingClientTypes.Customer?
    /// Read-only, system generated Opportunity unique identifier.
    /// This member is required.
    public var id: Swift.String?
    /// DateTime when the opportunity was last modified.
    /// This member is required.
    public var lastModifiedDate: Foundation.Date?
    /// An object that contains lifecycle details for the Opportunity.
    public var lifeCycle: PartnerCentralSellingClientTypes.LifeCycle?
    /// An object that contains marketing details for the Opportunity.
    public var marketing: PartnerCentralSellingClientTypes.Marketing?
    /// Indicates whether the Opportunity pertains to a national security project. This field must be set to true only when the customer's industry is Government. Additional privacy and security measures apply during the review and management process for opportunities marked as NationalSecurity.
    public var nationalSecurity: PartnerCentralSellingClientTypes.NationalSecurity?
    /// Represents the internal team handling the opportunity. Specify the members involved in collaborating on this opportunity within the partner's organization.
    public var opportunityTeam: [PartnerCentralSellingClientTypes.Contact]?
    /// Specifies the opportunity type as renewal, new, or expansion. Opportunity types:
    ///
    /// * New opportunity: Represents a new business opportunity with a potential customer that's not previously engaged with your solutions or services.
    ///
    /// * Renewal opportunity: Represents an opportunity to renew an existing contract or subscription with a current customer, which helps to ensure service continuity.
    ///
    /// * Expansion opportunity: Represents an opportunity to expand the scope of a customer's contract or subscription, either by adding new services or increasing the volume of existing services.
    public var opportunityType: PartnerCentralSellingClientTypes.OpportunityType?
    /// Specifies the opportunity's unique identifier in the partner's CRM system. This value is essential to track and reconcile because it's included in the outbound payload sent back to the partner.
    public var partnerOpportunityIdentifier: Swift.String?
    /// Identifies the type of support the partner needs from Amazon Web Services. Valid values:
    ///
    /// * Cosell—Architectural Validation: Confirmation from Amazon Web Services that the partner's proposed solution architecture is aligned with Amazon Web Services best practices and poses minimal architectural risks.
    ///
    /// * Cosell—Business Presentation: Request Amazon Web Services seller's participation in a joint customer presentation.
    ///
    /// * Cosell—Competitive Information: Access to Amazon Web Services competitive resources and support for the partner's proposed solution.
    ///
    /// * Cosell—Pricing Assistance: Connect with an Amazon Web Services seller for support situations where a partner may be receiving an upfront discount on a service (for example: EDP deals).
    ///
    /// * Cosell—Technical Consultation: Connect with an Amazon Web Services Solutions Architect to address the partner's questions about the proposed solution.
    ///
    /// * Cosell—Total Cost of Ownership Evaluation: Assistance with quoting different cost savings of proposed solutions on Amazon Web Services versus on-premises or a traditional hosting environment.
    ///
    /// * Cosell—Deal Support: Request Amazon Web Services seller's support to progress the opportunity (for example: joint customer call, strategic positioning).
    ///
    /// * Cosell—Support for Public Tender/RFx: Opportunity related to the public sector where the partner needs Amazon Web Services RFx support.
    public var primaryNeedsFromAws: [PartnerCentralSellingClientTypes.PrimaryNeedFromAws]?
    /// An object that contains project details summary for the Opportunity.
    public var project: PartnerCentralSellingClientTypes.Project?
    /// Provides information about the associations of other entities with the opportunity. These entities include identifiers for AWSProducts, Partner Solutions, and AWSMarketplaceOffers.
    /// This member is required.
    public var relatedEntityIdentifiers: PartnerCentralSellingClientTypes.RelatedEntityIdentifiers?
    /// Specifies details of a customer's procurement terms. Required only for partners in eligible programs.
    public var softwareRevenue: PartnerCentralSellingClientTypes.SoftwareRevenue?

    public init(
        arn: Swift.String? = nil,
        catalog: Swift.String? = nil,
        createdDate: Foundation.Date? = nil,
        customer: PartnerCentralSellingClientTypes.Customer? = nil,
        id: Swift.String? = nil,
        lastModifiedDate: Foundation.Date? = nil,
        lifeCycle: PartnerCentralSellingClientTypes.LifeCycle? = nil,
        marketing: PartnerCentralSellingClientTypes.Marketing? = nil,
        nationalSecurity: PartnerCentralSellingClientTypes.NationalSecurity? = nil,
        opportunityTeam: [PartnerCentralSellingClientTypes.Contact]? = nil,
        opportunityType: PartnerCentralSellingClientTypes.OpportunityType? = nil,
        partnerOpportunityIdentifier: Swift.String? = nil,
        primaryNeedsFromAws: [PartnerCentralSellingClientTypes.PrimaryNeedFromAws]? = nil,
        project: PartnerCentralSellingClientTypes.Project? = nil,
        relatedEntityIdentifiers: PartnerCentralSellingClientTypes.RelatedEntityIdentifiers? = nil,
        softwareRevenue: PartnerCentralSellingClientTypes.SoftwareRevenue? = nil
    ) {
        self.arn = arn
        self.catalog = catalog
        self.createdDate = createdDate
        self.customer = customer
        self.id = id
        self.lastModifiedDate = lastModifiedDate
        self.lifeCycle = lifeCycle
        self.marketing = marketing
        self.nationalSecurity = nationalSecurity
        self.opportunityTeam = opportunityTeam
        self.opportunityType = opportunityType
        self.partnerOpportunityIdentifier = partnerOpportunityIdentifier
        self.primaryNeedsFromAws = primaryNeedsFromAws
        self.project = project
        self.relatedEntityIdentifiers = relatedEntityIdentifiers
        self.softwareRevenue = softwareRevenue
    }
}

extension PartnerCentralSellingClientTypes {

    /// Filter for opportunities based on creation date range.
    public struct CreatedDateFilter: Swift.Sendable {
        /// Filter opportunities created after this date.
        public var afterCreatedDate: Foundation.Date?
        /// Filter opportunities created before this date.
        public var beforeCreatedDate: Foundation.Date?

        public init(
            afterCreatedDate: Foundation.Date? = nil,
            beforeCreatedDate: Foundation.Date? = nil
        ) {
            self.afterCreatedDate = afterCreatedDate
            self.beforeCreatedDate = beforeCreatedDate
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Defines a filter to retrieve opportunities based on the last modified date. This filter is useful for tracking changes or updates to opportunities over time.
    public struct LastModifiedDate: Swift.Sendable {
        /// Specifies the date after which the opportunities were modified. Use this filter to retrieve only those opportunities that were modified after a given timestamp.
        public var afterLastModifiedDate: Foundation.Date?
        /// Specifies the date before which the opportunities were modified. Use this filter to retrieve only those opportunities that were modified before a given timestamp.
        public var beforeLastModifiedDate: Foundation.Date?

        public init(
            afterLastModifiedDate: Foundation.Date? = nil,
            beforeLastModifiedDate: Foundation.Date? = nil
        ) {
            self.afterLastModifiedDate = afterLastModifiedDate
            self.beforeLastModifiedDate = beforeLastModifiedDate
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum OpportunitySortName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createdDate
        case customerCompanyName
        case identifier
        case lastModifieddate
        case sdkUnknown(Swift.String)

        public static var allCases: [OpportunitySortName] {
            return [
                .createdDate,
                .customerCompanyName,
                .identifier,
                .lastModifieddate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createdDate: return "CreatedDate"
            case .customerCompanyName: return "CustomerCompanyName"
            case .identifier: return "Identifier"
            case .lastModifieddate: return "LastModifiedDate"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Object that configures response sorting.
    public struct OpportunitySort: Swift.Sendable {
        /// Field name to sort by.
        /// This member is required.
        public var sortBy: PartnerCentralSellingClientTypes.OpportunitySortName?
        /// Sort order. Default: Descending
        /// This member is required.
        public var sortOrder: PartnerCentralSellingClientTypes.SortOrder?

        public init(
            sortBy: PartnerCentralSellingClientTypes.OpportunitySortName? = nil,
            sortOrder: PartnerCentralSellingClientTypes.SortOrder? = nil
        ) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }
}

public struct ListOpportunitiesInput: Swift.Sendable {
    /// Specifies the catalog associated with the request. This field takes a string value from a predefined list: AWS or Sandbox. The catalog determines which environment the opportunities are listed in. Use AWS for listing real opportunities in the Amazon Web Services catalog, and Sandbox for testing in secure, isolated environments.
    /// This member is required.
    public var catalog: Swift.String?
    /// Filter opportunities by creation date criteria.
    public var createdDate: PartnerCentralSellingClientTypes.CreatedDateFilter?
    /// Filters the opportunities based on the customer's company name. This allows partners to search for opportunities associated with a specific customer by matching the provided company name string.
    public var customerCompanyName: [Swift.String]?
    /// Filters the opportunities based on the opportunity identifier. This allows partners to retrieve specific opportunities by providing their unique identifiers, ensuring precise results.
    public var identifier: [Swift.String]?
    /// Filters the opportunities based on their last modified date. This filter helps retrieve opportunities that were updated after the specified date, allowing partners to track recent changes or updates.
    public var lastModifiedDate: PartnerCentralSellingClientTypes.LastModifiedDate?
    /// Filters the opportunities based on their current lifecycle approval status. Use this filter to retrieve opportunities with statuses such as Pending Submission, In Review, Action Required, or Approved.
    public var lifeCycleReviewStatus: [PartnerCentralSellingClientTypes.ReviewStatus]?
    /// Filters the opportunities based on their lifecycle stage. This filter allows partners to retrieve opportunities at various stages in the sales cycle, such as Qualified, Technical Validation, Business Validation, or Closed Won.
    public var lifeCycleStage: [PartnerCentralSellingClientTypes.Stage]?
    /// Specifies the maximum number of results to return in a single call. This limits the number of opportunities returned in the response to avoid providing too many results at once. Default: 20
    public var maxResults: Swift.Int?
    /// A pagination token used to retrieve the next set of results in subsequent calls. This token is included in the response only if there are additional result pages available.
    public var nextToken: Swift.String?
    /// An object that specifies how the response is sorted. The default Sort.SortBy value is LastModifiedDate.
    public var sort: PartnerCentralSellingClientTypes.OpportunitySort?

    public init(
        catalog: Swift.String? = nil,
        createdDate: PartnerCentralSellingClientTypes.CreatedDateFilter? = nil,
        customerCompanyName: [Swift.String]? = nil,
        identifier: [Swift.String]? = nil,
        lastModifiedDate: PartnerCentralSellingClientTypes.LastModifiedDate? = nil,
        lifeCycleReviewStatus: [PartnerCentralSellingClientTypes.ReviewStatus]? = nil,
        lifeCycleStage: [PartnerCentralSellingClientTypes.Stage]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sort: PartnerCentralSellingClientTypes.OpportunitySort? = nil
    ) {
        self.catalog = catalog
        self.createdDate = createdDate
        self.customerCompanyName = customerCompanyName
        self.identifier = identifier
        self.lastModifiedDate = lastModifiedDate
        self.lifeCycleReviewStatus = lifeCycleReviewStatus
        self.lifeCycleStage = lifeCycleStage
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
    }
}

extension PartnerCentralSellingClientTypes {

    /// An object that contains a Customer object's subset of fields.
    public struct CustomerSummary: Swift.Sendable {
        /// An object that contains a customer's account details.
        public var account: PartnerCentralSellingClientTypes.AccountSummary?

        public init(
            account: PartnerCentralSellingClientTypes.AccountSummary? = nil
        ) {
            self.account = account
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// An object that contains a LifeCycle object's subset of fields.
    public struct LifeCycleSummary: Swift.Sendable {
        /// Specifies the reason code when an opportunity is marked as Closed Lost. When you select an appropriate reason code, you communicate the context for closing the Opportunity, and aid in accurate reports and analysis of opportunity outcomes.
        public var closedLostReason: PartnerCentralSellingClientTypes.ClosedLostReason?
        /// Specifies the upcoming actions or tasks for the Opportunity. This field is utilized to communicate to Amazon Web Services the next actions required for the Opportunity.
        public var nextSteps: Swift.String?
        /// Indicates why an opportunity was sent back for further details. Partners must take corrective action based on the ReviewComments.
        public var reviewComments: Swift.String?
        /// Indicates the review status of a partner referred opportunity. This field is read-only and only applicable for partner referrals. Valid values:
        ///
        /// * Pending Submission: Not submitted for validation (editable).
        ///
        /// * Submitted: Submitted for validation and not yet Amazon Web Services reviewed (read-only).
        ///
        /// * In Review: Undergoing Amazon Web Services validation (read-only).
        ///
        /// * Action Required: Address any issues Amazon Web Services highlights. Use the UpdateOpportunity API action to update the opportunity, and ensure you make all required changes. Only these fields are editable when the Lifecycle.ReviewStatus is Action Required:
        ///
        /// * Customer.Account.Address.City
        ///
        /// * Customer.Account.Address.CountryCode
        ///
        /// * Customer.Account.Address.PostalCode
        ///
        /// * Customer.Account.Address.StateOrRegion
        ///
        /// * Customer.Account.Address.StreetAddress
        ///
        /// * Customer.Account.WebsiteUrl
        ///
        /// * LifeCycle.TargetCloseDate
        ///
        /// * Project.ExpectedCustomerSpend.Amount
        ///
        /// * Project.ExpectedCustomerSpend.CurrencyCode
        ///
        /// * Project.CustomerBusinessProblem
        ///
        /// * PartnerOpportunityIdentifier
        ///
        ///
        /// After updates, the opportunity re-enters the validation phase. This process repeats until all issues are resolved, and the opportunity's Lifecycle.ReviewStatus is set to Approved or Rejected.
        ///
        /// * Approved: Validated and converted into the Amazon Web Services seller's pipeline (editable).
        ///
        /// * Rejected: Disqualified (read-only).
        public var reviewStatus: PartnerCentralSellingClientTypes.ReviewStatus?
        /// Indicates the reason a specific decision was taken during the opportunity review process. This field combines the reasons for both disqualified and action required statuses, and provides clarity for why an opportunity was disqualified or required further action.
        public var reviewStatusReason: Swift.String?
        /// Specifies the current stage of the Opportunity's lifecycle as it maps to Amazon Web Services stages from the current stage in the partner CRM. This field provides a translated value of the stage, and offers insight into the Opportunity's progression in the sales cycle, according to Amazon Web Services definitions. A lead and a prospect must be further matured to a Qualified opportunity before submission. Opportunities that were closed/lost before submission aren't suitable for submission. The descriptions of each sales stage are:
        ///
        /// * Prospect: Amazon Web Services identifies the opportunity. It can be active (Comes directly from the end customer through a lead) or latent (Your account team believes it exists based on research, account plans, sales plays).
        ///
        /// * Qualified: Your account team engaged with the customer to discuss viability and understand requirements. The customer agreed that the opportunity is real, of interest, and may solve business/technical needs.
        ///
        /// * Technical Validation: All parties understand the implementation plan.
        ///
        /// * Business Validation: Pricing was proposed, and all parties agree to the steps to close.
        ///
        /// * Committed: The customer signed the contract, but Amazon Web Services hasn't started billing.
        ///
        /// * Launched: The workload is complete, and Amazon Web Services has started billing.
        ///
        /// * Closed Lost: The opportunity is lost, and there are no steps to move forward.
        public var stage: PartnerCentralSellingClientTypes.Stage?
        /// Specifies the date when Amazon Web Services expects to start significant billing, when the project finishes, and when it moves into production. This field informs the Amazon Web Services seller about when the opportunity launches and starts to incur Amazon Web Services usage. Ensure the Target Close Date isn't in the past.
        public var targetCloseDate: Swift.String?

        public init(
            closedLostReason: PartnerCentralSellingClientTypes.ClosedLostReason? = nil,
            nextSteps: Swift.String? = nil,
            reviewComments: Swift.String? = nil,
            reviewStatus: PartnerCentralSellingClientTypes.ReviewStatus? = nil,
            reviewStatusReason: Swift.String? = nil,
            stage: PartnerCentralSellingClientTypes.Stage? = nil,
            targetCloseDate: Swift.String? = nil
        ) {
            self.closedLostReason = closedLostReason
            self.nextSteps = nextSteps
            self.reviewComments = reviewComments
            self.reviewStatus = reviewStatus
            self.reviewStatusReason = reviewStatusReason
            self.stage = stage
            self.targetCloseDate = targetCloseDate
        }
    }
}

extension PartnerCentralSellingClientTypes.LifeCycleSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LifeCycleSummary(closedLostReason: \(Swift.String(describing: closedLostReason)), reviewComments: \(Swift.String(describing: reviewComments)), reviewStatus: \(Swift.String(describing: reviewStatus)), reviewStatusReason: \(Swift.String(describing: reviewStatusReason)), stage: \(Swift.String(describing: stage)), targetCloseDate: \(Swift.String(describing: targetCloseDate)), nextSteps: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// An object that contains a Project object's subset of fields.
    public struct ProjectSummary: Swift.Sendable {
        /// Specifies your solution or service's deployment or consumption model in the Opportunity's context. You can select multiple options. Options' descriptions from the Delivery Model field are:
        ///
        /// * SaaS or PaaS: Your Amazon Web Services based solution deployed as SaaS or PaaS in your Amazon Web Services environment.
        ///
        /// * BYOL or AMI: Your Amazon Web Services based solution deployed as BYOL or AMI in the end customer's Amazon Web Services environment.
        ///
        /// * Managed Services: The end customer's Amazon Web Services business management (For example: Consulting, design, implementation, billing support, cost optimization, technical support).
        ///
        /// * Professional Services: Offerings to help enterprise end customers achieve specific business outcomes for enterprise cloud adoption (For example: Advisory or transformation planning).
        ///
        /// * Resell: Amazon Web Services accounts and billing management for your customers.
        ///
        /// * Other: Delivery model not described above.
        public var deliveryModels: [PartnerCentralSellingClientTypes.DeliveryModel]?
        /// Provides a summary of the expected customer spend for the project, offering a high-level view of the potential financial impact.
        public var expectedCustomerSpend: [PartnerCentralSellingClientTypes.ExpectedCustomerSpend]?

        public init(
            deliveryModels: [PartnerCentralSellingClientTypes.DeliveryModel]? = nil,
            expectedCustomerSpend: [PartnerCentralSellingClientTypes.ExpectedCustomerSpend]? = nil
        ) {
            self.deliveryModels = deliveryModels
            self.expectedCustomerSpend = expectedCustomerSpend
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// An object that contains an Opportunity's subset of fields.
    public struct OpportunitySummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) for the opportunity. This globally unique identifier can be used for IAM policies and cross-service references.
        public var arn: Swift.String?
        /// Specifies the catalog associated with the opportunity, either AWS or Sandbox. This indicates the environment in which the opportunity is managed.
        /// This member is required.
        public var catalog: Swift.String?
        /// DateTime when the Opportunity was last created.
        public var createdDate: Foundation.Date?
        /// An object that contains the Opportunity's customer details.
        public var customer: PartnerCentralSellingClientTypes.CustomerSummary?
        /// Read-only, system-generated Opportunity unique identifier.
        public var id: Swift.String?
        /// DateTime when the Opportunity was last modified.
        public var lastModifiedDate: Foundation.Date?
        /// An object that contains the Opportunity's lifecycle details.
        public var lifeCycle: PartnerCentralSellingClientTypes.LifeCycleSummary?
        /// Specifies opportunity type as a renewal, new, or expansion. Opportunity types:
        ///
        /// * New Opportunity: Represents a new business opportunity with a potential customer that's not previously engaged with your solutions or services.
        ///
        /// * Renewal Opportunity: Represents an opportunity to renew an existing contract or subscription with a current customer, ensuring continuity of service.
        ///
        /// * Expansion Opportunity: Represents an opportunity to expand the scope of an existing contract or subscription, either by adding new services or increasing the volume of existing services for a current customer.
        public var opportunityType: PartnerCentralSellingClientTypes.OpportunityType?
        /// Specifies the Opportunity's unique identifier in the partner's CRM system. This value is essential to track and reconcile because it's included in the outbound payload sent back to the partner. It allows partners to link an opportunity to their CRM.
        public var partnerOpportunityIdentifier: Swift.String?
        /// An object that contains the Opportunity's project details summary.
        public var project: PartnerCentralSellingClientTypes.ProjectSummary?

        public init(
            arn: Swift.String? = nil,
            catalog: Swift.String? = nil,
            createdDate: Foundation.Date? = nil,
            customer: PartnerCentralSellingClientTypes.CustomerSummary? = nil,
            id: Swift.String? = nil,
            lastModifiedDate: Foundation.Date? = nil,
            lifeCycle: PartnerCentralSellingClientTypes.LifeCycleSummary? = nil,
            opportunityType: PartnerCentralSellingClientTypes.OpportunityType? = nil,
            partnerOpportunityIdentifier: Swift.String? = nil,
            project: PartnerCentralSellingClientTypes.ProjectSummary? = nil
        ) {
            self.arn = arn
            self.catalog = catalog
            self.createdDate = createdDate
            self.customer = customer
            self.id = id
            self.lastModifiedDate = lastModifiedDate
            self.lifeCycle = lifeCycle
            self.opportunityType = opportunityType
            self.partnerOpportunityIdentifier = partnerOpportunityIdentifier
            self.project = project
        }
    }
}

public struct ListOpportunitiesOutput: Swift.Sendable {
    /// A pagination token used to retrieve the next set of results in subsequent calls. This token is included in the response only if there are additional result pages available.
    public var nextToken: Swift.String?
    /// An array that contains minimal details for opportunities that match the request criteria. This summary view provides a quick overview of relevant opportunities.
    /// This member is required.
    public var opportunitySummaries: [PartnerCentralSellingClientTypes.OpportunitySummary]?

    public init(
        nextToken: Swift.String? = nil,
        opportunitySummaries: [PartnerCentralSellingClientTypes.OpportunitySummary]? = nil
    ) {
        self.nextToken = nextToken
        self.opportunitySummaries = opportunitySummaries
    }
}

public struct SubmitOpportunityInput: Swift.Sendable {
    /// Specifies the catalog related to the request. Valid values are:
    ///
    /// * AWS: Submits the opportunity request from the production AWS environment.
    ///
    /// * Sandbox: Submits the opportunity request from a sandbox environment used for testing or development purposes.
    /// This member is required.
    public var catalog: Swift.String?
    /// The identifier of the Opportunity previously created by partner and needs to be submitted.
    /// This member is required.
    public var identifier: Swift.String?
    /// Specifies the level of AWS sellers' involvement on the opportunity. Valid values:
    ///
    /// * Co-sell: Indicates the user wants to co-sell with AWS. Share the opportunity with AWS to receive deal assistance and support.
    ///
    /// * For Visibility Only: Indicates that the user does not need support from AWS Sales Rep. Share this opportunity with AWS for visibility only, you will not receive deal assistance and support.
    /// This member is required.
    public var involvementType: PartnerCentralSellingClientTypes.SalesInvolvementType?
    /// Determines whether to restrict visibility of the opportunity from AWS sales. Default value is Full. Valid values:
    ///
    /// * Full: The opportunity is fully visible to AWS sales.
    ///
    /// * Limited: The opportunity has restricted visibility to AWS sales.
    public var visibility: PartnerCentralSellingClientTypes.Visibility?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil,
        involvementType: PartnerCentralSellingClientTypes.SalesInvolvementType? = nil,
        visibility: PartnerCentralSellingClientTypes.Visibility? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
        self.involvementType = involvementType
        self.visibility = visibility
    }
}

public struct UpdateOpportunityInput: Swift.Sendable {
    /// Specifies the catalog associated with the request. This field takes a string value from a predefined list: AWS or Sandbox. The catalog determines which environment the opportunity is updated in. Use AWS to update real opportunities in the production environment, and Sandbox for testing in secure, isolated environments. When you use the Sandbox catalog, it allows you to simulate and validate your interactions with Amazon Web Services services without affecting live data or operations.
    /// This member is required.
    public var catalog: Swift.String?
    /// Specifies details of the customer associated with the Opportunity.
    public var customer: PartnerCentralSellingClientTypes.Customer?
    /// Read-only, system generated Opportunity unique identifier.
    /// This member is required.
    public var identifier: Swift.String?
    /// DateTime when the opportunity was last modified.
    /// This member is required.
    public var lastModifiedDate: Foundation.Date?
    /// An object that contains lifecycle details for the Opportunity.
    public var lifeCycle: PartnerCentralSellingClientTypes.LifeCycle?
    /// An object that contains marketing details for the Opportunity.
    public var marketing: PartnerCentralSellingClientTypes.Marketing?
    /// Specifies if the opportunity is associated with national security concerns. This flag is only applicable when the industry is Government. For national-security-related opportunities, validation and compliance rules may apply, impacting the opportunity's visibility and processing.
    public var nationalSecurity: PartnerCentralSellingClientTypes.NationalSecurity?
    /// Specifies the opportunity type as a renewal, new, or expansion. Opportunity types:
    ///
    /// * New opportunity: Represents a new business opportunity with a potential customer that's not previously engaged with your solutions or services.
    ///
    /// * Renewal opportunity: Represents an opportunity to renew an existing contract or subscription with a current customer, ensuring continuity of service.
    ///
    /// * Expansion opportunity: Represents an opportunity to expand the scope of an existing contract or subscription, either by adding new services or increasing the volume of existing services for a current customer.
    public var opportunityType: PartnerCentralSellingClientTypes.OpportunityType?
    /// Specifies the opportunity's unique identifier in the partner's CRM system. This value is essential to track and reconcile because it's included in the outbound payload sent back to the partner.
    public var partnerOpportunityIdentifier: Swift.String?
    /// Identifies the type of support the partner needs from Amazon Web Services. Valid values:
    ///
    /// * Cosell—Architectural Validation: Confirmation from Amazon Web Services that the partner's proposed solution architecture is aligned with Amazon Web Services best practices and poses minimal architectural risks.
    ///
    /// * Cosell—Business Presentation: Request Amazon Web Services seller's participation in a joint customer presentation.
    ///
    /// * Cosell—Competitive Information: Access to Amazon Web Services competitive resources and support for the partner's proposed solution.
    ///
    /// * Cosell—Pricing Assistance: Connect with an AWS seller for support situations where a partner may be receiving an upfront discount on a service (for example: EDP deals).
    ///
    /// * Cosell—Technical Consultation: Connection with an Amazon Web Services Solutions Architect to address the partner's questions about the proposed solution.
    ///
    /// * Cosell—Total Cost of Ownership Evaluation: Assistance with quoting different cost savings of proposed solutions on Amazon Web Services versus on-premises or a traditional hosting environment.
    ///
    /// * Cosell—Deal Support: Request Amazon Web Services seller's support to progress the opportunity (for example: joint customer call, strategic positioning).
    ///
    /// * Cosell—Support for Public Tender/RFx: Opportunity related to the public sector where the partner needs RFx support from Amazon Web Services.
    public var primaryNeedsFromAws: [PartnerCentralSellingClientTypes.PrimaryNeedFromAws]?
    /// An object that contains project details summary for the Opportunity.
    public var project: PartnerCentralSellingClientTypes.Project?
    /// Specifies details of a customer's procurement terms. Required only for partners in eligible programs.
    public var softwareRevenue: PartnerCentralSellingClientTypes.SoftwareRevenue?

    public init(
        catalog: Swift.String? = nil,
        customer: PartnerCentralSellingClientTypes.Customer? = nil,
        identifier: Swift.String? = nil,
        lastModifiedDate: Foundation.Date? = nil,
        lifeCycle: PartnerCentralSellingClientTypes.LifeCycle? = nil,
        marketing: PartnerCentralSellingClientTypes.Marketing? = nil,
        nationalSecurity: PartnerCentralSellingClientTypes.NationalSecurity? = nil,
        opportunityType: PartnerCentralSellingClientTypes.OpportunityType? = nil,
        partnerOpportunityIdentifier: Swift.String? = nil,
        primaryNeedsFromAws: [PartnerCentralSellingClientTypes.PrimaryNeedFromAws]? = nil,
        project: PartnerCentralSellingClientTypes.Project? = nil,
        softwareRevenue: PartnerCentralSellingClientTypes.SoftwareRevenue? = nil
    ) {
        self.catalog = catalog
        self.customer = customer
        self.identifier = identifier
        self.lastModifiedDate = lastModifiedDate
        self.lifeCycle = lifeCycle
        self.marketing = marketing
        self.nationalSecurity = nationalSecurity
        self.opportunityType = opportunityType
        self.partnerOpportunityIdentifier = partnerOpportunityIdentifier
        self.primaryNeedsFromAws = primaryNeedsFromAws
        self.project = project
        self.softwareRevenue = softwareRevenue
    }
}

public struct UpdateOpportunityOutput: Swift.Sendable {
    /// Read-only, system generated Opportunity unique identifier.
    /// This member is required.
    public var id: Swift.String?
    /// DateTime when the opportunity was last modified.
    /// This member is required.
    public var lastModifiedDate: Foundation.Date?

    public init(
        id: Swift.String? = nil,
        lastModifiedDate: Foundation.Date? = nil
    ) {
        self.id = id
        self.lastModifiedDate = lastModifiedDate
    }
}

public struct ListOpportunityFromEngagementTasksInput: Swift.Sendable {
    /// Specifies the catalog related to the request. Valid values are AWS for production environments and Sandbox for testing or development purposes. The catalog determines which environment the task data is retrieved from.
    /// This member is required.
    public var catalog: Swift.String?
    /// Filters tasks by the identifiers of the engagement contexts associated with the opportunity creation. Use this to find tasks related to specific contextual information within engagements that are being converted to opportunities.
    public var contextIdentifier: [Swift.String]?
    /// Filters tasks by the identifiers of the engagements from which opportunities are being created. Use this to find all opportunity creation tasks associated with a specific engagement.
    public var engagementIdentifier: [Swift.String]?
    /// Specifies the maximum number of results to return in a single page of the response. Use this parameter to control the number of items returned in each request, which can be useful for performance tuning and managing large result sets.
    public var maxResults: Swift.Int?
    /// The token for requesting the next page of results. This value is obtained from the NextToken field in the response of a previous call to this API. Use this parameter for pagination when the result set spans multiple pages.
    public var nextToken: Swift.String?
    /// Filters tasks by the identifiers of the opportunities they created or are associated with. Use this to find tasks related to specific opportunity creation processes.
    public var opportunityIdentifier: [Swift.String]?
    /// Defines the sorting parameters for listing tasks. This structure allows for specifying the field to sort by and the order of sorting.
    public var sort: PartnerCentralSellingClientTypes.ListTasksSortBase?
    /// Filters tasks by their unique identifiers. Use this when you want to retrieve information about specific tasks. Provide the task ID to get details about a particular opportunity creation task.
    public var taskIdentifier: [Swift.String]?
    /// Filters the tasks based on their current status. This allows you to focus on tasks in specific states. Valid values are COMPLETE for tasks that have finished successfully, INPROGRESS for tasks that are currently running, and FAILED for tasks that have encountered an error and failed to complete.
    public var taskStatus: [PartnerCentralSellingClientTypes.TaskStatus]?

    public init(
        catalog: Swift.String? = nil,
        contextIdentifier: [Swift.String]? = nil,
        engagementIdentifier: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        opportunityIdentifier: [Swift.String]? = nil,
        sort: PartnerCentralSellingClientTypes.ListTasksSortBase? = nil,
        taskIdentifier: [Swift.String]? = nil,
        taskStatus: [PartnerCentralSellingClientTypes.TaskStatus]? = nil
    ) {
        self.catalog = catalog
        self.contextIdentifier = contextIdentifier
        self.engagementIdentifier = engagementIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.opportunityIdentifier = opportunityIdentifier
        self.sort = sort
        self.taskIdentifier = taskIdentifier
        self.taskStatus = taskStatus
    }
}

extension PartnerCentralSellingClientTypes {

    /// Provides a summary of a task related to creating an opportunity from an engagement. This structure contains key information about the task's status, associated identifiers, and any failure details for opportunity creation processes.
    public struct ListOpportunityFromEngagementTaskSummary: Swift.Sendable {
        /// The unique identifier of the engagement context associated with the opportunity creation task. This links the task to specific contextual information within the engagement.
        public var contextId: Swift.String?
        /// The unique identifier of the engagement from which the opportunity is being created. This field helps track the source of the opportunity creation task.
        public var engagementId: Swift.String?
        /// A detailed message providing additional information about the task, especially useful in case of failures. This field may contain error details or other relevant information about the task's execution.
        public var message: Swift.String?
        /// The unique identifier of the opportunity created as a result of the task. This field is populated when the task is completed successfully.
        public var opportunityId: Swift.String?
        /// A code indicating the specific reason for a task failure. This field is populated when the task status is FAILED and provides a categorized reason for the failure.
        public var reasonCode: PartnerCentralSellingClientTypes.ReasonCode?
        /// The identifier of the resource snapshot job associated with this task, if a snapshot was created as part of the opportunity creation process.
        public var resourceSnapshotJobId: Swift.String?
        /// The timestamp indicating when the task was initiated, in RFC 3339 format.
        public var startTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) that uniquely identifies the task within AWS. This ARN can be used for referencing the task in other AWS services or APIs.
        public var taskArn: Swift.String?
        /// The unique identifier of the task for creating an opportunity from an engagement.
        public var taskId: Swift.String?
        /// The current status of the task. Valid values are COMPLETE, INPROGRESS, or FAILED.
        public var taskStatus: PartnerCentralSellingClientTypes.TaskStatus?

        public init(
            contextId: Swift.String? = nil,
            engagementId: Swift.String? = nil,
            message: Swift.String? = nil,
            opportunityId: Swift.String? = nil,
            reasonCode: PartnerCentralSellingClientTypes.ReasonCode? = nil,
            resourceSnapshotJobId: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            taskArn: Swift.String? = nil,
            taskId: Swift.String? = nil,
            taskStatus: PartnerCentralSellingClientTypes.TaskStatus? = nil
        ) {
            self.contextId = contextId
            self.engagementId = engagementId
            self.message = message
            self.opportunityId = opportunityId
            self.reasonCode = reasonCode
            self.resourceSnapshotJobId = resourceSnapshotJobId
            self.startTime = startTime
            self.taskArn = taskArn
            self.taskId = taskId
            self.taskStatus = taskStatus
        }
    }
}

public struct ListOpportunityFromEngagementTasksOutput: Swift.Sendable {
    /// A token used for pagination to retrieve the next page of results. If there are more results available, this field will contain a token that can be used in a subsequent API call to retrieve the next page. If there are no more results, this field will be null or an empty string.
    public var nextToken: Swift.String?
    /// An array of ListOpportunityFromEngagementTaskSummary objects, each representing a task that matches the specified filters. The array may be empty if no tasks match the criteria.
    public var taskSummaries: [PartnerCentralSellingClientTypes.ListOpportunityFromEngagementTaskSummary]?

    public init(
        nextToken: Swift.String? = nil,
        taskSummaries: [PartnerCentralSellingClientTypes.ListOpportunityFromEngagementTaskSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.taskSummaries = taskSummaries
    }
}

public struct StartOpportunityFromEngagementTaskInput: Swift.Sendable {
    /// Specifies the catalog in which the opportunity creation task is executed. Acceptable values include AWS for production and Sandbox for testing environments.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique token provided by the client to help ensure the idempotency of the request. It helps prevent the same task from being performed multiple times.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The unique identifier of the engagement context from which to create the opportunity. This specifies the specific contextual information within the engagement that will be used for opportunity creation.
    /// This member is required.
    public var contextIdentifier: Swift.String?
    /// The unique identifier of the engagement from which the opportunity creation task is to be initiated. This helps ensure that the task is applied to the correct engagement.
    /// This member is required.
    public var identifier: Swift.String?
    /// A map of the key-value pairs of the tag or tags to assign.
    public var tags: [PartnerCentralSellingClientTypes.Tag]?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        contextIdentifier: Swift.String? = nil,
        identifier: Swift.String? = nil,
        tags: [PartnerCentralSellingClientTypes.Tag]? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.contextIdentifier = contextIdentifier
        self.identifier = identifier
        self.tags = tags
    }
}

public struct StartOpportunityFromEngagementTaskOutput: Swift.Sendable {
    /// The unique identifier of the engagement context used to create the opportunity.
    public var contextId: Swift.String?
    /// The unique identifier of the engagement from which the opportunity was created.
    public var engagementId: Swift.String?
    /// If the task fails, this field contains a detailed message describing the failure and possible recovery steps.
    public var message: Swift.String?
    /// The unique identifier of the opportunity created as a result of the task. This field is populated when the task is completed successfully.
    public var opportunityId: Swift.String?
    /// Indicates the reason for task failure using an enumerated code.
    public var reasonCode: PartnerCentralSellingClientTypes.ReasonCode?
    /// The identifier of the resource snapshot job created as part of the opportunity creation process.
    public var resourceSnapshotJobId: Swift.String?
    /// The timestamp indicating when the task was initiated. The format follows RFC 3339 section 5.6.
    public var startTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the task, used for tracking and managing the task within AWS.
    public var taskArn: Swift.String?
    /// The unique identifier of the task, used to track the task's progress.
    public var taskId: Swift.String?
    /// Indicates the current status of the task.
    public var taskStatus: PartnerCentralSellingClientTypes.TaskStatus?

    public init(
        contextId: Swift.String? = nil,
        engagementId: Swift.String? = nil,
        message: Swift.String? = nil,
        opportunityId: Swift.String? = nil,
        reasonCode: PartnerCentralSellingClientTypes.ReasonCode? = nil,
        resourceSnapshotJobId: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        taskArn: Swift.String? = nil,
        taskId: Swift.String? = nil,
        taskStatus: PartnerCentralSellingClientTypes.TaskStatus? = nil
    ) {
        self.contextId = contextId
        self.engagementId = engagementId
        self.message = message
        self.opportunityId = opportunityId
        self.reasonCode = reasonCode
        self.resourceSnapshotJobId = resourceSnapshotJobId
        self.startTime = startTime
        self.taskArn = taskArn
        self.taskId = taskId
        self.taskStatus = taskStatus
    }
}

public struct PutSellingSystemSettingsInput: Swift.Sendable {
    /// Specifies the catalog in which the settings will be updated. Acceptable values include AWS for production and Sandbox for testing environments.
    /// This member is required.
    public var catalog: Swift.String?
    /// Specifies the ARN of the IAM Role used for resource snapshot job executions.
    public var resourceSnapshotJobRoleIdentifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        resourceSnapshotJobRoleIdentifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.resourceSnapshotJobRoleIdentifier = resourceSnapshotJobRoleIdentifier
    }
}

public struct PutSellingSystemSettingsOutput: Swift.Sendable {
    /// Specifies the catalog in which the settings are defined. Acceptable values include AWS for production and Sandbox for testing environments.
    /// This member is required.
    public var catalog: Swift.String?
    /// Specifies the ARN of the IAM Role used for resource snapshot job executions.
    public var resourceSnapshotJobRoleArn: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        resourceSnapshotJobRoleArn: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.resourceSnapshotJobRoleArn = resourceSnapshotJobRoleArn
    }
}

extension PartnerCentralSellingClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case opportunity
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .opportunity
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .opportunity: return "Opportunity"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateResourceSnapshotInput: Swift.Sendable {
    /// Specifies the catalog where the snapshot is created. Valid values are AWS and Sandbox.
    /// This member is required.
    public var catalog: Swift.String?
    /// Specifies a unique, client-generated UUID to ensure that the request is handled exactly once. This token helps prevent duplicate snapshot creations.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The unique identifier of the engagement associated with this snapshot. This field links the snapshot to a specific engagement context.
    /// This member is required.
    public var engagementIdentifier: Swift.String?
    /// The unique identifier of the specific resource to be snapshotted. The format and constraints of this identifier depend on the ResourceType specified. For example: For Opportunity type, it will be an opportunity ID.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// The name of the template that defines the schema for the snapshot. This template determines which subset of the resource data will be included in the snapshot. Must correspond to an existing and valid template for the specified ResourceType.
    /// This member is required.
    public var resourceSnapshotTemplateIdentifier: Swift.String?
    /// Specifies the type of resource for which the snapshot is being created. This field determines the structure and content of the snapshot. Must be one of the supported resource types, such as: Opportunity.
    /// This member is required.
    public var resourceType: PartnerCentralSellingClientTypes.ResourceType?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        engagementIdentifier: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceSnapshotTemplateIdentifier: Swift.String? = nil,
        resourceType: PartnerCentralSellingClientTypes.ResourceType? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.engagementIdentifier = engagementIdentifier
        self.resourceIdentifier = resourceIdentifier
        self.resourceSnapshotTemplateIdentifier = resourceSnapshotTemplateIdentifier
        self.resourceType = resourceType
    }
}

public struct CreateResourceSnapshotOutput: Swift.Sendable {
    /// Specifies the Amazon Resource Name (ARN) that uniquely identifies the snapshot created.
    public var arn: Swift.String?
    /// Specifies the revision number of the created snapshot. This field provides important information about the snapshot's place in the sequence of snapshots for the given resource.
    public var revision: Swift.Int?

    public init(
        arn: Swift.String? = nil,
        revision: Swift.Int? = nil
    ) {
        self.arn = arn
        self.revision = revision
    }
}

public struct GetResourceSnapshotInput: Swift.Sendable {
    /// Specifies the catalog related to the request. Valid values are:
    ///
    /// * AWS: Retrieves the snapshot from the production AWS environment.
    ///
    /// * Sandbox: Retrieves the snapshot from a sandbox environment used for testing or development purposes.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the engagement associated with the snapshot. This field links the snapshot to a specific engagement context.
    /// This member is required.
    public var engagementIdentifier: Swift.String?
    /// The unique identifier of the specific resource that was snapshotted. The format and constraints of this identifier depend on the ResourceType specified. For Opportunity type, it will be an opportunity ID
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// he name of the template that defines the schema for the snapshot. This template determines which subset of the resource data is included in the snapshot and must correspond to an existing and valid template for the specified ResourceType.
    /// This member is required.
    public var resourceSnapshotTemplateIdentifier: Swift.String?
    /// Specifies the type of resource that was snapshotted. This field determines the structure and content of the snapshot payload. Valid value includes:Opportunity: For opportunity-related data.
    /// This member is required.
    public var resourceType: PartnerCentralSellingClientTypes.ResourceType?
    /// Specifies which revision of the snapshot to retrieve. If omitted returns the latest revision.
    public var revision: Swift.Int?

    public init(
        catalog: Swift.String? = nil,
        engagementIdentifier: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceSnapshotTemplateIdentifier: Swift.String? = nil,
        resourceType: PartnerCentralSellingClientTypes.ResourceType? = nil,
        revision: Swift.Int? = nil
    ) {
        self.catalog = catalog
        self.engagementIdentifier = engagementIdentifier
        self.resourceIdentifier = resourceIdentifier
        self.resourceSnapshotTemplateIdentifier = resourceSnapshotTemplateIdentifier
        self.resourceType = resourceType
        self.revision = revision
    }
}

extension PartnerCentralSellingClientTypes {

    /// Provides the lifecycle view of an opportunity resource shared through a snapshot.
    public struct LifeCycleForView: Swift.Sendable {
        /// Describes the next steps for the opportunity shared through a snapshot.
        public var nextSteps: Swift.String?
        /// Defines the approval status of the opportunity shared through a snapshot.
        public var reviewStatus: PartnerCentralSellingClientTypes.ReviewStatus?
        /// Defines the current stage of the opportunity shared through a snapshot.
        public var stage: PartnerCentralSellingClientTypes.Stage?
        /// The projected launch date of the opportunity shared through a snapshot.
        public var targetCloseDate: Swift.String?

        public init(
            nextSteps: Swift.String? = nil,
            reviewStatus: PartnerCentralSellingClientTypes.ReviewStatus? = nil,
            stage: PartnerCentralSellingClientTypes.Stage? = nil,
            targetCloseDate: Swift.String? = nil
        ) {
            self.nextSteps = nextSteps
            self.reviewStatus = reviewStatus
            self.stage = stage
            self.targetCloseDate = targetCloseDate
        }
    }
}

extension PartnerCentralSellingClientTypes.LifeCycleForView: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LifeCycleForView(reviewStatus: \(Swift.String(describing: reviewStatus)), stage: \(Swift.String(describing: stage)), targetCloseDate: \(Swift.String(describing: targetCloseDate)), nextSteps: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// Provides the project view of an opportunity resource shared through a snapshot.
    public struct ProjectView: Swift.Sendable {
        /// Specifies the proposed solution focus or type of workload for the project.
        public var customerUseCase: Swift.String?
        /// Describes the deployment or consumption model for the partner solution or offering. This field indicates how the project's solution will be delivered or implemented for the customer.
        public var deliveryModels: [PartnerCentralSellingClientTypes.DeliveryModel]?
        /// Provides information about the anticipated customer spend related to this project. This may include details such as amount, frequency, and currency of expected expenditure.
        public var expectedCustomerSpend: [PartnerCentralSellingClientTypes.ExpectedCustomerSpend]?
        /// Offers a description of other solutions if the standard solutions do not adequately cover the project's scope.
        public var otherSolutionDescription: Swift.String?
        /// Lists the pre-sales activities that have occurred with the end-customer related to the opportunity. This field is conditionally mandatory when the project is qualified for Co-Sell and helps drive assignment priority on the AWS side. It provides insight into the engagement level with the customer.
        public var salesActivities: [PartnerCentralSellingClientTypes.SalesActivity]?

        public init(
            customerUseCase: Swift.String? = nil,
            deliveryModels: [PartnerCentralSellingClientTypes.DeliveryModel]? = nil,
            expectedCustomerSpend: [PartnerCentralSellingClientTypes.ExpectedCustomerSpend]? = nil,
            otherSolutionDescription: Swift.String? = nil,
            salesActivities: [PartnerCentralSellingClientTypes.SalesActivity]? = nil
        ) {
            self.customerUseCase = customerUseCase
            self.deliveryModels = deliveryModels
            self.expectedCustomerSpend = expectedCustomerSpend
            self.otherSolutionDescription = otherSolutionDescription
            self.salesActivities = salesActivities
        }
    }
}

extension PartnerCentralSellingClientTypes.ProjectView: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProjectView(customerUseCase: \(Swift.String(describing: customerUseCase)), deliveryModels: \(Swift.String(describing: deliveryModels)), expectedCustomerSpend: \(Swift.String(describing: expectedCustomerSpend)), salesActivities: \(Swift.String(describing: salesActivities)), otherSolutionDescription: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// Provides a comprehensive view of an opportunity summary, including lifecycle information, team details, opportunity type, primary needs from AWS, and associated project information.
    public struct OpportunitySummaryView: Swift.Sendable {
        /// An object that contains the customer's Account and Contact.
        public var customer: PartnerCentralSellingClientTypes.Customer?
        /// Contains information about the opportunity's lifecycle, including its current stage, status, and important dates such as creation and last modification times.
        public var lifecycle: PartnerCentralSellingClientTypes.LifeCycleForView?
        /// Represents the internal team handling the opportunity. Specify the members involved in collaborating on an opportunity within the partner's organization.
        public var opportunityTeam: [PartnerCentralSellingClientTypes.Contact]?
        /// Specifies the opportunity type.
        public var opportunityType: PartnerCentralSellingClientTypes.OpportunityType?
        /// Identifies the type of support the partner needs from AWS.
        public var primaryNeedsFromAws: [PartnerCentralSellingClientTypes.PrimaryNeedFromAws]?
        /// Contains summary information about the project associated with the opportunity, including project name, description, timeline, and other relevant details.
        public var project: PartnerCentralSellingClientTypes.ProjectView?
        /// This field provides the associations' information for other entities with the opportunity. These entities include identifiers for AWSProducts, Partner Solutions, and AWSMarketplaceOffers.
        public var relatedEntityIdentifiers: PartnerCentralSellingClientTypes.RelatedEntityIdentifiers?

        public init(
            customer: PartnerCentralSellingClientTypes.Customer? = nil,
            lifecycle: PartnerCentralSellingClientTypes.LifeCycleForView? = nil,
            opportunityTeam: [PartnerCentralSellingClientTypes.Contact]? = nil,
            opportunityType: PartnerCentralSellingClientTypes.OpportunityType? = nil,
            primaryNeedsFromAws: [PartnerCentralSellingClientTypes.PrimaryNeedFromAws]? = nil,
            project: PartnerCentralSellingClientTypes.ProjectView? = nil,
            relatedEntityIdentifiers: PartnerCentralSellingClientTypes.RelatedEntityIdentifiers? = nil
        ) {
            self.customer = customer
            self.lifecycle = lifecycle
            self.opportunityTeam = opportunityTeam
            self.opportunityType = opportunityType
            self.primaryNeedsFromAws = primaryNeedsFromAws
            self.project = project
            self.relatedEntityIdentifiers = relatedEntityIdentifiers
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Represents the payload of a resource snapshot. This structure is designed to accommodate different types of resource snapshots, currently supporting opportunity summaries.
    public enum ResourceSnapshotPayload: Swift.Sendable {
        /// An object that contains an opportunity's subset of fields.
        case opportunitysummary(PartnerCentralSellingClientTypes.OpportunitySummaryView)
        /// Provides a comprehensive view of AwsOpportunitySummaryFullView template.
        case awsopportunitysummaryfullview(PartnerCentralSellingClientTypes.AwsOpportunitySummaryFullView)
        case sdkUnknown(Swift.String)
    }
}

public struct GetResourceSnapshotOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that uniquely identifies the resource snapshot.
    public var arn: Swift.String?
    /// The catalog in which the snapshot was created. Matches the Catalog specified in the request.
    /// This member is required.
    public var catalog: Swift.String?
    /// The timestamp when the snapshot was created, in ISO 8601 format (e.g., "2023-06-01T14:30:00Z"). This allows for precise tracking of when the snapshot was taken.
    public var createdAt: Foundation.Date?
    /// The AWS account ID of the principal (user or role) who created the snapshot. This helps in tracking the origin of the snapshot.
    public var createdBy: Swift.String?
    /// The identifier of the engagement associated with this snapshot. Matches the EngagementIdentifier specified in the request.
    public var engagementId: Swift.String?
    /// Represents the payload of a resource snapshot. This structure is designed to accommodate different types of resource snapshots, currently supporting opportunity summaries.
    public var payload: PartnerCentralSellingClientTypes.ResourceSnapshotPayload?
    /// The identifier of the specific resource that was snapshotted. Matches the ResourceIdentifier specified in the request.
    public var resourceId: Swift.String?
    /// The name of the view used for this snapshot. This is the same as the template name.
    public var resourceSnapshotTemplateName: Swift.String?
    /// The type of the resource that was snapshotted. Matches the ResourceType specified in the request.
    public var resourceType: PartnerCentralSellingClientTypes.ResourceType?
    /// The revision number of this snapshot. This is a positive integer that is sequential and unique within the context of a resource view.
    public var revision: Swift.Int?
    /// Target member accounts associated with the resource snapshot.
    public var targetMemberAccounts: [Swift.String]?

    public init(
        arn: Swift.String? = nil,
        catalog: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        engagementId: Swift.String? = nil,
        payload: PartnerCentralSellingClientTypes.ResourceSnapshotPayload? = nil,
        resourceId: Swift.String? = nil,
        resourceSnapshotTemplateName: Swift.String? = nil,
        resourceType: PartnerCentralSellingClientTypes.ResourceType? = nil,
        revision: Swift.Int? = nil,
        targetMemberAccounts: [Swift.String]? = nil
    ) {
        self.arn = arn
        self.catalog = catalog
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.engagementId = engagementId
        self.payload = payload
        self.resourceId = resourceId
        self.resourceSnapshotTemplateName = resourceSnapshotTemplateName
        self.resourceType = resourceType
        self.revision = revision
        self.targetMemberAccounts = targetMemberAccounts
    }
}

extension GetResourceSnapshotOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetResourceSnapshotOutput(arn: \(Swift.String(describing: arn)), catalog: \(Swift.String(describing: catalog)), createdAt: \(Swift.String(describing: createdAt)), engagementId: \(Swift.String(describing: engagementId)), payload: \(Swift.String(describing: payload)), resourceId: \(Swift.String(describing: resourceId)), resourceSnapshotTemplateName: \(Swift.String(describing: resourceSnapshotTemplateName)), resourceType: \(Swift.String(describing: resourceType)), revision: \(Swift.String(describing: revision)), createdBy: \"CONTENT_REDACTED\", targetMemberAccounts: \"CONTENT_REDACTED\")"}
}

public struct ListEngagementResourceAssociationsInput: Swift.Sendable {
    /// Specifies the catalog in which to search for engagement-resource associations. Valid Values: "AWS" or "Sandbox"
    ///
    /// * AWS for production environments.
    ///
    /// * Sandbox for testing and development purposes.
    /// This member is required.
    public var catalog: Swift.String?
    /// Filters the response to include only snapshots of resources owned by the specified AWS account ID. Use this when you want to find associations related to resources owned by a particular account.
    public var createdBy: Swift.String?
    /// Filters the results to include only associations related to the specified engagement. Use this when you want to find all resources associated with a specific engagement.
    public var engagementIdentifier: Swift.String?
    /// Limits the number of results returned in a single call. Use this to control the number of results returned, especially useful for pagination.
    public var maxResults: Swift.Int?
    /// A token used for pagination of results. Include this token in subsequent requests to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Filters the results to include only associations with the specified resource. Varies depending on the resource type. Use this when you want to find all engagements associated with a specific resource.
    public var resourceIdentifier: Swift.String?
    /// Filters the results to include only associations with resources of the specified type.
    public var resourceType: PartnerCentralSellingClientTypes.ResourceType?

    public init(
        catalog: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        engagementIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceType: PartnerCentralSellingClientTypes.ResourceType? = nil
    ) {
        self.catalog = catalog
        self.createdBy = createdBy
        self.engagementIdentifier = engagementIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIdentifier = resourceIdentifier
        self.resourceType = resourceType
    }
}

extension ListEngagementResourceAssociationsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListEngagementResourceAssociationsInput(catalog: \(Swift.String(describing: catalog)), engagementIdentifier: \(Swift.String(describing: engagementIdentifier)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceIdentifier: \(Swift.String(describing: resourceIdentifier)), resourceType: \(Swift.String(describing: resourceType)), createdBy: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// This provide a streamlined view of the relationships between engagements and resources. These summaries offer a crucial link between collaborative engagements and the specific resources involved, such as opportunities.These summaries are particularly valuable for partners navigating complex engagements with multiple resources. They enable quick insights into resource distribution across engagements, support efficient resource management, and help maintain a clear overview of collaborative activities.
    public struct EngagementResourceAssociationSummary: Swift.Sendable {
        /// Indicates the environment in which the resource and engagement exist.
        /// This member is required.
        public var catalog: Swift.String?
        /// The AWS account ID of the entity that owns the resource. Identifies the account responsible for or having primary control over the resource.
        public var createdBy: Swift.String?
        /// A unique identifier for the engagement associated with the resource.
        public var engagementId: Swift.String?
        /// A unique identifier for the specific resource. Varies depending on the resource type.
        public var resourceId: Swift.String?
        /// Categorizes the type of resource associated with the engagement.
        public var resourceType: PartnerCentralSellingClientTypes.ResourceType?

        public init(
            catalog: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            engagementId: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceType: PartnerCentralSellingClientTypes.ResourceType? = nil
        ) {
            self.catalog = catalog
            self.createdBy = createdBy
            self.engagementId = engagementId
            self.resourceId = resourceId
            self.resourceType = resourceType
        }
    }
}

extension PartnerCentralSellingClientTypes.EngagementResourceAssociationSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EngagementResourceAssociationSummary(catalog: \(Swift.String(describing: catalog)), engagementId: \(Swift.String(describing: engagementId)), resourceId: \(Swift.String(describing: resourceId)), resourceType: \(Swift.String(describing: resourceType)), createdBy: \"CONTENT_REDACTED\")"}
}

public struct ListEngagementResourceAssociationsOutput: Swift.Sendable {
    /// A list of engagement-resource association summaries.
    /// This member is required.
    public var engagementResourceAssociationSummaries: [PartnerCentralSellingClientTypes.EngagementResourceAssociationSummary]?
    /// A token to retrieve the next set of results. Use this token in a subsequent request to retrieve additional results if the response was truncated.
    public var nextToken: Swift.String?

    public init(
        engagementResourceAssociationSummaries: [PartnerCentralSellingClientTypes.EngagementResourceAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.engagementResourceAssociationSummaries = engagementResourceAssociationSummaries
        self.nextToken = nextToken
    }
}

public struct ListResourceSnapshotsInput: Swift.Sendable {
    /// Specifies the catalog related to the request.
    /// This member is required.
    public var catalog: Swift.String?
    /// Filters the response to include only snapshots of resources owned by the specified AWS account.
    public var createdBy: Swift.String?
    /// The unique identifier of the engagement associated with the snapshots.
    /// This member is required.
    public var engagementIdentifier: Swift.String?
    /// The maximum number of results to return in a single call.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// Filters the response to include only snapshots of the specified resource.
    public var resourceIdentifier: Swift.String?
    /// Filters the response to include only snapshots created using the specified template.
    public var resourceSnapshotTemplateIdentifier: Swift.String?
    /// Filters the response to include only snapshots of the specified resource type.
    public var resourceType: PartnerCentralSellingClientTypes.ResourceType?

    public init(
        catalog: Swift.String? = nil,
        createdBy: Swift.String? = nil,
        engagementIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceSnapshotTemplateIdentifier: Swift.String? = nil,
        resourceType: PartnerCentralSellingClientTypes.ResourceType? = nil
    ) {
        self.catalog = catalog
        self.createdBy = createdBy
        self.engagementIdentifier = engagementIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceIdentifier = resourceIdentifier
        self.resourceSnapshotTemplateIdentifier = resourceSnapshotTemplateIdentifier
        self.resourceType = resourceType
    }
}

extension ListResourceSnapshotsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListResourceSnapshotsInput(catalog: \(Swift.String(describing: catalog)), engagementIdentifier: \(Swift.String(describing: engagementIdentifier)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), resourceIdentifier: \(Swift.String(describing: resourceIdentifier)), resourceSnapshotTemplateIdentifier: \(Swift.String(describing: resourceSnapshotTemplateIdentifier)), resourceType: \(Swift.String(describing: resourceType)), createdBy: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralSellingClientTypes {

    /// Provides a concise summary of a resource snapshot, including its unique identifier and version information. This structure is used to quickly reference and identify specific versions of resource snapshots.
    public struct ResourceSnapshotSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the snapshot. This globally unique identifier can be used for cross-service references and in IAM policies.
        public var arn: Swift.String?
        /// The AWS account ID of the entity that owns the resource from which the snapshot was created.
        public var createdBy: Swift.String?
        /// The identifier of the specific resource snapshotted. The format might vary depending on the ResourceType.
        public var resourceId: Swift.String?
        /// The name of the template used to create the snapshot.
        public var resourceSnapshotTemplateName: Swift.String?
        /// The type of resource snapshotted.
        public var resourceType: PartnerCentralSellingClientTypes.ResourceType?
        /// The revision number of the snapshot. This integer value is incremented each time the snapshot is updated, allowing for version tracking of the resource snapshot.
        public var revision: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            createdBy: Swift.String? = nil,
            resourceId: Swift.String? = nil,
            resourceSnapshotTemplateName: Swift.String? = nil,
            resourceType: PartnerCentralSellingClientTypes.ResourceType? = nil,
            revision: Swift.Int? = nil
        ) {
            self.arn = arn
            self.createdBy = createdBy
            self.resourceId = resourceId
            self.resourceSnapshotTemplateName = resourceSnapshotTemplateName
            self.resourceType = resourceType
            self.revision = revision
        }
    }
}

extension PartnerCentralSellingClientTypes.ResourceSnapshotSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResourceSnapshotSummary(arn: \(Swift.String(describing: arn)), resourceId: \(Swift.String(describing: resourceId)), resourceSnapshotTemplateName: \(Swift.String(describing: resourceSnapshotTemplateName)), resourceType: \(Swift.String(describing: resourceType)), revision: \(Swift.String(describing: revision)), createdBy: \"CONTENT_REDACTED\")"}
}

public struct ListResourceSnapshotsOutput: Swift.Sendable {
    /// The token to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextToken: Swift.String?
    /// An array of resource snapshot summary objects.
    /// This member is required.
    public var resourceSnapshotSummaries: [PartnerCentralSellingClientTypes.ResourceSnapshotSummary]?

    public init(
        nextToken: Swift.String? = nil,
        resourceSnapshotSummaries: [PartnerCentralSellingClientTypes.ResourceSnapshotSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.resourceSnapshotSummaries = resourceSnapshotSummaries
    }
}

public struct CreateResourceSnapshotJobInput: Swift.Sendable {
    /// Specifies the catalog in which to create the snapshot job. Valid values are AWS and  Sandbox.
    /// This member is required.
    public var catalog: Swift.String?
    /// A client-generated UUID used for idempotency check. The token helps prevent duplicate job creations.
    /// This member is required.
    public var clientToken: Swift.String?
    /// Specifies the identifier of the engagement associated with the resource to be snapshotted.
    /// This member is required.
    public var engagementIdentifier: Swift.String?
    /// Specifies the identifier of the specific resource to be snapshotted. The format depends on the  ResourceType.
    /// This member is required.
    public var resourceIdentifier: Swift.String?
    /// Specifies the name of the template that defines the schema for the snapshot.
    /// This member is required.
    public var resourceSnapshotTemplateIdentifier: Swift.String?
    /// The type of resource for which the snapshot job is being created. Must be one of the supported resource types i.e. Opportunity
    /// This member is required.
    public var resourceType: PartnerCentralSellingClientTypes.ResourceType?
    /// A map of the key-value pairs of the tag or tags to assign.
    public var tags: [PartnerCentralSellingClientTypes.Tag]?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        engagementIdentifier: Swift.String? = nil,
        resourceIdentifier: Swift.String? = nil,
        resourceSnapshotTemplateIdentifier: Swift.String? = nil,
        resourceType: PartnerCentralSellingClientTypes.ResourceType? = nil,
        tags: [PartnerCentralSellingClientTypes.Tag]? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.engagementIdentifier = engagementIdentifier
        self.resourceIdentifier = resourceIdentifier
        self.resourceSnapshotTemplateIdentifier = resourceSnapshotTemplateIdentifier
        self.resourceType = resourceType
        self.tags = tags
    }
}

public struct CreateResourceSnapshotJobOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the created snapshot job.
    public var arn: Swift.String?
    /// The unique identifier for the created snapshot job.
    public var id: Swift.String?

    public init(
        arn: Swift.String? = nil,
        id: Swift.String? = nil
    ) {
        self.arn = arn
        self.id = id
    }
}

public struct DeleteResourceSnapshotJobInput: Swift.Sendable {
    /// Specifies the catalog from which to delete the snapshot job. Valid values are AWS and Sandbox.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the resource snapshot job to be deleted.
    /// This member is required.
    public var resourceSnapshotJobIdentifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        resourceSnapshotJobIdentifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.resourceSnapshotJobIdentifier = resourceSnapshotJobIdentifier
    }
}

public struct GetResourceSnapshotJobInput: Swift.Sendable {
    /// Specifies the catalog related to the request. Valid values are:
    ///
    /// * AWS: Retrieves the snapshot job from the production AWS environment.
    ///
    /// * Sandbox: Retrieves the snapshot job from a sandbox environment used for testing or development purposes.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the resource snapshot job to be retrieved. This identifier is crucial for pinpointing the specific job you want to query.
    /// This member is required.
    public var resourceSnapshotJobIdentifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        resourceSnapshotJobIdentifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.resourceSnapshotJobIdentifier = resourceSnapshotJobIdentifier
    }
}

extension PartnerCentralSellingClientTypes {

    public enum ResourceSnapshotJobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case running
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceSnapshotJobStatus] {
            return [
                .running,
                .stopped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .running: return "Running"
            case .stopped: return "Stopped"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetResourceSnapshotJobOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the snapshot job. This globally unique identifier can be used for resource-specific operations across AWS services.
    public var arn: Swift.String?
    /// The catalog in which the snapshot job was created. This will match the Catalog specified in the request.
    /// This member is required.
    public var catalog: Swift.String?
    /// The date and time when the snapshot job was created in ISO 8601 format (UTC). Example: "2023-05-01T20:37:46Z"
    public var createdAt: Foundation.Date?
    /// The identifier of the engagement associated with this snapshot job. This links the job to a specific engagement context.
    public var engagementId: Swift.String?
    /// The unique identifier of the snapshot job. This matches the ResourceSnapshotJobIdentifier provided in the request.
    public var id: Swift.String?
    /// If the job has encountered any failures, this field contains the error message from the most recent failure. This can be useful for troubleshooting issues with the job.
    public var lastFailure: Swift.String?
    /// The date and time of the last successful execution of the job, in ISO 8601 format (UTC). Example: "2023-05-01T20:37:46Z"
    public var lastSuccessfulExecutionDate: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the resource being snapshotted. This provides a globally unique identifier for the resource across AWS.
    public var resourceArn: Swift.String?
    /// The identifier of the specific resource being snapshotted. The format might vary depending on the ResourceType.
    public var resourceId: Swift.String?
    /// The name of the template used for creating the snapshot. This is the same as the template name. It defines the structure and content of the snapshot.
    public var resourceSnapshotTemplateName: Swift.String?
    /// The type of resource being snapshotted. This would have "Opportunity" as a value as it is dependent on the supported resource type.
    public var resourceType: PartnerCentralSellingClientTypes.ResourceType?
    /// The current status of the snapshot job. Valid values:
    ///
    /// * STOPPED: The job is not currently running.
    ///
    /// * RUNNING: The job is actively executing.
    public var status: PartnerCentralSellingClientTypes.ResourceSnapshotJobStatus?

    public init(
        arn: Swift.String? = nil,
        catalog: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        engagementId: Swift.String? = nil,
        id: Swift.String? = nil,
        lastFailure: Swift.String? = nil,
        lastSuccessfulExecutionDate: Foundation.Date? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceSnapshotTemplateName: Swift.String? = nil,
        resourceType: PartnerCentralSellingClientTypes.ResourceType? = nil,
        status: PartnerCentralSellingClientTypes.ResourceSnapshotJobStatus? = nil
    ) {
        self.arn = arn
        self.catalog = catalog
        self.createdAt = createdAt
        self.engagementId = engagementId
        self.id = id
        self.lastFailure = lastFailure
        self.lastSuccessfulExecutionDate = lastSuccessfulExecutionDate
        self.resourceArn = resourceArn
        self.resourceId = resourceId
        self.resourceSnapshotTemplateName = resourceSnapshotTemplateName
        self.resourceType = resourceType
        self.status = status
    }
}

extension PartnerCentralSellingClientTypes {

    public enum SortBy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createdDate
        case sdkUnknown(Swift.String)

        public static var allCases: [SortBy] {
            return [
                .createdDate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createdDate: return "CreatedDate"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Defines the sorting parameters for listing resource snapshot jobs. This structure allows you to specify the field to sort by and the order of sorting.
    public struct SortObject: Swift.Sendable {
        /// Specifies the field by which to sort the resource snapshot jobs.
        public var sortBy: PartnerCentralSellingClientTypes.SortBy?
        /// Determines the order in which the sorted results are presented.
        public var sortOrder: PartnerCentralSellingClientTypes.SortOrder?

        public init(
            sortBy: PartnerCentralSellingClientTypes.SortBy? = nil,
            sortOrder: PartnerCentralSellingClientTypes.SortOrder? = nil
        ) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }
}

public struct ListResourceSnapshotJobsInput: Swift.Sendable {
    /// Specifies the catalog related to the request.
    /// This member is required.
    public var catalog: Swift.String?
    /// The identifier of the engagement to filter the response.
    public var engagementIdentifier: Swift.String?
    /// The maximum number of results to return in a single call. If omitted, defaults to 50.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// Configures the sorting of the response. If omitted, results are sorted by CreatedDate in descending order.
    public var sort: PartnerCentralSellingClientTypes.SortObject?
    /// The status of the jobs to filter the response.
    public var status: PartnerCentralSellingClientTypes.ResourceSnapshotJobStatus?

    public init(
        catalog: Swift.String? = nil,
        engagementIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sort: PartnerCentralSellingClientTypes.SortObject? = nil,
        status: PartnerCentralSellingClientTypes.ResourceSnapshotJobStatus? = nil
    ) {
        self.catalog = catalog
        self.engagementIdentifier = engagementIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
        self.status = status
    }
}

extension PartnerCentralSellingClientTypes {

    /// An object that contains a Resource Snapshot Job's subset of fields.
    public struct ResourceSnapshotJobSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) for the resource snapshot job.
        public var arn: Swift.String?
        /// The unique identifier of the Engagement.
        public var engagementId: Swift.String?
        /// The unique identifier for the resource snapshot job within the AWS Partner Central system. This ID is used for direct references to the job within the service.
        public var id: Swift.String?
        /// The current status of the snapshot job. Valid values:
        ///
        /// * STOPPED: The job is not currently running.
        ///
        /// * RUNNING: The job is actively executing.
        public var status: PartnerCentralSellingClientTypes.ResourceSnapshotJobStatus?

        public init(
            arn: Swift.String? = nil,
            engagementId: Swift.String? = nil,
            id: Swift.String? = nil,
            status: PartnerCentralSellingClientTypes.ResourceSnapshotJobStatus? = nil
        ) {
            self.arn = arn
            self.engagementId = engagementId
            self.id = id
            self.status = status
        }
    }
}

public struct ListResourceSnapshotJobsOutput: Swift.Sendable {
    /// The token to retrieve the next set of results. If there are no additional results, this value is null.
    public var nextToken: Swift.String?
    /// An array of resource snapshot job summary objects.
    /// This member is required.
    public var resourceSnapshotJobSummaries: [PartnerCentralSellingClientTypes.ResourceSnapshotJobSummary]?

    public init(
        nextToken: Swift.String? = nil,
        resourceSnapshotJobSummaries: [PartnerCentralSellingClientTypes.ResourceSnapshotJobSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.resourceSnapshotJobSummaries = resourceSnapshotJobSummaries
    }
}

public struct StartResourceSnapshotJobInput: Swift.Sendable {
    /// Specifies the catalog related to the request. Valid values are:
    ///
    /// * AWS: Starts the request from the production AWS environment.
    ///
    /// * Sandbox: Starts the request from a sandbox environment used for testing or development purposes.
    /// This member is required.
    public var catalog: Swift.String?
    /// The identifier of the resource snapshot job to start.
    /// This member is required.
    public var resourceSnapshotJobIdentifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        resourceSnapshotJobIdentifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.resourceSnapshotJobIdentifier = resourceSnapshotJobIdentifier
    }
}

public struct StopResourceSnapshotJobInput: Swift.Sendable {
    /// Specifies the catalog related to the request. Valid values are:
    ///
    /// * AWS: Stops the request from the production AWS environment.
    ///
    /// * Sandbox: Stops the request from a sandbox environment used for testing or development purposes.
    /// This member is required.
    public var catalog: Swift.String?
    /// The identifier of the job to stop.
    /// This member is required.
    public var resourceSnapshotJobIdentifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        resourceSnapshotJobIdentifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.resourceSnapshotJobIdentifier = resourceSnapshotJobIdentifier
    }
}

extension PartnerCentralSellingClientTypes {

    public enum SolutionSortName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case category
        case createddate
        case identifier
        case name
        case status
        case sdkUnknown(Swift.String)

        public static var allCases: [SolutionSortName] {
            return [
                .category,
                .createddate,
                .identifier,
                .name,
                .status
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .category: return "Category"
            case .createddate: return "CreatedDate"
            case .identifier: return "Identifier"
            case .name: return "Name"
            case .status: return "Status"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Configures the solutions' response sorting that enables partners to order solutions based on specified attributes.
    public struct SolutionSort: Swift.Sendable {
        /// Specifies the attribute to sort by, such as Name, CreatedDate, or Status.
        /// This member is required.
        public var sortBy: PartnerCentralSellingClientTypes.SolutionSortName?
        /// Specifies the sorting order, either Ascending or Descending. The default is Descending.
        /// This member is required.
        public var sortOrder: PartnerCentralSellingClientTypes.SortOrder?

        public init(
            sortBy: PartnerCentralSellingClientTypes.SolutionSortName? = nil,
            sortOrder: PartnerCentralSellingClientTypes.SortOrder? = nil
        ) {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }
}

extension PartnerCentralSellingClientTypes {

    public enum SolutionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case draft
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [SolutionStatus] {
            return [
                .active,
                .draft,
                .inactive
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "Active"
            case .draft: return "Draft"
            case .inactive: return "Inactive"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListSolutionsInput: Swift.Sendable {
    /// Specifies the catalog associated with the request. This field takes a string value from a predefined list: AWS or Sandbox. The catalog determines which environment the solutions are listed in. Use AWS to list solutions in the Amazon Web Services catalog, and Sandbox to list solutions in a secure and isolated testing environment.
    /// This member is required.
    public var catalog: Swift.String?
    /// Filters the solutions based on the category to which they belong. This allows partners to search for solutions within specific categories, such as Software, Consulting, or Managed Services.
    public var category: [Swift.String]?
    /// Filters the solutions based on their unique identifier. Use this filter to retrieve specific solutions by providing the solution's identifier for accurate results.
    public var identifier: [Swift.String]?
    /// The maximum number of results returned by a single call. This value must be provided in the next call to retrieve the next set of results. Default: 20
    public var maxResults: Swift.Int?
    /// A pagination token used to retrieve the next set of results in subsequent calls. This token is included in the response only if there are additional result pages available.
    public var nextToken: Swift.String?
    /// Object that configures sorting done on the response. Default Sort.SortBy is Identifier.
    public var sort: PartnerCentralSellingClientTypes.SolutionSort?
    /// Filters solutions based on their status. This filter helps partners manage their solution portfolios effectively.
    public var status: [PartnerCentralSellingClientTypes.SolutionStatus]?

    public init(
        catalog: Swift.String? = nil,
        category: [Swift.String]? = nil,
        identifier: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sort: PartnerCentralSellingClientTypes.SolutionSort? = nil,
        status: [PartnerCentralSellingClientTypes.SolutionStatus]? = nil
    ) {
        self.catalog = catalog
        self.category = category
        self.identifier = identifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
        self.status = status
    }
}

extension PartnerCentralSellingClientTypes {

    /// Specifies minimal information for the solution offered to solve the customer's business problem.
    public struct SolutionBase: Swift.Sendable {
        /// The SolutionBase structure provides essential information about a solution.
        public var arn: Swift.String?
        /// Specifies the catalog in which the solution is hosted, either AWS or Sandbox. This helps partners differentiate between live solutions and those in testing environments.
        /// This member is required.
        public var catalog: Swift.String?
        /// Specifies the solution category, which helps to categorize and organize the solutions partners offer. Valid values: Software Product | Consulting Service | Hardware Product | Communications Product | Professional Service | Managed Service | Value-Added Resale Amazon Web Services Service | Distribution Service | Training Service | Merger and Acquisition Advising Service.
        /// This member is required.
        public var category: Swift.String?
        /// Indicates the solution creation date. This is useful to track and audit.
        /// This member is required.
        public var createdDate: Foundation.Date?
        /// Enables the association of solutions (offerings) to opportunities.
        /// This member is required.
        public var id: Swift.String?
        /// Specifies the solution name.
        /// This member is required.
        public var name: Swift.String?
        /// Specifies the solution's current status, which indicates its state in the system. Valid values: Active | Inactive | Draft. The status helps partners and Amazon Web Services track the solution's lifecycle and availability. Filter for Active solutions for association to an opportunity.
        /// This member is required.
        public var status: PartnerCentralSellingClientTypes.SolutionStatus?

        public init(
            arn: Swift.String? = nil,
            catalog: Swift.String? = nil,
            category: Swift.String? = nil,
            createdDate: Foundation.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: PartnerCentralSellingClientTypes.SolutionStatus? = nil
        ) {
            self.arn = arn
            self.catalog = catalog
            self.category = category
            self.createdDate = createdDate
            self.id = id
            self.name = name
            self.status = status
        }
    }
}

public struct ListSolutionsOutput: Swift.Sendable {
    /// A pagination token used to retrieve the next set of results in subsequent calls. This token is included in the response only if there are additional result pages available.
    public var nextToken: Swift.String?
    /// An array with minimal details for solutions matching the request criteria.
    /// This member is required.
    public var solutionSummaries: [PartnerCentralSellingClientTypes.SolutionBase]?

    public init(
        nextToken: Swift.String? = nil,
        solutionSummaries: [PartnerCentralSellingClientTypes.SolutionBase]? = nil
    ) {
        self.nextToken = nextToken
        self.solutionSummaries = solutionSummaries
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map of the key-value pairs of the tag or tags to assign.
    /// This member is required.
    public var tags: [PartnerCentralSellingClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [PartnerCentralSellingClientTypes.Tag]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the key-value pairs for the tag or tags you want to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension PartnerCentralSellingClientTypes {

    /// Updates the context information for a lead with qualification status, customer details, and interaction data.
    public struct UpdateLeadContext: Swift.Sendable {
        /// Updated customer information associated with the lead.
        /// This member is required.
        public var customer: PartnerCentralSellingClientTypes.LeadCustomer?
        /// Updated interaction details for the lead context.
        public var interaction: PartnerCentralSellingClientTypes.LeadInteraction?
        /// The updated qualification status of the lead.
        public var qualificationStatus: Swift.String?

        public init(
            customer: PartnerCentralSellingClientTypes.LeadCustomer? = nil,
            interaction: PartnerCentralSellingClientTypes.LeadInteraction? = nil,
            qualificationStatus: Swift.String? = "Unqualified"
        ) {
            self.customer = customer
            self.interaction = interaction
            self.qualificationStatus = qualificationStatus
        }
    }
}

extension PartnerCentralSellingClientTypes {

    /// Represents the updated payload of an engagement context. The structure of this payload varies based on the context type being updated.
    public enum UpdateEngagementContextPayload: Swift.Sendable {
        /// Contains updated information about a lead when the context type is "Lead". This field is present only when updating a lead context within the engagement.
        case lead(PartnerCentralSellingClientTypes.UpdateLeadContext)
        /// The CustomerProjects structure in Engagements offers a flexible framework for managing customer-project relationships. It supports multiple customers per Engagement and multiple projects per customer, while also allowing for customers without projects and projects without specific customers. All Engagement members have full visibility of customers and their associated projects, enabling the capture of relevant context even when project details are not fully defined. This structure also facilitates targeted invitations, allowing partners to focus on specific customers and their business problems when sending Engagement invitations.
        case customerproject(PartnerCentralSellingClientTypes.CustomerProjectsContext)
        case sdkUnknown(Swift.String)
    }
}

public struct UpdateEngagementContextInput: Swift.Sendable {
    /// Specifies the catalog associated with the engagement context update request. This field takes a string value from a predefined list: AWS or Sandbox. The catalog determines which environment the engagement context is updated in.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the specific engagement context to be updated. This ensures that the correct context within the engagement is modified.
    /// This member is required.
    public var contextIdentifier: Swift.String?
    /// The unique identifier of the Engagement containing the context to be updated. This parameter ensures the context update is applied to the correct engagement.
    /// This member is required.
    public var engagementIdentifier: Swift.String?
    /// The timestamp when the engagement was last modified, used for optimistic concurrency control. This helps prevent conflicts when multiple users attempt to update the same engagement simultaneously.
    /// This member is required.
    public var engagementLastModifiedAt: Foundation.Date?
    /// Contains the updated contextual information for the engagement. The structure of this payload varies based on the context type specified in the Type field.
    /// This member is required.
    public var payload: PartnerCentralSellingClientTypes.UpdateEngagementContextPayload?
    /// Specifies the type of context being updated within the engagement. This field determines the structure and content of the context payload being modified.
    /// This member is required.
    public var type: PartnerCentralSellingClientTypes.EngagementContextType?

    public init(
        catalog: Swift.String? = nil,
        contextIdentifier: Swift.String? = nil,
        engagementIdentifier: Swift.String? = nil,
        engagementLastModifiedAt: Foundation.Date? = nil,
        payload: PartnerCentralSellingClientTypes.UpdateEngagementContextPayload? = nil,
        type: PartnerCentralSellingClientTypes.EngagementContextType? = nil
    ) {
        self.catalog = catalog
        self.contextIdentifier = contextIdentifier
        self.engagementIdentifier = engagementIdentifier
        self.engagementLastModifiedAt = engagementLastModifiedAt
        self.payload = payload
        self.type = type
    }
}

public struct UpdateEngagementContextOutput: Swift.Sendable {
    /// The unique identifier of the engagement context that was updated.
    /// This member is required.
    public var contextId: Swift.String?
    /// The Amazon Resource Name (ARN) of the updated engagement.
    /// This member is required.
    public var engagementArn: Swift.String?
    /// The unique identifier of the engagement that was updated.
    /// This member is required.
    public var engagementId: Swift.String?
    /// The timestamp when the engagement context was last modified.
    /// This member is required.
    public var engagementLastModifiedAt: Foundation.Date?

    public init(
        contextId: Swift.String? = nil,
        engagementArn: Swift.String? = nil,
        engagementId: Swift.String? = nil,
        engagementLastModifiedAt: Foundation.Date? = nil
    ) {
        self.contextId = contextId
        self.engagementArn = engagementArn
        self.engagementId = engagementId
        self.engagementLastModifiedAt = engagementLastModifiedAt
    }
}

extension AcceptEngagementInvitationInput {

    static func urlPathProvider(_ value: AcceptEngagementInvitationInput) -> Swift.String? {
        return "/"
    }
}

extension AssignOpportunityInput {

    static func urlPathProvider(_ value: AssignOpportunityInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateOpportunityInput {

    static func urlPathProvider(_ value: AssociateOpportunityInput) -> Swift.String? {
        return "/"
    }
}

extension CreateEngagementInput {

    static func urlPathProvider(_ value: CreateEngagementInput) -> Swift.String? {
        return "/"
    }
}

extension CreateEngagementContextInput {

    static func urlPathProvider(_ value: CreateEngagementContextInput) -> Swift.String? {
        return "/"
    }
}

extension CreateEngagementInvitationInput {

    static func urlPathProvider(_ value: CreateEngagementInvitationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateOpportunityInput {

    static func urlPathProvider(_ value: CreateOpportunityInput) -> Swift.String? {
        return "/"
    }
}

extension CreateResourceSnapshotInput {

    static func urlPathProvider(_ value: CreateResourceSnapshotInput) -> Swift.String? {
        return "/"
    }
}

extension CreateResourceSnapshotJobInput {

    static func urlPathProvider(_ value: CreateResourceSnapshotJobInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteResourceSnapshotJobInput {

    static func urlPathProvider(_ value: DeleteResourceSnapshotJobInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateOpportunityInput {

    static func urlPathProvider(_ value: DisassociateOpportunityInput) -> Swift.String? {
        return "/"
    }
}

extension GetAwsOpportunitySummaryInput {

    static func urlPathProvider(_ value: GetAwsOpportunitySummaryInput) -> Swift.String? {
        return "/"
    }
}

extension GetEngagementInput {

    static func urlPathProvider(_ value: GetEngagementInput) -> Swift.String? {
        return "/"
    }
}

extension GetEngagementInvitationInput {

    static func urlPathProvider(_ value: GetEngagementInvitationInput) -> Swift.String? {
        return "/"
    }
}

extension GetOpportunityInput {

    static func urlPathProvider(_ value: GetOpportunityInput) -> Swift.String? {
        return "/"
    }
}

extension GetResourceSnapshotInput {

    static func urlPathProvider(_ value: GetResourceSnapshotInput) -> Swift.String? {
        return "/"
    }
}

extension GetResourceSnapshotJobInput {

    static func urlPathProvider(_ value: GetResourceSnapshotJobInput) -> Swift.String? {
        return "/"
    }
}

extension GetSellingSystemSettingsInput {

    static func urlPathProvider(_ value: GetSellingSystemSettingsInput) -> Swift.String? {
        return "/"
    }
}

extension ListEngagementByAcceptingInvitationTasksInput {

    static func urlPathProvider(_ value: ListEngagementByAcceptingInvitationTasksInput) -> Swift.String? {
        return "/"
    }
}

extension ListEngagementFromOpportunityTasksInput {

    static func urlPathProvider(_ value: ListEngagementFromOpportunityTasksInput) -> Swift.String? {
        return "/"
    }
}

extension ListEngagementInvitationsInput {

    static func urlPathProvider(_ value: ListEngagementInvitationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListEngagementMembersInput {

    static func urlPathProvider(_ value: ListEngagementMembersInput) -> Swift.String? {
        return "/"
    }
}

extension ListEngagementResourceAssociationsInput {

    static func urlPathProvider(_ value: ListEngagementResourceAssociationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListEngagementsInput {

    static func urlPathProvider(_ value: ListEngagementsInput) -> Swift.String? {
        return "/"
    }
}

extension ListOpportunitiesInput {

    static func urlPathProvider(_ value: ListOpportunitiesInput) -> Swift.String? {
        return "/"
    }
}

extension ListOpportunityFromEngagementTasksInput {

    static func urlPathProvider(_ value: ListOpportunityFromEngagementTasksInput) -> Swift.String? {
        return "/"
    }
}

extension ListResourceSnapshotJobsInput {

    static func urlPathProvider(_ value: ListResourceSnapshotJobsInput) -> Swift.String? {
        return "/"
    }
}

extension ListResourceSnapshotsInput {

    static func urlPathProvider(_ value: ListResourceSnapshotsInput) -> Swift.String? {
        return "/"
    }
}

extension ListSolutionsInput {

    static func urlPathProvider(_ value: ListSolutionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension PutSellingSystemSettingsInput {

    static func urlPathProvider(_ value: PutSellingSystemSettingsInput) -> Swift.String? {
        return "/"
    }
}

extension RejectEngagementInvitationInput {

    static func urlPathProvider(_ value: RejectEngagementInvitationInput) -> Swift.String? {
        return "/"
    }
}

extension StartEngagementByAcceptingInvitationTaskInput {

    static func urlPathProvider(_ value: StartEngagementByAcceptingInvitationTaskInput) -> Swift.String? {
        return "/"
    }
}

extension StartEngagementFromOpportunityTaskInput {

    static func urlPathProvider(_ value: StartEngagementFromOpportunityTaskInput) -> Swift.String? {
        return "/"
    }
}

extension StartOpportunityFromEngagementTaskInput {

    static func urlPathProvider(_ value: StartOpportunityFromEngagementTaskInput) -> Swift.String? {
        return "/"
    }
}

extension StartResourceSnapshotJobInput {

    static func urlPathProvider(_ value: StartResourceSnapshotJobInput) -> Swift.String? {
        return "/"
    }
}

extension StopResourceSnapshotJobInput {

    static func urlPathProvider(_ value: StopResourceSnapshotJobInput) -> Swift.String? {
        return "/"
    }
}

extension SubmitOpportunityInput {

    static func urlPathProvider(_ value: SubmitOpportunityInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateEngagementContextInput {

    static func urlPathProvider(_ value: UpdateEngagementContextInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateOpportunityInput {

    static func urlPathProvider(_ value: UpdateOpportunityInput) -> Swift.String? {
        return "/"
    }
}

extension AcceptEngagementInvitationInput {

    static func write(value: AcceptEngagementInvitationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Identifier"].write(value.identifier)
    }
}

extension AssignOpportunityInput {

    static func write(value: AssignOpportunityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Assignee"].write(value.assignee, with: PartnerCentralSellingClientTypes.AssigneeContact.write(value:to:))
        try writer["Catalog"].write(value.catalog)
        try writer["Identifier"].write(value.identifier)
    }
}

extension AssociateOpportunityInput {

    static func write(value: AssociateOpportunityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["OpportunityIdentifier"].write(value.opportunityIdentifier)
        try writer["RelatedEntityIdentifier"].write(value.relatedEntityIdentifier)
        try writer["RelatedEntityType"].write(value.relatedEntityType)
    }
}

extension CreateEngagementInput {

    static func write(value: CreateEngagementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Contexts"].writeList(value.contexts, memberWritingClosure: PartnerCentralSellingClientTypes.EngagementContextDetails.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Description"].write(value.description)
        try writer["Title"].write(value.title)
    }
}

extension CreateEngagementContextInput {

    static func write(value: CreateEngagementContextInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["EngagementIdentifier"].write(value.engagementIdentifier)
        try writer["Payload"].write(value.payload, with: PartnerCentralSellingClientTypes.EngagementContextPayload.write(value:to:))
        try writer["Type"].write(value.type)
    }
}

extension CreateEngagementInvitationInput {

    static func write(value: CreateEngagementInvitationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["EngagementIdentifier"].write(value.engagementIdentifier)
        try writer["Invitation"].write(value.invitation, with: PartnerCentralSellingClientTypes.Invitation.write(value:to:))
    }
}

extension CreateOpportunityInput {

    static func write(value: CreateOpportunityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Customer"].write(value.customer, with: PartnerCentralSellingClientTypes.Customer.write(value:to:))
        try writer["LifeCycle"].write(value.lifeCycle, with: PartnerCentralSellingClientTypes.LifeCycle.write(value:to:))
        try writer["Marketing"].write(value.marketing, with: PartnerCentralSellingClientTypes.Marketing.write(value:to:))
        try writer["NationalSecurity"].write(value.nationalSecurity)
        try writer["OpportunityTeam"].writeList(value.opportunityTeam, memberWritingClosure: PartnerCentralSellingClientTypes.Contact.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OpportunityType"].write(value.opportunityType)
        try writer["Origin"].write(value.origin)
        try writer["PartnerOpportunityIdentifier"].write(value.partnerOpportunityIdentifier)
        try writer["PrimaryNeedsFromAws"].writeList(value.primaryNeedsFromAws, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralSellingClientTypes.PrimaryNeedFromAws>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Project"].write(value.project, with: PartnerCentralSellingClientTypes.Project.write(value:to:))
        try writer["SoftwareRevenue"].write(value.softwareRevenue, with: PartnerCentralSellingClientTypes.SoftwareRevenue.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PartnerCentralSellingClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateResourceSnapshotInput {

    static func write(value: CreateResourceSnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["EngagementIdentifier"].write(value.engagementIdentifier)
        try writer["ResourceIdentifier"].write(value.resourceIdentifier)
        try writer["ResourceSnapshotTemplateIdentifier"].write(value.resourceSnapshotTemplateIdentifier)
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension CreateResourceSnapshotJobInput {

    static func write(value: CreateResourceSnapshotJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["EngagementIdentifier"].write(value.engagementIdentifier)
        try writer["ResourceIdentifier"].write(value.resourceIdentifier)
        try writer["ResourceSnapshotTemplateIdentifier"].write(value.resourceSnapshotTemplateIdentifier)
        try writer["ResourceType"].write(value.resourceType)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PartnerCentralSellingClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteResourceSnapshotJobInput {

    static func write(value: DeleteResourceSnapshotJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ResourceSnapshotJobIdentifier"].write(value.resourceSnapshotJobIdentifier)
    }
}

extension DisassociateOpportunityInput {

    static func write(value: DisassociateOpportunityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["OpportunityIdentifier"].write(value.opportunityIdentifier)
        try writer["RelatedEntityIdentifier"].write(value.relatedEntityIdentifier)
        try writer["RelatedEntityType"].write(value.relatedEntityType)
    }
}

extension GetAwsOpportunitySummaryInput {

    static func write(value: GetAwsOpportunitySummaryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["RelatedOpportunityIdentifier"].write(value.relatedOpportunityIdentifier)
    }
}

extension GetEngagementInput {

    static func write(value: GetEngagementInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Identifier"].write(value.identifier)
    }
}

extension GetEngagementInvitationInput {

    static func write(value: GetEngagementInvitationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Identifier"].write(value.identifier)
    }
}

extension GetOpportunityInput {

    static func write(value: GetOpportunityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Identifier"].write(value.identifier)
    }
}

extension GetResourceSnapshotInput {

    static func write(value: GetResourceSnapshotInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["EngagementIdentifier"].write(value.engagementIdentifier)
        try writer["ResourceIdentifier"].write(value.resourceIdentifier)
        try writer["ResourceSnapshotTemplateIdentifier"].write(value.resourceSnapshotTemplateIdentifier)
        try writer["ResourceType"].write(value.resourceType)
        try writer["Revision"].write(value.revision)
    }
}

extension GetResourceSnapshotJobInput {

    static func write(value: GetResourceSnapshotJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ResourceSnapshotJobIdentifier"].write(value.resourceSnapshotJobIdentifier)
    }
}

extension GetSellingSystemSettingsInput {

    static func write(value: GetSellingSystemSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
    }
}

extension ListEngagementByAcceptingInvitationTasksInput {

    static func write(value: ListEngagementByAcceptingInvitationTasksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["EngagementInvitationIdentifier"].writeList(value.engagementInvitationIdentifier, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OpportunityIdentifier"].writeList(value.opportunityIdentifier, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Sort"].write(value.sort, with: PartnerCentralSellingClientTypes.ListTasksSortBase.write(value:to:))
        try writer["TaskIdentifier"].writeList(value.taskIdentifier, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TaskStatus"].writeList(value.taskStatus, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralSellingClientTypes.TaskStatus>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListEngagementFromOpportunityTasksInput {

    static func write(value: ListEngagementFromOpportunityTasksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["EngagementIdentifier"].writeList(value.engagementIdentifier, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OpportunityIdentifier"].writeList(value.opportunityIdentifier, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Sort"].write(value.sort, with: PartnerCentralSellingClientTypes.ListTasksSortBase.write(value:to:))
        try writer["TaskIdentifier"].writeList(value.taskIdentifier, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TaskStatus"].writeList(value.taskStatus, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralSellingClientTypes.TaskStatus>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListEngagementInvitationsInput {

    static func write(value: ListEngagementInvitationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["EngagementIdentifier"].writeList(value.engagementIdentifier, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ParticipantType"].write(value.participantType)
        try writer["PayloadType"].writeList(value.payloadType, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralSellingClientTypes.EngagementInvitationPayloadType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SenderAwsAccountId"].writeList(value.senderAwsAccountId, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Sort"].write(value.sort, with: PartnerCentralSellingClientTypes.OpportunityEngagementInvitationSort.write(value:to:))
        try writer["Status"].writeList(value.status, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralSellingClientTypes.InvitationStatus>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListEngagementMembersInput {

    static func write(value: ListEngagementMembersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Identifier"].write(value.identifier)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListEngagementResourceAssociationsInput {

    static func write(value: ListEngagementResourceAssociationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["CreatedBy"].write(value.createdBy)
        try writer["EngagementIdentifier"].write(value.engagementIdentifier)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceIdentifier"].write(value.resourceIdentifier)
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension ListEngagementsInput {

    static func write(value: ListEngagementsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ContextTypes"].writeList(value.contextTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralSellingClientTypes.EngagementContextType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CreatedBy"].writeList(value.createdBy, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EngagementIdentifier"].writeList(value.engagementIdentifier, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExcludeContextTypes"].writeList(value.excludeContextTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralSellingClientTypes.EngagementContextType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExcludeCreatedBy"].writeList(value.excludeCreatedBy, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Sort"].write(value.sort, with: PartnerCentralSellingClientTypes.EngagementSort.write(value:to:))
    }
}

extension ListOpportunitiesInput {

    static func write(value: ListOpportunitiesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["CreatedDate"].write(value.createdDate, with: PartnerCentralSellingClientTypes.CreatedDateFilter.write(value:to:))
        try writer["CustomerCompanyName"].writeList(value.customerCompanyName, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Identifier"].writeList(value.identifier, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LastModifiedDate"].write(value.lastModifiedDate, with: PartnerCentralSellingClientTypes.LastModifiedDate.write(value:to:))
        try writer["LifeCycleReviewStatus"].writeList(value.lifeCycleReviewStatus, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralSellingClientTypes.ReviewStatus>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LifeCycleStage"].writeList(value.lifeCycleStage, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralSellingClientTypes.Stage>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Sort"].write(value.sort, with: PartnerCentralSellingClientTypes.OpportunitySort.write(value:to:))
    }
}

extension ListOpportunityFromEngagementTasksInput {

    static func write(value: ListOpportunityFromEngagementTasksInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ContextIdentifier"].writeList(value.contextIdentifier, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["EngagementIdentifier"].writeList(value.engagementIdentifier, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OpportunityIdentifier"].writeList(value.opportunityIdentifier, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Sort"].write(value.sort, with: PartnerCentralSellingClientTypes.ListTasksSortBase.write(value:to:))
        try writer["TaskIdentifier"].writeList(value.taskIdentifier, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TaskStatus"].writeList(value.taskStatus, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralSellingClientTypes.TaskStatus>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListResourceSnapshotJobsInput {

    static func write(value: ListResourceSnapshotJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["EngagementIdentifier"].write(value.engagementIdentifier)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Sort"].write(value.sort, with: PartnerCentralSellingClientTypes.SortObject.write(value:to:))
        try writer["Status"].write(value.status)
    }
}

extension ListResourceSnapshotsInput {

    static func write(value: ListResourceSnapshotsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["CreatedBy"].write(value.createdBy)
        try writer["EngagementIdentifier"].write(value.engagementIdentifier)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceIdentifier"].write(value.resourceIdentifier)
        try writer["ResourceSnapshotTemplateIdentifier"].write(value.resourceSnapshotTemplateIdentifier)
        try writer["ResourceType"].write(value.resourceType)
    }
}

extension ListSolutionsInput {

    static func write(value: ListSolutionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Category"].writeList(value.category, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Identifier"].writeList(value.identifier, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Sort"].write(value.sort, with: PartnerCentralSellingClientTypes.SolutionSort.write(value:to:))
        try writer["Status"].writeList(value.status, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralSellingClientTypes.SolutionStatus>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension PutSellingSystemSettingsInput {

    static func write(value: PutSellingSystemSettingsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ResourceSnapshotJobRoleIdentifier"].write(value.resourceSnapshotJobRoleIdentifier)
    }
}

extension RejectEngagementInvitationInput {

    static func write(value: RejectEngagementInvitationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Identifier"].write(value.identifier)
        try writer["RejectionReason"].write(value.rejectionReason)
    }
}

extension StartEngagementByAcceptingInvitationTaskInput {

    static func write(value: StartEngagementByAcceptingInvitationTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Identifier"].write(value.identifier)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PartnerCentralSellingClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartEngagementFromOpportunityTaskInput {

    static func write(value: StartEngagementFromOpportunityTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsSubmission"].write(value.awsSubmission, with: PartnerCentralSellingClientTypes.AwsSubmission.write(value:to:))
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Identifier"].write(value.identifier)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PartnerCentralSellingClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartOpportunityFromEngagementTaskInput {

    static func write(value: StartOpportunityFromEngagementTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["ContextIdentifier"].write(value.contextIdentifier)
        try writer["Identifier"].write(value.identifier)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PartnerCentralSellingClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartResourceSnapshotJobInput {

    static func write(value: StartResourceSnapshotJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ResourceSnapshotJobIdentifier"].write(value.resourceSnapshotJobIdentifier)
    }
}

extension StopResourceSnapshotJobInput {

    static func write(value: StopResourceSnapshotJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ResourceSnapshotJobIdentifier"].write(value.resourceSnapshotJobIdentifier)
    }
}

extension SubmitOpportunityInput {

    static func write(value: SubmitOpportunityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Identifier"].write(value.identifier)
        try writer["InvolvementType"].write(value.involvementType)
        try writer["Visibility"].write(value.visibility)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PartnerCentralSellingClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateEngagementContextInput {

    static func write(value: UpdateEngagementContextInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ContextIdentifier"].write(value.contextIdentifier)
        try writer["EngagementIdentifier"].write(value.engagementIdentifier)
        try writer["EngagementLastModifiedAt"].writeTimestamp(value.engagementLastModifiedAt, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["Payload"].write(value.payload, with: PartnerCentralSellingClientTypes.UpdateEngagementContextPayload.write(value:to:))
        try writer["Type"].write(value.type)
    }
}

extension UpdateOpportunityInput {

    static func write(value: UpdateOpportunityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Customer"].write(value.customer, with: PartnerCentralSellingClientTypes.Customer.write(value:to:))
        try writer["Identifier"].write(value.identifier)
        try writer["LastModifiedDate"].writeTimestamp(value.lastModifiedDate, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["LifeCycle"].write(value.lifeCycle, with: PartnerCentralSellingClientTypes.LifeCycle.write(value:to:))
        try writer["Marketing"].write(value.marketing, with: PartnerCentralSellingClientTypes.Marketing.write(value:to:))
        try writer["NationalSecurity"].write(value.nationalSecurity)
        try writer["OpportunityType"].write(value.opportunityType)
        try writer["PartnerOpportunityIdentifier"].write(value.partnerOpportunityIdentifier)
        try writer["PrimaryNeedsFromAws"].writeList(value.primaryNeedsFromAws, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralSellingClientTypes.PrimaryNeedFromAws>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Project"].write(value.project, with: PartnerCentralSellingClientTypes.Project.write(value:to:))
        try writer["SoftwareRevenue"].write(value.softwareRevenue, with: PartnerCentralSellingClientTypes.SoftwareRevenue.write(value:to:))
    }
}

extension AcceptEngagementInvitationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AcceptEngagementInvitationOutput {
        return AcceptEngagementInvitationOutput()
    }
}

extension AssignOpportunityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssignOpportunityOutput {
        return AssignOpportunityOutput()
    }
}

extension AssociateOpportunityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateOpportunityOutput {
        return AssociateOpportunityOutput()
    }
}

extension CreateEngagementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEngagementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEngagementOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.modifiedAt = try reader["ModifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension CreateEngagementContextOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEngagementContextOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEngagementContextOutput()
        value.contextId = try reader["ContextId"].readIfPresent()
        value.engagementArn = try reader["EngagementArn"].readIfPresent()
        value.engagementId = try reader["EngagementId"].readIfPresent()
        value.engagementLastModifiedAt = try reader["EngagementLastModifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        return value
    }
}

extension CreateEngagementInvitationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEngagementInvitationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEngagementInvitationOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        return value
    }
}

extension CreateOpportunityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateOpportunityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateOpportunityOutput()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.lastModifiedDate = try reader["LastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.partnerOpportunityIdentifier = try reader["PartnerOpportunityIdentifier"].readIfPresent()
        return value
    }
}

extension CreateResourceSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateResourceSnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateResourceSnapshotOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.revision = try reader["Revision"].readIfPresent()
        return value
    }
}

extension CreateResourceSnapshotJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateResourceSnapshotJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateResourceSnapshotJobOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        return value
    }
}

extension DeleteResourceSnapshotJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteResourceSnapshotJobOutput {
        return DeleteResourceSnapshotJobOutput()
    }
}

extension DisassociateOpportunityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateOpportunityOutput {
        return DisassociateOpportunityOutput()
    }
}

extension GetAwsOpportunitySummaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAwsOpportunitySummaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAwsOpportunitySummaryOutput()
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.customer = try reader["Customer"].readIfPresent(with: PartnerCentralSellingClientTypes.AwsOpportunityCustomer.read(from:))
        value.insights = try reader["Insights"].readIfPresent(with: PartnerCentralSellingClientTypes.AwsOpportunityInsights.read(from:))
        value.involvementType = try reader["InvolvementType"].readIfPresent()
        value.involvementTypeChangeReason = try reader["InvolvementTypeChangeReason"].readIfPresent()
        value.lifeCycle = try reader["LifeCycle"].readIfPresent(with: PartnerCentralSellingClientTypes.AwsOpportunityLifeCycle.read(from:))
        value.opportunityTeam = try reader["OpportunityTeam"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.AwsTeamMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.origin = try reader["Origin"].readIfPresent()
        value.project = try reader["Project"].readIfPresent(with: PartnerCentralSellingClientTypes.AwsOpportunityProject.read(from:))
        value.relatedEntityIds = try reader["RelatedEntityIds"].readIfPresent(with: PartnerCentralSellingClientTypes.AwsOpportunityRelatedEntities.read(from:))
        value.relatedOpportunityId = try reader["RelatedOpportunityId"].readIfPresent()
        value.visibility = try reader["Visibility"].readIfPresent()
        return value
    }
}

extension GetEngagementOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEngagementOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEngagementOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.contexts = try reader["Contexts"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.EngagementContextDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["CreatedBy"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.memberCount = try reader["MemberCount"].readIfPresent()
        value.modifiedAt = try reader["ModifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.modifiedBy = try reader["ModifiedBy"].readIfPresent()
        value.title = try reader["Title"].readIfPresent()
        return value
    }
}

extension GetEngagementInvitationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEngagementInvitationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEngagementInvitationOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.engagementDescription = try reader["EngagementDescription"].readIfPresent()
        value.engagementId = try reader["EngagementId"].readIfPresent()
        value.engagementTitle = try reader["EngagementTitle"].readIfPresent()
        value.existingMembers = try reader["ExistingMembers"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.EngagementMemberSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.expirationDate = try reader["ExpirationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.invitationDate = try reader["InvitationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.invitationMessage = try reader["InvitationMessage"].readIfPresent()
        value.payload = try reader["Payload"].readIfPresent(with: PartnerCentralSellingClientTypes.Payload.read(from:))
        value.payloadType = try reader["PayloadType"].readIfPresent()
        value.receiver = try reader["Receiver"].readIfPresent(with: PartnerCentralSellingClientTypes.Receiver.read(from:))
        value.rejectionReason = try reader["RejectionReason"].readIfPresent()
        value.senderAwsAccountId = try reader["SenderAwsAccountId"].readIfPresent()
        value.senderCompanyName = try reader["SenderCompanyName"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension GetOpportunityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetOpportunityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOpportunityOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.customer = try reader["Customer"].readIfPresent(with: PartnerCentralSellingClientTypes.Customer.read(from:))
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.lastModifiedDate = try reader["LastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lifeCycle = try reader["LifeCycle"].readIfPresent(with: PartnerCentralSellingClientTypes.LifeCycle.read(from:))
        value.marketing = try reader["Marketing"].readIfPresent(with: PartnerCentralSellingClientTypes.Marketing.read(from:))
        value.nationalSecurity = try reader["NationalSecurity"].readIfPresent()
        value.opportunityTeam = try reader["OpportunityTeam"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.Contact.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.opportunityType = try reader["OpportunityType"].readIfPresent()
        value.partnerOpportunityIdentifier = try reader["PartnerOpportunityIdentifier"].readIfPresent()
        value.primaryNeedsFromAws = try reader["PrimaryNeedsFromAws"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PartnerCentralSellingClientTypes.PrimaryNeedFromAws>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.project = try reader["Project"].readIfPresent(with: PartnerCentralSellingClientTypes.Project.read(from:))
        value.relatedEntityIdentifiers = try reader["RelatedEntityIdentifiers"].readIfPresent(with: PartnerCentralSellingClientTypes.RelatedEntityIdentifiers.read(from:))
        value.softwareRevenue = try reader["SoftwareRevenue"].readIfPresent(with: PartnerCentralSellingClientTypes.SoftwareRevenue.read(from:))
        return value
    }
}

extension GetResourceSnapshotOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourceSnapshotOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceSnapshotOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["CreatedBy"].readIfPresent()
        value.engagementId = try reader["EngagementId"].readIfPresent()
        value.payload = try reader["Payload"].readIfPresent(with: PartnerCentralSellingClientTypes.ResourceSnapshotPayload.read(from:))
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.resourceSnapshotTemplateName = try reader["ResourceSnapshotTemplateName"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.revision = try reader["Revision"].readIfPresent()
        value.targetMemberAccounts = try reader["TargetMemberAccounts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetResourceSnapshotJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourceSnapshotJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourceSnapshotJobOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.engagementId = try reader["EngagementId"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.lastFailure = try reader["LastFailure"].readIfPresent()
        value.lastSuccessfulExecutionDate = try reader["LastSuccessfulExecutionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.resourceArn = try reader["ResourceArn"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.resourceSnapshotTemplateName = try reader["ResourceSnapshotTemplateName"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension GetSellingSystemSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSellingSystemSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSellingSystemSettingsOutput()
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.resourceSnapshotJobRoleArn = try reader["ResourceSnapshotJobRoleArn"].readIfPresent()
        return value
    }
}

extension ListEngagementByAcceptingInvitationTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEngagementByAcceptingInvitationTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEngagementByAcceptingInvitationTasksOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.taskSummaries = try reader["TaskSummaries"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.ListEngagementByAcceptingInvitationTaskSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListEngagementFromOpportunityTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEngagementFromOpportunityTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEngagementFromOpportunityTasksOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.taskSummaries = try reader["TaskSummaries"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.ListEngagementFromOpportunityTaskSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListEngagementInvitationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEngagementInvitationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEngagementInvitationsOutput()
        value.engagementInvitationSummaries = try reader["EngagementInvitationSummaries"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.EngagementInvitationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListEngagementMembersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEngagementMembersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEngagementMembersOutput()
        value.engagementMemberList = try reader["EngagementMemberList"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.EngagementMember.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListEngagementResourceAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEngagementResourceAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEngagementResourceAssociationsOutput()
        value.engagementResourceAssociationSummaries = try reader["EngagementResourceAssociationSummaries"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.EngagementResourceAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListEngagementsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEngagementsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEngagementsOutput()
        value.engagementSummaryList = try reader["EngagementSummaryList"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.EngagementSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListOpportunitiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOpportunitiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOpportunitiesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.opportunitySummaries = try reader["OpportunitySummaries"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.OpportunitySummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListOpportunityFromEngagementTasksOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListOpportunityFromEngagementTasksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOpportunityFromEngagementTasksOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.taskSummaries = try reader["TaskSummaries"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.ListOpportunityFromEngagementTaskSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListResourceSnapshotJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourceSnapshotJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourceSnapshotJobsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resourceSnapshotJobSummaries = try reader["ResourceSnapshotJobSummaries"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.ResourceSnapshotJobSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListResourceSnapshotsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListResourceSnapshotsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListResourceSnapshotsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.resourceSnapshotSummaries = try reader["ResourceSnapshotSummaries"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.ResourceSnapshotSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListSolutionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSolutionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSolutionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.solutionSummaries = try reader["SolutionSummaries"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.SolutionBase.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PutSellingSystemSettingsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutSellingSystemSettingsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutSellingSystemSettingsOutput()
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.resourceSnapshotJobRoleArn = try reader["ResourceSnapshotJobRoleArn"].readIfPresent()
        return value
    }
}

extension RejectEngagementInvitationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RejectEngagementInvitationOutput {
        return RejectEngagementInvitationOutput()
    }
}

extension StartEngagementByAcceptingInvitationTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartEngagementByAcceptingInvitationTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartEngagementByAcceptingInvitationTaskOutput()
        value.engagementInvitationId = try reader["EngagementInvitationId"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.opportunityId = try reader["OpportunityId"].readIfPresent()
        value.reasonCode = try reader["ReasonCode"].readIfPresent()
        value.resourceSnapshotJobId = try reader["ResourceSnapshotJobId"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.taskArn = try reader["TaskArn"].readIfPresent()
        value.taskId = try reader["TaskId"].readIfPresent()
        value.taskStatus = try reader["TaskStatus"].readIfPresent()
        return value
    }
}

extension StartEngagementFromOpportunityTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartEngagementFromOpportunityTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartEngagementFromOpportunityTaskOutput()
        value.engagementId = try reader["EngagementId"].readIfPresent()
        value.engagementInvitationId = try reader["EngagementInvitationId"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.opportunityId = try reader["OpportunityId"].readIfPresent()
        value.reasonCode = try reader["ReasonCode"].readIfPresent()
        value.resourceSnapshotJobId = try reader["ResourceSnapshotJobId"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.taskArn = try reader["TaskArn"].readIfPresent()
        value.taskId = try reader["TaskId"].readIfPresent()
        value.taskStatus = try reader["TaskStatus"].readIfPresent()
        return value
    }
}

extension StartOpportunityFromEngagementTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartOpportunityFromEngagementTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartOpportunityFromEngagementTaskOutput()
        value.contextId = try reader["ContextId"].readIfPresent()
        value.engagementId = try reader["EngagementId"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.opportunityId = try reader["OpportunityId"].readIfPresent()
        value.reasonCode = try reader["ReasonCode"].readIfPresent()
        value.resourceSnapshotJobId = try reader["ResourceSnapshotJobId"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.taskArn = try reader["TaskArn"].readIfPresent()
        value.taskId = try reader["TaskId"].readIfPresent()
        value.taskStatus = try reader["TaskStatus"].readIfPresent()
        return value
    }
}

extension StartResourceSnapshotJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartResourceSnapshotJobOutput {
        return StartResourceSnapshotJobOutput()
    }
}

extension StopResourceSnapshotJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopResourceSnapshotJobOutput {
        return StopResourceSnapshotJobOutput()
    }
}

extension SubmitOpportunityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SubmitOpportunityOutput {
        return SubmitOpportunityOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateEngagementContextOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEngagementContextOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEngagementContextOutput()
        value.contextId = try reader["ContextId"].readIfPresent() ?? ""
        value.engagementArn = try reader["EngagementArn"].readIfPresent() ?? ""
        value.engagementId = try reader["EngagementId"].readIfPresent() ?? ""
        value.engagementLastModifiedAt = try reader["EngagementLastModifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension UpdateOpportunityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateOpportunityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateOpportunityOutput()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.lastModifiedDate = try reader["LastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

enum AcceptEngagementInvitationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssignOpportunityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateOpportunityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEngagementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEngagementContextOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEngagementInvitationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateOpportunityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateResourceSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateResourceSnapshotJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteResourceSnapshotJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateOpportunityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAwsOpportunitySummaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEngagementOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEngagementInvitationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetOpportunityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourceSnapshotOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourceSnapshotJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSellingSystemSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEngagementByAcceptingInvitationTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEngagementFromOpportunityTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEngagementInvitationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEngagementMembersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEngagementResourceAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEngagementsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOpportunitiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListOpportunityFromEngagementTasksOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourceSnapshotJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListResourceSnapshotsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSolutionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutSellingSystemSettingsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RejectEngagementInvitationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartEngagementByAcceptingInvitationTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartEngagementFromOpportunityTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartOpportunityFromEngagementTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartResourceSnapshotJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopResourceSnapshotJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SubmitOpportunityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEngagementContextOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateOpportunityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.reason = try reader["Reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.errorList = try reader["ErrorList"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.ValidationExceptionError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PartnerCentralSellingClientTypes.Account {

    static func write(value: PartnerCentralSellingClientTypes.Account?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address"].write(value.address, with: PartnerCentralSellingClientTypes.Address.write(value:to:))
        try writer["AwsAccountId"].write(value.awsAccountId)
        try writer["CompanyName"].write(value.companyName)
        try writer["Duns"].write(value.duns)
        try writer["Industry"].write(value.industry)
        try writer["OtherIndustry"].write(value.otherIndustry)
        try writer["WebsiteUrl"].write(value.websiteUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.Account {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.Account()
        value.industry = try reader["Industry"].readIfPresent()
        value.otherIndustry = try reader["OtherIndustry"].readIfPresent()
        value.companyName = try reader["CompanyName"].readIfPresent() ?? ""
        value.websiteUrl = try reader["WebsiteUrl"].readIfPresent()
        value.awsAccountId = try reader["AwsAccountId"].readIfPresent()
        value.address = try reader["Address"].readIfPresent(with: PartnerCentralSellingClientTypes.Address.read(from:))
        value.duns = try reader["Duns"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.AccountReceiver {

    static func write(value: PartnerCentralSellingClientTypes.AccountReceiver?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Alias"].write(value.alias)
        try writer["AwsAccountId"].write(value.awsAccountId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.AccountReceiver {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.AccountReceiver()
        value.alias = try reader["Alias"].readIfPresent()
        value.awsAccountId = try reader["AwsAccountId"].readIfPresent() ?? ""
        return value
    }
}

extension PartnerCentralSellingClientTypes.AccountSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.AccountSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.AccountSummary()
        value.industry = try reader["Industry"].readIfPresent()
        value.otherIndustry = try reader["OtherIndustry"].readIfPresent()
        value.companyName = try reader["CompanyName"].readIfPresent() ?? ""
        value.websiteUrl = try reader["WebsiteUrl"].readIfPresent()
        value.address = try reader["Address"].readIfPresent(with: PartnerCentralSellingClientTypes.AddressSummary.read(from:))
        return value
    }
}

extension PartnerCentralSellingClientTypes.Address {

    static func write(value: PartnerCentralSellingClientTypes.Address?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["City"].write(value.city)
        try writer["CountryCode"].write(value.countryCode)
        try writer["PostalCode"].write(value.postalCode)
        try writer["StateOrRegion"].write(value.stateOrRegion)
        try writer["StreetAddress"].write(value.streetAddress)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.Address {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.Address()
        value.city = try reader["City"].readIfPresent()
        value.postalCode = try reader["PostalCode"].readIfPresent()
        value.stateOrRegion = try reader["StateOrRegion"].readIfPresent()
        value.countryCode = try reader["CountryCode"].readIfPresent()
        value.streetAddress = try reader["StreetAddress"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.AddressSummary {

    static func write(value: PartnerCentralSellingClientTypes.AddressSummary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["City"].write(value.city)
        try writer["CountryCode"].write(value.countryCode)
        try writer["PostalCode"].write(value.postalCode)
        try writer["StateOrRegion"].write(value.stateOrRegion)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.AddressSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.AddressSummary()
        value.city = try reader["City"].readIfPresent()
        value.postalCode = try reader["PostalCode"].readIfPresent()
        value.stateOrRegion = try reader["StateOrRegion"].readIfPresent()
        value.countryCode = try reader["CountryCode"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.AssigneeContact {

    static func write(value: PartnerCentralSellingClientTypes.AssigneeContact?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BusinessTitle"].write(value.businessTitle)
        try writer["Email"].write(value.email)
        try writer["FirstName"].write(value.firstName)
        try writer["LastName"].write(value.lastName)
        try writer["Phone"].write(value.phone)
    }
}

extension PartnerCentralSellingClientTypes.AwsOpportunityCustomer {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.AwsOpportunityCustomer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.AwsOpportunityCustomer()
        value.contacts = try reader["Contacts"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.Contact.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PartnerCentralSellingClientTypes.AwsOpportunityInsights {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.AwsOpportunityInsights {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.AwsOpportunityInsights()
        value.nextBestActions = try reader["NextBestActions"].readIfPresent()
        value.engagementScore = try reader["EngagementScore"].readIfPresent()
        value.awsProductsSpendInsightsBySource = try reader["AwsProductsSpendInsightsBySource"].readIfPresent(with: PartnerCentralSellingClientTypes.AwsProductsSpendInsightsBySource.read(from:))
        return value
    }
}

extension PartnerCentralSellingClientTypes.AwsOpportunityLifeCycle {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.AwsOpportunityLifeCycle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.AwsOpportunityLifeCycle()
        value.targetCloseDate = try reader["TargetCloseDate"].readIfPresent()
        value.closedLostReason = try reader["ClosedLostReason"].readIfPresent()
        value.stage = try reader["Stage"].readIfPresent()
        value.nextSteps = try reader["NextSteps"].readIfPresent()
        value.nextStepsHistory = try reader["NextStepsHistory"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.ProfileNextStepsHistory.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PartnerCentralSellingClientTypes.AwsOpportunityProject {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.AwsOpportunityProject {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.AwsOpportunityProject()
        value.expectedCustomerSpend = try reader["ExpectedCustomerSpend"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.ExpectedCustomerSpend.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.awsPartition = try reader["AwsPartition"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.AwsOpportunityRelatedEntities {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.AwsOpportunityRelatedEntities {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.AwsOpportunityRelatedEntities()
        value.awsProducts = try reader["AwsProducts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.solutions = try reader["Solutions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PartnerCentralSellingClientTypes.AwsOpportunitySummaryFullView {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.AwsOpportunitySummaryFullView {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.AwsOpportunitySummaryFullView()
        value.relatedOpportunityId = try reader["RelatedOpportunityId"].readIfPresent()
        value.origin = try reader["Origin"].readIfPresent()
        value.involvementType = try reader["InvolvementType"].readIfPresent()
        value.visibility = try reader["Visibility"].readIfPresent()
        value.lifeCycle = try reader["LifeCycle"].readIfPresent(with: PartnerCentralSellingClientTypes.AwsOpportunityLifeCycle.read(from:))
        value.opportunityTeam = try reader["OpportunityTeam"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.AwsTeamMember.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.insights = try reader["Insights"].readIfPresent(with: PartnerCentralSellingClientTypes.AwsOpportunityInsights.read(from:))
        value.involvementTypeChangeReason = try reader["InvolvementTypeChangeReason"].readIfPresent()
        value.relatedEntityIds = try reader["RelatedEntityIds"].readIfPresent(with: PartnerCentralSellingClientTypes.AwsOpportunityRelatedEntities.read(from:))
        value.customer = try reader["Customer"].readIfPresent(with: PartnerCentralSellingClientTypes.AwsOpportunityCustomer.read(from:))
        value.project = try reader["Project"].readIfPresent(with: PartnerCentralSellingClientTypes.AwsOpportunityProject.read(from:))
        return value
    }
}

extension PartnerCentralSellingClientTypes.AwsProductDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.AwsProductDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.AwsProductDetails()
        value.productCode = try reader["ProductCode"].readIfPresent() ?? ""
        value.serviceCode = try reader["ServiceCode"].readIfPresent()
        value.categories = try reader["Categories"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.amount = try reader["Amount"].readIfPresent()
        value.optimizedAmount = try reader["OptimizedAmount"].readIfPresent()
        value.potentialSavingsAmount = try reader["PotentialSavingsAmount"].readIfPresent()
        value.optimizations = try reader["Optimizations"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.AwsProductOptimization.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PartnerCentralSellingClientTypes.AwsProductInsights {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.AwsProductInsights {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.AwsProductInsights()
        value.currencyCode = try reader["CurrencyCode"].readIfPresent() ?? .sdkUnknown("")
        value.frequency = try reader["Frequency"].readIfPresent() ?? .sdkUnknown("")
        value.totalAmount = try reader["TotalAmount"].readIfPresent()
        value.totalOptimizedAmount = try reader["TotalOptimizedAmount"].readIfPresent()
        value.totalPotentialSavingsAmount = try reader["TotalPotentialSavingsAmount"].readIfPresent()
        value.totalAmountByCategory = try reader["TotalAmountByCategory"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.awsProducts = try reader["AwsProducts"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.AwsProductDetails.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PartnerCentralSellingClientTypes.AwsProductOptimization {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.AwsProductOptimization {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.AwsProductOptimization()
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.savingsAmount = try reader["SavingsAmount"].readIfPresent() ?? ""
        return value
    }
}

extension PartnerCentralSellingClientTypes.AwsProductsSpendInsightsBySource {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.AwsProductsSpendInsightsBySource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.AwsProductsSpendInsightsBySource()
        value.partner = try reader["Partner"].readIfPresent(with: PartnerCentralSellingClientTypes.AwsProductInsights.read(from:))
        value.aws = try reader["AWS"].readIfPresent(with: PartnerCentralSellingClientTypes.AwsProductInsights.read(from:))
        return value
    }
}

extension PartnerCentralSellingClientTypes.AwsSubmission {

    static func write(value: PartnerCentralSellingClientTypes.AwsSubmission?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InvolvementType"].write(value.involvementType)
        try writer["Visibility"].write(value.visibility)
    }
}

extension PartnerCentralSellingClientTypes.AwsTeamMember {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.AwsTeamMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.AwsTeamMember()
        value.email = try reader["Email"].readIfPresent()
        value.firstName = try reader["FirstName"].readIfPresent()
        value.lastName = try reader["LastName"].readIfPresent()
        value.businessTitle = try reader["BusinessTitle"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.Contact {

    static func write(value: PartnerCentralSellingClientTypes.Contact?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BusinessTitle"].write(value.businessTitle)
        try writer["Email"].write(value.email)
        try writer["FirstName"].write(value.firstName)
        try writer["LastName"].write(value.lastName)
        try writer["Phone"].write(value.phone)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.Contact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.Contact()
        value.email = try reader["Email"].readIfPresent()
        value.firstName = try reader["FirstName"].readIfPresent()
        value.lastName = try reader["LastName"].readIfPresent()
        value.businessTitle = try reader["BusinessTitle"].readIfPresent()
        value.phone = try reader["Phone"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.CreatedDateFilter {

    static func write(value: PartnerCentralSellingClientTypes.CreatedDateFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AfterCreatedDate"].writeTimestamp(value.afterCreatedDate, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["BeforeCreatedDate"].writeTimestamp(value.beforeCreatedDate, format: SmithyTimestamps.TimestampFormat.dateTime)
    }
}

extension PartnerCentralSellingClientTypes.Customer {

    static func write(value: PartnerCentralSellingClientTypes.Customer?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Account"].write(value.account, with: PartnerCentralSellingClientTypes.Account.write(value:to:))
        try writer["Contacts"].writeList(value.contacts, memberWritingClosure: PartnerCentralSellingClientTypes.Contact.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.Customer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.Customer()
        value.account = try reader["Account"].readIfPresent(with: PartnerCentralSellingClientTypes.Account.read(from:))
        value.contacts = try reader["Contacts"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.Contact.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PartnerCentralSellingClientTypes.CustomerProjectsContext {

    static func write(value: PartnerCentralSellingClientTypes.CustomerProjectsContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Customer"].write(value.customer, with: PartnerCentralSellingClientTypes.EngagementCustomer.write(value:to:))
        try writer["Project"].write(value.project, with: PartnerCentralSellingClientTypes.EngagementCustomerProjectDetails.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.CustomerProjectsContext {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.CustomerProjectsContext()
        value.customer = try reader["Customer"].readIfPresent(with: PartnerCentralSellingClientTypes.EngagementCustomer.read(from:))
        value.project = try reader["Project"].readIfPresent(with: PartnerCentralSellingClientTypes.EngagementCustomerProjectDetails.read(from:))
        return value
    }
}

extension PartnerCentralSellingClientTypes.CustomerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.CustomerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.CustomerSummary()
        value.account = try reader["Account"].readIfPresent(with: PartnerCentralSellingClientTypes.AccountSummary.read(from:))
        return value
    }
}

extension PartnerCentralSellingClientTypes.EngagementContextDetails {

    static func write(value: PartnerCentralSellingClientTypes.EngagementContextDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Id"].write(value.id)
        try writer["Payload"].write(value.payload, with: PartnerCentralSellingClientTypes.EngagementContextPayload.write(value:to:))
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.EngagementContextDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.EngagementContextDetails()
        value.id = try reader["Id"].readIfPresent()
        value.type = try reader["Type"].readIfPresent() ?? .sdkUnknown("")
        value.payload = try reader["Payload"].readIfPresent(with: PartnerCentralSellingClientTypes.EngagementContextPayload.read(from:))
        return value
    }
}

extension PartnerCentralSellingClientTypes.EngagementContextPayload {

    static func write(value: PartnerCentralSellingClientTypes.EngagementContextPayload?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .customerproject(customerproject):
                try writer["CustomerProject"].write(customerproject, with: PartnerCentralSellingClientTypes.CustomerProjectsContext.write(value:to:))
            case let .lead(lead):
                try writer["Lead"].write(lead, with: PartnerCentralSellingClientTypes.LeadContext.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.EngagementContextPayload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "CustomerProject":
                return .customerproject(try reader["CustomerProject"].read(with: PartnerCentralSellingClientTypes.CustomerProjectsContext.read(from:)))
            case "Lead":
                return .lead(try reader["Lead"].read(with: PartnerCentralSellingClientTypes.LeadContext.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension PartnerCentralSellingClientTypes.EngagementCustomer {

    static func write(value: PartnerCentralSellingClientTypes.EngagementCustomer?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CompanyName"].write(value.companyName)
        try writer["CountryCode"].write(value.countryCode)
        try writer["Industry"].write(value.industry)
        try writer["WebsiteUrl"].write(value.websiteUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.EngagementCustomer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.EngagementCustomer()
        value.industry = try reader["Industry"].readIfPresent() ?? .sdkUnknown("")
        value.companyName = try reader["CompanyName"].readIfPresent() ?? ""
        value.websiteUrl = try reader["WebsiteUrl"].readIfPresent() ?? ""
        value.countryCode = try reader["CountryCode"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension PartnerCentralSellingClientTypes.EngagementCustomerProjectDetails {

    static func write(value: PartnerCentralSellingClientTypes.EngagementCustomerProjectDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BusinessProblem"].write(value.businessProblem)
        try writer["TargetCompletionDate"].write(value.targetCompletionDate)
        try writer["Title"].write(value.title)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.EngagementCustomerProjectDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.EngagementCustomerProjectDetails()
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.businessProblem = try reader["BusinessProblem"].readIfPresent() ?? ""
        value.targetCompletionDate = try reader["TargetCompletionDate"].readIfPresent() ?? ""
        return value
    }
}

extension PartnerCentralSellingClientTypes.EngagementInvitationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.EngagementInvitationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.EngagementInvitationSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.payloadType = try reader["PayloadType"].readIfPresent()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.engagementId = try reader["EngagementId"].readIfPresent()
        value.engagementTitle = try reader["EngagementTitle"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.invitationDate = try reader["InvitationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.expirationDate = try reader["ExpirationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.senderAwsAccountId = try reader["SenderAwsAccountId"].readIfPresent()
        value.senderCompanyName = try reader["SenderCompanyName"].readIfPresent()
        value.receiver = try reader["Receiver"].readIfPresent(with: PartnerCentralSellingClientTypes.Receiver.read(from:))
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.participantType = try reader["ParticipantType"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.EngagementMember {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.EngagementMember {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.EngagementMember()
        value.companyName = try reader["CompanyName"].readIfPresent()
        value.websiteUrl = try reader["WebsiteUrl"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.EngagementMemberSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.EngagementMemberSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.EngagementMemberSummary()
        value.companyName = try reader["CompanyName"].readIfPresent()
        value.websiteUrl = try reader["WebsiteUrl"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.EngagementResourceAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.EngagementResourceAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.EngagementResourceAssociationSummary()
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.engagementId = try reader["EngagementId"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.createdBy = try reader["CreatedBy"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.EngagementSort {

    static func write(value: PartnerCentralSellingClientTypes.EngagementSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SortBy"].write(value.sortBy)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension PartnerCentralSellingClientTypes.EngagementSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.EngagementSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.EngagementSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.id = try reader["Id"].readIfPresent()
        value.title = try reader["Title"].readIfPresent()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdBy = try reader["CreatedBy"].readIfPresent()
        value.memberCount = try reader["MemberCount"].readIfPresent()
        value.modifiedAt = try reader["ModifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.modifiedBy = try reader["ModifiedBy"].readIfPresent()
        value.contextTypes = try reader["ContextTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PartnerCentralSellingClientTypes.EngagementContextType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PartnerCentralSellingClientTypes.ExpectedCustomerSpend {

    static func write(value: PartnerCentralSellingClientTypes.ExpectedCustomerSpend?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Amount"].write(value.amount)
        try writer["CurrencyCode"].write(value.currencyCode)
        try writer["EstimationUrl"].write(value.estimationUrl)
        try writer["Frequency"].write(value.frequency)
        try writer["TargetCompany"].write(value.targetCompany)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.ExpectedCustomerSpend {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.ExpectedCustomerSpend()
        value.amount = try reader["Amount"].readIfPresent() ?? ""
        value.currencyCode = try reader["CurrencyCode"].readIfPresent() ?? .sdkUnknown("")
        value.frequency = try reader["Frequency"].readIfPresent() ?? .sdkUnknown("")
        value.targetCompany = try reader["TargetCompany"].readIfPresent() ?? ""
        value.estimationUrl = try reader["EstimationUrl"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.Invitation {

    static func write(value: PartnerCentralSellingClientTypes.Invitation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Message"].write(value.message)
        try writer["Payload"].write(value.payload, with: PartnerCentralSellingClientTypes.Payload.write(value:to:))
        try writer["Receiver"].write(value.receiver, with: PartnerCentralSellingClientTypes.Receiver.write(value:to:))
    }
}

extension PartnerCentralSellingClientTypes.LastModifiedDate {

    static func write(value: PartnerCentralSellingClientTypes.LastModifiedDate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AfterLastModifiedDate"].writeTimestamp(value.afterLastModifiedDate, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["BeforeLastModifiedDate"].writeTimestamp(value.beforeLastModifiedDate, format: SmithyTimestamps.TimestampFormat.dateTime)
    }
}

extension PartnerCentralSellingClientTypes.LeadContact {

    static func write(value: PartnerCentralSellingClientTypes.LeadContact?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BusinessTitle"].write(value.businessTitle)
        try writer["Email"].write(value.email)
        try writer["FirstName"].write(value.firstName)
        try writer["LastName"].write(value.lastName)
        try writer["Phone"].write(value.phone)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.LeadContact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.LeadContact()
        value.businessTitle = try reader["BusinessTitle"].readIfPresent() ?? ""
        value.email = try reader["Email"].readIfPresent() ?? ""
        value.firstName = try reader["FirstName"].readIfPresent() ?? ""
        value.lastName = try reader["LastName"].readIfPresent() ?? ""
        value.phone = try reader["Phone"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.LeadContext {

    static func write(value: PartnerCentralSellingClientTypes.LeadContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Customer"].write(value.customer, with: PartnerCentralSellingClientTypes.LeadCustomer.write(value:to:))
        try writer["Interactions"].writeList(value.interactions, memberWritingClosure: PartnerCentralSellingClientTypes.LeadInteraction.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["QualificationStatus"].write(value.qualificationStatus)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.LeadContext {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.LeadContext()
        value.qualificationStatus = try reader["QualificationStatus"].readIfPresent() ?? "Unqualified"
        value.customer = try reader["Customer"].readIfPresent(with: PartnerCentralSellingClientTypes.LeadCustomer.read(from:))
        value.interactions = try reader["Interactions"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.LeadInteraction.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PartnerCentralSellingClientTypes.LeadCustomer {

    static func write(value: PartnerCentralSellingClientTypes.LeadCustomer?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address"].write(value.address, with: PartnerCentralSellingClientTypes.AddressSummary.write(value:to:))
        try writer["AwsMaturity"].write(value.awsMaturity)
        try writer["CompanyName"].write(value.companyName)
        try writer["Industry"].write(value.industry)
        try writer["MarketSegment"].write(value.marketSegment)
        try writer["WebsiteUrl"].write(value.websiteUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.LeadCustomer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.LeadCustomer()
        value.industry = try reader["Industry"].readIfPresent()
        value.companyName = try reader["CompanyName"].readIfPresent() ?? ""
        value.websiteUrl = try reader["WebsiteUrl"].readIfPresent()
        value.address = try reader["Address"].readIfPresent(with: PartnerCentralSellingClientTypes.AddressSummary.read(from:))
        value.awsMaturity = try reader["AwsMaturity"].readIfPresent()
        value.marketSegment = try reader["MarketSegment"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.LeadInteraction {

    static func write(value: PartnerCentralSellingClientTypes.LeadInteraction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BusinessProblem"].write(value.businessProblem)
        try writer["Contact"].write(value.contact, with: PartnerCentralSellingClientTypes.LeadContact.write(value:to:))
        try writer["CustomerAction"].write(value.customerAction)
        try writer["InteractionDate"].writeTimestamp(value.interactionDate, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["SourceId"].write(value.sourceId)
        try writer["SourceName"].write(value.sourceName)
        try writer["SourceType"].write(value.sourceType)
        try writer["Usecase"].write(value.usecase)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.LeadInteraction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.LeadInteraction()
        value.sourceType = try reader["SourceType"].readIfPresent() ?? ""
        value.sourceId = try reader["SourceId"].readIfPresent() ?? ""
        value.sourceName = try reader["SourceName"].readIfPresent() ?? ""
        value.usecase = try reader["Usecase"].readIfPresent()
        value.interactionDate = try reader["InteractionDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.customerAction = try reader["CustomerAction"].readIfPresent() ?? ""
        value.businessProblem = try reader["BusinessProblem"].readIfPresent()
        value.contact = try reader["Contact"].readIfPresent(with: PartnerCentralSellingClientTypes.LeadContact.read(from:))
        return value
    }
}

extension PartnerCentralSellingClientTypes.LeadInvitationCustomer {

    static func write(value: PartnerCentralSellingClientTypes.LeadInvitationCustomer?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsMaturity"].write(value.awsMaturity)
        try writer["CompanyName"].write(value.companyName)
        try writer["CountryCode"].write(value.countryCode)
        try writer["Industry"].write(value.industry)
        try writer["MarketSegment"].write(value.marketSegment)
        try writer["WebsiteUrl"].write(value.websiteUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.LeadInvitationCustomer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.LeadInvitationCustomer()
        value.industry = try reader["Industry"].readIfPresent()
        value.companyName = try reader["CompanyName"].readIfPresent() ?? ""
        value.websiteUrl = try reader["WebsiteUrl"].readIfPresent()
        value.countryCode = try reader["CountryCode"].readIfPresent() ?? .sdkUnknown("")
        value.awsMaturity = try reader["AwsMaturity"].readIfPresent()
        value.marketSegment = try reader["MarketSegment"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.LeadInvitationInteraction {

    static func write(value: PartnerCentralSellingClientTypes.LeadInvitationInteraction?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ContactBusinessTitle"].write(value.contactBusinessTitle)
        try writer["SourceId"].write(value.sourceId)
        try writer["SourceName"].write(value.sourceName)
        try writer["SourceType"].write(value.sourceType)
        try writer["Usecase"].write(value.usecase)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.LeadInvitationInteraction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.LeadInvitationInteraction()
        value.sourceType = try reader["SourceType"].readIfPresent() ?? ""
        value.sourceId = try reader["SourceId"].readIfPresent() ?? ""
        value.sourceName = try reader["SourceName"].readIfPresent() ?? ""
        value.usecase = try reader["Usecase"].readIfPresent()
        value.contactBusinessTitle = try reader["ContactBusinessTitle"].readIfPresent() ?? ""
        return value
    }
}

extension PartnerCentralSellingClientTypes.LeadInvitationPayload {

    static func write(value: PartnerCentralSellingClientTypes.LeadInvitationPayload?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Customer"].write(value.customer, with: PartnerCentralSellingClientTypes.LeadInvitationCustomer.write(value:to:))
        try writer["Interaction"].write(value.interaction, with: PartnerCentralSellingClientTypes.LeadInvitationInteraction.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.LeadInvitationPayload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.LeadInvitationPayload()
        value.customer = try reader["Customer"].readIfPresent(with: PartnerCentralSellingClientTypes.LeadInvitationCustomer.read(from:))
        value.interaction = try reader["Interaction"].readIfPresent(with: PartnerCentralSellingClientTypes.LeadInvitationInteraction.read(from:))
        return value
    }
}

extension PartnerCentralSellingClientTypes.LifeCycle {

    static func write(value: PartnerCentralSellingClientTypes.LifeCycle?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClosedLostReason"].write(value.closedLostReason)
        try writer["NextSteps"].write(value.nextSteps)
        try writer["NextStepsHistory"].writeList(value.nextStepsHistory, memberWritingClosure: PartnerCentralSellingClientTypes.NextStepsHistory.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ReviewComments"].write(value.reviewComments)
        try writer["ReviewStatus"].write(value.reviewStatus)
        try writer["ReviewStatusReason"].write(value.reviewStatusReason)
        try writer["Stage"].write(value.stage)
        try writer["TargetCloseDate"].write(value.targetCloseDate)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.LifeCycle {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.LifeCycle()
        value.stage = try reader["Stage"].readIfPresent()
        value.closedLostReason = try reader["ClosedLostReason"].readIfPresent()
        value.nextSteps = try reader["NextSteps"].readIfPresent()
        value.targetCloseDate = try reader["TargetCloseDate"].readIfPresent()
        value.reviewStatus = try reader["ReviewStatus"].readIfPresent()
        value.reviewComments = try reader["ReviewComments"].readIfPresent()
        value.reviewStatusReason = try reader["ReviewStatusReason"].readIfPresent()
        value.nextStepsHistory = try reader["NextStepsHistory"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.NextStepsHistory.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PartnerCentralSellingClientTypes.LifeCycleForView {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.LifeCycleForView {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.LifeCycleForView()
        value.targetCloseDate = try reader["TargetCloseDate"].readIfPresent()
        value.reviewStatus = try reader["ReviewStatus"].readIfPresent()
        value.stage = try reader["Stage"].readIfPresent()
        value.nextSteps = try reader["NextSteps"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.LifeCycleSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.LifeCycleSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.LifeCycleSummary()
        value.stage = try reader["Stage"].readIfPresent()
        value.closedLostReason = try reader["ClosedLostReason"].readIfPresent()
        value.nextSteps = try reader["NextSteps"].readIfPresent()
        value.targetCloseDate = try reader["TargetCloseDate"].readIfPresent()
        value.reviewStatus = try reader["ReviewStatus"].readIfPresent()
        value.reviewComments = try reader["ReviewComments"].readIfPresent()
        value.reviewStatusReason = try reader["ReviewStatusReason"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.ListEngagementByAcceptingInvitationTaskSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.ListEngagementByAcceptingInvitationTaskSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.ListEngagementByAcceptingInvitationTaskSummary()
        value.taskId = try reader["TaskId"].readIfPresent()
        value.taskArn = try reader["TaskArn"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.taskStatus = try reader["TaskStatus"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.reasonCode = try reader["ReasonCode"].readIfPresent()
        value.opportunityId = try reader["OpportunityId"].readIfPresent()
        value.resourceSnapshotJobId = try reader["ResourceSnapshotJobId"].readIfPresent()
        value.engagementInvitationId = try reader["EngagementInvitationId"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.ListEngagementFromOpportunityTaskSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.ListEngagementFromOpportunityTaskSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.ListEngagementFromOpportunityTaskSummary()
        value.taskId = try reader["TaskId"].readIfPresent()
        value.taskArn = try reader["TaskArn"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.taskStatus = try reader["TaskStatus"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.reasonCode = try reader["ReasonCode"].readIfPresent()
        value.opportunityId = try reader["OpportunityId"].readIfPresent()
        value.resourceSnapshotJobId = try reader["ResourceSnapshotJobId"].readIfPresent()
        value.engagementId = try reader["EngagementId"].readIfPresent()
        value.engagementInvitationId = try reader["EngagementInvitationId"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.ListOpportunityFromEngagementTaskSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.ListOpportunityFromEngagementTaskSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.ListOpportunityFromEngagementTaskSummary()
        value.taskId = try reader["TaskId"].readIfPresent()
        value.taskArn = try reader["TaskArn"].readIfPresent()
        value.startTime = try reader["StartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.taskStatus = try reader["TaskStatus"].readIfPresent()
        value.message = try reader["Message"].readIfPresent()
        value.reasonCode = try reader["ReasonCode"].readIfPresent()
        value.opportunityId = try reader["OpportunityId"].readIfPresent()
        value.resourceSnapshotJobId = try reader["ResourceSnapshotJobId"].readIfPresent()
        value.engagementId = try reader["EngagementId"].readIfPresent()
        value.contextId = try reader["ContextId"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.ListTasksSortBase {

    static func write(value: PartnerCentralSellingClientTypes.ListTasksSortBase?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SortBy"].write(value.sortBy)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension PartnerCentralSellingClientTypes.Marketing {

    static func write(value: PartnerCentralSellingClientTypes.Marketing?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AwsFundingUsed"].write(value.awsFundingUsed)
        try writer["CampaignName"].write(value.campaignName)
        try writer["Channels"].writeList(value.channels, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralSellingClientTypes.Channel>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Source"].write(value.source)
        try writer["UseCases"].writeList(value.useCases, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.Marketing {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.Marketing()
        value.campaignName = try reader["CampaignName"].readIfPresent()
        value.source = try reader["Source"].readIfPresent()
        value.useCases = try reader["UseCases"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.channels = try reader["Channels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PartnerCentralSellingClientTypes.Channel>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.awsFundingUsed = try reader["AwsFundingUsed"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.MonetaryValue {

    static func write(value: PartnerCentralSellingClientTypes.MonetaryValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Amount"].write(value.amount)
        try writer["CurrencyCode"].write(value.currencyCode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.MonetaryValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.MonetaryValue()
        value.amount = try reader["Amount"].readIfPresent() ?? ""
        value.currencyCode = try reader["CurrencyCode"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension PartnerCentralSellingClientTypes.NextStepsHistory {

    static func write(value: PartnerCentralSellingClientTypes.NextStepsHistory?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Time"].writeTimestamp(value.time, format: SmithyTimestamps.TimestampFormat.dateTime)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.NextStepsHistory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.NextStepsHistory()
        value.value = try reader["Value"].readIfPresent() ?? ""
        value.time = try reader["Time"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension PartnerCentralSellingClientTypes.OpportunityEngagementInvitationSort {

    static func write(value: PartnerCentralSellingClientTypes.OpportunityEngagementInvitationSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SortBy"].write(value.sortBy)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension PartnerCentralSellingClientTypes.OpportunityInvitationPayload {

    static func write(value: PartnerCentralSellingClientTypes.OpportunityInvitationPayload?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Customer"].write(value.customer, with: PartnerCentralSellingClientTypes.EngagementCustomer.write(value:to:))
        try writer["Project"].write(value.project, with: PartnerCentralSellingClientTypes.ProjectDetails.write(value:to:))
        try writer["ReceiverResponsibilities"].writeList(value.receiverResponsibilities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralSellingClientTypes.ReceiverResponsibility>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SenderContacts"].writeList(value.senderContacts, memberWritingClosure: PartnerCentralSellingClientTypes.SenderContact.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.OpportunityInvitationPayload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.OpportunityInvitationPayload()
        value.senderContacts = try reader["SenderContacts"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.SenderContact.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.receiverResponsibilities = try reader["ReceiverResponsibilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PartnerCentralSellingClientTypes.ReceiverResponsibility>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.customer = try reader["Customer"].readIfPresent(with: PartnerCentralSellingClientTypes.EngagementCustomer.read(from:))
        value.project = try reader["Project"].readIfPresent(with: PartnerCentralSellingClientTypes.ProjectDetails.read(from:))
        return value
    }
}

extension PartnerCentralSellingClientTypes.OpportunitySort {

    static func write(value: PartnerCentralSellingClientTypes.OpportunitySort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SortBy"].write(value.sortBy)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension PartnerCentralSellingClientTypes.OpportunitySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.OpportunitySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.OpportunitySummary()
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.partnerOpportunityIdentifier = try reader["PartnerOpportunityIdentifier"].readIfPresent()
        value.opportunityType = try reader["OpportunityType"].readIfPresent()
        value.lastModifiedDate = try reader["LastModifiedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.lifeCycle = try reader["LifeCycle"].readIfPresent(with: PartnerCentralSellingClientTypes.LifeCycleSummary.read(from:))
        value.customer = try reader["Customer"].readIfPresent(with: PartnerCentralSellingClientTypes.CustomerSummary.read(from:))
        value.project = try reader["Project"].readIfPresent(with: PartnerCentralSellingClientTypes.ProjectSummary.read(from:))
        return value
    }
}

extension PartnerCentralSellingClientTypes.OpportunitySummaryView {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.OpportunitySummaryView {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.OpportunitySummaryView()
        value.opportunityType = try reader["OpportunityType"].readIfPresent()
        value.lifecycle = try reader["Lifecycle"].readIfPresent(with: PartnerCentralSellingClientTypes.LifeCycleForView.read(from:))
        value.opportunityTeam = try reader["OpportunityTeam"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.Contact.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.primaryNeedsFromAws = try reader["PrimaryNeedsFromAws"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PartnerCentralSellingClientTypes.PrimaryNeedFromAws>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.customer = try reader["Customer"].readIfPresent(with: PartnerCentralSellingClientTypes.Customer.read(from:))
        value.project = try reader["Project"].readIfPresent(with: PartnerCentralSellingClientTypes.ProjectView.read(from:))
        value.relatedEntityIdentifiers = try reader["RelatedEntityIdentifiers"].readIfPresent(with: PartnerCentralSellingClientTypes.RelatedEntityIdentifiers.read(from:))
        return value
    }
}

extension PartnerCentralSellingClientTypes.Payload {

    static func write(value: PartnerCentralSellingClientTypes.Payload?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .leadinvitation(leadinvitation):
                try writer["LeadInvitation"].write(leadinvitation, with: PartnerCentralSellingClientTypes.LeadInvitationPayload.write(value:to:))
            case let .opportunityinvitation(opportunityinvitation):
                try writer["OpportunityInvitation"].write(opportunityinvitation, with: PartnerCentralSellingClientTypes.OpportunityInvitationPayload.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.Payload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "OpportunityInvitation":
                return .opportunityinvitation(try reader["OpportunityInvitation"].read(with: PartnerCentralSellingClientTypes.OpportunityInvitationPayload.read(from:)))
            case "LeadInvitation":
                return .leadinvitation(try reader["LeadInvitation"].read(with: PartnerCentralSellingClientTypes.LeadInvitationPayload.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension PartnerCentralSellingClientTypes.ProfileNextStepsHistory {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.ProfileNextStepsHistory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.ProfileNextStepsHistory()
        value.value = try reader["Value"].readIfPresent() ?? ""
        value.time = try reader["Time"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension PartnerCentralSellingClientTypes.Project {

    static func write(value: PartnerCentralSellingClientTypes.Project?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AdditionalComments"].write(value.additionalComments)
        try writer["ApnPrograms"].writeList(value.apnPrograms, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["AwsPartition"].write(value.awsPartition)
        try writer["CompetitorName"].write(value.competitorName)
        try writer["CustomerBusinessProblem"].write(value.customerBusinessProblem)
        try writer["CustomerUseCase"].write(value.customerUseCase)
        try writer["DeliveryModels"].writeList(value.deliveryModels, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralSellingClientTypes.DeliveryModel>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ExpectedCustomerSpend"].writeList(value.expectedCustomerSpend, memberWritingClosure: PartnerCentralSellingClientTypes.ExpectedCustomerSpend.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["OtherCompetitorNames"].write(value.otherCompetitorNames)
        try writer["OtherSolutionDescription"].write(value.otherSolutionDescription)
        try writer["RelatedOpportunityIdentifier"].write(value.relatedOpportunityIdentifier)
        try writer["SalesActivities"].writeList(value.salesActivities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralSellingClientTypes.SalesActivity>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Title"].write(value.title)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.Project {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.Project()
        value.deliveryModels = try reader["DeliveryModels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PartnerCentralSellingClientTypes.DeliveryModel>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.expectedCustomerSpend = try reader["ExpectedCustomerSpend"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.ExpectedCustomerSpend.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.title = try reader["Title"].readIfPresent()
        value.apnPrograms = try reader["ApnPrograms"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.customerBusinessProblem = try reader["CustomerBusinessProblem"].readIfPresent()
        value.customerUseCase = try reader["CustomerUseCase"].readIfPresent()
        value.relatedOpportunityIdentifier = try reader["RelatedOpportunityIdentifier"].readIfPresent()
        value.salesActivities = try reader["SalesActivities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PartnerCentralSellingClientTypes.SalesActivity>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.competitorName = try reader["CompetitorName"].readIfPresent()
        value.otherCompetitorNames = try reader["OtherCompetitorNames"].readIfPresent()
        value.otherSolutionDescription = try reader["OtherSolutionDescription"].readIfPresent()
        value.additionalComments = try reader["AdditionalComments"].readIfPresent()
        value.awsPartition = try reader["AwsPartition"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.ProjectDetails {

    static func write(value: PartnerCentralSellingClientTypes.ProjectDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BusinessProblem"].write(value.businessProblem)
        try writer["ExpectedCustomerSpend"].writeList(value.expectedCustomerSpend, memberWritingClosure: PartnerCentralSellingClientTypes.ExpectedCustomerSpend.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TargetCompletionDate"].write(value.targetCompletionDate)
        try writer["Title"].write(value.title)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.ProjectDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.ProjectDetails()
        value.businessProblem = try reader["BusinessProblem"].readIfPresent() ?? ""
        value.title = try reader["Title"].readIfPresent() ?? ""
        value.targetCompletionDate = try reader["TargetCompletionDate"].readIfPresent() ?? ""
        value.expectedCustomerSpend = try reader["ExpectedCustomerSpend"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.ExpectedCustomerSpend.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PartnerCentralSellingClientTypes.ProjectSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.ProjectSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.ProjectSummary()
        value.deliveryModels = try reader["DeliveryModels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PartnerCentralSellingClientTypes.DeliveryModel>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.expectedCustomerSpend = try reader["ExpectedCustomerSpend"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.ExpectedCustomerSpend.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PartnerCentralSellingClientTypes.ProjectView {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.ProjectView {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.ProjectView()
        value.deliveryModels = try reader["DeliveryModels"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PartnerCentralSellingClientTypes.DeliveryModel>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.expectedCustomerSpend = try reader["ExpectedCustomerSpend"].readListIfPresent(memberReadingClosure: PartnerCentralSellingClientTypes.ExpectedCustomerSpend.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.customerUseCase = try reader["CustomerUseCase"].readIfPresent()
        value.salesActivities = try reader["SalesActivities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PartnerCentralSellingClientTypes.SalesActivity>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.otherSolutionDescription = try reader["OtherSolutionDescription"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.Receiver {

    static func write(value: PartnerCentralSellingClientTypes.Receiver?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .account(account):
                try writer["Account"].write(account, with: PartnerCentralSellingClientTypes.AccountReceiver.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.Receiver {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Account":
                return .account(try reader["Account"].read(with: PartnerCentralSellingClientTypes.AccountReceiver.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension PartnerCentralSellingClientTypes.RelatedEntityIdentifiers {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.RelatedEntityIdentifiers {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.RelatedEntityIdentifiers()
        value.awsMarketplaceOffers = try reader["AwsMarketplaceOffers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.awsMarketplaceOfferSets = try reader["AwsMarketplaceOfferSets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.solutions = try reader["Solutions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.awsProducts = try reader["AwsProducts"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PartnerCentralSellingClientTypes.ResourceSnapshotJobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.ResourceSnapshotJobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.ResourceSnapshotJobSummary()
        value.id = try reader["Id"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        value.engagementId = try reader["EngagementId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.ResourceSnapshotPayload {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.ResourceSnapshotPayload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "OpportunitySummary":
                return .opportunitysummary(try reader["OpportunitySummary"].read(with: PartnerCentralSellingClientTypes.OpportunitySummaryView.read(from:)))
            case "AwsOpportunitySummaryFullView":
                return .awsopportunitysummaryfullview(try reader["AwsOpportunitySummaryFullView"].read(with: PartnerCentralSellingClientTypes.AwsOpportunitySummaryFullView.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension PartnerCentralSellingClientTypes.ResourceSnapshotSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.ResourceSnapshotSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.ResourceSnapshotSummary()
        value.arn = try reader["Arn"].readIfPresent()
        value.revision = try reader["Revision"].readIfPresent()
        value.resourceType = try reader["ResourceType"].readIfPresent()
        value.resourceId = try reader["ResourceId"].readIfPresent()
        value.resourceSnapshotTemplateName = try reader["ResourceSnapshotTemplateName"].readIfPresent()
        value.createdBy = try reader["CreatedBy"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.SenderContact {

    static func write(value: PartnerCentralSellingClientTypes.SenderContact?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BusinessTitle"].write(value.businessTitle)
        try writer["Email"].write(value.email)
        try writer["FirstName"].write(value.firstName)
        try writer["LastName"].write(value.lastName)
        try writer["Phone"].write(value.phone)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.SenderContact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.SenderContact()
        value.email = try reader["Email"].readIfPresent() ?? ""
        value.firstName = try reader["FirstName"].readIfPresent()
        value.lastName = try reader["LastName"].readIfPresent()
        value.businessTitle = try reader["BusinessTitle"].readIfPresent()
        value.phone = try reader["Phone"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.SoftwareRevenue {

    static func write(value: PartnerCentralSellingClientTypes.SoftwareRevenue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeliveryModel"].write(value.deliveryModel)
        try writer["EffectiveDate"].write(value.effectiveDate)
        try writer["ExpirationDate"].write(value.expirationDate)
        try writer["Value"].write(value.value, with: PartnerCentralSellingClientTypes.MonetaryValue.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.SoftwareRevenue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.SoftwareRevenue()
        value.deliveryModel = try reader["DeliveryModel"].readIfPresent()
        value.value = try reader["Value"].readIfPresent(with: PartnerCentralSellingClientTypes.MonetaryValue.read(from:))
        value.effectiveDate = try reader["EffectiveDate"].readIfPresent()
        value.expirationDate = try reader["ExpirationDate"].readIfPresent()
        return value
    }
}

extension PartnerCentralSellingClientTypes.SolutionBase {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.SolutionBase {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.SolutionBase()
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.category = try reader["Category"].readIfPresent() ?? ""
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension PartnerCentralSellingClientTypes.SolutionSort {

    static func write(value: PartnerCentralSellingClientTypes.SolutionSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SortBy"].write(value.sortBy)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension PartnerCentralSellingClientTypes.SortObject {

    static func write(value: PartnerCentralSellingClientTypes.SortObject?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SortBy"].write(value.sortBy)
        try writer["SortOrder"].write(value.sortOrder)
    }
}

extension PartnerCentralSellingClientTypes.Tag {

    static func write(value: PartnerCentralSellingClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension PartnerCentralSellingClientTypes.UpdateEngagementContextPayload {

    static func write(value: PartnerCentralSellingClientTypes.UpdateEngagementContextPayload?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .customerproject(customerproject):
                try writer["CustomerProject"].write(customerproject, with: PartnerCentralSellingClientTypes.CustomerProjectsContext.write(value:to:))
            case let .lead(lead):
                try writer["Lead"].write(lead, with: PartnerCentralSellingClientTypes.UpdateLeadContext.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension PartnerCentralSellingClientTypes.UpdateLeadContext {

    static func write(value: PartnerCentralSellingClientTypes.UpdateLeadContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Customer"].write(value.customer, with: PartnerCentralSellingClientTypes.LeadCustomer.write(value:to:))
        try writer["Interaction"].write(value.interaction, with: PartnerCentralSellingClientTypes.LeadInteraction.write(value:to:))
        try writer["QualificationStatus"].write(value.qualificationStatus)
    }
}

extension PartnerCentralSellingClientTypes.ValidationExceptionError {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralSellingClientTypes.ValidationExceptionError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralSellingClientTypes.ValidationExceptionError()
        value.fieldName = try reader["FieldName"].readIfPresent()
        value.message = try reader["Message"].readIfPresent() ?? ""
        value.code = try reader["Code"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

public enum PartnerCentralSellingClientTypes {}
