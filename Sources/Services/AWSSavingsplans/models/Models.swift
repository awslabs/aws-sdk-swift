// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CreateSavingsPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case commitment
        case purchaseTime
        case savingsPlanOfferingId
        case tags
        case upfrontPaymentAmount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let commitment = self.commitment {
            try encodeContainer.encode(commitment, forKey: .commitment)
        }
        if let purchaseTime = self.purchaseTime {
            try encodeContainer.encodeTimestamp(purchaseTime, format: .epochSeconds, forKey: .purchaseTime)
        }
        if let savingsPlanOfferingId = self.savingsPlanOfferingId {
            try encodeContainer.encode(savingsPlanOfferingId, forKey: .savingsPlanOfferingId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let upfrontPaymentAmount = self.upfrontPaymentAmount {
            try encodeContainer.encode(upfrontPaymentAmount, forKey: .upfrontPaymentAmount)
        }
    }
}

extension CreateSavingsPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateSavingsPlan"
    }
}

public struct CreateSavingsPlanInput: Swift.Equatable {
    /// Unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The hourly commitment, in USD. This is a value between 0.001 and 1 million. You cannot specify more than five digits after the decimal point.
    /// This member is required.
    public var commitment: Swift.String?
    /// The time at which to purchase the Savings Plan, in UTC format (YYYY-MM-DDTHH:MM:SSZ).
    public var purchaseTime: ClientRuntime.Date?
    /// The ID of the offering.
    /// This member is required.
    public var savingsPlanOfferingId: Swift.String?
    /// One or more tags.
    public var tags: [Swift.String:Swift.String]?
    /// The up-front payment amount. This is a whole number between 50 and 99 percent of the total value of the Savings Plan. This parameter is supported only if the payment option is Partial Upfront.
    public var upfrontPaymentAmount: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        commitment: Swift.String? = nil,
        purchaseTime: ClientRuntime.Date? = nil,
        savingsPlanOfferingId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        upfrontPaymentAmount: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.commitment = commitment
        self.purchaseTime = purchaseTime
        self.savingsPlanOfferingId = savingsPlanOfferingId
        self.tags = tags
        self.upfrontPaymentAmount = upfrontPaymentAmount
    }
}

struct CreateSavingsPlanInputBody: Swift.Equatable {
    let savingsPlanOfferingId: Swift.String?
    let commitment: Swift.String?
    let upfrontPaymentAmount: Swift.String?
    let purchaseTime: ClientRuntime.Date?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSavingsPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case commitment
        case purchaseTime
        case savingsPlanOfferingId
        case tags
        case upfrontPaymentAmount
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlanOfferingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .savingsPlanOfferingId)
        savingsPlanOfferingId = savingsPlanOfferingIdDecoded
        let commitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitment)
        commitment = commitmentDecoded
        let upfrontPaymentAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upfrontPaymentAmount)
        upfrontPaymentAmount = upfrontPaymentAmountDecoded
        let purchaseTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .purchaseTime)
        purchaseTime = purchaseTimeDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSavingsPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSavingsPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSavingsPlanOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSavingsPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSavingsPlanOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.savingsPlanId = output.savingsPlanId
        } else {
            self.savingsPlanId = nil
        }
    }
}

public struct CreateSavingsPlanOutputResponse: Swift.Equatable {
    /// The ID of the Savings Plan.
    public var savingsPlanId: Swift.String?

    public init (
        savingsPlanId: Swift.String? = nil
    )
    {
        self.savingsPlanId = savingsPlanId
    }
}

struct CreateSavingsPlanOutputResponseBody: Swift.Equatable {
    let savingsPlanId: Swift.String?
}

extension CreateSavingsPlanOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case savingsPlanId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .savingsPlanId)
        savingsPlanId = savingsPlanIdDecoded
    }
}

extension SavingsplansClientTypes {
    public enum CurrencyCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cny
        case usd
        case sdkUnknown(Swift.String)

        public static var allCases: [CurrencyCode] {
            return [
                .cny,
                .usd,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cny: return "CNY"
            case .usd: return "USD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CurrencyCode(rawValue: rawValue) ?? CurrencyCode.sdkUnknown(rawValue)
        }
    }
}

extension DeleteQueuedSavingsPlanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case savingsPlanId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let savingsPlanId = self.savingsPlanId {
            try encodeContainer.encode(savingsPlanId, forKey: .savingsPlanId)
        }
    }
}

extension DeleteQueuedSavingsPlanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteQueuedSavingsPlan"
    }
}

public struct DeleteQueuedSavingsPlanInput: Swift.Equatable {
    /// The ID of the Savings Plan.
    /// This member is required.
    public var savingsPlanId: Swift.String?

    public init (
        savingsPlanId: Swift.String? = nil
    )
    {
        self.savingsPlanId = savingsPlanId
    }
}

struct DeleteQueuedSavingsPlanInputBody: Swift.Equatable {
    let savingsPlanId: Swift.String?
}

extension DeleteQueuedSavingsPlanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case savingsPlanId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .savingsPlanId)
        savingsPlanId = savingsPlanIdDecoded
    }
}

extension DeleteQueuedSavingsPlanOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteQueuedSavingsPlanOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteQueuedSavingsPlanOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteQueuedSavingsPlanOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteQueuedSavingsPlanOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeSavingsPlanRatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case savingsPlanId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for savingsplanratefilter0 in filters {
                try filtersContainer.encode(savingsplanratefilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let savingsPlanId = self.savingsPlanId {
            try encodeContainer.encode(savingsPlanId, forKey: .savingsPlanId)
        }
    }
}

extension DescribeSavingsPlanRatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeSavingsPlanRates"
    }
}

public struct DescribeSavingsPlanRatesInput: Swift.Equatable {
    /// The filters.
    public var filters: [SavingsplansClientTypes.SavingsPlanRateFilter]?
    /// The maximum number of results to return with a single call. To retrieve additional results, make another call with the returned token value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The ID of the Savings Plan.
    /// This member is required.
    public var savingsPlanId: Swift.String?

    public init (
        filters: [SavingsplansClientTypes.SavingsPlanRateFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        savingsPlanId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.savingsPlanId = savingsPlanId
    }
}

struct DescribeSavingsPlanRatesInputBody: Swift.Equatable {
    let savingsPlanId: Swift.String?
    let filters: [SavingsplansClientTypes.SavingsPlanRateFilter]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeSavingsPlanRatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case savingsPlanId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .savingsPlanId)
        savingsPlanId = savingsPlanIdDecoded
        let filtersContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.SavingsPlanRateFilter?].self, forKey: .filters)
        var filtersDecoded0:[SavingsplansClientTypes.SavingsPlanRateFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SavingsplansClientTypes.SavingsPlanRateFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeSavingsPlanRatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSavingsPlanRatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSavingsPlanRatesOutputError: Swift.Error, Swift.Equatable {
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSavingsPlanRatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSavingsPlanRatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.savingsPlanId = output.savingsPlanId
            self.searchResults = output.searchResults
        } else {
            self.nextToken = nil
            self.savingsPlanId = nil
            self.searchResults = nil
        }
    }
}

public struct DescribeSavingsPlanRatesOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The ID of the Savings Plan.
    public var savingsPlanId: Swift.String?
    /// Information about the Savings Plans rates.
    public var searchResults: [SavingsplansClientTypes.SavingsPlanRate]?

    public init (
        nextToken: Swift.String? = nil,
        savingsPlanId: Swift.String? = nil,
        searchResults: [SavingsplansClientTypes.SavingsPlanRate]? = nil
    )
    {
        self.nextToken = nextToken
        self.savingsPlanId = savingsPlanId
        self.searchResults = searchResults
    }
}

struct DescribeSavingsPlanRatesOutputResponseBody: Swift.Equatable {
    let savingsPlanId: Swift.String?
    let searchResults: [SavingsplansClientTypes.SavingsPlanRate]?
    let nextToken: Swift.String?
}

extension DescribeSavingsPlanRatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case savingsPlanId
        case searchResults
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .savingsPlanId)
        savingsPlanId = savingsPlanIdDecoded
        let searchResultsContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.SavingsPlanRate?].self, forKey: .searchResults)
        var searchResultsDecoded0:[SavingsplansClientTypes.SavingsPlanRate]? = nil
        if let searchResultsContainer = searchResultsContainer {
            searchResultsDecoded0 = [SavingsplansClientTypes.SavingsPlanRate]()
            for structure0 in searchResultsContainer {
                if let structure0 = structure0 {
                    searchResultsDecoded0?.append(structure0)
                }
            }
        }
        searchResults = searchResultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSavingsPlansInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case savingsPlanArns
        case savingsPlanIds
        case states
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for savingsplanfilter0 in filters {
                try filtersContainer.encode(savingsplanfilter0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let savingsPlanArns = savingsPlanArns {
            var savingsPlanArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .savingsPlanArns)
            for savingsplanarn0 in savingsPlanArns {
                try savingsPlanArnsContainer.encode(savingsplanarn0)
            }
        }
        if let savingsPlanIds = savingsPlanIds {
            var savingsPlanIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .savingsPlanIds)
            for savingsplanid0 in savingsPlanIds {
                try savingsPlanIdsContainer.encode(savingsplanid0)
            }
        }
        if let states = states {
            var statesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .states)
            for savingsplanstate0 in states {
                try statesContainer.encode(savingsplanstate0.rawValue)
            }
        }
    }
}

extension DescribeSavingsPlansInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeSavingsPlans"
    }
}

public struct DescribeSavingsPlansInput: Swift.Equatable {
    /// The filters.
    public var filters: [SavingsplansClientTypes.SavingsPlanFilter]?
    /// The maximum number of results to return with a single call. To retrieve additional results, make another call with the returned token value.
    public var maxResults: Swift.Int?
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Names (ARN) of the Savings Plans.
    public var savingsPlanArns: [Swift.String]?
    /// The IDs of the Savings Plans.
    public var savingsPlanIds: [Swift.String]?
    /// The states.
    public var states: [SavingsplansClientTypes.SavingsPlanState]?

    public init (
        filters: [SavingsplansClientTypes.SavingsPlanFilter]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        savingsPlanArns: [Swift.String]? = nil,
        savingsPlanIds: [Swift.String]? = nil,
        states: [SavingsplansClientTypes.SavingsPlanState]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.savingsPlanArns = savingsPlanArns
        self.savingsPlanIds = savingsPlanIds
        self.states = states
    }
}

struct DescribeSavingsPlansInputBody: Swift.Equatable {
    let savingsPlanArns: [Swift.String]?
    let savingsPlanIds: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let states: [SavingsplansClientTypes.SavingsPlanState]?
    let filters: [SavingsplansClientTypes.SavingsPlanFilter]?
}

extension DescribeSavingsPlansInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case savingsPlanArns
        case savingsPlanIds
        case states
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlanArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .savingsPlanArns)
        var savingsPlanArnsDecoded0:[Swift.String]? = nil
        if let savingsPlanArnsContainer = savingsPlanArnsContainer {
            savingsPlanArnsDecoded0 = [Swift.String]()
            for string0 in savingsPlanArnsContainer {
                if let string0 = string0 {
                    savingsPlanArnsDecoded0?.append(string0)
                }
            }
        }
        savingsPlanArns = savingsPlanArnsDecoded0
        let savingsPlanIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .savingsPlanIds)
        var savingsPlanIdsDecoded0:[Swift.String]? = nil
        if let savingsPlanIdsContainer = savingsPlanIdsContainer {
            savingsPlanIdsDecoded0 = [Swift.String]()
            for string0 in savingsPlanIdsContainer {
                if let string0 = string0 {
                    savingsPlanIdsDecoded0?.append(string0)
                }
            }
        }
        savingsPlanIds = savingsPlanIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let statesContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.SavingsPlanState?].self, forKey: .states)
        var statesDecoded0:[SavingsplansClientTypes.SavingsPlanState]? = nil
        if let statesContainer = statesContainer {
            statesDecoded0 = [SavingsplansClientTypes.SavingsPlanState]()
            for string0 in statesContainer {
                if let string0 = string0 {
                    statesDecoded0?.append(string0)
                }
            }
        }
        states = statesDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.SavingsPlanFilter?].self, forKey: .filters)
        var filtersDecoded0:[SavingsplansClientTypes.SavingsPlanFilter]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SavingsplansClientTypes.SavingsPlanFilter]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
    }
}

extension DescribeSavingsPlansOfferingRatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case operations
        case products
        case savingsPlanOfferingIds
        case savingsPlanPaymentOptions
        case savingsPlanTypes
        case serviceCodes
        case usageTypes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for savingsplanofferingratefilterelement0 in filters {
                try filtersContainer.encode(savingsplanofferingratefilterelement0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for savingsplanrateoperation0 in operations {
                try operationsContainer.encode(savingsplanrateoperation0)
            }
        }
        if let products = products {
            var productsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .products)
            for savingsplanproducttype0 in products {
                try productsContainer.encode(savingsplanproducttype0.rawValue)
            }
        }
        if let savingsPlanOfferingIds = savingsPlanOfferingIds {
            var savingsPlanOfferingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .savingsPlanOfferingIds)
            for uuid0 in savingsPlanOfferingIds {
                try savingsPlanOfferingIdsContainer.encode(uuid0)
            }
        }
        if let savingsPlanPaymentOptions = savingsPlanPaymentOptions {
            var savingsPlanPaymentOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .savingsPlanPaymentOptions)
            for savingsplanpaymentoption0 in savingsPlanPaymentOptions {
                try savingsPlanPaymentOptionsContainer.encode(savingsplanpaymentoption0.rawValue)
            }
        }
        if let savingsPlanTypes = savingsPlanTypes {
            var savingsPlanTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .savingsPlanTypes)
            for savingsplantype0 in savingsPlanTypes {
                try savingsPlanTypesContainer.encode(savingsplantype0.rawValue)
            }
        }
        if let serviceCodes = serviceCodes {
            var serviceCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceCodes)
            for savingsplanrateservicecode0 in serviceCodes {
                try serviceCodesContainer.encode(savingsplanrateservicecode0.rawValue)
            }
        }
        if let usageTypes = usageTypes {
            var usageTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usageTypes)
            for savingsplanrateusagetype0 in usageTypes {
                try usageTypesContainer.encode(savingsplanrateusagetype0)
            }
        }
    }
}

extension DescribeSavingsPlansOfferingRatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeSavingsPlansOfferingRates"
    }
}

public struct DescribeSavingsPlansOfferingRatesInput: Swift.Equatable {
    /// The filters.
    public var filters: [SavingsplansClientTypes.SavingsPlanOfferingRateFilterElement]?
    /// The maximum number of results to return with a single call. To retrieve additional results, make another call with the returned token value.
    public var maxResults: Swift.Int
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The specific AWS operation for the line item in the billing report.
    public var operations: [Swift.String]?
    /// The AWS products.
    public var products: [SavingsplansClientTypes.SavingsPlanProductType]?
    /// The IDs of the offerings.
    public var savingsPlanOfferingIds: [Swift.String]?
    /// The payment options.
    public var savingsPlanPaymentOptions: [SavingsplansClientTypes.SavingsPlanPaymentOption]?
    /// The plan types.
    public var savingsPlanTypes: [SavingsplansClientTypes.SavingsPlanType]?
    /// The services.
    public var serviceCodes: [SavingsplansClientTypes.SavingsPlanRateServiceCode]?
    /// The usage details of the line item in the billing report.
    public var usageTypes: [Swift.String]?

    public init (
        filters: [SavingsplansClientTypes.SavingsPlanOfferingRateFilterElement]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        operations: [Swift.String]? = nil,
        products: [SavingsplansClientTypes.SavingsPlanProductType]? = nil,
        savingsPlanOfferingIds: [Swift.String]? = nil,
        savingsPlanPaymentOptions: [SavingsplansClientTypes.SavingsPlanPaymentOption]? = nil,
        savingsPlanTypes: [SavingsplansClientTypes.SavingsPlanType]? = nil,
        serviceCodes: [SavingsplansClientTypes.SavingsPlanRateServiceCode]? = nil,
        usageTypes: [Swift.String]? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.operations = operations
        self.products = products
        self.savingsPlanOfferingIds = savingsPlanOfferingIds
        self.savingsPlanPaymentOptions = savingsPlanPaymentOptions
        self.savingsPlanTypes = savingsPlanTypes
        self.serviceCodes = serviceCodes
        self.usageTypes = usageTypes
    }
}

struct DescribeSavingsPlansOfferingRatesInputBody: Swift.Equatable {
    let savingsPlanOfferingIds: [Swift.String]?
    let savingsPlanPaymentOptions: [SavingsplansClientTypes.SavingsPlanPaymentOption]?
    let savingsPlanTypes: [SavingsplansClientTypes.SavingsPlanType]?
    let products: [SavingsplansClientTypes.SavingsPlanProductType]?
    let serviceCodes: [SavingsplansClientTypes.SavingsPlanRateServiceCode]?
    let usageTypes: [Swift.String]?
    let operations: [Swift.String]?
    let filters: [SavingsplansClientTypes.SavingsPlanOfferingRateFilterElement]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension DescribeSavingsPlansOfferingRatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case operations
        case products
        case savingsPlanOfferingIds
        case savingsPlanPaymentOptions
        case savingsPlanTypes
        case serviceCodes
        case usageTypes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlanOfferingIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .savingsPlanOfferingIds)
        var savingsPlanOfferingIdsDecoded0:[Swift.String]? = nil
        if let savingsPlanOfferingIdsContainer = savingsPlanOfferingIdsContainer {
            savingsPlanOfferingIdsDecoded0 = [Swift.String]()
            for string0 in savingsPlanOfferingIdsContainer {
                if let string0 = string0 {
                    savingsPlanOfferingIdsDecoded0?.append(string0)
                }
            }
        }
        savingsPlanOfferingIds = savingsPlanOfferingIdsDecoded0
        let savingsPlanPaymentOptionsContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.SavingsPlanPaymentOption?].self, forKey: .savingsPlanPaymentOptions)
        var savingsPlanPaymentOptionsDecoded0:[SavingsplansClientTypes.SavingsPlanPaymentOption]? = nil
        if let savingsPlanPaymentOptionsContainer = savingsPlanPaymentOptionsContainer {
            savingsPlanPaymentOptionsDecoded0 = [SavingsplansClientTypes.SavingsPlanPaymentOption]()
            for string0 in savingsPlanPaymentOptionsContainer {
                if let string0 = string0 {
                    savingsPlanPaymentOptionsDecoded0?.append(string0)
                }
            }
        }
        savingsPlanPaymentOptions = savingsPlanPaymentOptionsDecoded0
        let savingsPlanTypesContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.SavingsPlanType?].self, forKey: .savingsPlanTypes)
        var savingsPlanTypesDecoded0:[SavingsplansClientTypes.SavingsPlanType]? = nil
        if let savingsPlanTypesContainer = savingsPlanTypesContainer {
            savingsPlanTypesDecoded0 = [SavingsplansClientTypes.SavingsPlanType]()
            for string0 in savingsPlanTypesContainer {
                if let string0 = string0 {
                    savingsPlanTypesDecoded0?.append(string0)
                }
            }
        }
        savingsPlanTypes = savingsPlanTypesDecoded0
        let productsContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.SavingsPlanProductType?].self, forKey: .products)
        var productsDecoded0:[SavingsplansClientTypes.SavingsPlanProductType]? = nil
        if let productsContainer = productsContainer {
            productsDecoded0 = [SavingsplansClientTypes.SavingsPlanProductType]()
            for string0 in productsContainer {
                if let string0 = string0 {
                    productsDecoded0?.append(string0)
                }
            }
        }
        products = productsDecoded0
        let serviceCodesContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.SavingsPlanRateServiceCode?].self, forKey: .serviceCodes)
        var serviceCodesDecoded0:[SavingsplansClientTypes.SavingsPlanRateServiceCode]? = nil
        if let serviceCodesContainer = serviceCodesContainer {
            serviceCodesDecoded0 = [SavingsplansClientTypes.SavingsPlanRateServiceCode]()
            for string0 in serviceCodesContainer {
                if let string0 = string0 {
                    serviceCodesDecoded0?.append(string0)
                }
            }
        }
        serviceCodes = serviceCodesDecoded0
        let usageTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .usageTypes)
        var usageTypesDecoded0:[Swift.String]? = nil
        if let usageTypesContainer = usageTypesContainer {
            usageTypesDecoded0 = [Swift.String]()
            for string0 in usageTypesContainer {
                if let string0 = string0 {
                    usageTypesDecoded0?.append(string0)
                }
            }
        }
        usageTypes = usageTypesDecoded0
        let operationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .operations)
        var operationsDecoded0:[Swift.String]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [Swift.String]()
            for string0 in operationsContainer {
                if let string0 = string0 {
                    operationsDecoded0?.append(string0)
                }
            }
        }
        operations = operationsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.SavingsPlanOfferingRateFilterElement?].self, forKey: .filters)
        var filtersDecoded0:[SavingsplansClientTypes.SavingsPlanOfferingRateFilterElement]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SavingsplansClientTypes.SavingsPlanOfferingRateFilterElement]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension DescribeSavingsPlansOfferingRatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSavingsPlansOfferingRatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSavingsPlansOfferingRatesOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSavingsPlansOfferingRatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSavingsPlansOfferingRatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.searchResults = output.searchResults
        } else {
            self.nextToken = nil
            self.searchResults = nil
        }
    }
}

public struct DescribeSavingsPlansOfferingRatesOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the Savings Plans offering rates.
    public var searchResults: [SavingsplansClientTypes.SavingsPlanOfferingRate]?

    public init (
        nextToken: Swift.String? = nil,
        searchResults: [SavingsplansClientTypes.SavingsPlanOfferingRate]? = nil
    )
    {
        self.nextToken = nextToken
        self.searchResults = searchResults
    }
}

struct DescribeSavingsPlansOfferingRatesOutputResponseBody: Swift.Equatable {
    let searchResults: [SavingsplansClientTypes.SavingsPlanOfferingRate]?
    let nextToken: Swift.String?
}

extension DescribeSavingsPlansOfferingRatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case searchResults
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchResultsContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.SavingsPlanOfferingRate?].self, forKey: .searchResults)
        var searchResultsDecoded0:[SavingsplansClientTypes.SavingsPlanOfferingRate]? = nil
        if let searchResultsContainer = searchResultsContainer {
            searchResultsDecoded0 = [SavingsplansClientTypes.SavingsPlanOfferingRate]()
            for structure0 in searchResultsContainer {
                if let structure0 = structure0 {
                    searchResultsDecoded0?.append(structure0)
                }
            }
        }
        searchResults = searchResultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSavingsPlansOfferingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencies
        case descriptions
        case durations
        case filters
        case maxResults
        case nextToken
        case offeringIds
        case operations
        case paymentOptions
        case planTypes
        case productType
        case serviceCodes
        case usageTypes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currencies = currencies {
            var currenciesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .currencies)
            for currencycode0 in currencies {
                try currenciesContainer.encode(currencycode0.rawValue)
            }
        }
        if let descriptions = descriptions {
            var descriptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .descriptions)
            for savingsplandescription0 in descriptions {
                try descriptionsContainer.encode(savingsplandescription0)
            }
        }
        if let durations = durations {
            var durationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .durations)
            for savingsplansduration0 in durations {
                try durationsContainer.encode(savingsplansduration0)
            }
        }
        if let filters = filters {
            var filtersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filters)
            for savingsplanofferingfilterelement0 in filters {
                try filtersContainer.encode(savingsplanofferingfilterelement0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let offeringIds = offeringIds {
            var offeringIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .offeringIds)
            for uuid0 in offeringIds {
                try offeringIdsContainer.encode(uuid0)
            }
        }
        if let operations = operations {
            var operationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .operations)
            for savingsplanoperation0 in operations {
                try operationsContainer.encode(savingsplanoperation0)
            }
        }
        if let paymentOptions = paymentOptions {
            var paymentOptionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .paymentOptions)
            for savingsplanpaymentoption0 in paymentOptions {
                try paymentOptionsContainer.encode(savingsplanpaymentoption0.rawValue)
            }
        }
        if let planTypes = planTypes {
            var planTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .planTypes)
            for savingsplantype0 in planTypes {
                try planTypesContainer.encode(savingsplantype0.rawValue)
            }
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
        if let serviceCodes = serviceCodes {
            var serviceCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serviceCodes)
            for savingsplanservicecode0 in serviceCodes {
                try serviceCodesContainer.encode(savingsplanservicecode0)
            }
        }
        if let usageTypes = usageTypes {
            var usageTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .usageTypes)
            for savingsplanusagetype0 in usageTypes {
                try usageTypesContainer.encode(savingsplanusagetype0)
            }
        }
    }
}

extension DescribeSavingsPlansOfferingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeSavingsPlansOfferings"
    }
}

public struct DescribeSavingsPlansOfferingsInput: Swift.Equatable {
    /// The currencies.
    public var currencies: [SavingsplansClientTypes.CurrencyCode]?
    /// The descriptions.
    public var descriptions: [Swift.String]?
    /// The durations, in seconds.
    public var durations: [Swift.Int]?
    /// The filters.
    public var filters: [SavingsplansClientTypes.SavingsPlanOfferingFilterElement]?
    /// The maximum number of results to return with a single call. To retrieve additional results, make another call with the returned token value.
    public var maxResults: Swift.Int
    /// The token for the next page of results.
    public var nextToken: Swift.String?
    /// The IDs of the offerings.
    public var offeringIds: [Swift.String]?
    /// The specific AWS operation for the line item in the billing report.
    public var operations: [Swift.String]?
    /// The payment options.
    public var paymentOptions: [SavingsplansClientTypes.SavingsPlanPaymentOption]?
    /// The plan type.
    public var planTypes: [SavingsplansClientTypes.SavingsPlanType]?
    /// The product type.
    public var productType: SavingsplansClientTypes.SavingsPlanProductType?
    /// The services.
    public var serviceCodes: [Swift.String]?
    /// The usage details of the line item in the billing report.
    public var usageTypes: [Swift.String]?

    public init (
        currencies: [SavingsplansClientTypes.CurrencyCode]? = nil,
        descriptions: [Swift.String]? = nil,
        durations: [Swift.Int]? = nil,
        filters: [SavingsplansClientTypes.SavingsPlanOfferingFilterElement]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        offeringIds: [Swift.String]? = nil,
        operations: [Swift.String]? = nil,
        paymentOptions: [SavingsplansClientTypes.SavingsPlanPaymentOption]? = nil,
        planTypes: [SavingsplansClientTypes.SavingsPlanType]? = nil,
        productType: SavingsplansClientTypes.SavingsPlanProductType? = nil,
        serviceCodes: [Swift.String]? = nil,
        usageTypes: [Swift.String]? = nil
    )
    {
        self.currencies = currencies
        self.descriptions = descriptions
        self.durations = durations
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.offeringIds = offeringIds
        self.operations = operations
        self.paymentOptions = paymentOptions
        self.planTypes = planTypes
        self.productType = productType
        self.serviceCodes = serviceCodes
        self.usageTypes = usageTypes
    }
}

struct DescribeSavingsPlansOfferingsInputBody: Swift.Equatable {
    let offeringIds: [Swift.String]?
    let paymentOptions: [SavingsplansClientTypes.SavingsPlanPaymentOption]?
    let productType: SavingsplansClientTypes.SavingsPlanProductType?
    let planTypes: [SavingsplansClientTypes.SavingsPlanType]?
    let durations: [Swift.Int]?
    let currencies: [SavingsplansClientTypes.CurrencyCode]?
    let descriptions: [Swift.String]?
    let serviceCodes: [Swift.String]?
    let usageTypes: [Swift.String]?
    let operations: [Swift.String]?
    let filters: [SavingsplansClientTypes.SavingsPlanOfferingFilterElement]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int
}

extension DescribeSavingsPlansOfferingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currencies
        case descriptions
        case durations
        case filters
        case maxResults
        case nextToken
        case offeringIds
        case operations
        case paymentOptions
        case planTypes
        case productType
        case serviceCodes
        case usageTypes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .offeringIds)
        var offeringIdsDecoded0:[Swift.String]? = nil
        if let offeringIdsContainer = offeringIdsContainer {
            offeringIdsDecoded0 = [Swift.String]()
            for string0 in offeringIdsContainer {
                if let string0 = string0 {
                    offeringIdsDecoded0?.append(string0)
                }
            }
        }
        offeringIds = offeringIdsDecoded0
        let paymentOptionsContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.SavingsPlanPaymentOption?].self, forKey: .paymentOptions)
        var paymentOptionsDecoded0:[SavingsplansClientTypes.SavingsPlanPaymentOption]? = nil
        if let paymentOptionsContainer = paymentOptionsContainer {
            paymentOptionsDecoded0 = [SavingsplansClientTypes.SavingsPlanPaymentOption]()
            for string0 in paymentOptionsContainer {
                if let string0 = string0 {
                    paymentOptionsDecoded0?.append(string0)
                }
            }
        }
        paymentOptions = paymentOptionsDecoded0
        let productTypeDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.SavingsPlanProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let planTypesContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.SavingsPlanType?].self, forKey: .planTypes)
        var planTypesDecoded0:[SavingsplansClientTypes.SavingsPlanType]? = nil
        if let planTypesContainer = planTypesContainer {
            planTypesDecoded0 = [SavingsplansClientTypes.SavingsPlanType]()
            for string0 in planTypesContainer {
                if let string0 = string0 {
                    planTypesDecoded0?.append(string0)
                }
            }
        }
        planTypes = planTypesDecoded0
        let durationsContainer = try containerValues.decodeIfPresent([Swift.Int?].self, forKey: .durations)
        var durationsDecoded0:[Swift.Int]? = nil
        if let durationsContainer = durationsContainer {
            durationsDecoded0 = [Swift.Int]()
            for long0 in durationsContainer {
                if let long0 = long0 {
                    durationsDecoded0?.append(long0)
                }
            }
        }
        durations = durationsDecoded0
        let currenciesContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.CurrencyCode?].self, forKey: .currencies)
        var currenciesDecoded0:[SavingsplansClientTypes.CurrencyCode]? = nil
        if let currenciesContainer = currenciesContainer {
            currenciesDecoded0 = [SavingsplansClientTypes.CurrencyCode]()
            for string0 in currenciesContainer {
                if let string0 = string0 {
                    currenciesDecoded0?.append(string0)
                }
            }
        }
        currencies = currenciesDecoded0
        let descriptionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .descriptions)
        var descriptionsDecoded0:[Swift.String]? = nil
        if let descriptionsContainer = descriptionsContainer {
            descriptionsDecoded0 = [Swift.String]()
            for string0 in descriptionsContainer {
                if let string0 = string0 {
                    descriptionsDecoded0?.append(string0)
                }
            }
        }
        descriptions = descriptionsDecoded0
        let serviceCodesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .serviceCodes)
        var serviceCodesDecoded0:[Swift.String]? = nil
        if let serviceCodesContainer = serviceCodesContainer {
            serviceCodesDecoded0 = [Swift.String]()
            for string0 in serviceCodesContainer {
                if let string0 = string0 {
                    serviceCodesDecoded0?.append(string0)
                }
            }
        }
        serviceCodes = serviceCodesDecoded0
        let usageTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .usageTypes)
        var usageTypesDecoded0:[Swift.String]? = nil
        if let usageTypesContainer = usageTypesContainer {
            usageTypesDecoded0 = [Swift.String]()
            for string0 in usageTypesContainer {
                if let string0 = string0 {
                    usageTypesDecoded0?.append(string0)
                }
            }
        }
        usageTypes = usageTypesDecoded0
        let operationsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .operations)
        var operationsDecoded0:[Swift.String]? = nil
        if let operationsContainer = operationsContainer {
            operationsDecoded0 = [Swift.String]()
            for string0 in operationsContainer {
                if let string0 = string0 {
                    operationsDecoded0?.append(string0)
                }
            }
        }
        operations = operationsDecoded0
        let filtersContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.SavingsPlanOfferingFilterElement?].self, forKey: .filters)
        var filtersDecoded0:[SavingsplansClientTypes.SavingsPlanOfferingFilterElement]? = nil
        if let filtersContainer = filtersContainer {
            filtersDecoded0 = [SavingsplansClientTypes.SavingsPlanOfferingFilterElement]()
            for structure0 in filtersContainer {
                if let structure0 = structure0 {
                    filtersDecoded0?.append(structure0)
                }
            }
        }
        filters = filtersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
    }
}

extension DescribeSavingsPlansOfferingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSavingsPlansOfferingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSavingsPlansOfferingsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSavingsPlansOfferingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSavingsPlansOfferingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.searchResults = output.searchResults
        } else {
            self.nextToken = nil
            self.searchResults = nil
        }
    }
}

public struct DescribeSavingsPlansOfferingsOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the Savings Plans offerings.
    public var searchResults: [SavingsplansClientTypes.SavingsPlanOffering]?

    public init (
        nextToken: Swift.String? = nil,
        searchResults: [SavingsplansClientTypes.SavingsPlanOffering]? = nil
    )
    {
        self.nextToken = nextToken
        self.searchResults = searchResults
    }
}

struct DescribeSavingsPlansOfferingsOutputResponseBody: Swift.Equatable {
    let searchResults: [SavingsplansClientTypes.SavingsPlanOffering]?
    let nextToken: Swift.String?
}

extension DescribeSavingsPlansOfferingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case searchResults
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let searchResultsContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.SavingsPlanOffering?].self, forKey: .searchResults)
        var searchResultsDecoded0:[SavingsplansClientTypes.SavingsPlanOffering]? = nil
        if let searchResultsContainer = searchResultsContainer {
            searchResultsDecoded0 = [SavingsplansClientTypes.SavingsPlanOffering]()
            for structure0 in searchResultsContainer {
                if let structure0 = structure0 {
                    searchResultsDecoded0?.append(structure0)
                }
            }
        }
        searchResults = searchResultsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSavingsPlansOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSavingsPlansOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSavingsPlansOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSavingsPlansOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSavingsPlansOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.savingsPlans = output.savingsPlans
        } else {
            self.nextToken = nil
            self.savingsPlans = nil
        }
    }
}

public struct DescribeSavingsPlansOutputResponse: Swift.Equatable {
    /// The token to use to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the Savings Plans.
    public var savingsPlans: [SavingsplansClientTypes.SavingsPlan]?

    public init (
        nextToken: Swift.String? = nil,
        savingsPlans: [SavingsplansClientTypes.SavingsPlan]? = nil
    )
    {
        self.nextToken = nextToken
        self.savingsPlans = savingsPlans
    }
}

struct DescribeSavingsPlansOutputResponseBody: Swift.Equatable {
    let savingsPlans: [SavingsplansClientTypes.SavingsPlan]?
    let nextToken: Swift.String?
}

extension DescribeSavingsPlansOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case savingsPlans
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlansContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.SavingsPlan?].self, forKey: .savingsPlans)
        var savingsPlansDecoded0:[SavingsplansClientTypes.SavingsPlan]? = nil
        if let savingsPlansContainer = savingsPlansContainer {
            savingsPlansDecoded0 = [SavingsplansClientTypes.SavingsPlan]()
            for structure0 in savingsPlansContainer {
                if let structure0 = structure0 {
                    savingsPlansDecoded0?.append(structure0)
                }
            }
        }
        savingsPlans = savingsPlansDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An unexpected error occurred.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListTagsForResource"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// Information about the tags.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SavingsplansClientTypes.ParentSavingsPlanOffering: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currency
        case durationSeconds
        case offeringId
        case paymentOption
        case planDescription
        case planType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currency = self.currency {
            try encodeContainer.encode(currency.rawValue, forKey: .currency)
        }
        if durationSeconds != 0 {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let offeringId = self.offeringId {
            try encodeContainer.encode(offeringId, forKey: .offeringId)
        }
        if let paymentOption = self.paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let planDescription = self.planDescription {
            try encodeContainer.encode(planDescription, forKey: .planDescription)
        }
        if let planType = self.planType {
            try encodeContainer.encode(planType.rawValue, forKey: .planType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringId)
        offeringId = offeringIdDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.SavingsPlanPaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let planTypeDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.SavingsPlanType.self, forKey: .planType)
        planType = planTypeDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationSeconds) ?? 0
        durationSeconds = durationSecondsDecoded
        let currencyDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.CurrencyCode.self, forKey: .currency)
        currency = currencyDecoded
        let planDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .planDescription)
        planDescription = planDescriptionDecoded
    }
}

extension SavingsplansClientTypes {
    /// Information about a Savings Plan offering.
    public struct ParentSavingsPlanOffering: Swift.Equatable {
        /// The currency.
        public var currency: SavingsplansClientTypes.CurrencyCode?
        /// The duration, in seconds.
        public var durationSeconds: Swift.Int
        /// The ID of the offering.
        public var offeringId: Swift.String?
        /// The payment option.
        public var paymentOption: SavingsplansClientTypes.SavingsPlanPaymentOption?
        /// The description.
        public var planDescription: Swift.String?
        /// The plan type.
        public var planType: SavingsplansClientTypes.SavingsPlanType?

        public init (
            currency: SavingsplansClientTypes.CurrencyCode? = nil,
            durationSeconds: Swift.Int = 0,
            offeringId: Swift.String? = nil,
            paymentOption: SavingsplansClientTypes.SavingsPlanPaymentOption? = nil,
            planDescription: Swift.String? = nil,
            planType: SavingsplansClientTypes.SavingsPlanType? = nil
        )
        {
            self.currency = currency
            self.durationSeconds = durationSeconds
            self.offeringId = offeringId
            self.paymentOption = paymentOption
            self.planDescription = planDescription
            self.planType = planType
        }
    }

}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource was not found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SavingsplansClientTypes.SavingsPlan: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case commitment
        case currency
        case description
        case ec2InstanceFamily
        case end
        case offeringId
        case paymentOption
        case productTypes
        case recurringPaymentAmount
        case region
        case savingsPlanArn
        case savingsPlanId
        case savingsPlanType
        case start
        case state
        case tags
        case termDurationInSeconds
        case upfrontPaymentAmount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let commitment = self.commitment {
            try encodeContainer.encode(commitment, forKey: .commitment)
        }
        if let currency = self.currency {
            try encodeContainer.encode(currency.rawValue, forKey: .currency)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let ec2InstanceFamily = self.ec2InstanceFamily {
            try encodeContainer.encode(ec2InstanceFamily, forKey: .ec2InstanceFamily)
        }
        if let end = self.end {
            try encodeContainer.encode(end, forKey: .end)
        }
        if let offeringId = self.offeringId {
            try encodeContainer.encode(offeringId, forKey: .offeringId)
        }
        if let paymentOption = self.paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let productTypes = productTypes {
            var productTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productTypes)
            for savingsplanproducttype0 in productTypes {
                try productTypesContainer.encode(savingsplanproducttype0.rawValue)
            }
        }
        if let recurringPaymentAmount = self.recurringPaymentAmount {
            try encodeContainer.encode(recurringPaymentAmount, forKey: .recurringPaymentAmount)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let savingsPlanArn = self.savingsPlanArn {
            try encodeContainer.encode(savingsPlanArn, forKey: .savingsPlanArn)
        }
        if let savingsPlanId = self.savingsPlanId {
            try encodeContainer.encode(savingsPlanId, forKey: .savingsPlanId)
        }
        if let savingsPlanType = self.savingsPlanType {
            try encodeContainer.encode(savingsPlanType.rawValue, forKey: .savingsPlanType)
        }
        if let start = self.start {
            try encodeContainer.encode(start, forKey: .start)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if termDurationInSeconds != 0 {
            try encodeContainer.encode(termDurationInSeconds, forKey: .termDurationInSeconds)
        }
        if let upfrontPaymentAmount = self.upfrontPaymentAmount {
            try encodeContainer.encode(upfrontPaymentAmount, forKey: .upfrontPaymentAmount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringId)
        offeringId = offeringIdDecoded
        let savingsPlanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .savingsPlanId)
        savingsPlanId = savingsPlanIdDecoded
        let savingsPlanArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .savingsPlanArn)
        savingsPlanArn = savingsPlanArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .end)
        end = endDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.SavingsPlanState.self, forKey: .state)
        state = stateDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let ec2InstanceFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceFamily)
        ec2InstanceFamily = ec2InstanceFamilyDecoded
        let savingsPlanTypeDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.SavingsPlanType.self, forKey: .savingsPlanType)
        savingsPlanType = savingsPlanTypeDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.SavingsPlanPaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let productTypesContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.SavingsPlanProductType?].self, forKey: .productTypes)
        var productTypesDecoded0:[SavingsplansClientTypes.SavingsPlanProductType]? = nil
        if let productTypesContainer = productTypesContainer {
            productTypesDecoded0 = [SavingsplansClientTypes.SavingsPlanProductType]()
            for string0 in productTypesContainer {
                if let string0 = string0 {
                    productTypesDecoded0?.append(string0)
                }
            }
        }
        productTypes = productTypesDecoded0
        let currencyDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.CurrencyCode.self, forKey: .currency)
        currency = currencyDecoded
        let commitmentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .commitment)
        commitment = commitmentDecoded
        let upfrontPaymentAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upfrontPaymentAmount)
        upfrontPaymentAmount = upfrontPaymentAmountDecoded
        let recurringPaymentAmountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recurringPaymentAmount)
        recurringPaymentAmount = recurringPaymentAmountDecoded
        let termDurationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .termDurationInSeconds) ?? 0
        termDurationInSeconds = termDurationInSecondsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension SavingsplansClientTypes {
    /// Information about a Savings Plan.
    public struct SavingsPlan: Swift.Equatable {
        /// The hourly commitment, in USD.
        public var commitment: Swift.String?
        /// The currency.
        public var currency: SavingsplansClientTypes.CurrencyCode?
        /// The description.
        public var description: Swift.String?
        /// The EC2 instance family.
        public var ec2InstanceFamily: Swift.String?
        /// The end time.
        public var end: Swift.String?
        /// The ID of the offering.
        public var offeringId: Swift.String?
        /// The payment option.
        public var paymentOption: SavingsplansClientTypes.SavingsPlanPaymentOption?
        /// The product types.
        public var productTypes: [SavingsplansClientTypes.SavingsPlanProductType]?
        /// The recurring payment amount.
        public var recurringPaymentAmount: Swift.String?
        /// The AWS Region.
        public var region: Swift.String?
        /// The Amazon Resource Name (ARN) of the Savings Plan.
        public var savingsPlanArn: Swift.String?
        /// The ID of the Savings Plan.
        public var savingsPlanId: Swift.String?
        /// The plan type.
        public var savingsPlanType: SavingsplansClientTypes.SavingsPlanType?
        /// The start time.
        public var start: Swift.String?
        /// The state.
        public var state: SavingsplansClientTypes.SavingsPlanState?
        /// One or more tags.
        public var tags: [Swift.String:Swift.String]?
        /// The duration of the term, in seconds.
        public var termDurationInSeconds: Swift.Int
        /// The up-front payment amount.
        public var upfrontPaymentAmount: Swift.String?

        public init (
            commitment: Swift.String? = nil,
            currency: SavingsplansClientTypes.CurrencyCode? = nil,
            description: Swift.String? = nil,
            ec2InstanceFamily: Swift.String? = nil,
            end: Swift.String? = nil,
            offeringId: Swift.String? = nil,
            paymentOption: SavingsplansClientTypes.SavingsPlanPaymentOption? = nil,
            productTypes: [SavingsplansClientTypes.SavingsPlanProductType]? = nil,
            recurringPaymentAmount: Swift.String? = nil,
            region: Swift.String? = nil,
            savingsPlanArn: Swift.String? = nil,
            savingsPlanId: Swift.String? = nil,
            savingsPlanType: SavingsplansClientTypes.SavingsPlanType? = nil,
            start: Swift.String? = nil,
            state: SavingsplansClientTypes.SavingsPlanState? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            termDurationInSeconds: Swift.Int = 0,
            upfrontPaymentAmount: Swift.String? = nil
        )
        {
            self.commitment = commitment
            self.currency = currency
            self.description = description
            self.ec2InstanceFamily = ec2InstanceFamily
            self.end = end
            self.offeringId = offeringId
            self.paymentOption = paymentOption
            self.productTypes = productTypes
            self.recurringPaymentAmount = recurringPaymentAmount
            self.region = region
            self.savingsPlanArn = savingsPlanArn
            self.savingsPlanId = savingsPlanId
            self.savingsPlanType = savingsPlanType
            self.start = start
            self.state = state
            self.tags = tags
            self.termDurationInSeconds = termDurationInSeconds
            self.upfrontPaymentAmount = upfrontPaymentAmount
        }
    }

}

extension SavingsplansClientTypes.SavingsPlanFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string0 in values {
                try valuesContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.SavingsPlansFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SavingsplansClientTypes {
    /// Information about a filter.
    public struct SavingsPlanFilter: Swift.Equatable {
        /// The filter name.
        public var name: SavingsplansClientTypes.SavingsPlansFilterName?
        /// The filter value.
        public var values: [Swift.String]?

        public init (
            name: SavingsplansClientTypes.SavingsPlansFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension SavingsplansClientTypes.SavingsPlanOffering: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currency
        case description
        case durationSeconds
        case offeringId
        case operation
        case paymentOption
        case planType
        case productTypes
        case properties
        case serviceCode
        case usageType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currency = self.currency {
            try encodeContainer.encode(currency.rawValue, forKey: .currency)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if durationSeconds != 0 {
            try encodeContainer.encode(durationSeconds, forKey: .durationSeconds)
        }
        if let offeringId = self.offeringId {
            try encodeContainer.encode(offeringId, forKey: .offeringId)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let paymentOption = self.paymentOption {
            try encodeContainer.encode(paymentOption.rawValue, forKey: .paymentOption)
        }
        if let planType = self.planType {
            try encodeContainer.encode(planType.rawValue, forKey: .planType)
        }
        if let productTypes = productTypes {
            var productTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productTypes)
            for savingsplanproducttype0 in productTypes {
                try productTypesContainer.encode(savingsplanproducttype0.rawValue)
            }
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for savingsplanofferingproperty0 in properties {
                try propertiesContainer.encode(savingsplanofferingproperty0)
            }
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode, forKey: .serviceCode)
        }
        if let usageType = self.usageType {
            try encodeContainer.encode(usageType, forKey: .usageType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let offeringIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offeringId)
        offeringId = offeringIdDecoded
        let productTypesContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.SavingsPlanProductType?].self, forKey: .productTypes)
        var productTypesDecoded0:[SavingsplansClientTypes.SavingsPlanProductType]? = nil
        if let productTypesContainer = productTypesContainer {
            productTypesDecoded0 = [SavingsplansClientTypes.SavingsPlanProductType]()
            for string0 in productTypesContainer {
                if let string0 = string0 {
                    productTypesDecoded0?.append(string0)
                }
            }
        }
        productTypes = productTypesDecoded0
        let planTypeDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.SavingsPlanType.self, forKey: .planType)
        planType = planTypeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let paymentOptionDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.SavingsPlanPaymentOption.self, forKey: .paymentOption)
        paymentOption = paymentOptionDecoded
        let durationSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationSeconds) ?? 0
        durationSeconds = durationSecondsDecoded
        let currencyDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.CurrencyCode.self, forKey: .currency)
        currency = currencyDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let usageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageType)
        usageType = usageTypeDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.SavingsPlanOfferingProperty?].self, forKey: .properties)
        var propertiesDecoded0:[SavingsplansClientTypes.SavingsPlanOfferingProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [SavingsplansClientTypes.SavingsPlanOfferingProperty]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
    }
}

extension SavingsplansClientTypes {
    /// Information about a Savings Plan offering.
    public struct SavingsPlanOffering: Swift.Equatable {
        /// The currency.
        public var currency: SavingsplansClientTypes.CurrencyCode?
        /// The description.
        public var description: Swift.String?
        /// The duration, in seconds.
        public var durationSeconds: Swift.Int
        /// The ID of the offering.
        public var offeringId: Swift.String?
        /// The specific AWS operation for the line item in the billing report.
        public var operation: Swift.String?
        /// The payment option.
        public var paymentOption: SavingsplansClientTypes.SavingsPlanPaymentOption?
        /// The plan type.
        public var planType: SavingsplansClientTypes.SavingsPlanType?
        /// The product type.
        public var productTypes: [SavingsplansClientTypes.SavingsPlanProductType]?
        /// The properties.
        public var properties: [SavingsplansClientTypes.SavingsPlanOfferingProperty]?
        /// The service.
        public var serviceCode: Swift.String?
        /// The usage details of the line item in the billing report.
        public var usageType: Swift.String?

        public init (
            currency: SavingsplansClientTypes.CurrencyCode? = nil,
            description: Swift.String? = nil,
            durationSeconds: Swift.Int = 0,
            offeringId: Swift.String? = nil,
            operation: Swift.String? = nil,
            paymentOption: SavingsplansClientTypes.SavingsPlanPaymentOption? = nil,
            planType: SavingsplansClientTypes.SavingsPlanType? = nil,
            productTypes: [SavingsplansClientTypes.SavingsPlanProductType]? = nil,
            properties: [SavingsplansClientTypes.SavingsPlanOfferingProperty]? = nil,
            serviceCode: Swift.String? = nil,
            usageType: Swift.String? = nil
        )
        {
            self.currency = currency
            self.description = description
            self.durationSeconds = durationSeconds
            self.offeringId = offeringId
            self.operation = operation
            self.paymentOption = paymentOption
            self.planType = planType
            self.productTypes = productTypes
            self.properties = properties
            self.serviceCode = serviceCode
            self.usageType = usageType
        }
    }

}

extension SavingsplansClientTypes {
    public enum SavingsPlanOfferingFilterAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case instancefamily
        case region
        case sdkUnknown(Swift.String)

        public static var allCases: [SavingsPlanOfferingFilterAttribute] {
            return [
                .instancefamily,
                .region,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .instancefamily: return "instanceFamily"
            case .region: return "region"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SavingsPlanOfferingFilterAttribute(rawValue: rawValue) ?? SavingsPlanOfferingFilterAttribute.sdkUnknown(rawValue)
        }
    }
}

extension SavingsplansClientTypes.SavingsPlanOfferingFilterElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for jsonsafefiltervaluestring0 in values {
                try valuesContainer.encode(jsonsafefiltervaluestring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.SavingsPlanOfferingFilterAttribute.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SavingsplansClientTypes {
    /// Information about a filter.
    public struct SavingsPlanOfferingFilterElement: Swift.Equatable {
        /// The filter name.
        public var name: SavingsplansClientTypes.SavingsPlanOfferingFilterAttribute?
        /// The filter values.
        public var values: [Swift.String]?

        public init (
            name: SavingsplansClientTypes.SavingsPlanOfferingFilterAttribute? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension SavingsplansClientTypes.SavingsPlanOfferingProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.SavingsPlanOfferingPropertyKey.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SavingsplansClientTypes {
    /// Information about a property.
    public struct SavingsPlanOfferingProperty: Swift.Equatable {
        /// The property name.
        public var name: SavingsplansClientTypes.SavingsPlanOfferingPropertyKey?
        /// The property value.
        public var value: Swift.String?

        public init (
            name: SavingsplansClientTypes.SavingsPlanOfferingPropertyKey? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension SavingsplansClientTypes {
    public enum SavingsPlanOfferingPropertyKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case instanceFamily
        case region
        case sdkUnknown(Swift.String)

        public static var allCases: [SavingsPlanOfferingPropertyKey] {
            return [
                .instanceFamily,
                .region,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .instanceFamily: return "instanceFamily"
            case .region: return "region"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SavingsPlanOfferingPropertyKey(rawValue: rawValue) ?? SavingsPlanOfferingPropertyKey.sdkUnknown(rawValue)
        }
    }
}

extension SavingsplansClientTypes.SavingsPlanOfferingRate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case operation
        case productType
        case properties
        case rate
        case savingsPlanOffering
        case serviceCode
        case unit
        case usageType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let operation = self.operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for savingsplanofferingrateproperty0 in properties {
                try propertiesContainer.encode(savingsplanofferingrateproperty0)
            }
        }
        if let rate = self.rate {
            try encodeContainer.encode(rate, forKey: .rate)
        }
        if let savingsPlanOffering = self.savingsPlanOffering {
            try encodeContainer.encode(savingsPlanOffering, forKey: .savingsPlanOffering)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode.rawValue, forKey: .serviceCode)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let usageType = self.usageType {
            try encodeContainer.encode(usageType, forKey: .usageType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let savingsPlanOfferingDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.ParentSavingsPlanOffering.self, forKey: .savingsPlanOffering)
        savingsPlanOffering = savingsPlanOfferingDecoded
        let rateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rate)
        rate = rateDecoded
        let unitDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.SavingsPlanRateUnit.self, forKey: .unit)
        unit = unitDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.SavingsPlanProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.SavingsPlanRateServiceCode.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let usageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageType)
        usageType = usageTypeDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.SavingsPlanOfferingRateProperty?].self, forKey: .properties)
        var propertiesDecoded0:[SavingsplansClientTypes.SavingsPlanOfferingRateProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [SavingsplansClientTypes.SavingsPlanOfferingRateProperty]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
    }
}

extension SavingsplansClientTypes {
    /// Information about a Savings Plan offering rate.
    public struct SavingsPlanOfferingRate: Swift.Equatable {
        /// The specific AWS operation for the line item in the billing report.
        public var operation: Swift.String?
        /// The product type.
        public var productType: SavingsplansClientTypes.SavingsPlanProductType?
        /// The properties.
        public var properties: [SavingsplansClientTypes.SavingsPlanOfferingRateProperty]?
        /// The Savings Plan rate.
        public var rate: Swift.String?
        /// The Savings Plan offering.
        public var savingsPlanOffering: SavingsplansClientTypes.ParentSavingsPlanOffering?
        /// The service.
        public var serviceCode: SavingsplansClientTypes.SavingsPlanRateServiceCode?
        /// The unit.
        public var unit: SavingsplansClientTypes.SavingsPlanRateUnit?
        /// The usage details of the line item in the billing report.
        public var usageType: Swift.String?

        public init (
            operation: Swift.String? = nil,
            productType: SavingsplansClientTypes.SavingsPlanProductType? = nil,
            properties: [SavingsplansClientTypes.SavingsPlanOfferingRateProperty]? = nil,
            rate: Swift.String? = nil,
            savingsPlanOffering: SavingsplansClientTypes.ParentSavingsPlanOffering? = nil,
            serviceCode: SavingsplansClientTypes.SavingsPlanRateServiceCode? = nil,
            unit: SavingsplansClientTypes.SavingsPlanRateUnit? = nil,
            usageType: Swift.String? = nil
        )
        {
            self.operation = operation
            self.productType = productType
            self.properties = properties
            self.rate = rate
            self.savingsPlanOffering = savingsPlanOffering
            self.serviceCode = serviceCode
            self.unit = unit
            self.usageType = usageType
        }
    }

}

extension SavingsplansClientTypes.SavingsPlanOfferingRateFilterElement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for jsonsafefiltervaluestring0 in values {
                try valuesContainer.encode(jsonsafefiltervaluestring0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.SavingsPlanRateFilterAttribute.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SavingsplansClientTypes {
    /// Information about a filter.
    public struct SavingsPlanOfferingRateFilterElement: Swift.Equatable {
        /// The filter name.
        public var name: SavingsplansClientTypes.SavingsPlanRateFilterAttribute?
        /// The filter values.
        public var values: [Swift.String]?

        public init (
            name: SavingsplansClientTypes.SavingsPlanRateFilterAttribute? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension SavingsplansClientTypes.SavingsPlanOfferingRateProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SavingsplansClientTypes {
    /// Information about a property.
    public struct SavingsPlanOfferingRateProperty: Swift.Equatable {
        /// The property name.
        public var name: Swift.String?
        /// The property value.
        public var value: Swift.String?

        public init (
            name: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension SavingsplansClientTypes {
    public enum SavingsPlanPaymentOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allUpfront
        case noUpfront
        case partialUpfront
        case sdkUnknown(Swift.String)

        public static var allCases: [SavingsPlanPaymentOption] {
            return [
                .allUpfront,
                .noUpfront,
                .partialUpfront,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allUpfront: return "All Upfront"
            case .noUpfront: return "No Upfront"
            case .partialUpfront: return "Partial Upfront"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SavingsPlanPaymentOption(rawValue: rawValue) ?? SavingsPlanPaymentOption.sdkUnknown(rawValue)
        }
    }
}

extension SavingsplansClientTypes {
    public enum SavingsPlanProductType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2
        case fargate
        case lambda
        case sagemaker
        case sdkUnknown(Swift.String)

        public static var allCases: [SavingsPlanProductType] {
            return [
                .ec2,
                .fargate,
                .lambda,
                .sagemaker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2: return "EC2"
            case .fargate: return "Fargate"
            case .lambda: return "Lambda"
            case .sagemaker: return "SageMaker"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SavingsPlanProductType(rawValue: rawValue) ?? SavingsPlanProductType.sdkUnknown(rawValue)
        }
    }
}

extension SavingsplansClientTypes.SavingsPlanRate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currency
        case operation
        case productType
        case properties
        case rate
        case serviceCode
        case unit
        case usageType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currency = self.currency {
            try encodeContainer.encode(currency.rawValue, forKey: .currency)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation, forKey: .operation)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType.rawValue, forKey: .productType)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for savingsplanrateproperty0 in properties {
                try propertiesContainer.encode(savingsplanrateproperty0)
            }
        }
        if let rate = self.rate {
            try encodeContainer.encode(rate, forKey: .rate)
        }
        if let serviceCode = self.serviceCode {
            try encodeContainer.encode(serviceCode.rawValue, forKey: .serviceCode)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit.rawValue, forKey: .unit)
        }
        if let usageType = self.usageType {
            try encodeContainer.encode(usageType, forKey: .usageType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rate)
        rate = rateDecoded
        let currencyDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.CurrencyCode.self, forKey: .currency)
        currency = currencyDecoded
        let unitDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.SavingsPlanRateUnit.self, forKey: .unit)
        unit = unitDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.SavingsPlanProductType.self, forKey: .productType)
        productType = productTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.SavingsPlanRateServiceCode.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let usageTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .usageType)
        usageType = usageTypeDecoded
        let operationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .operation)
        operation = operationDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([SavingsplansClientTypes.SavingsPlanRateProperty?].self, forKey: .properties)
        var propertiesDecoded0:[SavingsplansClientTypes.SavingsPlanRateProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [SavingsplansClientTypes.SavingsPlanRateProperty]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
    }
}

extension SavingsplansClientTypes {
    /// Information about a Savings Plan rate.
    public struct SavingsPlanRate: Swift.Equatable {
        /// The currency.
        public var currency: SavingsplansClientTypes.CurrencyCode?
        /// The specific AWS operation for the line item in the billing report.
        public var operation: Swift.String?
        /// The product type.
        public var productType: SavingsplansClientTypes.SavingsPlanProductType?
        /// The properties.
        public var properties: [SavingsplansClientTypes.SavingsPlanRateProperty]?
        /// The rate.
        public var rate: Swift.String?
        /// The service.
        public var serviceCode: SavingsplansClientTypes.SavingsPlanRateServiceCode?
        /// The unit.
        public var unit: SavingsplansClientTypes.SavingsPlanRateUnit?
        /// The usage details of the line item in the billing report.
        public var usageType: Swift.String?

        public init (
            currency: SavingsplansClientTypes.CurrencyCode? = nil,
            operation: Swift.String? = nil,
            productType: SavingsplansClientTypes.SavingsPlanProductType? = nil,
            properties: [SavingsplansClientTypes.SavingsPlanRateProperty]? = nil,
            rate: Swift.String? = nil,
            serviceCode: SavingsplansClientTypes.SavingsPlanRateServiceCode? = nil,
            unit: SavingsplansClientTypes.SavingsPlanRateUnit? = nil,
            usageType: Swift.String? = nil
        )
        {
            self.currency = currency
            self.operation = operation
            self.productType = productType
            self.properties = properties
            self.rate = rate
            self.serviceCode = serviceCode
            self.unit = unit
            self.usageType = usageType
        }
    }

}

extension SavingsplansClientTypes.SavingsPlanRateFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string0 in values {
                try valuesContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.SavingsPlanRateFilterName.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension SavingsplansClientTypes {
    /// Information about a filter.
    public struct SavingsPlanRateFilter: Swift.Equatable {
        /// The filter name.
        public var name: SavingsplansClientTypes.SavingsPlanRateFilterName?
        /// The filter values.
        public var values: [Swift.String]?

        public init (
            name: SavingsplansClientTypes.SavingsPlanRateFilterName? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.name = name
            self.values = values
        }
    }

}

extension SavingsplansClientTypes {
    public enum SavingsPlanRateFilterAttribute: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case instanceFamily
        case instanceType
        case productDescription
        case productId
        case region
        case tenancy
        case sdkUnknown(Swift.String)

        public static var allCases: [SavingsPlanRateFilterAttribute] {
            return [
                .instanceFamily,
                .instanceType,
                .productDescription,
                .productId,
                .region,
                .tenancy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .instanceFamily: return "instanceFamily"
            case .instanceType: return "instanceType"
            case .productDescription: return "productDescription"
            case .productId: return "productId"
            case .region: return "region"
            case .tenancy: return "tenancy"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SavingsPlanRateFilterAttribute(rawValue: rawValue) ?? SavingsPlanRateFilterAttribute.sdkUnknown(rawValue)
        }
    }
}

extension SavingsplansClientTypes {
    public enum SavingsPlanRateFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case instanceType
        case operation
        case productDescription
        case productType
        case region
        case serviceCode
        case tenancy
        case usageType
        case sdkUnknown(Swift.String)

        public static var allCases: [SavingsPlanRateFilterName] {
            return [
                .instanceType,
                .operation,
                .productDescription,
                .productType,
                .region,
                .serviceCode,
                .tenancy,
                .usageType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .instanceType: return "instanceType"
            case .operation: return "operation"
            case .productDescription: return "productDescription"
            case .productType: return "productType"
            case .region: return "region"
            case .serviceCode: return "serviceCode"
            case .tenancy: return "tenancy"
            case .usageType: return "usageType"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SavingsPlanRateFilterName(rawValue: rawValue) ?? SavingsPlanRateFilterName.sdkUnknown(rawValue)
        }
    }
}

extension SavingsplansClientTypes.SavingsPlanRateProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(SavingsplansClientTypes.SavingsPlanRatePropertyKey.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SavingsplansClientTypes {
    /// Information about a property.
    public struct SavingsPlanRateProperty: Swift.Equatable {
        /// The property name.
        public var name: SavingsplansClientTypes.SavingsPlanRatePropertyKey?
        /// The property value.
        public var value: Swift.String?

        public init (
            name: SavingsplansClientTypes.SavingsPlanRatePropertyKey? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension SavingsplansClientTypes {
    public enum SavingsPlanRatePropertyKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case instanceFamily
        case instanceType
        case productDescription
        case region
        case tenancy
        case sdkUnknown(Swift.String)

        public static var allCases: [SavingsPlanRatePropertyKey] {
            return [
                .instanceFamily,
                .instanceType,
                .productDescription,
                .region,
                .tenancy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .instanceFamily: return "instanceFamily"
            case .instanceType: return "instanceType"
            case .productDescription: return "productDescription"
            case .region: return "region"
            case .tenancy: return "tenancy"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SavingsPlanRatePropertyKey(rawValue: rawValue) ?? SavingsPlanRatePropertyKey.sdkUnknown(rawValue)
        }
    }
}

extension SavingsplansClientTypes {
    public enum SavingsPlanRateServiceCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2
        case fargate
        case fargateEks
        case lambda
        case sagemaker
        case sdkUnknown(Swift.String)

        public static var allCases: [SavingsPlanRateServiceCode] {
            return [
                .ec2,
                .fargate,
                .fargateEks,
                .lambda,
                .sagemaker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2: return "AmazonEC2"
            case .fargate: return "AmazonECS"
            case .fargateEks: return "AmazonEKS"
            case .lambda: return "AWSLambda"
            case .sagemaker: return "AmazonSageMaker"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SavingsPlanRateServiceCode(rawValue: rawValue) ?? SavingsPlanRateServiceCode.sdkUnknown(rawValue)
        }
    }
}

extension SavingsplansClientTypes {
    public enum SavingsPlanRateUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hours
        case lambdaGbSecond
        case request
        case sdkUnknown(Swift.String)

        public static var allCases: [SavingsPlanRateUnit] {
            return [
                .hours,
                .lambdaGbSecond,
                .request,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hours: return "Hrs"
            case .lambdaGbSecond: return "Lambda-GB-Second"
            case .request: return "Request"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SavingsPlanRateUnit(rawValue: rawValue) ?? SavingsPlanRateUnit.sdkUnknown(rawValue)
        }
    }
}

extension SavingsplansClientTypes {
    public enum SavingsPlanState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case paymentFailed
        case paymentPending
        case queued
        case queuedDeleted
        case retired
        case sdkUnknown(Swift.String)

        public static var allCases: [SavingsPlanState] {
            return [
                .active,
                .paymentFailed,
                .paymentPending,
                .queued,
                .queuedDeleted,
                .retired,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "active"
            case .paymentFailed: return "payment-failed"
            case .paymentPending: return "payment-pending"
            case .queued: return "queued"
            case .queuedDeleted: return "queued-deleted"
            case .retired: return "retired"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SavingsPlanState(rawValue: rawValue) ?? SavingsPlanState.sdkUnknown(rawValue)
        }
    }
}

extension SavingsplansClientTypes {
    public enum SavingsPlanType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compute
        case ec2Instance
        case sagemaker
        case sdkUnknown(Swift.String)

        public static var allCases: [SavingsPlanType] {
            return [
                .compute,
                .ec2Instance,
                .sagemaker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compute: return "Compute"
            case .ec2Instance: return "EC2Instance"
            case .sagemaker: return "SageMaker"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SavingsPlanType(rawValue: rawValue) ?? SavingsPlanType.sdkUnknown(rawValue)
        }
    }
}

extension SavingsplansClientTypes {
    public enum SavingsPlansFilterName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case commitment
        case ec2InstanceFamily
        case end
        case paymentOption
        case region
        case savingsPlanType
        case start
        case term
        case upfront
        case sdkUnknown(Swift.String)

        public static var allCases: [SavingsPlansFilterName] {
            return [
                .commitment,
                .ec2InstanceFamily,
                .end,
                .paymentOption,
                .region,
                .savingsPlanType,
                .start,
                .term,
                .upfront,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .commitment: return "commitment"
            case .ec2InstanceFamily: return "ec2-instance-family"
            case .end: return "end"
            case .paymentOption: return "payment-option"
            case .region: return "region"
            case .savingsPlanType: return "savings-plan-type"
            case .start: return "start"
            case .term: return "term"
            case .upfront: return "upfront"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SavingsPlansFilterName(rawValue: rawValue) ?? SavingsPlansFilterName.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A service quota has been exceeded.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/TagResource"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// One or more tags. For example, { "tags": {"key1":"value1", "key2":"value2"} }.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UntagResource"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One of the input parameters is not valid.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
