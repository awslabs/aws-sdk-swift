//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox

extension SMSClientTypes {

    public enum AppLaunchConfigurationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case configured
        case notconfigured
        case sdkUnknown(Swift.String)

        public static var allCases: [AppLaunchConfigurationStatus] {
            return [
                .configured,
                .notconfigured
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .configured: return "CONFIGURED"
            case .notconfigured: return "NOT_CONFIGURED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SMSClientTypes {

    public enum AppLaunchStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case configurationinprogress
        case configurationinvalid
        case deltalaunchfailed
        case deltalaunchinprogress
        case launchfailed
        case launchinprogress
        case launchpending
        case launched
        case partiallylaunched
        case readyforconfiguration
        case readyforlaunch
        case terminatefailed
        case terminateinprogress
        case terminated
        case validationinprogress
        case sdkUnknown(Swift.String)

        public static var allCases: [AppLaunchStatus] {
            return [
                .configurationinprogress,
                .configurationinvalid,
                .deltalaunchfailed,
                .deltalaunchinprogress,
                .launchfailed,
                .launchinprogress,
                .launchpending,
                .launched,
                .partiallylaunched,
                .readyforconfiguration,
                .readyforlaunch,
                .terminatefailed,
                .terminateinprogress,
                .terminated,
                .validationinprogress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .configurationinprogress: return "CONFIGURATION_IN_PROGRESS"
            case .configurationinvalid: return "CONFIGURATION_INVALID"
            case .deltalaunchfailed: return "DELTA_LAUNCH_FAILED"
            case .deltalaunchinprogress: return "DELTA_LAUNCH_IN_PROGRESS"
            case .launchfailed: return "LAUNCH_FAILED"
            case .launchinprogress: return "LAUNCH_IN_PROGRESS"
            case .launchpending: return "LAUNCH_PENDING"
            case .launched: return "LAUNCHED"
            case .partiallylaunched: return "PARTIALLY_LAUNCHED"
            case .readyforconfiguration: return "READY_FOR_CONFIGURATION"
            case .readyforlaunch: return "READY_FOR_LAUNCH"
            case .terminatefailed: return "TERMINATE_FAILED"
            case .terminateinprogress: return "TERMINATE_IN_PROGRESS"
            case .terminated: return "TERMINATED"
            case .validationinprogress: return "VALIDATION_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SMSClientTypes {

    public enum AppReplicationConfigurationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case configured
        case notconfigured
        case sdkUnknown(Swift.String)

        public static var allCases: [AppReplicationConfigurationStatus] {
            return [
                .configured,
                .notconfigured
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .configured: return "CONFIGURED"
            case .notconfigured: return "NOT_CONFIGURED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SMSClientTypes {

    public enum AppReplicationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case configurationinprogress
        case configurationinvalid
        case deltareplicated
        case deltareplicationfailed
        case deltareplicationinprogress
        case partiallyreplicated
        case readyforconfiguration
        case readyforreplication
        case replicated
        case replicationfailed
        case replicationinprogress
        case replicationpending
        case replicationstopfailed
        case replicationstopped
        case replicationstopping
        case validationinprogress
        case sdkUnknown(Swift.String)

        public static var allCases: [AppReplicationStatus] {
            return [
                .configurationinprogress,
                .configurationinvalid,
                .deltareplicated,
                .deltareplicationfailed,
                .deltareplicationinprogress,
                .partiallyreplicated,
                .readyforconfiguration,
                .readyforreplication,
                .replicated,
                .replicationfailed,
                .replicationinprogress,
                .replicationpending,
                .replicationstopfailed,
                .replicationstopped,
                .replicationstopping,
                .validationinprogress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .configurationinprogress: return "CONFIGURATION_IN_PROGRESS"
            case .configurationinvalid: return "CONFIGURATION_INVALID"
            case .deltareplicated: return "DELTA_REPLICATED"
            case .deltareplicationfailed: return "DELTA_REPLICATION_FAILED"
            case .deltareplicationinprogress: return "DELTA_REPLICATION_IN_PROGRESS"
            case .partiallyreplicated: return "PARTIALLY_REPLICATED"
            case .readyforconfiguration: return "READY_FOR_CONFIGURATION"
            case .readyforreplication: return "READY_FOR_REPLICATION"
            case .replicated: return "REPLICATED"
            case .replicationfailed: return "REPLICATION_FAILED"
            case .replicationinprogress: return "REPLICATION_IN_PROGRESS"
            case .replicationpending: return "REPLICATION_PENDING"
            case .replicationstopfailed: return "REPLICATION_STOP_FAILED"
            case .replicationstopped: return "REPLICATION_STOPPED"
            case .replicationstopping: return "REPLICATION_STOPPING"
            case .validationinprogress: return "VALIDATION_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SMSClientTypes {

    /// Details about the latest launch of an application.
    public struct LaunchDetails: Swift.Sendable {
        /// The latest time that this application was launched successfully.
        public var latestLaunchTime: Foundation.Date?
        /// The ID of the latest stack launched for this application.
        public var stackId: Swift.String?
        /// The name of the latest stack launched for this application.
        public var stackName: Swift.String?

        public init(
            latestLaunchTime: Foundation.Date? = nil,
            stackId: Swift.String? = nil,
            stackName: Swift.String? = nil
        )
        {
            self.latestLaunchTime = latestLaunchTime
            self.stackId = stackId
            self.stackName = stackName
        }
    }
}

extension SMSClientTypes {

    public enum AppStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleteFailed
        case deleted
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AppStatus] {
            return [
                .active,
                .creating,
                .deleteFailed,
                .deleted,
                .deleting,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SMSClientTypes {

    /// Information about the application.
    public struct AppSummary: Swift.Sendable {
        /// The unique ID of the application.
        public var appId: Swift.String?
        /// The creation time of the application.
        public var creationTime: Foundation.Date?
        /// The description of the application.
        public var description: Swift.String?
        /// The ID of the application.
        public var importedAppId: Swift.String?
        /// The last modified time of the application.
        public var lastModified: Foundation.Date?
        /// The timestamp of the application's most recent successful replication.
        public var latestReplicationTime: Foundation.Date?
        /// Status of the launch configuration.
        public var launchConfigurationStatus: SMSClientTypes.AppLaunchConfigurationStatus?
        /// Details about the latest launch of the application.
        public var launchDetails: SMSClientTypes.LaunchDetails?
        /// The launch status of the application.
        public var launchStatus: SMSClientTypes.AppLaunchStatus?
        /// A message related to the launch status of the application.
        public var launchStatusMessage: Swift.String?
        /// The name of the application.
        public var name: Swift.String?
        /// Status of the replication configuration.
        public var replicationConfigurationStatus: SMSClientTypes.AppReplicationConfigurationStatus?
        /// The replication status of the application.
        public var replicationStatus: SMSClientTypes.AppReplicationStatus?
        /// A message related to the replication status of the application.
        public var replicationStatusMessage: Swift.String?
        /// The name of the service role in the customer's account used by Server Migration Service.
        public var roleName: Swift.String?
        /// Status of the application.
        public var status: SMSClientTypes.AppStatus?
        /// A message related to the status of the application
        public var statusMessage: Swift.String?
        /// The number of server groups present in the application.
        public var totalServerGroups: Swift.Int?
        /// The number of servers present in the application.
        public var totalServers: Swift.Int?

        public init(
            appId: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            importedAppId: Swift.String? = nil,
            lastModified: Foundation.Date? = nil,
            latestReplicationTime: Foundation.Date? = nil,
            launchConfigurationStatus: SMSClientTypes.AppLaunchConfigurationStatus? = nil,
            launchDetails: SMSClientTypes.LaunchDetails? = nil,
            launchStatus: SMSClientTypes.AppLaunchStatus? = nil,
            launchStatusMessage: Swift.String? = nil,
            name: Swift.String? = nil,
            replicationConfigurationStatus: SMSClientTypes.AppReplicationConfigurationStatus? = nil,
            replicationStatus: SMSClientTypes.AppReplicationStatus? = nil,
            replicationStatusMessage: Swift.String? = nil,
            roleName: Swift.String? = nil,
            status: SMSClientTypes.AppStatus? = nil,
            statusMessage: Swift.String? = nil,
            totalServerGroups: Swift.Int? = nil,
            totalServers: Swift.Int? = nil
        )
        {
            self.appId = appId
            self.creationTime = creationTime
            self.description = description
            self.importedAppId = importedAppId
            self.lastModified = lastModified
            self.latestReplicationTime = latestReplicationTime
            self.launchConfigurationStatus = launchConfigurationStatus
            self.launchDetails = launchDetails
            self.launchStatus = launchStatus
            self.launchStatusMessage = launchStatusMessage
            self.name = name
            self.replicationConfigurationStatus = replicationConfigurationStatus
            self.replicationStatus = replicationStatus
            self.replicationStatusMessage = replicationStatusMessage
            self.roleName = roleName
            self.status = status
            self.statusMessage = statusMessage
            self.totalServerGroups = totalServerGroups
            self.totalServers = totalServers
        }
    }
}

extension SMSClientTypes {

    public enum AppValidationStrategy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ssm
        case sdkUnknown(Swift.String)

        public static var allCases: [AppValidationStrategy] {
            return [
                .ssm
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ssm: return "SSM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SMSClientTypes {

    public enum ScriptType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case powershellScript
        case shellScript
        case sdkUnknown(Swift.String)

        public static var allCases: [ScriptType] {
            return [
                .powershellScript,
                .shellScript
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .powershellScript: return "POWERSHELL_SCRIPT"
            case .shellScript: return "SHELL_SCRIPT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SMSClientTypes {

    /// Location of an Amazon S3 object.
    public struct S3Location: Swift.Sendable {
        /// The Amazon S3 bucket name.
        public var bucket: Swift.String?
        /// The Amazon S3 bucket key.
        public var key: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }
}

extension SMSClientTypes {

    /// Contains the location of a validation script.
    public struct Source: Swift.Sendable {
        /// Location of an Amazon S3 object.
        public var s3Location: SMSClientTypes.S3Location?

        public init(
            s3Location: SMSClientTypes.S3Location? = nil
        )
        {
            self.s3Location = s3Location
        }
    }
}

extension SMSClientTypes {

    /// Contains validation parameters.
    public struct SSMValidationParameters: Swift.Sendable {
        /// The command to run the validation script.
        public var command: Swift.String?
        /// The timeout interval, in seconds.
        public var executionTimeoutSeconds: Swift.Int
        /// The ID of the instance. The instance must have the following tag: UserForSMSApplicationValidation=true.
        public var instanceId: Swift.String?
        /// The name of the S3 bucket for output.
        public var outputS3BucketName: Swift.String?
        /// The type of validation script.
        public var scriptType: SMSClientTypes.ScriptType?
        /// The location of the validation script.
        public var source: SMSClientTypes.Source?

        public init(
            command: Swift.String? = nil,
            executionTimeoutSeconds: Swift.Int = 0,
            instanceId: Swift.String? = nil,
            outputS3BucketName: Swift.String? = nil,
            scriptType: SMSClientTypes.ScriptType? = nil,
            source: SMSClientTypes.Source? = nil
        )
        {
            self.command = command
            self.executionTimeoutSeconds = executionTimeoutSeconds
            self.instanceId = instanceId
            self.outputS3BucketName = outputS3BucketName
            self.scriptType = scriptType
            self.source = source
        }
    }
}

extension SMSClientTypes {

    /// Configuration for validating an application.
    public struct AppValidationConfiguration: Swift.Sendable {
        /// The validation strategy.
        public var appValidationStrategy: SMSClientTypes.AppValidationStrategy?
        /// The name of the configuration.
        public var name: Swift.String?
        /// The validation parameters.
        public var ssmValidationParameters: SMSClientTypes.SSMValidationParameters?
        /// The ID of the validation.
        public var validationId: Swift.String?

        public init(
            appValidationStrategy: SMSClientTypes.AppValidationStrategy? = nil,
            name: Swift.String? = nil,
            ssmValidationParameters: SMSClientTypes.SSMValidationParameters? = nil,
            validationId: Swift.String? = nil
        )
        {
            self.appValidationStrategy = appValidationStrategy
            self.name = name
            self.ssmValidationParameters = ssmValidationParameters
            self.validationId = validationId
        }
    }
}

extension SMSClientTypes {

    /// Contains the location of validation output.
    public struct SSMOutput: Swift.Sendable {
        /// Location of an Amazon S3 object.
        public var s3Location: SMSClientTypes.S3Location?

        public init(
            s3Location: SMSClientTypes.S3Location? = nil
        )
        {
            self.s3Location = s3Location
        }
    }
}

extension SMSClientTypes {

    /// Output from validating an application.
    public struct AppValidationOutput: Swift.Sendable {
        /// Output from using SSM to validate the application.
        public var ssmOutput: SMSClientTypes.SSMOutput?

        public init(
            ssmOutput: SMSClientTypes.SSMOutput? = nil
        )
        {
            self.ssmOutput = ssmOutput
        }
    }
}

/// An internal error occurred.
public struct InternalError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalError" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A specified parameter is not valid.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameter" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// A required parameter is missing.
public struct MissingRequiredParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MissingRequiredParameter" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// This operation is not allowed.
public struct OperationNotPermittedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationNotPermitted" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You lack permissions needed to perform this operation. Check your IAM policies, and ensure that you are using the correct access keys.
public struct UnauthorizedOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedOperation" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SMSClientTypes {

    public enum ServerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case virtualmachine
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerType] {
            return [
                .virtualmachine
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .virtualmachine: return "VIRTUAL_MACHINE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SMSClientTypes {

    public enum VmManagerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hypervmanager
        case scvmm
        case vsphere
        case sdkUnknown(Swift.String)

        public static var allCases: [VmManagerType] {
            return [
                .hypervmanager,
                .scvmm,
                .vsphere
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hypervmanager: return "HYPERV-MANAGER"
            case .scvmm: return "SCVMM"
            case .vsphere: return "VSPHERE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SMSClientTypes {

    /// Represents a VM server location.
    public struct VmServerAddress: Swift.Sendable {
        /// The ID of the VM.
        public var vmId: Swift.String?
        /// The ID of the VM manager.
        public var vmManagerId: Swift.String?

        public init(
            vmId: Swift.String? = nil,
            vmManagerId: Swift.String? = nil
        )
        {
            self.vmId = vmId
            self.vmManagerId = vmManagerId
        }
    }
}

extension SMSClientTypes {

    /// Represents a VM server.
    public struct VmServer: Swift.Sendable {
        /// The name of the VM manager.
        public var vmManagerName: Swift.String?
        /// The type of VM management product.
        public var vmManagerType: SMSClientTypes.VmManagerType?
        /// The name of the VM.
        public var vmName: Swift.String?
        /// The VM folder path in the vCenter Server virtual machine inventory tree.
        public var vmPath: Swift.String?
        /// The VM server location.
        public var vmServerAddress: SMSClientTypes.VmServerAddress?

        public init(
            vmManagerName: Swift.String? = nil,
            vmManagerType: SMSClientTypes.VmManagerType? = nil,
            vmName: Swift.String? = nil,
            vmPath: Swift.String? = nil,
            vmServerAddress: SMSClientTypes.VmServerAddress? = nil
        )
        {
            self.vmManagerName = vmManagerName
            self.vmManagerType = vmManagerType
            self.vmName = vmName
            self.vmPath = vmPath
            self.vmServerAddress = vmServerAddress
        }
    }
}

extension SMSClientTypes {

    /// Represents a server.
    public struct Server: Swift.Sendable {
        /// The ID of the replication job.
        public var replicationJobId: Swift.String?
        /// Indicates whether the replication job is deleted or failed.
        public var replicationJobTerminated: Swift.Bool?
        /// The ID of the server.
        public var serverId: Swift.String?
        /// The type of server.
        public var serverType: SMSClientTypes.ServerType?
        /// Information about the VM server.
        public var vmServer: SMSClientTypes.VmServer?

        public init(
            replicationJobId: Swift.String? = nil,
            replicationJobTerminated: Swift.Bool? = nil,
            serverId: Swift.String? = nil,
            serverType: SMSClientTypes.ServerType? = nil,
            vmServer: SMSClientTypes.VmServer? = nil
        )
        {
            self.replicationJobId = replicationJobId
            self.replicationJobTerminated = replicationJobTerminated
            self.serverId = serverId
            self.serverType = serverType
            self.vmServer = vmServer
        }
    }
}

extension SMSClientTypes {

    /// Logical grouping of servers.
    public struct ServerGroup: Swift.Sendable {
        /// The name of a server group.
        public var name: Swift.String?
        /// The ID of a server group.
        public var serverGroupId: Swift.String?
        /// The servers that belong to a server group.
        public var serverList: [SMSClientTypes.Server]?

        public init(
            name: Swift.String? = nil,
            serverGroupId: Swift.String? = nil,
            serverList: [SMSClientTypes.Server]? = nil
        )
        {
            self.name = name
            self.serverGroupId = serverGroupId
            self.serverList = serverList
        }
    }
}

extension SMSClientTypes {

    /// Key/value pair that can be assigned to an application.
    public struct Tag: Swift.Sendable {
        /// The tag key.
        public var key: Swift.String?
        /// The tag value.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateAppInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of application creation.
    public var clientToken: Swift.String?
    /// The description of the new application
    public var description: Swift.String?
    /// The name of the new application.
    public var name: Swift.String?
    /// The name of the service role in the customer's account to be used by Server Migration Service.
    public var roleName: Swift.String?
    /// The server groups to include in the application.
    public var serverGroups: [SMSClientTypes.ServerGroup]?
    /// The tags to be associated with the application.
    public var tags: [SMSClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        roleName: Swift.String? = nil,
        serverGroups: [SMSClientTypes.ServerGroup]? = nil,
        tags: [SMSClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.roleName = roleName
        self.serverGroups = serverGroups
        self.tags = tags
    }
}

public struct CreateAppOutput: Swift.Sendable {
    /// A summary description of the application.
    public var appSummary: SMSClientTypes.AppSummary?
    /// The server groups included in the application.
    public var serverGroups: [SMSClientTypes.ServerGroup]?
    /// The tags associated with the application.
    public var tags: [SMSClientTypes.Tag]?

    public init(
        appSummary: SMSClientTypes.AppSummary? = nil,
        serverGroups: [SMSClientTypes.ServerGroup]? = nil,
        tags: [SMSClientTypes.Tag]? = nil
    )
    {
        self.appSummary = appSummary
        self.serverGroups = serverGroups
        self.tags = tags
    }
}

/// There are no connectors available.
public struct NoConnectorsAvailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoConnectorsAvailable" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified replication job already exists.
public struct ReplicationJobAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReplicationJobAlreadyExists" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified server cannot be replicated.
public struct ServerCannotBeReplicatedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServerCannotBeReplicated" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The service is temporarily unavailable.
public struct TemporarilyUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "TemporarilyUnavailable" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

extension SMSClientTypes {

    public enum LicenseType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aws
        case byol
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseType] {
            return [
                .aws,
                .byol
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .byol: return "BYOL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateReplicationJobInput: Swift.Sendable {
    /// The description of the replication job.
    public var description: Swift.String?
    /// Indicates whether the replication job produces encrypted AMIs.
    public var encrypted: Swift.Bool?
    /// The time between consecutive replication runs, in hours.
    public var frequency: Swift.Int?
    /// The ID of the KMS key for replication jobs that produce encrypted AMIs. This value can be any of the following:
    ///
    /// * KMS key ID
    ///
    /// * KMS key alias
    ///
    /// * ARN referring to the KMS key ID
    ///
    /// * ARN referring to the KMS key alias
    ///
    ///
    /// If encrypted is true but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
    public var kmsKeyId: Swift.String?
    /// The license type to be used for the AMI created by a successful replication run.
    public var licenseType: SMSClientTypes.LicenseType?
    /// The maximum number of SMS-created AMIs to retain. The oldest is deleted after the maximum number is reached and a new AMI is created.
    public var numberOfRecentAmisToKeep: Swift.Int?
    /// The name of the IAM role to be used by the Server Migration Service.
    public var roleName: Swift.String?
    /// Indicates whether to run the replication job one time.
    public var runOnce: Swift.Bool?
    /// The seed replication time.
    /// This member is required.
    public var seedReplicationTime: Foundation.Date?
    /// The ID of the server.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        description: Swift.String? = nil,
        encrypted: Swift.Bool? = nil,
        frequency: Swift.Int? = nil,
        kmsKeyId: Swift.String? = nil,
        licenseType: SMSClientTypes.LicenseType? = nil,
        numberOfRecentAmisToKeep: Swift.Int? = nil,
        roleName: Swift.String? = nil,
        runOnce: Swift.Bool? = nil,
        seedReplicationTime: Foundation.Date? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.description = description
        self.encrypted = encrypted
        self.frequency = frequency
        self.kmsKeyId = kmsKeyId
        self.licenseType = licenseType
        self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
        self.roleName = roleName
        self.runOnce = runOnce
        self.seedReplicationTime = seedReplicationTime
        self.serverId = serverId
    }
}

public struct CreateReplicationJobOutput: Swift.Sendable {
    /// The unique identifier of the replication job.
    public var replicationJobId: Swift.String?

    public init(
        replicationJobId: Swift.String? = nil
    )
    {
        self.replicationJobId = replicationJobId
    }
}

public struct DeleteAppInput: Swift.Sendable {
    /// The ID of the application.
    public var appId: Swift.String?
    /// Indicates whether to stop all replication jobs corresponding to the servers in the application while deleting the application.
    public var forceStopAppReplication: Swift.Bool?
    /// Indicates whether to terminate the stack corresponding to the application while deleting the application.
    public var forceTerminateApp: Swift.Bool?

    public init(
        appId: Swift.String? = nil,
        forceStopAppReplication: Swift.Bool? = nil,
        forceTerminateApp: Swift.Bool? = nil
    )
    {
        self.appId = appId
        self.forceStopAppReplication = forceStopAppReplication
        self.forceTerminateApp = forceTerminateApp
    }
}

public struct DeleteAppOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAppLaunchConfigurationInput: Swift.Sendable {
    /// The ID of the application.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

public struct DeleteAppLaunchConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAppReplicationConfigurationInput: Swift.Sendable {
    /// The ID of the application.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

public struct DeleteAppReplicationConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAppValidationConfigurationInput: Swift.Sendable {
    /// The ID of the application.
    /// This member is required.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

public struct DeleteAppValidationConfigurationOutput: Swift.Sendable {

    public init() { }
}

/// The specified replication job does not exist.
public struct ReplicationJobNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReplicationJobNotFound" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteReplicationJobInput: Swift.Sendable {
    /// The ID of the replication job.
    /// This member is required.
    public var replicationJobId: Swift.String?

    public init(
        replicationJobId: Swift.String? = nil
    )
    {
        self.replicationJobId = replicationJobId
    }
}

public struct DeleteReplicationJobOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteServerCatalogInput: Swift.Sendable {

    public init() { }
}

public struct DeleteServerCatalogOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateConnectorInput: Swift.Sendable {
    /// The ID of the connector.
    /// This member is required.
    public var connectorId: Swift.String?

    public init(
        connectorId: Swift.String? = nil
    )
    {
        self.connectorId = connectorId
    }
}

public struct DisassociateConnectorOutput: Swift.Sendable {

    public init() { }
}

extension SMSClientTypes {

    public enum OutputFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case json
        case yaml
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputFormat] {
            return [
                .json,
                .yaml
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .yaml: return "YAML"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GenerateChangeSetInput: Swift.Sendable {
    /// The ID of the application associated with the change set.
    public var appId: Swift.String?
    /// The format for the change set.
    public var changesetFormat: SMSClientTypes.OutputFormat?

    public init(
        appId: Swift.String? = nil,
        changesetFormat: SMSClientTypes.OutputFormat? = nil
    )
    {
        self.appId = appId
        self.changesetFormat = changesetFormat
    }
}

public struct GenerateChangeSetOutput: Swift.Sendable {
    /// The location of the Amazon S3 object.
    public var s3Location: SMSClientTypes.S3Location?

    public init(
        s3Location: SMSClientTypes.S3Location? = nil
    )
    {
        self.s3Location = s3Location
    }
}

public struct GenerateTemplateInput: Swift.Sendable {
    /// The ID of the application associated with the CloudFormation template.
    public var appId: Swift.String?
    /// The format for generating the CloudFormation template.
    public var templateFormat: SMSClientTypes.OutputFormat?

    public init(
        appId: Swift.String? = nil,
        templateFormat: SMSClientTypes.OutputFormat? = nil
    )
    {
        self.appId = appId
        self.templateFormat = templateFormat
    }
}

public struct GenerateTemplateOutput: Swift.Sendable {
    /// The location of the Amazon S3 object.
    public var s3Location: SMSClientTypes.S3Location?

    public init(
        s3Location: SMSClientTypes.S3Location? = nil
    )
    {
        self.s3Location = s3Location
    }
}

public struct GetAppInput: Swift.Sendable {
    /// The ID of the application.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

public struct GetAppOutput: Swift.Sendable {
    /// Information about the application.
    public var appSummary: SMSClientTypes.AppSummary?
    /// The server groups that belong to the application.
    public var serverGroups: [SMSClientTypes.ServerGroup]?
    /// The tags associated with the application.
    public var tags: [SMSClientTypes.Tag]?

    public init(
        appSummary: SMSClientTypes.AppSummary? = nil,
        serverGroups: [SMSClientTypes.ServerGroup]? = nil,
        tags: [SMSClientTypes.Tag]? = nil
    )
    {
        self.appSummary = appSummary
        self.serverGroups = serverGroups
        self.tags = tags
    }
}

public struct GetAppLaunchConfigurationInput: Swift.Sendable {
    /// The ID of the application.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

extension SMSClientTypes {

    /// A script that runs on first launch of an Amazon EC2 instance. Used for configuring the server during launch.
    public struct UserData: Swift.Sendable {
        /// Amazon S3 location of the user-data script.
        public var s3Location: SMSClientTypes.S3Location?

        public init(
            s3Location: SMSClientTypes.S3Location? = nil
        )
        {
            self.s3Location = s3Location
        }
    }
}

extension SMSClientTypes {

    /// Launch configuration for a server.
    public struct ServerLaunchConfiguration: Swift.Sendable {
        /// Indicates whether a publicly accessible IP address is created when launching the server.
        public var associatePublicIpAddress: Swift.Bool?
        /// Location of an Amazon S3 object.
        public var configureScript: SMSClientTypes.S3Location?
        /// The type of configuration script.
        public var configureScriptType: SMSClientTypes.ScriptType?
        /// The name of the Amazon EC2 SSH key to be used for connecting to the launched server.
        public var ec2KeyName: Swift.String?
        /// The name of the IAM instance profile.
        public var iamInstanceProfileName: Swift.String?
        /// The instance type to use when launching the server.
        public var instanceType: Swift.String?
        /// The logical ID of the server in the CloudFormation template.
        public var logicalId: Swift.String?
        /// The ID of the security group that applies to the launched server.
        public var securityGroup: Swift.String?
        /// The ID of the server with which the launch configuration is associated.
        public var server: SMSClientTypes.Server?
        /// The ID of the subnet the server should be launched into.
        public var subnet: Swift.String?
        /// Location of the user-data script to be executed when launching the server.
        public var userData: SMSClientTypes.UserData?
        /// The ID of the VPC into which the server should be launched.
        public var vpc: Swift.String?

        public init(
            associatePublicIpAddress: Swift.Bool? = nil,
            configureScript: SMSClientTypes.S3Location? = nil,
            configureScriptType: SMSClientTypes.ScriptType? = nil,
            ec2KeyName: Swift.String? = nil,
            iamInstanceProfileName: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            logicalId: Swift.String? = nil,
            securityGroup: Swift.String? = nil,
            server: SMSClientTypes.Server? = nil,
            subnet: Swift.String? = nil,
            userData: SMSClientTypes.UserData? = nil,
            vpc: Swift.String? = nil
        )
        {
            self.associatePublicIpAddress = associatePublicIpAddress
            self.configureScript = configureScript
            self.configureScriptType = configureScriptType
            self.ec2KeyName = ec2KeyName
            self.iamInstanceProfileName = iamInstanceProfileName
            self.instanceType = instanceType
            self.logicalId = logicalId
            self.securityGroup = securityGroup
            self.server = server
            self.subnet = subnet
            self.userData = userData
            self.vpc = vpc
        }
    }
}

extension SMSClientTypes {

    /// Launch configuration for a server group.
    public struct ServerGroupLaunchConfiguration: Swift.Sendable {
        /// The launch order of servers in the server group.
        public var launchOrder: Swift.Int?
        /// The ID of the server group with which the launch configuration is associated.
        public var serverGroupId: Swift.String?
        /// The launch configuration for servers in the server group.
        public var serverLaunchConfigurations: [SMSClientTypes.ServerLaunchConfiguration]?

        public init(
            launchOrder: Swift.Int? = nil,
            serverGroupId: Swift.String? = nil,
            serverLaunchConfigurations: [SMSClientTypes.ServerLaunchConfiguration]? = nil
        )
        {
            self.launchOrder = launchOrder
            self.serverGroupId = serverGroupId
            self.serverLaunchConfigurations = serverLaunchConfigurations
        }
    }
}

public struct GetAppLaunchConfigurationOutput: Swift.Sendable {
    /// The ID of the application.
    public var appId: Swift.String?
    /// Indicates whether the application is configured to launch automatically after replication is complete.
    public var autoLaunch: Swift.Bool?
    /// The name of the service role in the customer's account that CloudFormation uses to launch the application.
    public var roleName: Swift.String?
    /// The launch configurations for server groups in this application.
    public var serverGroupLaunchConfigurations: [SMSClientTypes.ServerGroupLaunchConfiguration]?

    public init(
        appId: Swift.String? = nil,
        autoLaunch: Swift.Bool? = nil,
        roleName: Swift.String? = nil,
        serverGroupLaunchConfigurations: [SMSClientTypes.ServerGroupLaunchConfiguration]? = nil
    )
    {
        self.appId = appId
        self.autoLaunch = autoLaunch
        self.roleName = roleName
        self.serverGroupLaunchConfigurations = serverGroupLaunchConfigurations
    }
}

public struct GetAppReplicationConfigurationInput: Swift.Sendable {
    /// The ID of the application.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

extension SMSClientTypes {

    /// The replication parameters for replicating a server.
    public struct ServerReplicationParameters: Swift.Sendable {
        /// Indicates whether the replication job produces encrypted AMIs.
        public var encrypted: Swift.Bool?
        /// The frequency of creating replication jobs for the server.
        public var frequency: Swift.Int?
        /// The ID of the KMS key for replication jobs that produce encrypted AMIs. This value can be any of the following:
        ///
        /// * KMS key ID
        ///
        /// * KMS key alias
        ///
        /// * ARN referring to the KMS key ID
        ///
        /// * ARN referring to the KMS key alias
        ///
        ///
        /// If encrypted is enabled but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
        public var kmsKeyId: Swift.String?
        /// The license type for creating a replication job for the server.
        public var licenseType: SMSClientTypes.LicenseType?
        /// The number of recent AMIs to keep when creating a replication job for this server.
        public var numberOfRecentAmisToKeep: Swift.Int?
        /// Indicates whether to run the replication job one time.
        public var runOnce: Swift.Bool?
        /// The seed time for creating a replication job for the server.
        public var seedTime: Foundation.Date?

        public init(
            encrypted: Swift.Bool? = nil,
            frequency: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            licenseType: SMSClientTypes.LicenseType? = nil,
            numberOfRecentAmisToKeep: Swift.Int? = nil,
            runOnce: Swift.Bool? = nil,
            seedTime: Foundation.Date? = nil
        )
        {
            self.encrypted = encrypted
            self.frequency = frequency
            self.kmsKeyId = kmsKeyId
            self.licenseType = licenseType
            self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
            self.runOnce = runOnce
            self.seedTime = seedTime
        }
    }
}

extension SMSClientTypes {

    /// Replication configuration of a server.
    public struct ServerReplicationConfiguration: Swift.Sendable {
        /// The ID of the server with which this replication configuration is associated.
        public var server: SMSClientTypes.Server?
        /// The parameters for replicating the server.
        public var serverReplicationParameters: SMSClientTypes.ServerReplicationParameters?

        public init(
            server: SMSClientTypes.Server? = nil,
            serverReplicationParameters: SMSClientTypes.ServerReplicationParameters? = nil
        )
        {
            self.server = server
            self.serverReplicationParameters = serverReplicationParameters
        }
    }
}

extension SMSClientTypes {

    /// Replication configuration for a server group.
    public struct ServerGroupReplicationConfiguration: Swift.Sendable {
        /// The ID of the server group with which this replication configuration is associated.
        public var serverGroupId: Swift.String?
        /// The replication configuration for servers in the server group.
        public var serverReplicationConfigurations: [SMSClientTypes.ServerReplicationConfiguration]?

        public init(
            serverGroupId: Swift.String? = nil,
            serverReplicationConfigurations: [SMSClientTypes.ServerReplicationConfiguration]? = nil
        )
        {
            self.serverGroupId = serverGroupId
            self.serverReplicationConfigurations = serverReplicationConfigurations
        }
    }
}

public struct GetAppReplicationConfigurationOutput: Swift.Sendable {
    /// The replication configurations associated with server groups in this application.
    public var serverGroupReplicationConfigurations: [SMSClientTypes.ServerGroupReplicationConfiguration]?

    public init(
        serverGroupReplicationConfigurations: [SMSClientTypes.ServerGroupReplicationConfiguration]? = nil
    )
    {
        self.serverGroupReplicationConfigurations = serverGroupReplicationConfigurations
    }
}

public struct GetAppValidationConfigurationInput: Swift.Sendable {
    /// The ID of the application.
    /// This member is required.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

extension SMSClientTypes {

    public enum ServerValidationStrategy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case userdata
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerValidationStrategy] {
            return [
                .userdata
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .userdata: return "USERDATA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SMSClientTypes {

    /// Contains validation parameters.
    public struct UserDataValidationParameters: Swift.Sendable {
        /// The type of validation script.
        public var scriptType: SMSClientTypes.ScriptType?
        /// The location of the validation script.
        public var source: SMSClientTypes.Source?

        public init(
            scriptType: SMSClientTypes.ScriptType? = nil,
            source: SMSClientTypes.Source? = nil
        )
        {
            self.scriptType = scriptType
            self.source = source
        }
    }
}

extension SMSClientTypes {

    /// Configuration for validating an instance.
    public struct ServerValidationConfiguration: Swift.Sendable {
        /// The name of the configuration.
        public var name: Swift.String?
        /// Represents a server.
        public var server: SMSClientTypes.Server?
        /// The validation strategy.
        public var serverValidationStrategy: SMSClientTypes.ServerValidationStrategy?
        /// The validation parameters.
        public var userDataValidationParameters: SMSClientTypes.UserDataValidationParameters?
        /// The ID of the validation.
        public var validationId: Swift.String?

        public init(
            name: Swift.String? = nil,
            server: SMSClientTypes.Server? = nil,
            serverValidationStrategy: SMSClientTypes.ServerValidationStrategy? = nil,
            userDataValidationParameters: SMSClientTypes.UserDataValidationParameters? = nil,
            validationId: Swift.String? = nil
        )
        {
            self.name = name
            self.server = server
            self.serverValidationStrategy = serverValidationStrategy
            self.userDataValidationParameters = userDataValidationParameters
            self.validationId = validationId
        }
    }
}

extension SMSClientTypes {

    /// Configuration for validating an instance.
    public struct ServerGroupValidationConfiguration: Swift.Sendable {
        /// The ID of the server group.
        public var serverGroupId: Swift.String?
        /// The validation configuration.
        public var serverValidationConfigurations: [SMSClientTypes.ServerValidationConfiguration]?

        public init(
            serverGroupId: Swift.String? = nil,
            serverValidationConfigurations: [SMSClientTypes.ServerValidationConfiguration]? = nil
        )
        {
            self.serverGroupId = serverGroupId
            self.serverValidationConfigurations = serverValidationConfigurations
        }
    }
}

public struct GetAppValidationConfigurationOutput: Swift.Sendable {
    /// The configuration for application validation.
    public var appValidationConfigurations: [SMSClientTypes.AppValidationConfiguration]?
    /// The configuration for instance validation.
    public var serverGroupValidationConfigurations: [SMSClientTypes.ServerGroupValidationConfiguration]?

    public init(
        appValidationConfigurations: [SMSClientTypes.AppValidationConfiguration]? = nil,
        serverGroupValidationConfigurations: [SMSClientTypes.ServerGroupValidationConfiguration]? = nil
    )
    {
        self.appValidationConfigurations = appValidationConfigurations
        self.serverGroupValidationConfigurations = serverGroupValidationConfigurations
    }
}

public struct GetAppValidationOutputInput: Swift.Sendable {
    /// The ID of the application.
    /// This member is required.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

extension SMSClientTypes {

    /// Contains output from validating an instance.
    public struct ServerValidationOutput: Swift.Sendable {
        /// Represents a server.
        public var server: SMSClientTypes.Server?

        public init(
            server: SMSClientTypes.Server? = nil
        )
        {
            self.server = server
        }
    }
}

extension SMSClientTypes {

    public enum ValidationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inprogress
        case pending
        case readyforvalidation
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationStatus] {
            return [
                .failed,
                .inprogress,
                .pending,
                .readyforvalidation,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inprogress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .readyforvalidation: return "READY_FOR_VALIDATION"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SMSClientTypes {

    /// Contains validation output.
    public struct ValidationOutput: Swift.Sendable {
        /// The output from validating an application.
        public var appValidationOutput: SMSClientTypes.AppValidationOutput?
        /// The latest time that the validation was performed.
        public var latestValidationTime: Foundation.Date?
        /// The name of the validation.
        public var name: Swift.String?
        /// The output from validation an instance.
        public var serverValidationOutput: SMSClientTypes.ServerValidationOutput?
        /// The status of the validation.
        public var status: SMSClientTypes.ValidationStatus?
        /// The status message.
        public var statusMessage: Swift.String?
        /// The ID of the validation.
        public var validationId: Swift.String?

        public init(
            appValidationOutput: SMSClientTypes.AppValidationOutput? = nil,
            latestValidationTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            serverValidationOutput: SMSClientTypes.ServerValidationOutput? = nil,
            status: SMSClientTypes.ValidationStatus? = nil,
            statusMessage: Swift.String? = nil,
            validationId: Swift.String? = nil
        )
        {
            self.appValidationOutput = appValidationOutput
            self.latestValidationTime = latestValidationTime
            self.name = name
            self.serverValidationOutput = serverValidationOutput
            self.status = status
            self.statusMessage = statusMessage
            self.validationId = validationId
        }
    }
}

public struct GetAppValidationOutputOutput: Swift.Sendable {
    /// The validation output.
    public var validationOutputList: [SMSClientTypes.ValidationOutput]?

    public init(
        validationOutputList: [SMSClientTypes.ValidationOutput]? = nil
    )
    {
        self.validationOutputList = validationOutputList
    }
}

public struct GetConnectorsInput: Swift.Sendable {
    /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SMSClientTypes {

    public enum ConnectorCapability: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hypervmanager
        case scvmm
        case smsoptimized
        case snapshotbatching
        case vsphere
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectorCapability] {
            return [
                .hypervmanager,
                .scvmm,
                .smsoptimized,
                .snapshotbatching,
                .vsphere
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hypervmanager: return "HYPERV-MANAGER"
            case .scvmm: return "SCVMM"
            case .smsoptimized: return "SMS_OPTIMIZED"
            case .snapshotbatching: return "SNAPSHOT_BATCHING"
            case .vsphere: return "VSPHERE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SMSClientTypes {

    public enum ConnectorStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case healthy
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectorStatus] {
            return [
                .healthy,
                .unhealthy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SMSClientTypes {

    /// Represents a connector.
    public struct Connector: Swift.Sendable {
        /// The time the connector was associated.
        public var associatedOn: Foundation.Date?
        /// The capabilities of the connector.
        public var capabilityList: [SMSClientTypes.ConnectorCapability]?
        /// The ID of the connector.
        public var connectorId: Swift.String?
        /// The IP address of the connector.
        public var ipAddress: Swift.String?
        /// The MAC address of the connector.
        public var macAddress: Swift.String?
        /// The status of the connector.
        public var status: SMSClientTypes.ConnectorStatus?
        /// The connector version.
        public var version: Swift.String?
        /// The ID of the VM manager.
        public var vmManagerId: Swift.String?
        /// The name of the VM manager.
        public var vmManagerName: Swift.String?
        /// The VM management product.
        public var vmManagerType: SMSClientTypes.VmManagerType?

        public init(
            associatedOn: Foundation.Date? = nil,
            capabilityList: [SMSClientTypes.ConnectorCapability]? = nil,
            connectorId: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            macAddress: Swift.String? = nil,
            status: SMSClientTypes.ConnectorStatus? = nil,
            version: Swift.String? = nil,
            vmManagerId: Swift.String? = nil,
            vmManagerName: Swift.String? = nil,
            vmManagerType: SMSClientTypes.VmManagerType? = nil
        )
        {
            self.associatedOn = associatedOn
            self.capabilityList = capabilityList
            self.connectorId = connectorId
            self.ipAddress = ipAddress
            self.macAddress = macAddress
            self.status = status
            self.version = version
            self.vmManagerId = vmManagerId
            self.vmManagerName = vmManagerName
            self.vmManagerType = vmManagerType
        }
    }
}

public struct GetConnectorsOutput: Swift.Sendable {
    /// Information about the registered connectors.
    public var connectorList: [SMSClientTypes.Connector]?
    /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        connectorList: [SMSClientTypes.Connector]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorList = connectorList
        self.nextToken = nextToken
    }
}

public struct GetReplicationJobsInput: Swift.Sendable {
    /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The ID of the replication job.
    public var replicationJobId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        replicationJobId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.replicationJobId = replicationJobId
    }
}

extension SMSClientTypes {

    /// Details of the current stage of a replication run.
    public struct ReplicationRunStageDetails: Swift.Sendable {
        /// The current stage of a replication run.
        public var stage: Swift.String?
        /// The progress of the current stage of a replication run.
        public var stageProgress: Swift.String?

        public init(
            stage: Swift.String? = nil,
            stageProgress: Swift.String? = nil
        )
        {
            self.stage = stage
            self.stageProgress = stageProgress
        }
    }
}

extension SMSClientTypes {

    public enum ReplicationRunState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case completed
        case deleted
        case deleting
        case failed
        case missed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationRunState] {
            return [
                .active,
                .completed,
                .deleted,
                .deleting,
                .failed,
                .missed,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .completed: return "COMPLETED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .missed: return "MISSED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SMSClientTypes {

    public enum ReplicationRunType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case automatic
        case ondemand
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationRunType] {
            return [
                .automatic,
                .ondemand
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .automatic: return "AUTOMATIC"
            case .ondemand: return "ON_DEMAND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SMSClientTypes {

    /// Represents a replication run.
    public struct ReplicationRun: Swift.Sendable {
        /// The ID of the Amazon Machine Image (AMI) from the replication run.
        public var amiId: Swift.String?
        /// The completion time of the last replication run.
        public var completedTime: Foundation.Date?
        /// The description of the replication run.
        public var description: Swift.String?
        /// Indicates whether the replication run should produce an encrypted AMI.
        public var encrypted: Swift.Bool?
        /// The ID of the KMS key for replication jobs that produce encrypted AMIs. This value can be any of the following:
        ///
        /// * KMS key ID
        ///
        /// * KMS key alias
        ///
        /// * ARN referring to the KMS key ID
        ///
        /// * ARN referring to the KMS key alias
        ///
        ///
        /// If encrypted is true but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
        public var kmsKeyId: Swift.String?
        /// The ID of the replication run.
        public var replicationRunId: Swift.String?
        /// The start time of the next replication run.
        public var scheduledStartTime: Foundation.Date?
        /// Details about the current stage of the replication run.
        public var stageDetails: SMSClientTypes.ReplicationRunStageDetails?
        /// The state of the replication run.
        public var state: SMSClientTypes.ReplicationRunState?
        /// The description of the current status of the replication job.
        public var statusMessage: Swift.String?
        /// The type of replication run.
        public var type: SMSClientTypes.ReplicationRunType?

        public init(
            amiId: Swift.String? = nil,
            completedTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            encrypted: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil,
            replicationRunId: Swift.String? = nil,
            scheduledStartTime: Foundation.Date? = nil,
            stageDetails: SMSClientTypes.ReplicationRunStageDetails? = nil,
            state: SMSClientTypes.ReplicationRunState? = nil,
            statusMessage: Swift.String? = nil,
            type: SMSClientTypes.ReplicationRunType? = nil
        )
        {
            self.amiId = amiId
            self.completedTime = completedTime
            self.description = description
            self.encrypted = encrypted
            self.kmsKeyId = kmsKeyId
            self.replicationRunId = replicationRunId
            self.scheduledStartTime = scheduledStartTime
            self.stageDetails = stageDetails
            self.state = state
            self.statusMessage = statusMessage
            self.type = type
        }
    }
}

extension SMSClientTypes {

    public enum ReplicationJobState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case completed
        case deleted
        case deleting
        case failed
        case failing
        case pausedonfailure
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationJobState] {
            return [
                .active,
                .completed,
                .deleted,
                .deleting,
                .failed,
                .failing,
                .pausedonfailure,
                .pending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .completed: return "COMPLETED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .failing: return "FAILING"
            case .pausedonfailure: return "PAUSED_ON_FAILURE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SMSClientTypes {

    /// Represents a replication job.
    public struct ReplicationJob: Swift.Sendable {
        /// The description of the replication job.
        public var description: Swift.String?
        /// Indicates whether the replication job should produce encrypted AMIs.
        public var encrypted: Swift.Bool?
        /// The time between consecutive replication runs, in hours.
        public var frequency: Swift.Int?
        /// The ID of the KMS key for replication jobs that produce encrypted AMIs. This value can be any of the following:
        ///
        /// * KMS key ID
        ///
        /// * KMS key alias
        ///
        /// * ARN referring to the KMS key ID
        ///
        /// * ARN referring to the KMS key alias
        ///
        ///
        /// If encrypted is enabled but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
        public var kmsKeyId: Swift.String?
        /// The ID of the latest Amazon Machine Image (AMI).
        public var latestAmiId: Swift.String?
        /// The license type to be used for the AMI created by a successful replication run.
        public var licenseType: SMSClientTypes.LicenseType?
        /// The start time of the next replication run.
        public var nextReplicationRunStartTime: Foundation.Date?
        /// The number of recent AMIs to keep in the customer's account for a replication job. By default, the value is set to zero, meaning that all AMIs are kept.
        public var numberOfRecentAmisToKeep: Swift.Int?
        /// The ID of the replication job.
        public var replicationJobId: Swift.String?
        /// Information about the replication runs.
        public var replicationRunList: [SMSClientTypes.ReplicationRun]?
        /// The name of the IAM role to be used by Server Migration Service.
        public var roleName: Swift.String?
        /// Indicates whether to run the replication job one time.
        public var runOnce: Swift.Bool?
        /// The seed replication time.
        public var seedReplicationTime: Foundation.Date?
        /// The ID of the server.
        public var serverId: Swift.String?
        /// The type of server.
        public var serverType: SMSClientTypes.ServerType?
        /// The state of the replication job.
        public var state: SMSClientTypes.ReplicationJobState?
        /// The description of the current status of the replication job.
        public var statusMessage: Swift.String?
        /// Information about the VM server.
        public var vmServer: SMSClientTypes.VmServer?

        public init(
            description: Swift.String? = nil,
            encrypted: Swift.Bool? = nil,
            frequency: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            latestAmiId: Swift.String? = nil,
            licenseType: SMSClientTypes.LicenseType? = nil,
            nextReplicationRunStartTime: Foundation.Date? = nil,
            numberOfRecentAmisToKeep: Swift.Int? = nil,
            replicationJobId: Swift.String? = nil,
            replicationRunList: [SMSClientTypes.ReplicationRun]? = nil,
            roleName: Swift.String? = nil,
            runOnce: Swift.Bool? = nil,
            seedReplicationTime: Foundation.Date? = nil,
            serverId: Swift.String? = nil,
            serverType: SMSClientTypes.ServerType? = nil,
            state: SMSClientTypes.ReplicationJobState? = nil,
            statusMessage: Swift.String? = nil,
            vmServer: SMSClientTypes.VmServer? = nil
        )
        {
            self.description = description
            self.encrypted = encrypted
            self.frequency = frequency
            self.kmsKeyId = kmsKeyId
            self.latestAmiId = latestAmiId
            self.licenseType = licenseType
            self.nextReplicationRunStartTime = nextReplicationRunStartTime
            self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
            self.replicationJobId = replicationJobId
            self.replicationRunList = replicationRunList
            self.roleName = roleName
            self.runOnce = runOnce
            self.seedReplicationTime = seedReplicationTime
            self.serverId = serverId
            self.serverType = serverType
            self.state = state
            self.statusMessage = statusMessage
            self.vmServer = vmServer
        }
    }
}

public struct GetReplicationJobsOutput: Swift.Sendable {
    /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the replication jobs.
    public var replicationJobList: [SMSClientTypes.ReplicationJob]?

    public init(
        nextToken: Swift.String? = nil,
        replicationJobList: [SMSClientTypes.ReplicationJob]? = nil
    )
    {
        self.nextToken = nextToken
        self.replicationJobList = replicationJobList
    }
}

public struct GetReplicationRunsInput: Swift.Sendable {
    /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The ID of the replication job.
    /// This member is required.
    public var replicationJobId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        replicationJobId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.replicationJobId = replicationJobId
    }
}

public struct GetReplicationRunsOutput: Swift.Sendable {
    /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the replication job.
    public var replicationJob: SMSClientTypes.ReplicationJob?
    /// Information about the replication runs.
    public var replicationRunList: [SMSClientTypes.ReplicationRun]?

    public init(
        nextToken: Swift.String? = nil,
        replicationJob: SMSClientTypes.ReplicationJob? = nil,
        replicationRunList: [SMSClientTypes.ReplicationRun]? = nil
    )
    {
        self.nextToken = nextToken
        self.replicationJob = replicationJob
        self.replicationRunList = replicationRunList
    }
}

public struct GetServersInput: Swift.Sendable {
    /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The server addresses.
    public var vmServerAddressList: [SMSClientTypes.VmServerAddress]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        vmServerAddressList: [SMSClientTypes.VmServerAddress]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vmServerAddressList = vmServerAddressList
    }
}

extension SMSClientTypes {

    public enum ServerCatalogStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case deleted
        case expired
        case importing
        case notimported
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerCatalogStatus] {
            return [
                .available,
                .deleted,
                .expired,
                .importing,
                .notimported
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .expired: return "EXPIRED"
            case .importing: return "IMPORTING"
            case .notimported: return "NOT_IMPORTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetServersOutput: Swift.Sendable {
    /// The time when the server was last modified.
    public var lastModifiedOn: Foundation.Date?
    /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The status of the server catalog.
    public var serverCatalogStatus: SMSClientTypes.ServerCatalogStatus?
    /// Information about the servers.
    public var serverList: [SMSClientTypes.Server]?

    public init(
        lastModifiedOn: Foundation.Date? = nil,
        nextToken: Swift.String? = nil,
        serverCatalogStatus: SMSClientTypes.ServerCatalogStatus? = nil,
        serverList: [SMSClientTypes.Server]? = nil
    )
    {
        self.lastModifiedOn = lastModifiedOn
        self.nextToken = nextToken
        self.serverCatalogStatus = serverCatalogStatus
        self.serverList = serverList
    }
}

public struct ImportAppCatalogInput: Swift.Sendable {
    /// The name of the service role. If you omit this parameter, we create a service-linked role for Migration Hub in your account. Otherwise, the role that you provide must have the [policy and trust policy](https://docs.aws.amazon.com/migrationhub/latest/ug/new-customer-setup.html#sms-managed) described in the Migration Hub User Guide.
    public var roleName: Swift.String?

    public init(
        roleName: Swift.String? = nil
    )
    {
        self.roleName = roleName
    }
}

public struct ImportAppCatalogOutput: Swift.Sendable {

    public init() { }
}

public struct ImportServerCatalogInput: Swift.Sendable {

    public init() { }
}

public struct ImportServerCatalogOutput: Swift.Sendable {

    public init() { }
}

public struct LaunchAppInput: Swift.Sendable {
    /// The ID of the application.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

public struct LaunchAppOutput: Swift.Sendable {

    public init() { }
}

public struct ListAppsInput: Swift.Sendable {
    /// The unique application IDs.
    public var appIds: [Swift.String]?
    /// The maximum number of results to return in a single call. The default value is 100. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        appIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appIds = appIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAppsOutput: Swift.Sendable {
    /// The application summaries.
    public var apps: [SMSClientTypes.AppSummary]?
    /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        apps: [SMSClientTypes.AppSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apps = apps
        self.nextToken = nextToken
    }
}

extension SMSClientTypes {

    /// Contains the status of validating an application.
    public struct NotificationContext: Swift.Sendable {
        /// The status of the validation.
        public var status: SMSClientTypes.ValidationStatus?
        /// The status message.
        public var statusMessage: Swift.String?
        /// The ID of the validation.
        public var validationId: Swift.String?

        public init(
            status: SMSClientTypes.ValidationStatus? = nil,
            statusMessage: Swift.String? = nil,
            validationId: Swift.String? = nil
        )
        {
            self.status = status
            self.statusMessage = statusMessage
            self.validationId = validationId
        }
    }
}

public struct NotifyAppValidationOutputInput: Swift.Sendable {
    /// The ID of the application.
    /// This member is required.
    public var appId: Swift.String?
    /// The notification information.
    public var notificationContext: SMSClientTypes.NotificationContext?

    public init(
        appId: Swift.String? = nil,
        notificationContext: SMSClientTypes.NotificationContext? = nil
    )
    {
        self.appId = appId
        self.notificationContext = notificationContext
    }
}

public struct NotifyAppValidationOutputOutput: Swift.Sendable {

    public init() { }
}

public struct PutAppLaunchConfigurationInput: Swift.Sendable {
    /// The ID of the application.
    public var appId: Swift.String?
    /// Indicates whether the application is configured to launch automatically after replication is complete.
    public var autoLaunch: Swift.Bool?
    /// The name of service role in the customer's account that CloudFormation uses to launch the application.
    public var roleName: Swift.String?
    /// Information about the launch configurations for server groups in the application.
    public var serverGroupLaunchConfigurations: [SMSClientTypes.ServerGroupLaunchConfiguration]?

    public init(
        appId: Swift.String? = nil,
        autoLaunch: Swift.Bool? = nil,
        roleName: Swift.String? = nil,
        serverGroupLaunchConfigurations: [SMSClientTypes.ServerGroupLaunchConfiguration]? = nil
    )
    {
        self.appId = appId
        self.autoLaunch = autoLaunch
        self.roleName = roleName
        self.serverGroupLaunchConfigurations = serverGroupLaunchConfigurations
    }
}

public struct PutAppLaunchConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct PutAppReplicationConfigurationInput: Swift.Sendable {
    /// The ID of the application.
    public var appId: Swift.String?
    /// Information about the replication configurations for server groups in the application.
    public var serverGroupReplicationConfigurations: [SMSClientTypes.ServerGroupReplicationConfiguration]?

    public init(
        appId: Swift.String? = nil,
        serverGroupReplicationConfigurations: [SMSClientTypes.ServerGroupReplicationConfiguration]? = nil
    )
    {
        self.appId = appId
        self.serverGroupReplicationConfigurations = serverGroupReplicationConfigurations
    }
}

public struct PutAppReplicationConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct PutAppValidationConfigurationInput: Swift.Sendable {
    /// The ID of the application.
    /// This member is required.
    public var appId: Swift.String?
    /// The configuration for application validation.
    public var appValidationConfigurations: [SMSClientTypes.AppValidationConfiguration]?
    /// The configuration for instance validation.
    public var serverGroupValidationConfigurations: [SMSClientTypes.ServerGroupValidationConfiguration]?

    public init(
        appId: Swift.String? = nil,
        appValidationConfigurations: [SMSClientTypes.AppValidationConfiguration]? = nil,
        serverGroupValidationConfigurations: [SMSClientTypes.ServerGroupValidationConfiguration]? = nil
    )
    {
        self.appId = appId
        self.appValidationConfigurations = appValidationConfigurations
        self.serverGroupValidationConfigurations = serverGroupValidationConfigurations
    }
}

public struct PutAppValidationConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct StartAppReplicationInput: Swift.Sendable {
    /// The ID of the application.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

public struct StartAppReplicationOutput: Swift.Sendable {

    public init() { }
}

public struct StartOnDemandAppReplicationInput: Swift.Sendable {
    /// The ID of the application.
    /// This member is required.
    public var appId: Swift.String?
    /// The description of the replication run.
    public var description: Swift.String?

    public init(
        appId: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.appId = appId
        self.description = description
    }
}

public struct StartOnDemandAppReplicationOutput: Swift.Sendable {

    public init() { }
}

/// The user has the required permissions, so the request would have succeeded, but a dry run was performed.
public struct DryRunOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DryRunOperationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have exceeded the number of on-demand replication runs you can request in a 24-hour period.
public struct ReplicationRunLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReplicationRunLimitExceeded" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StartOnDemandReplicationRunInput: Swift.Sendable {
    /// The description of the replication run.
    public var description: Swift.String?
    /// The ID of the replication job.
    /// This member is required.
    public var replicationJobId: Swift.String?

    public init(
        description: Swift.String? = nil,
        replicationJobId: Swift.String? = nil
    )
    {
        self.description = description
        self.replicationJobId = replicationJobId
    }
}

public struct StartOnDemandReplicationRunOutput: Swift.Sendable {
    /// The ID of the replication run.
    public var replicationRunId: Swift.String?

    public init(
        replicationRunId: Swift.String? = nil
    )
    {
        self.replicationRunId = replicationRunId
    }
}

public struct StopAppReplicationInput: Swift.Sendable {
    /// The ID of the application.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

public struct StopAppReplicationOutput: Swift.Sendable {

    public init() { }
}

public struct TerminateAppInput: Swift.Sendable {
    /// The ID of the application.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

public struct TerminateAppOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateAppInput: Swift.Sendable {
    /// The ID of the application.
    public var appId: Swift.String?
    /// The new description of the application.
    public var description: Swift.String?
    /// The new name of the application.
    public var name: Swift.String?
    /// The name of the service role in the customer's account used by Server Migration Service.
    public var roleName: Swift.String?
    /// The server groups in the application to update.
    public var serverGroups: [SMSClientTypes.ServerGroup]?
    /// The tags to associate with the application.
    public var tags: [SMSClientTypes.Tag]?

    public init(
        appId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        roleName: Swift.String? = nil,
        serverGroups: [SMSClientTypes.ServerGroup]? = nil,
        tags: [SMSClientTypes.Tag]? = nil
    )
    {
        self.appId = appId
        self.description = description
        self.name = name
        self.roleName = roleName
        self.serverGroups = serverGroups
        self.tags = tags
    }
}

public struct UpdateAppOutput: Swift.Sendable {
    /// A summary description of the application.
    public var appSummary: SMSClientTypes.AppSummary?
    /// The updated server groups in the application.
    public var serverGroups: [SMSClientTypes.ServerGroup]?
    /// The tags associated with the application.
    public var tags: [SMSClientTypes.Tag]?

    public init(
        appSummary: SMSClientTypes.AppSummary? = nil,
        serverGroups: [SMSClientTypes.ServerGroup]? = nil,
        tags: [SMSClientTypes.Tag]? = nil
    )
    {
        self.appSummary = appSummary
        self.serverGroups = serverGroups
        self.tags = tags
    }
}

public struct UpdateReplicationJobInput: Swift.Sendable {
    /// The description of the replication job.
    public var description: Swift.String?
    /// When true, the replication job produces encrypted AMIs. For more information, KmsKeyId.
    public var encrypted: Swift.Bool?
    /// The time between consecutive replication runs, in hours.
    public var frequency: Swift.Int?
    /// The ID of the KMS key for replication jobs that produce encrypted AMIs. This value can be any of the following:
    ///
    /// * KMS key ID
    ///
    /// * KMS key alias
    ///
    /// * ARN referring to the KMS key ID
    ///
    /// * ARN referring to the KMS key alias
    ///
    ///
    /// If encrypted is enabled but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
    public var kmsKeyId: Swift.String?
    /// The license type to be used for the AMI created by a successful replication run.
    public var licenseType: SMSClientTypes.LicenseType?
    /// The start time of the next replication run.
    public var nextReplicationRunStartTime: Foundation.Date?
    /// The maximum number of SMS-created AMIs to retain. The oldest is deleted after the maximum number is reached and a new AMI is created.
    public var numberOfRecentAmisToKeep: Swift.Int?
    /// The ID of the replication job.
    /// This member is required.
    public var replicationJobId: Swift.String?
    /// The name of the IAM role to be used by Server Migration Service.
    public var roleName: Swift.String?

    public init(
        description: Swift.String? = nil,
        encrypted: Swift.Bool? = nil,
        frequency: Swift.Int? = nil,
        kmsKeyId: Swift.String? = nil,
        licenseType: SMSClientTypes.LicenseType? = nil,
        nextReplicationRunStartTime: Foundation.Date? = nil,
        numberOfRecentAmisToKeep: Swift.Int? = nil,
        replicationJobId: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.description = description
        self.encrypted = encrypted
        self.frequency = frequency
        self.kmsKeyId = kmsKeyId
        self.licenseType = licenseType
        self.nextReplicationRunStartTime = nextReplicationRunStartTime
        self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
        self.replicationJobId = replicationJobId
        self.roleName = roleName
    }
}

public struct UpdateReplicationJobOutput: Swift.Sendable {

    public init() { }
}

extension CreateAppInput {

    static func urlPathProvider(_ value: CreateAppInput) -> Swift.String? {
        return "/"
    }
}

extension CreateReplicationJobInput {

    static func urlPathProvider(_ value: CreateReplicationJobInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAppInput {

    static func urlPathProvider(_ value: DeleteAppInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAppLaunchConfigurationInput {

    static func urlPathProvider(_ value: DeleteAppLaunchConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAppReplicationConfigurationInput {

    static func urlPathProvider(_ value: DeleteAppReplicationConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAppValidationConfigurationInput {

    static func urlPathProvider(_ value: DeleteAppValidationConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteReplicationJobInput {

    static func urlPathProvider(_ value: DeleteReplicationJobInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteServerCatalogInput {

    static func urlPathProvider(_ value: DeleteServerCatalogInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateConnectorInput {

    static func urlPathProvider(_ value: DisassociateConnectorInput) -> Swift.String? {
        return "/"
    }
}

extension GenerateChangeSetInput {

    static func urlPathProvider(_ value: GenerateChangeSetInput) -> Swift.String? {
        return "/"
    }
}

extension GenerateTemplateInput {

    static func urlPathProvider(_ value: GenerateTemplateInput) -> Swift.String? {
        return "/"
    }
}

extension GetAppInput {

    static func urlPathProvider(_ value: GetAppInput) -> Swift.String? {
        return "/"
    }
}

extension GetAppLaunchConfigurationInput {

    static func urlPathProvider(_ value: GetAppLaunchConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension GetAppReplicationConfigurationInput {

    static func urlPathProvider(_ value: GetAppReplicationConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension GetAppValidationConfigurationInput {

    static func urlPathProvider(_ value: GetAppValidationConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension GetAppValidationOutputInput {

    static func urlPathProvider(_ value: GetAppValidationOutputInput) -> Swift.String? {
        return "/"
    }
}

extension GetConnectorsInput {

    static func urlPathProvider(_ value: GetConnectorsInput) -> Swift.String? {
        return "/"
    }
}

extension GetReplicationJobsInput {

    static func urlPathProvider(_ value: GetReplicationJobsInput) -> Swift.String? {
        return "/"
    }
}

extension GetReplicationRunsInput {

    static func urlPathProvider(_ value: GetReplicationRunsInput) -> Swift.String? {
        return "/"
    }
}

extension GetServersInput {

    static func urlPathProvider(_ value: GetServersInput) -> Swift.String? {
        return "/"
    }
}

extension ImportAppCatalogInput {

    static func urlPathProvider(_ value: ImportAppCatalogInput) -> Swift.String? {
        return "/"
    }
}

extension ImportServerCatalogInput {

    static func urlPathProvider(_ value: ImportServerCatalogInput) -> Swift.String? {
        return "/"
    }
}

extension LaunchAppInput {

    static func urlPathProvider(_ value: LaunchAppInput) -> Swift.String? {
        return "/"
    }
}

extension ListAppsInput {

    static func urlPathProvider(_ value: ListAppsInput) -> Swift.String? {
        return "/"
    }
}

extension NotifyAppValidationOutputInput {

    static func urlPathProvider(_ value: NotifyAppValidationOutputInput) -> Swift.String? {
        return "/"
    }
}

extension PutAppLaunchConfigurationInput {

    static func urlPathProvider(_ value: PutAppLaunchConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension PutAppReplicationConfigurationInput {

    static func urlPathProvider(_ value: PutAppReplicationConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension PutAppValidationConfigurationInput {

    static func urlPathProvider(_ value: PutAppValidationConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension StartAppReplicationInput {

    static func urlPathProvider(_ value: StartAppReplicationInput) -> Swift.String? {
        return "/"
    }
}

extension StartOnDemandAppReplicationInput {

    static func urlPathProvider(_ value: StartOnDemandAppReplicationInput) -> Swift.String? {
        return "/"
    }
}

extension StartOnDemandReplicationRunInput {

    static func urlPathProvider(_ value: StartOnDemandReplicationRunInput) -> Swift.String? {
        return "/"
    }
}

extension StopAppReplicationInput {

    static func urlPathProvider(_ value: StopAppReplicationInput) -> Swift.String? {
        return "/"
    }
}

extension TerminateAppInput {

    static func urlPathProvider(_ value: TerminateAppInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateAppInput {

    static func urlPathProvider(_ value: UpdateAppInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateReplicationJobInput {

    static func urlPathProvider(_ value: UpdateReplicationJobInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAppInput {

    static func write(value: CreateAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["roleName"].write(value.roleName)
        try writer["serverGroups"].writeList(value.serverGroups, memberWritingClosure: SMSClientTypes.ServerGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeList(value.tags, memberWritingClosure: SMSClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateReplicationJobInput {

    static func write(value: CreateReplicationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["encrypted"].write(value.encrypted)
        try writer["frequency"].write(value.frequency)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["licenseType"].write(value.licenseType)
        try writer["numberOfRecentAmisToKeep"].write(value.numberOfRecentAmisToKeep)
        try writer["roleName"].write(value.roleName)
        try writer["runOnce"].write(value.runOnce)
        try writer["seedReplicationTime"].writeTimestamp(value.seedReplicationTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["serverId"].write(value.serverId)
    }
}

extension DeleteAppInput {

    static func write(value: DeleteAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
        try writer["forceStopAppReplication"].write(value.forceStopAppReplication)
        try writer["forceTerminateApp"].write(value.forceTerminateApp)
    }
}

extension DeleteAppLaunchConfigurationInput {

    static func write(value: DeleteAppLaunchConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
    }
}

extension DeleteAppReplicationConfigurationInput {

    static func write(value: DeleteAppReplicationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
    }
}

extension DeleteAppValidationConfigurationInput {

    static func write(value: DeleteAppValidationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
    }
}

extension DeleteReplicationJobInput {

    static func write(value: DeleteReplicationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["replicationJobId"].write(value.replicationJobId)
    }
}

extension DeleteServerCatalogInput {

    static func write(value: DeleteServerCatalogInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension DisassociateConnectorInput {

    static func write(value: DisassociateConnectorInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["connectorId"].write(value.connectorId)
    }
}

extension GenerateChangeSetInput {

    static func write(value: GenerateChangeSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
        try writer["changesetFormat"].write(value.changesetFormat)
    }
}

extension GenerateTemplateInput {

    static func write(value: GenerateTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
        try writer["templateFormat"].write(value.templateFormat)
    }
}

extension GetAppInput {

    static func write(value: GetAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
    }
}

extension GetAppLaunchConfigurationInput {

    static func write(value: GetAppLaunchConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
    }
}

extension GetAppReplicationConfigurationInput {

    static func write(value: GetAppReplicationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
    }
}

extension GetAppValidationConfigurationInput {

    static func write(value: GetAppValidationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
    }
}

extension GetAppValidationOutputInput {

    static func write(value: GetAppValidationOutputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
    }
}

extension GetConnectorsInput {

    static func write(value: GetConnectorsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension GetReplicationJobsInput {

    static func write(value: GetReplicationJobsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["replicationJobId"].write(value.replicationJobId)
    }
}

extension GetReplicationRunsInput {

    static func write(value: GetReplicationRunsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["replicationJobId"].write(value.replicationJobId)
    }
}

extension GetServersInput {

    static func write(value: GetServersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["vmServerAddressList"].writeList(value.vmServerAddressList, memberWritingClosure: SMSClientTypes.VmServerAddress.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ImportAppCatalogInput {

    static func write(value: ImportAppCatalogInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["roleName"].write(value.roleName)
    }
}

extension ImportServerCatalogInput {

    static func write(value: ImportServerCatalogInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension LaunchAppInput {

    static func write(value: LaunchAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
    }
}

extension ListAppsInput {

    static func write(value: ListAppsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appIds"].writeList(value.appIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension NotifyAppValidationOutputInput {

    static func write(value: NotifyAppValidationOutputInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
        try writer["notificationContext"].write(value.notificationContext, with: SMSClientTypes.NotificationContext.write(value:to:))
    }
}

extension PutAppLaunchConfigurationInput {

    static func write(value: PutAppLaunchConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
        try writer["autoLaunch"].write(value.autoLaunch)
        try writer["roleName"].write(value.roleName)
        try writer["serverGroupLaunchConfigurations"].writeList(value.serverGroupLaunchConfigurations, memberWritingClosure: SMSClientTypes.ServerGroupLaunchConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutAppReplicationConfigurationInput {

    static func write(value: PutAppReplicationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
        try writer["serverGroupReplicationConfigurations"].writeList(value.serverGroupReplicationConfigurations, memberWritingClosure: SMSClientTypes.ServerGroupReplicationConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension PutAppValidationConfigurationInput {

    static func write(value: PutAppValidationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
        try writer["appValidationConfigurations"].writeList(value.appValidationConfigurations, memberWritingClosure: SMSClientTypes.AppValidationConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["serverGroupValidationConfigurations"].writeList(value.serverGroupValidationConfigurations, memberWritingClosure: SMSClientTypes.ServerGroupValidationConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension StartAppReplicationInput {

    static func write(value: StartAppReplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
    }
}

extension StartOnDemandAppReplicationInput {

    static func write(value: StartOnDemandAppReplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
        try writer["description"].write(value.description)
    }
}

extension StartOnDemandReplicationRunInput {

    static func write(value: StartOnDemandReplicationRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["replicationJobId"].write(value.replicationJobId)
    }
}

extension StopAppReplicationInput {

    static func write(value: StopAppReplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
    }
}

extension TerminateAppInput {

    static func write(value: TerminateAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
    }
}

extension UpdateAppInput {

    static func write(value: UpdateAppInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appId"].write(value.appId)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["roleName"].write(value.roleName)
        try writer["serverGroups"].writeList(value.serverGroups, memberWritingClosure: SMSClientTypes.ServerGroup.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].writeList(value.tags, memberWritingClosure: SMSClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateReplicationJobInput {

    static func write(value: UpdateReplicationJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["encrypted"].write(value.encrypted)
        try writer["frequency"].write(value.frequency)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["licenseType"].write(value.licenseType)
        try writer["nextReplicationRunStartTime"].writeTimestamp(value.nextReplicationRunStartTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["numberOfRecentAmisToKeep"].write(value.numberOfRecentAmisToKeep)
        try writer["replicationJobId"].write(value.replicationJobId)
        try writer["roleName"].write(value.roleName)
    }
}

extension CreateAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAppOutput()
        value.appSummary = try reader["appSummary"].readIfPresent(with: SMSClientTypes.AppSummary.read(from:))
        value.serverGroups = try reader["serverGroups"].readListIfPresent(memberReadingClosure: SMSClientTypes.ServerGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: SMSClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CreateReplicationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateReplicationJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateReplicationJobOutput()
        value.replicationJobId = try reader["replicationJobId"].readIfPresent()
        return value
    }
}

extension DeleteAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAppOutput {
        return DeleteAppOutput()
    }
}

extension DeleteAppLaunchConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAppLaunchConfigurationOutput {
        return DeleteAppLaunchConfigurationOutput()
    }
}

extension DeleteAppReplicationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAppReplicationConfigurationOutput {
        return DeleteAppReplicationConfigurationOutput()
    }
}

extension DeleteAppValidationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAppValidationConfigurationOutput {
        return DeleteAppValidationConfigurationOutput()
    }
}

extension DeleteReplicationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteReplicationJobOutput {
        return DeleteReplicationJobOutput()
    }
}

extension DeleteServerCatalogOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteServerCatalogOutput {
        return DeleteServerCatalogOutput()
    }
}

extension DisassociateConnectorOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateConnectorOutput {
        return DisassociateConnectorOutput()
    }
}

extension GenerateChangeSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GenerateChangeSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GenerateChangeSetOutput()
        value.s3Location = try reader["s3Location"].readIfPresent(with: SMSClientTypes.S3Location.read(from:))
        return value
    }
}

extension GenerateTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GenerateTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GenerateTemplateOutput()
        value.s3Location = try reader["s3Location"].readIfPresent(with: SMSClientTypes.S3Location.read(from:))
        return value
    }
}

extension GetAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAppOutput()
        value.appSummary = try reader["appSummary"].readIfPresent(with: SMSClientTypes.AppSummary.read(from:))
        value.serverGroups = try reader["serverGroups"].readListIfPresent(memberReadingClosure: SMSClientTypes.ServerGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: SMSClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetAppLaunchConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAppLaunchConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAppLaunchConfigurationOutput()
        value.appId = try reader["appId"].readIfPresent()
        value.autoLaunch = try reader["autoLaunch"].readIfPresent()
        value.roleName = try reader["roleName"].readIfPresent()
        value.serverGroupLaunchConfigurations = try reader["serverGroupLaunchConfigurations"].readListIfPresent(memberReadingClosure: SMSClientTypes.ServerGroupLaunchConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetAppReplicationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAppReplicationConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAppReplicationConfigurationOutput()
        value.serverGroupReplicationConfigurations = try reader["serverGroupReplicationConfigurations"].readListIfPresent(memberReadingClosure: SMSClientTypes.ServerGroupReplicationConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetAppValidationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAppValidationConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAppValidationConfigurationOutput()
        value.appValidationConfigurations = try reader["appValidationConfigurations"].readListIfPresent(memberReadingClosure: SMSClientTypes.AppValidationConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.serverGroupValidationConfigurations = try reader["serverGroupValidationConfigurations"].readListIfPresent(memberReadingClosure: SMSClientTypes.ServerGroupValidationConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetAppValidationOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAppValidationOutputOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAppValidationOutputOutput()
        value.validationOutputList = try reader["validationOutputList"].readListIfPresent(memberReadingClosure: SMSClientTypes.ValidationOutput.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetConnectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConnectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectorsOutput()
        value.connectorList = try reader["connectorList"].readListIfPresent(memberReadingClosure: SMSClientTypes.Connector.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetReplicationJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetReplicationJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetReplicationJobsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.replicationJobList = try reader["replicationJobList"].readListIfPresent(memberReadingClosure: SMSClientTypes.ReplicationJob.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetReplicationRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetReplicationRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetReplicationRunsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.replicationJob = try reader["replicationJob"].readIfPresent(with: SMSClientTypes.ReplicationJob.read(from:))
        value.replicationRunList = try reader["replicationRunList"].readListIfPresent(memberReadingClosure: SMSClientTypes.ReplicationRun.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetServersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServersOutput()
        value.lastModifiedOn = try reader["lastModifiedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.serverCatalogStatus = try reader["serverCatalogStatus"].readIfPresent()
        value.serverList = try reader["serverList"].readListIfPresent(memberReadingClosure: SMSClientTypes.Server.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ImportAppCatalogOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportAppCatalogOutput {
        return ImportAppCatalogOutput()
    }
}

extension ImportServerCatalogOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ImportServerCatalogOutput {
        return ImportServerCatalogOutput()
    }
}

extension LaunchAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> LaunchAppOutput {
        return LaunchAppOutput()
    }
}

extension ListAppsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAppsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAppsOutput()
        value.apps = try reader["apps"].readListIfPresent(memberReadingClosure: SMSClientTypes.AppSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension NotifyAppValidationOutputOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> NotifyAppValidationOutputOutput {
        return NotifyAppValidationOutputOutput()
    }
}

extension PutAppLaunchConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutAppLaunchConfigurationOutput {
        return PutAppLaunchConfigurationOutput()
    }
}

extension PutAppReplicationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutAppReplicationConfigurationOutput {
        return PutAppReplicationConfigurationOutput()
    }
}

extension PutAppValidationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutAppValidationConfigurationOutput {
        return PutAppValidationConfigurationOutput()
    }
}

extension StartAppReplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartAppReplicationOutput {
        return StartAppReplicationOutput()
    }
}

extension StartOnDemandAppReplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartOnDemandAppReplicationOutput {
        return StartOnDemandAppReplicationOutput()
    }
}

extension StartOnDemandReplicationRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartOnDemandReplicationRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartOnDemandReplicationRunOutput()
        value.replicationRunId = try reader["replicationRunId"].readIfPresent()
        return value
    }
}

extension StopAppReplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopAppReplicationOutput {
        return StopAppReplicationOutput()
    }
}

extension TerminateAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TerminateAppOutput {
        return TerminateAppOutput()
    }
}

extension UpdateAppOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAppOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAppOutput()
        value.appSummary = try reader["appSummary"].readIfPresent(with: SMSClientTypes.AppSummary.read(from:))
        value.serverGroups = try reader["serverGroups"].readListIfPresent(memberReadingClosure: SMSClientTypes.ServerGroup.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.tags = try reader["tags"].readListIfPresent(memberReadingClosure: SMSClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension UpdateReplicationJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateReplicationJobOutput {
        return UpdateReplicationJobOutput()
    }
}

enum CreateAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateReplicationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "NoConnectorsAvailable": return try NoConnectorsAvailableException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ReplicationJobAlreadyExists": return try ReplicationJobAlreadyExistsException.makeError(baseError: baseError)
            case "ServerCannotBeReplicated": return try ServerCannotBeReplicatedException.makeError(baseError: baseError)
            case "TemporarilyUnavailable": return try TemporarilyUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAppLaunchConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAppReplicationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAppValidationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteReplicationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ReplicationJobNotFound": return try ReplicationJobNotFoundException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteServerCatalogOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateConnectorOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GenerateChangeSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GenerateTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAppLaunchConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAppReplicationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAppValidationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAppValidationOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConnectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetReplicationJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetReplicationRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportAppCatalogOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ImportServerCatalogOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "NoConnectorsAvailable": return try NoConnectorsAvailableException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum LaunchAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAppsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum NotifyAppValidationOutputOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutAppLaunchConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutAppReplicationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutAppValidationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartAppReplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartOnDemandAppReplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartOnDemandReplicationRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "DryRunOperationException": return try DryRunOperationException.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ReplicationRunLimitExceeded": return try ReplicationRunLimitExceededException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopAppReplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TerminateAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAppOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateReplicationJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalError": return try InternalError.makeError(baseError: baseError)
            case "InvalidParameter": return try InvalidParameterException.makeError(baseError: baseError)
            case "MissingRequiredParameter": return try MissingRequiredParameterException.makeError(baseError: baseError)
            case "OperationNotPermitted": return try OperationNotPermittedException.makeError(baseError: baseError)
            case "ReplicationJobNotFound": return try ReplicationJobNotFoundException.makeError(baseError: baseError)
            case "ServerCannotBeReplicated": return try ServerCannotBeReplicatedException.makeError(baseError: baseError)
            case "TemporarilyUnavailable": return try TemporarilyUnavailableException.makeError(baseError: baseError)
            case "UnauthorizedOperation": return try UnauthorizedOperationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension OperationNotPermittedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> OperationNotPermittedException {
        let reader = baseError.errorBodyReader
        var value = OperationNotPermittedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParameterException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedOperationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> UnauthorizedOperationException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedOperationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalError {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalError {
        let reader = baseError.errorBodyReader
        var value = InternalError()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MissingRequiredParameterException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> MissingRequiredParameterException {
        let reader = baseError.errorBodyReader
        var value = MissingRequiredParameterException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ReplicationJobAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ReplicationJobAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ReplicationJobAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoConnectorsAvailableException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NoConnectorsAvailableException {
        let reader = baseError.errorBodyReader
        var value = NoConnectorsAvailableException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TemporarilyUnavailableException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TemporarilyUnavailableException {
        var value = TemporarilyUnavailableException()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServerCannotBeReplicatedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServerCannotBeReplicatedException {
        let reader = baseError.errorBodyReader
        var value = ServerCannotBeReplicatedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ReplicationJobNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ReplicationJobNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ReplicationJobNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ReplicationRunLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ReplicationRunLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ReplicationRunLimitExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DryRunOperationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DryRunOperationException {
        let reader = baseError.errorBodyReader
        var value = DryRunOperationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SMSClientTypes.AppSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.AppSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.AppSummary()
        value.appId = try reader["appId"].readIfPresent()
        value.importedAppId = try reader["importedAppId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.replicationConfigurationStatus = try reader["replicationConfigurationStatus"].readIfPresent()
        value.replicationStatus = try reader["replicationStatus"].readIfPresent()
        value.replicationStatusMessage = try reader["replicationStatusMessage"].readIfPresent()
        value.latestReplicationTime = try reader["latestReplicationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.launchConfigurationStatus = try reader["launchConfigurationStatus"].readIfPresent()
        value.launchStatus = try reader["launchStatus"].readIfPresent()
        value.launchStatusMessage = try reader["launchStatusMessage"].readIfPresent()
        value.launchDetails = try reader["launchDetails"].readIfPresent(with: SMSClientTypes.LaunchDetails.read(from:))
        value.creationTime = try reader["creationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModified = try reader["lastModified"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.roleName = try reader["roleName"].readIfPresent()
        value.totalServerGroups = try reader["totalServerGroups"].readIfPresent()
        value.totalServers = try reader["totalServers"].readIfPresent()
        return value
    }
}

extension SMSClientTypes.LaunchDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.LaunchDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.LaunchDetails()
        value.latestLaunchTime = try reader["latestLaunchTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.stackName = try reader["stackName"].readIfPresent()
        value.stackId = try reader["stackId"].readIfPresent()
        return value
    }
}

extension SMSClientTypes.ServerGroup {

    static func write(value: SMSClientTypes.ServerGroup?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["serverGroupId"].write(value.serverGroupId)
        try writer["serverList"].writeList(value.serverList, memberWritingClosure: SMSClientTypes.Server.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.ServerGroup {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.ServerGroup()
        value.serverGroupId = try reader["serverGroupId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.serverList = try reader["serverList"].readListIfPresent(memberReadingClosure: SMSClientTypes.Server.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SMSClientTypes.Server {

    static func write(value: SMSClientTypes.Server?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["replicationJobId"].write(value.replicationJobId)
        try writer["replicationJobTerminated"].write(value.replicationJobTerminated)
        try writer["serverId"].write(value.serverId)
        try writer["serverType"].write(value.serverType)
        try writer["vmServer"].write(value.vmServer, with: SMSClientTypes.VmServer.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.Server {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.Server()
        value.serverId = try reader["serverId"].readIfPresent()
        value.serverType = try reader["serverType"].readIfPresent()
        value.vmServer = try reader["vmServer"].readIfPresent(with: SMSClientTypes.VmServer.read(from:))
        value.replicationJobId = try reader["replicationJobId"].readIfPresent()
        value.replicationJobTerminated = try reader["replicationJobTerminated"].readIfPresent()
        return value
    }
}

extension SMSClientTypes.VmServer {

    static func write(value: SMSClientTypes.VmServer?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vmManagerName"].write(value.vmManagerName)
        try writer["vmManagerType"].write(value.vmManagerType)
        try writer["vmName"].write(value.vmName)
        try writer["vmPath"].write(value.vmPath)
        try writer["vmServerAddress"].write(value.vmServerAddress, with: SMSClientTypes.VmServerAddress.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.VmServer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.VmServer()
        value.vmServerAddress = try reader["vmServerAddress"].readIfPresent(with: SMSClientTypes.VmServerAddress.read(from:))
        value.vmName = try reader["vmName"].readIfPresent()
        value.vmManagerName = try reader["vmManagerName"].readIfPresent()
        value.vmManagerType = try reader["vmManagerType"].readIfPresent()
        value.vmPath = try reader["vmPath"].readIfPresent()
        return value
    }
}

extension SMSClientTypes.VmServerAddress {

    static func write(value: SMSClientTypes.VmServerAddress?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["vmId"].write(value.vmId)
        try writer["vmManagerId"].write(value.vmManagerId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.VmServerAddress {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.VmServerAddress()
        value.vmManagerId = try reader["vmManagerId"].readIfPresent()
        value.vmId = try reader["vmId"].readIfPresent()
        return value
    }
}

extension SMSClientTypes.Tag {

    static func write(value: SMSClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.Tag()
        value.key = try reader["key"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        return value
    }
}

extension SMSClientTypes.S3Location {

    static func write(value: SMSClientTypes.S3Location?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucket"].write(value.bucket)
        try writer["key"].write(value.key)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.S3Location {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.S3Location()
        value.bucket = try reader["bucket"].readIfPresent()
        value.key = try reader["key"].readIfPresent()
        return value
    }
}

extension SMSClientTypes.ServerGroupLaunchConfiguration {

    static func write(value: SMSClientTypes.ServerGroupLaunchConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["launchOrder"].write(value.launchOrder)
        try writer["serverGroupId"].write(value.serverGroupId)
        try writer["serverLaunchConfigurations"].writeList(value.serverLaunchConfigurations, memberWritingClosure: SMSClientTypes.ServerLaunchConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.ServerGroupLaunchConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.ServerGroupLaunchConfiguration()
        value.serverGroupId = try reader["serverGroupId"].readIfPresent()
        value.launchOrder = try reader["launchOrder"].readIfPresent()
        value.serverLaunchConfigurations = try reader["serverLaunchConfigurations"].readListIfPresent(memberReadingClosure: SMSClientTypes.ServerLaunchConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SMSClientTypes.ServerLaunchConfiguration {

    static func write(value: SMSClientTypes.ServerLaunchConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["associatePublicIpAddress"].write(value.associatePublicIpAddress)
        try writer["configureScript"].write(value.configureScript, with: SMSClientTypes.S3Location.write(value:to:))
        try writer["configureScriptType"].write(value.configureScriptType)
        try writer["ec2KeyName"].write(value.ec2KeyName)
        try writer["iamInstanceProfileName"].write(value.iamInstanceProfileName)
        try writer["instanceType"].write(value.instanceType)
        try writer["logicalId"].write(value.logicalId)
        try writer["securityGroup"].write(value.securityGroup)
        try writer["server"].write(value.server, with: SMSClientTypes.Server.write(value:to:))
        try writer["subnet"].write(value.subnet)
        try writer["userData"].write(value.userData, with: SMSClientTypes.UserData.write(value:to:))
        try writer["vpc"].write(value.vpc)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.ServerLaunchConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.ServerLaunchConfiguration()
        value.server = try reader["server"].readIfPresent(with: SMSClientTypes.Server.read(from:))
        value.logicalId = try reader["logicalId"].readIfPresent()
        value.vpc = try reader["vpc"].readIfPresent()
        value.subnet = try reader["subnet"].readIfPresent()
        value.securityGroup = try reader["securityGroup"].readIfPresent()
        value.ec2KeyName = try reader["ec2KeyName"].readIfPresent()
        value.userData = try reader["userData"].readIfPresent(with: SMSClientTypes.UserData.read(from:))
        value.instanceType = try reader["instanceType"].readIfPresent()
        value.associatePublicIpAddress = try reader["associatePublicIpAddress"].readIfPresent()
        value.iamInstanceProfileName = try reader["iamInstanceProfileName"].readIfPresent()
        value.configureScript = try reader["configureScript"].readIfPresent(with: SMSClientTypes.S3Location.read(from:))
        value.configureScriptType = try reader["configureScriptType"].readIfPresent()
        return value
    }
}

extension SMSClientTypes.UserData {

    static func write(value: SMSClientTypes.UserData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Location"].write(value.s3Location, with: SMSClientTypes.S3Location.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.UserData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.UserData()
        value.s3Location = try reader["s3Location"].readIfPresent(with: SMSClientTypes.S3Location.read(from:))
        return value
    }
}

extension SMSClientTypes.ServerGroupReplicationConfiguration {

    static func write(value: SMSClientTypes.ServerGroupReplicationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["serverGroupId"].write(value.serverGroupId)
        try writer["serverReplicationConfigurations"].writeList(value.serverReplicationConfigurations, memberWritingClosure: SMSClientTypes.ServerReplicationConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.ServerGroupReplicationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.ServerGroupReplicationConfiguration()
        value.serverGroupId = try reader["serverGroupId"].readIfPresent()
        value.serverReplicationConfigurations = try reader["serverReplicationConfigurations"].readListIfPresent(memberReadingClosure: SMSClientTypes.ServerReplicationConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SMSClientTypes.ServerReplicationConfiguration {

    static func write(value: SMSClientTypes.ServerReplicationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["server"].write(value.server, with: SMSClientTypes.Server.write(value:to:))
        try writer["serverReplicationParameters"].write(value.serverReplicationParameters, with: SMSClientTypes.ServerReplicationParameters.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.ServerReplicationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.ServerReplicationConfiguration()
        value.server = try reader["server"].readIfPresent(with: SMSClientTypes.Server.read(from:))
        value.serverReplicationParameters = try reader["serverReplicationParameters"].readIfPresent(with: SMSClientTypes.ServerReplicationParameters.read(from:))
        return value
    }
}

extension SMSClientTypes.ServerReplicationParameters {

    static func write(value: SMSClientTypes.ServerReplicationParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encrypted"].write(value.encrypted)
        try writer["frequency"].write(value.frequency)
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["licenseType"].write(value.licenseType)
        try writer["numberOfRecentAmisToKeep"].write(value.numberOfRecentAmisToKeep)
        try writer["runOnce"].write(value.runOnce)
        try writer["seedTime"].writeTimestamp(value.seedTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.ServerReplicationParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.ServerReplicationParameters()
        value.seedTime = try reader["seedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.frequency = try reader["frequency"].readIfPresent()
        value.runOnce = try reader["runOnce"].readIfPresent()
        value.licenseType = try reader["licenseType"].readIfPresent()
        value.numberOfRecentAmisToKeep = try reader["numberOfRecentAmisToKeep"].readIfPresent()
        value.encrypted = try reader["encrypted"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        return value
    }
}

extension SMSClientTypes.AppValidationConfiguration {

    static func write(value: SMSClientTypes.AppValidationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appValidationStrategy"].write(value.appValidationStrategy)
        try writer["name"].write(value.name)
        try writer["ssmValidationParameters"].write(value.ssmValidationParameters, with: SMSClientTypes.SSMValidationParameters.write(value:to:))
        try writer["validationId"].write(value.validationId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.AppValidationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.AppValidationConfiguration()
        value.validationId = try reader["validationId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.appValidationStrategy = try reader["appValidationStrategy"].readIfPresent()
        value.ssmValidationParameters = try reader["ssmValidationParameters"].readIfPresent(with: SMSClientTypes.SSMValidationParameters.read(from:))
        return value
    }
}

extension SMSClientTypes.SSMValidationParameters {

    static func write(value: SMSClientTypes.SSMValidationParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["command"].write(value.command)
        try writer["executionTimeoutSeconds"].write(value.executionTimeoutSeconds)
        try writer["instanceId"].write(value.instanceId)
        try writer["outputS3BucketName"].write(value.outputS3BucketName)
        try writer["scriptType"].write(value.scriptType)
        try writer["source"].write(value.source, with: SMSClientTypes.Source.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.SSMValidationParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.SSMValidationParameters()
        value.source = try reader["source"].readIfPresent(with: SMSClientTypes.Source.read(from:))
        value.instanceId = try reader["instanceId"].readIfPresent()
        value.scriptType = try reader["scriptType"].readIfPresent()
        value.command = try reader["command"].readIfPresent()
        value.executionTimeoutSeconds = try reader["executionTimeoutSeconds"].readIfPresent() ?? 0
        value.outputS3BucketName = try reader["outputS3BucketName"].readIfPresent()
        return value
    }
}

extension SMSClientTypes.Source {

    static func write(value: SMSClientTypes.Source?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["s3Location"].write(value.s3Location, with: SMSClientTypes.S3Location.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.Source {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.Source()
        value.s3Location = try reader["s3Location"].readIfPresent(with: SMSClientTypes.S3Location.read(from:))
        return value
    }
}

extension SMSClientTypes.ServerGroupValidationConfiguration {

    static func write(value: SMSClientTypes.ServerGroupValidationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["serverGroupId"].write(value.serverGroupId)
        try writer["serverValidationConfigurations"].writeList(value.serverValidationConfigurations, memberWritingClosure: SMSClientTypes.ServerValidationConfiguration.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.ServerGroupValidationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.ServerGroupValidationConfiguration()
        value.serverGroupId = try reader["serverGroupId"].readIfPresent()
        value.serverValidationConfigurations = try reader["serverValidationConfigurations"].readListIfPresent(memberReadingClosure: SMSClientTypes.ServerValidationConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SMSClientTypes.ServerValidationConfiguration {

    static func write(value: SMSClientTypes.ServerValidationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["server"].write(value.server, with: SMSClientTypes.Server.write(value:to:))
        try writer["serverValidationStrategy"].write(value.serverValidationStrategy)
        try writer["userDataValidationParameters"].write(value.userDataValidationParameters, with: SMSClientTypes.UserDataValidationParameters.write(value:to:))
        try writer["validationId"].write(value.validationId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.ServerValidationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.ServerValidationConfiguration()
        value.server = try reader["server"].readIfPresent(with: SMSClientTypes.Server.read(from:))
        value.validationId = try reader["validationId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.serverValidationStrategy = try reader["serverValidationStrategy"].readIfPresent()
        value.userDataValidationParameters = try reader["userDataValidationParameters"].readIfPresent(with: SMSClientTypes.UserDataValidationParameters.read(from:))
        return value
    }
}

extension SMSClientTypes.UserDataValidationParameters {

    static func write(value: SMSClientTypes.UserDataValidationParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["scriptType"].write(value.scriptType)
        try writer["source"].write(value.source, with: SMSClientTypes.Source.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.UserDataValidationParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.UserDataValidationParameters()
        value.source = try reader["source"].readIfPresent(with: SMSClientTypes.Source.read(from:))
        value.scriptType = try reader["scriptType"].readIfPresent()
        return value
    }
}

extension SMSClientTypes.ValidationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.ValidationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.ValidationOutput()
        value.validationId = try reader["validationId"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.latestValidationTime = try reader["latestValidationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.appValidationOutput = try reader["appValidationOutput"].readIfPresent(with: SMSClientTypes.AppValidationOutput.read(from:))
        value.serverValidationOutput = try reader["serverValidationOutput"].readIfPresent(with: SMSClientTypes.ServerValidationOutput.read(from:))
        return value
    }
}

extension SMSClientTypes.ServerValidationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.ServerValidationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.ServerValidationOutput()
        value.server = try reader["server"].readIfPresent(with: SMSClientTypes.Server.read(from:))
        return value
    }
}

extension SMSClientTypes.AppValidationOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.AppValidationOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.AppValidationOutput()
        value.ssmOutput = try reader["ssmOutput"].readIfPresent(with: SMSClientTypes.SSMOutput.read(from:))
        return value
    }
}

extension SMSClientTypes.SSMOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.SSMOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.SSMOutput()
        value.s3Location = try reader["s3Location"].readIfPresent(with: SMSClientTypes.S3Location.read(from:))
        return value
    }
}

extension SMSClientTypes.Connector {

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.Connector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.Connector()
        value.connectorId = try reader["connectorId"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.capabilityList = try reader["capabilityList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<SMSClientTypes.ConnectorCapability>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.vmManagerName = try reader["vmManagerName"].readIfPresent()
        value.vmManagerType = try reader["vmManagerType"].readIfPresent()
        value.vmManagerId = try reader["vmManagerId"].readIfPresent()
        value.ipAddress = try reader["ipAddress"].readIfPresent()
        value.macAddress = try reader["macAddress"].readIfPresent()
        value.associatedOn = try reader["associatedOn"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension SMSClientTypes.ReplicationJob {

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.ReplicationJob {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.ReplicationJob()
        value.replicationJobId = try reader["replicationJobId"].readIfPresent()
        value.serverId = try reader["serverId"].readIfPresent()
        value.serverType = try reader["serverType"].readIfPresent()
        value.vmServer = try reader["vmServer"].readIfPresent(with: SMSClientTypes.VmServer.read(from:))
        value.seedReplicationTime = try reader["seedReplicationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.frequency = try reader["frequency"].readIfPresent()
        value.runOnce = try reader["runOnce"].readIfPresent()
        value.nextReplicationRunStartTime = try reader["nextReplicationRunStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.licenseType = try reader["licenseType"].readIfPresent()
        value.roleName = try reader["roleName"].readIfPresent()
        value.latestAmiId = try reader["latestAmiId"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.numberOfRecentAmisToKeep = try reader["numberOfRecentAmisToKeep"].readIfPresent()
        value.encrypted = try reader["encrypted"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.replicationRunList = try reader["replicationRunList"].readListIfPresent(memberReadingClosure: SMSClientTypes.ReplicationRun.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SMSClientTypes.ReplicationRun {

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.ReplicationRun {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.ReplicationRun()
        value.replicationRunId = try reader["replicationRunId"].readIfPresent()
        value.state = try reader["state"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.stageDetails = try reader["stageDetails"].readIfPresent(with: SMSClientTypes.ReplicationRunStageDetails.read(from:))
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.amiId = try reader["amiId"].readIfPresent()
        value.scheduledStartTime = try reader["scheduledStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completedTime = try reader["completedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["description"].readIfPresent()
        value.encrypted = try reader["encrypted"].readIfPresent()
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        return value
    }
}

extension SMSClientTypes.ReplicationRunStageDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SMSClientTypes.ReplicationRunStageDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SMSClientTypes.ReplicationRunStageDetails()
        value.stage = try reader["stage"].readIfPresent()
        value.stageProgress = try reader["stageProgress"].readIfPresent()
        return value
    }
}

extension SMSClientTypes.NotificationContext {

    static func write(value: SMSClientTypes.NotificationContext?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["status"].write(value.status)
        try writer["statusMessage"].write(value.statusMessage)
        try writer["validationId"].write(value.validationId)
    }
}

public enum SMSClientTypes {}
