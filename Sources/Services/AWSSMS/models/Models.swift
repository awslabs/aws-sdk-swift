// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension SMSClientTypes {
    public enum AppLaunchConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case configured
        case notconfigured
        case sdkUnknown(Swift.String)

        public static var allCases: [AppLaunchConfigurationStatus] {
            return [
                .configured,
                .notconfigured,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .configured: return "CONFIGURED"
            case .notconfigured: return "NOT_CONFIGURED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppLaunchConfigurationStatus(rawValue: rawValue) ?? AppLaunchConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension SMSClientTypes {
    public enum AppLaunchStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case configurationinprogress
        case configurationinvalid
        case deltalaunchfailed
        case deltalaunchinprogress
        case launchfailed
        case launchinprogress
        case launchpending
        case launched
        case partiallylaunched
        case readyforconfiguration
        case readyforlaunch
        case terminatefailed
        case terminateinprogress
        case terminated
        case validationinprogress
        case sdkUnknown(Swift.String)

        public static var allCases: [AppLaunchStatus] {
            return [
                .configurationinprogress,
                .configurationinvalid,
                .deltalaunchfailed,
                .deltalaunchinprogress,
                .launchfailed,
                .launchinprogress,
                .launchpending,
                .launched,
                .partiallylaunched,
                .readyforconfiguration,
                .readyforlaunch,
                .terminatefailed,
                .terminateinprogress,
                .terminated,
                .validationinprogress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .configurationinprogress: return "CONFIGURATION_IN_PROGRESS"
            case .configurationinvalid: return "CONFIGURATION_INVALID"
            case .deltalaunchfailed: return "DELTA_LAUNCH_FAILED"
            case .deltalaunchinprogress: return "DELTA_LAUNCH_IN_PROGRESS"
            case .launchfailed: return "LAUNCH_FAILED"
            case .launchinprogress: return "LAUNCH_IN_PROGRESS"
            case .launchpending: return "LAUNCH_PENDING"
            case .launched: return "LAUNCHED"
            case .partiallylaunched: return "PARTIALLY_LAUNCHED"
            case .readyforconfiguration: return "READY_FOR_CONFIGURATION"
            case .readyforlaunch: return "READY_FOR_LAUNCH"
            case .terminatefailed: return "TERMINATE_FAILED"
            case .terminateinprogress: return "TERMINATE_IN_PROGRESS"
            case .terminated: return "TERMINATED"
            case .validationinprogress: return "VALIDATION_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppLaunchStatus(rawValue: rawValue) ?? AppLaunchStatus.sdkUnknown(rawValue)
        }
    }
}

extension SMSClientTypes {
    public enum AppReplicationConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case configured
        case notconfigured
        case sdkUnknown(Swift.String)

        public static var allCases: [AppReplicationConfigurationStatus] {
            return [
                .configured,
                .notconfigured,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .configured: return "CONFIGURED"
            case .notconfigured: return "NOT_CONFIGURED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppReplicationConfigurationStatus(rawValue: rawValue) ?? AppReplicationConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension SMSClientTypes {
    public enum AppReplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case configurationinprogress
        case configurationinvalid
        case deltareplicated
        case deltareplicationfailed
        case deltareplicationinprogress
        case partiallyreplicated
        case readyforconfiguration
        case readyforreplication
        case replicated
        case replicationfailed
        case replicationinprogress
        case replicationpending
        case replicationstopfailed
        case replicationstopped
        case replicationstopping
        case validationinprogress
        case sdkUnknown(Swift.String)

        public static var allCases: [AppReplicationStatus] {
            return [
                .configurationinprogress,
                .configurationinvalid,
                .deltareplicated,
                .deltareplicationfailed,
                .deltareplicationinprogress,
                .partiallyreplicated,
                .readyforconfiguration,
                .readyforreplication,
                .replicated,
                .replicationfailed,
                .replicationinprogress,
                .replicationpending,
                .replicationstopfailed,
                .replicationstopped,
                .replicationstopping,
                .validationinprogress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .configurationinprogress: return "CONFIGURATION_IN_PROGRESS"
            case .configurationinvalid: return "CONFIGURATION_INVALID"
            case .deltareplicated: return "DELTA_REPLICATED"
            case .deltareplicationfailed: return "DELTA_REPLICATION_FAILED"
            case .deltareplicationinprogress: return "DELTA_REPLICATION_IN_PROGRESS"
            case .partiallyreplicated: return "PARTIALLY_REPLICATED"
            case .readyforconfiguration: return "READY_FOR_CONFIGURATION"
            case .readyforreplication: return "READY_FOR_REPLICATION"
            case .replicated: return "REPLICATED"
            case .replicationfailed: return "REPLICATION_FAILED"
            case .replicationinprogress: return "REPLICATION_IN_PROGRESS"
            case .replicationpending: return "REPLICATION_PENDING"
            case .replicationstopfailed: return "REPLICATION_STOP_FAILED"
            case .replicationstopped: return "REPLICATION_STOPPED"
            case .replicationstopping: return "REPLICATION_STOPPING"
            case .validationinprogress: return "VALIDATION_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppReplicationStatus(rawValue: rawValue) ?? AppReplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension SMSClientTypes {
    public enum AppStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleteFailed
        case deleted
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AppStatus] {
            return [
                .active,
                .creating,
                .deleteFailed,
                .deleted,
                .deleting,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppStatus(rawValue: rawValue) ?? AppStatus.sdkUnknown(rawValue)
        }
    }
}

extension SMSClientTypes.AppSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case creationTime
        case description
        case importedAppId
        case lastModified
        case latestReplicationTime
        case launchConfigurationStatus
        case launchDetails
        case launchStatus
        case launchStatusMessage
        case name
        case replicationConfigurationStatus
        case replicationStatus
        case replicationStatusMessage
        case roleName
        case status
        case statusMessage
        case totalServerGroups
        case totalServers
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let importedAppId = self.importedAppId {
            try encodeContainer.encode(importedAppId, forKey: .importedAppId)
        }
        if let lastModified = self.lastModified {
            try encodeContainer.encodeTimestamp(lastModified, format: .epochSeconds, forKey: .lastModified)
        }
        if let latestReplicationTime = self.latestReplicationTime {
            try encodeContainer.encodeTimestamp(latestReplicationTime, format: .epochSeconds, forKey: .latestReplicationTime)
        }
        if let launchConfigurationStatus = self.launchConfigurationStatus {
            try encodeContainer.encode(launchConfigurationStatus.rawValue, forKey: .launchConfigurationStatus)
        }
        if let launchDetails = self.launchDetails {
            try encodeContainer.encode(launchDetails, forKey: .launchDetails)
        }
        if let launchStatus = self.launchStatus {
            try encodeContainer.encode(launchStatus.rawValue, forKey: .launchStatus)
        }
        if let launchStatusMessage = self.launchStatusMessage {
            try encodeContainer.encode(launchStatusMessage, forKey: .launchStatusMessage)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let replicationConfigurationStatus = self.replicationConfigurationStatus {
            try encodeContainer.encode(replicationConfigurationStatus.rawValue, forKey: .replicationConfigurationStatus)
        }
        if let replicationStatus = self.replicationStatus {
            try encodeContainer.encode(replicationStatus.rawValue, forKey: .replicationStatus)
        }
        if let replicationStatusMessage = self.replicationStatusMessage {
            try encodeContainer.encode(replicationStatusMessage, forKey: .replicationStatusMessage)
        }
        if let roleName = self.roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let totalServerGroups = self.totalServerGroups {
            try encodeContainer.encode(totalServerGroups, forKey: .totalServerGroups)
        }
        if let totalServers = self.totalServers {
            try encodeContainer.encode(totalServers, forKey: .totalServers)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let importedAppIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importedAppId)
        importedAppId = importedAppIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SMSClientTypes.AppStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let replicationConfigurationStatusDecoded = try containerValues.decodeIfPresent(SMSClientTypes.AppReplicationConfigurationStatus.self, forKey: .replicationConfigurationStatus)
        replicationConfigurationStatus = replicationConfigurationStatusDecoded
        let replicationStatusDecoded = try containerValues.decodeIfPresent(SMSClientTypes.AppReplicationStatus.self, forKey: .replicationStatus)
        replicationStatus = replicationStatusDecoded
        let replicationStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationStatusMessage)
        replicationStatusMessage = replicationStatusMessageDecoded
        let latestReplicationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .latestReplicationTime)
        latestReplicationTime = latestReplicationTimeDecoded
        let launchConfigurationStatusDecoded = try containerValues.decodeIfPresent(SMSClientTypes.AppLaunchConfigurationStatus.self, forKey: .launchConfigurationStatus)
        launchConfigurationStatus = launchConfigurationStatusDecoded
        let launchStatusDecoded = try containerValues.decodeIfPresent(SMSClientTypes.AppLaunchStatus.self, forKey: .launchStatus)
        launchStatus = launchStatusDecoded
        let launchStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchStatusMessage)
        launchStatusMessage = launchStatusMessageDecoded
        let launchDetailsDecoded = try containerValues.decodeIfPresent(SMSClientTypes.LaunchDetails.self, forKey: .launchDetails)
        launchDetails = launchDetailsDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastModifiedDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModified)
        lastModified = lastModifiedDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let totalServerGroupsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalServerGroups)
        totalServerGroups = totalServerGroupsDecoded
        let totalServersDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalServers)
        totalServers = totalServersDecoded
    }
}

extension SMSClientTypes {
    /// Information about the application.
    public struct AppSummary: Swift.Equatable {
        /// The unique ID of the application.
        public var appId: Swift.String?
        /// The creation time of the application.
        public var creationTime: ClientRuntime.Date?
        /// The description of the application.
        public var description: Swift.String?
        /// The ID of the application.
        public var importedAppId: Swift.String?
        /// The last modified time of the application.
        public var lastModified: ClientRuntime.Date?
        /// The timestamp of the application's most recent successful replication.
        public var latestReplicationTime: ClientRuntime.Date?
        /// Status of the launch configuration.
        public var launchConfigurationStatus: SMSClientTypes.AppLaunchConfigurationStatus?
        /// Details about the latest launch of the application.
        public var launchDetails: SMSClientTypes.LaunchDetails?
        /// The launch status of the application.
        public var launchStatus: SMSClientTypes.AppLaunchStatus?
        /// A message related to the launch status of the application.
        public var launchStatusMessage: Swift.String?
        /// The name of the application.
        public var name: Swift.String?
        /// Status of the replication configuration.
        public var replicationConfigurationStatus: SMSClientTypes.AppReplicationConfigurationStatus?
        /// The replication status of the application.
        public var replicationStatus: SMSClientTypes.AppReplicationStatus?
        /// A message related to the replication status of the application.
        public var replicationStatusMessage: Swift.String?
        /// The name of the service role in the customer's account used by Server Migration Service.
        public var roleName: Swift.String?
        /// Status of the application.
        public var status: SMSClientTypes.AppStatus?
        /// A message related to the status of the application
        public var statusMessage: Swift.String?
        /// The number of server groups present in the application.
        public var totalServerGroups: Swift.Int?
        /// The number of servers present in the application.
        public var totalServers: Swift.Int?

        public init(
            appId: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            importedAppId: Swift.String? = nil,
            lastModified: ClientRuntime.Date? = nil,
            latestReplicationTime: ClientRuntime.Date? = nil,
            launchConfigurationStatus: SMSClientTypes.AppLaunchConfigurationStatus? = nil,
            launchDetails: SMSClientTypes.LaunchDetails? = nil,
            launchStatus: SMSClientTypes.AppLaunchStatus? = nil,
            launchStatusMessage: Swift.String? = nil,
            name: Swift.String? = nil,
            replicationConfigurationStatus: SMSClientTypes.AppReplicationConfigurationStatus? = nil,
            replicationStatus: SMSClientTypes.AppReplicationStatus? = nil,
            replicationStatusMessage: Swift.String? = nil,
            roleName: Swift.String? = nil,
            status: SMSClientTypes.AppStatus? = nil,
            statusMessage: Swift.String? = nil,
            totalServerGroups: Swift.Int? = nil,
            totalServers: Swift.Int? = nil
        )
        {
            self.appId = appId
            self.creationTime = creationTime
            self.description = description
            self.importedAppId = importedAppId
            self.lastModified = lastModified
            self.latestReplicationTime = latestReplicationTime
            self.launchConfigurationStatus = launchConfigurationStatus
            self.launchDetails = launchDetails
            self.launchStatus = launchStatus
            self.launchStatusMessage = launchStatusMessage
            self.name = name
            self.replicationConfigurationStatus = replicationConfigurationStatus
            self.replicationStatus = replicationStatus
            self.replicationStatusMessage = replicationStatusMessage
            self.roleName = roleName
            self.status = status
            self.statusMessage = statusMessage
            self.totalServerGroups = totalServerGroups
            self.totalServers = totalServers
        }
    }

}

extension SMSClientTypes.AppValidationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appValidationStrategy
        case name
        case ssmValidationParameters
        case validationId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appValidationStrategy = self.appValidationStrategy {
            try encodeContainer.encode(appValidationStrategy.rawValue, forKey: .appValidationStrategy)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ssmValidationParameters = self.ssmValidationParameters {
            try encodeContainer.encode(ssmValidationParameters, forKey: .ssmValidationParameters)
        }
        if let validationId = self.validationId {
            try encodeContainer.encode(validationId, forKey: .validationId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validationId)
        validationId = validationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let appValidationStrategyDecoded = try containerValues.decodeIfPresent(SMSClientTypes.AppValidationStrategy.self, forKey: .appValidationStrategy)
        appValidationStrategy = appValidationStrategyDecoded
        let ssmValidationParametersDecoded = try containerValues.decodeIfPresent(SMSClientTypes.SSMValidationParameters.self, forKey: .ssmValidationParameters)
        ssmValidationParameters = ssmValidationParametersDecoded
    }
}

extension SMSClientTypes {
    /// Configuration for validating an application.
    public struct AppValidationConfiguration: Swift.Equatable {
        /// The validation strategy.
        public var appValidationStrategy: SMSClientTypes.AppValidationStrategy?
        /// The name of the configuration.
        public var name: Swift.String?
        /// The validation parameters.
        public var ssmValidationParameters: SMSClientTypes.SSMValidationParameters?
        /// The ID of the validation.
        public var validationId: Swift.String?

        public init(
            appValidationStrategy: SMSClientTypes.AppValidationStrategy? = nil,
            name: Swift.String? = nil,
            ssmValidationParameters: SMSClientTypes.SSMValidationParameters? = nil,
            validationId: Swift.String? = nil
        )
        {
            self.appValidationStrategy = appValidationStrategy
            self.name = name
            self.ssmValidationParameters = ssmValidationParameters
            self.validationId = validationId
        }
    }

}

extension SMSClientTypes.AppValidationOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ssmOutput
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ssmOutput = self.ssmOutput {
            try encodeContainer.encode(ssmOutput, forKey: .ssmOutput)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ssmOutputDecoded = try containerValues.decodeIfPresent(SMSClientTypes.SSMOutput.self, forKey: .ssmOutput)
        ssmOutput = ssmOutputDecoded
    }
}

extension SMSClientTypes {
    /// Output from validating an application.
    public struct AppValidationOutput: Swift.Equatable {
        /// Output from using SSM to validate the application.
        public var ssmOutput: SMSClientTypes.SSMOutput?

        public init(
            ssmOutput: SMSClientTypes.SSMOutput? = nil
        )
        {
            self.ssmOutput = ssmOutput
        }
    }

}

extension SMSClientTypes {
    public enum AppValidationStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ssm
        case sdkUnknown(Swift.String)

        public static var allCases: [AppValidationStrategy] {
            return [
                .ssm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ssm: return "SSM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppValidationStrategy(rawValue: rawValue) ?? AppValidationStrategy.sdkUnknown(rawValue)
        }
    }
}

extension SMSClientTypes.Connector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedOn
        case capabilityList
        case connectorId
        case ipAddress
        case macAddress
        case status
        case version
        case vmManagerId
        case vmManagerName
        case vmManagerType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatedOn = self.associatedOn {
            try encodeContainer.encodeTimestamp(associatedOn, format: .epochSeconds, forKey: .associatedOn)
        }
        if let capabilityList = capabilityList {
            var capabilityListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .capabilityList)
            for connectorcapability0 in capabilityList {
                try capabilityListContainer.encode(connectorcapability0.rawValue)
            }
        }
        if let connectorId = self.connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let macAddress = self.macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let vmManagerId = self.vmManagerId {
            try encodeContainer.encode(vmManagerId, forKey: .vmManagerId)
        }
        if let vmManagerName = self.vmManagerName {
            try encodeContainer.encode(vmManagerName, forKey: .vmManagerName)
        }
        if let vmManagerType = self.vmManagerType {
            try encodeContainer.encode(vmManagerType.rawValue, forKey: .vmManagerType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SMSClientTypes.ConnectorStatus.self, forKey: .status)
        status = statusDecoded
        let capabilityListContainer = try containerValues.decodeIfPresent([SMSClientTypes.ConnectorCapability?].self, forKey: .capabilityList)
        var capabilityListDecoded0:[SMSClientTypes.ConnectorCapability]? = nil
        if let capabilityListContainer = capabilityListContainer {
            capabilityListDecoded0 = [SMSClientTypes.ConnectorCapability]()
            for enum0 in capabilityListContainer {
                if let enum0 = enum0 {
                    capabilityListDecoded0?.append(enum0)
                }
            }
        }
        capabilityList = capabilityListDecoded0
        let vmManagerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmManagerName)
        vmManagerName = vmManagerNameDecoded
        let vmManagerTypeDecoded = try containerValues.decodeIfPresent(SMSClientTypes.VmManagerType.self, forKey: .vmManagerType)
        vmManagerType = vmManagerTypeDecoded
        let vmManagerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmManagerId)
        vmManagerId = vmManagerIdDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let macAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let associatedOnDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .associatedOn)
        associatedOn = associatedOnDecoded
    }
}

extension SMSClientTypes {
    /// Represents a connector.
    public struct Connector: Swift.Equatable {
        /// The time the connector was associated.
        public var associatedOn: ClientRuntime.Date?
        /// The capabilities of the connector.
        public var capabilityList: [SMSClientTypes.ConnectorCapability]?
        /// The ID of the connector.
        public var connectorId: Swift.String?
        /// The IP address of the connector.
        public var ipAddress: Swift.String?
        /// The MAC address of the connector.
        public var macAddress: Swift.String?
        /// The status of the connector.
        public var status: SMSClientTypes.ConnectorStatus?
        /// The connector version.
        public var version: Swift.String?
        /// The ID of the VM manager.
        public var vmManagerId: Swift.String?
        /// The name of the VM manager.
        public var vmManagerName: Swift.String?
        /// The VM management product.
        public var vmManagerType: SMSClientTypes.VmManagerType?

        public init(
            associatedOn: ClientRuntime.Date? = nil,
            capabilityList: [SMSClientTypes.ConnectorCapability]? = nil,
            connectorId: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            macAddress: Swift.String? = nil,
            status: SMSClientTypes.ConnectorStatus? = nil,
            version: Swift.String? = nil,
            vmManagerId: Swift.String? = nil,
            vmManagerName: Swift.String? = nil,
            vmManagerType: SMSClientTypes.VmManagerType? = nil
        )
        {
            self.associatedOn = associatedOn
            self.capabilityList = capabilityList
            self.connectorId = connectorId
            self.ipAddress = ipAddress
            self.macAddress = macAddress
            self.status = status
            self.version = version
            self.vmManagerId = vmManagerId
            self.vmManagerName = vmManagerName
            self.vmManagerType = vmManagerType
        }
    }

}

extension SMSClientTypes {
    public enum ConnectorCapability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hypervmanager
        case scvmm
        case smsoptimized
        case snapshotbatching
        case vsphere
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectorCapability] {
            return [
                .hypervmanager,
                .scvmm,
                .smsoptimized,
                .snapshotbatching,
                .vsphere,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hypervmanager: return "HYPERV-MANAGER"
            case .scvmm: return "SCVMM"
            case .smsoptimized: return "SMS_OPTIMIZED"
            case .snapshotbatching: return "SNAPSHOT_BATCHING"
            case .vsphere: return "VSPHERE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectorCapability(rawValue: rawValue) ?? ConnectorCapability.sdkUnknown(rawValue)
        }
    }
}

extension SMSClientTypes {
    public enum ConnectorStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectorStatus] {
            return [
                .healthy,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectorStatus(rawValue: rawValue) ?? ConnectorStatus.sdkUnknown(rawValue)
        }
    }
}

extension CreateAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case roleName
        case serverGroups
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleName = self.roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let serverGroups = serverGroups {
            var serverGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serverGroups)
            for servergroup0 in serverGroups {
                try serverGroupsContainer.encode(servergroup0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAppInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of application creation.
    public var clientToken: Swift.String?
    /// The description of the new application
    public var description: Swift.String?
    /// The name of the new application.
    public var name: Swift.String?
    /// The name of the service role in the customer's account to be used by Server Migration Service.
    public var roleName: Swift.String?
    /// The server groups to include in the application.
    public var serverGroups: [SMSClientTypes.ServerGroup]?
    /// The tags to be associated with the application.
    public var tags: [SMSClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        roleName: Swift.String? = nil,
        serverGroups: [SMSClientTypes.ServerGroup]? = nil,
        tags: [SMSClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.roleName = roleName
        self.serverGroups = serverGroups
        self.tags = tags
    }
}

struct CreateAppInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let roleName: Swift.String?
    let clientToken: Swift.String?
    let serverGroups: [SMSClientTypes.ServerGroup]?
    let tags: [SMSClientTypes.Tag]?
}

extension CreateAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case description
        case name
        case roleName
        case serverGroups
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let serverGroupsContainer = try containerValues.decodeIfPresent([SMSClientTypes.ServerGroup?].self, forKey: .serverGroups)
        var serverGroupsDecoded0:[SMSClientTypes.ServerGroup]? = nil
        if let serverGroupsContainer = serverGroupsContainer {
            serverGroupsDecoded0 = [SMSClientTypes.ServerGroup]()
            for structure0 in serverGroupsContainer {
                if let structure0 = structure0 {
                    serverGroupsDecoded0?.append(structure0)
                }
            }
        }
        serverGroups = serverGroupsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([SMSClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SMSClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SMSClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAppOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAppOutputBody = try responseDecoder.decode(responseBody: data)
            self.appSummary = output.appSummary
            self.serverGroups = output.serverGroups
            self.tags = output.tags
        } else {
            self.appSummary = nil
            self.serverGroups = nil
            self.tags = nil
        }
    }
}

public struct CreateAppOutput: Swift.Equatable {
    /// A summary description of the application.
    public var appSummary: SMSClientTypes.AppSummary?
    /// The server groups included in the application.
    public var serverGroups: [SMSClientTypes.ServerGroup]?
    /// The tags associated with the application.
    public var tags: [SMSClientTypes.Tag]?

    public init(
        appSummary: SMSClientTypes.AppSummary? = nil,
        serverGroups: [SMSClientTypes.ServerGroup]? = nil,
        tags: [SMSClientTypes.Tag]? = nil
    )
    {
        self.appSummary = appSummary
        self.serverGroups = serverGroups
        self.tags = tags
    }
}

struct CreateAppOutputBody: Swift.Equatable {
    let appSummary: SMSClientTypes.AppSummary?
    let serverGroups: [SMSClientTypes.ServerGroup]?
    let tags: [SMSClientTypes.Tag]?
}

extension CreateAppOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appSummary
        case serverGroups
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appSummaryDecoded = try containerValues.decodeIfPresent(SMSClientTypes.AppSummary.self, forKey: .appSummary)
        appSummary = appSummaryDecoded
        let serverGroupsContainer = try containerValues.decodeIfPresent([SMSClientTypes.ServerGroup?].self, forKey: .serverGroups)
        var serverGroupsDecoded0:[SMSClientTypes.ServerGroup]? = nil
        if let serverGroupsContainer = serverGroupsContainer {
            serverGroupsDecoded0 = [SMSClientTypes.ServerGroup]()
            for structure0 in serverGroupsContainer {
                if let structure0 = structure0 {
                    serverGroupsDecoded0?.append(structure0)
                }
            }
        }
        serverGroups = serverGroupsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([SMSClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SMSClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SMSClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum CreateAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateReplicationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case encrypted
        case frequency
        case kmsKeyId
        case licenseType
        case numberOfRecentAmisToKeep
        case roleName
        case runOnce
        case seedReplicationTime
        case serverId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encrypted = self.encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let frequency = self.frequency {
            try encodeContainer.encode(frequency, forKey: .frequency)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let licenseType = self.licenseType {
            try encodeContainer.encode(licenseType.rawValue, forKey: .licenseType)
        }
        if let numberOfRecentAmisToKeep = self.numberOfRecentAmisToKeep {
            try encodeContainer.encode(numberOfRecentAmisToKeep, forKey: .numberOfRecentAmisToKeep)
        }
        if let roleName = self.roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let runOnce = self.runOnce {
            try encodeContainer.encode(runOnce, forKey: .runOnce)
        }
        if let seedReplicationTime = self.seedReplicationTime {
            try encodeContainer.encodeTimestamp(seedReplicationTime, format: .epochSeconds, forKey: .seedReplicationTime)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
    }
}

extension CreateReplicationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateReplicationJobInput: Swift.Equatable {
    /// The description of the replication job.
    public var description: Swift.String?
    /// Indicates whether the replication job produces encrypted AMIs.
    public var encrypted: Swift.Bool?
    /// The time between consecutive replication runs, in hours.
    public var frequency: Swift.Int?
    /// The ID of the KMS key for replication jobs that produce encrypted AMIs. This value can be any of the following:
    ///
    /// * KMS key ID
    ///
    /// * KMS key alias
    ///
    /// * ARN referring to the KMS key ID
    ///
    /// * ARN referring to the KMS key alias
    ///
    ///
    /// If encrypted is true but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
    public var kmsKeyId: Swift.String?
    /// The license type to be used for the AMI created by a successful replication run.
    public var licenseType: SMSClientTypes.LicenseType?
    /// The maximum number of SMS-created AMIs to retain. The oldest is deleted after the maximum number is reached and a new AMI is created.
    public var numberOfRecentAmisToKeep: Swift.Int?
    /// The name of the IAM role to be used by the Server Migration Service.
    public var roleName: Swift.String?
    /// Indicates whether to run the replication job one time.
    public var runOnce: Swift.Bool?
    /// The seed replication time.
    /// This member is required.
    public var seedReplicationTime: ClientRuntime.Date?
    /// The ID of the server.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        description: Swift.String? = nil,
        encrypted: Swift.Bool? = nil,
        frequency: Swift.Int? = nil,
        kmsKeyId: Swift.String? = nil,
        licenseType: SMSClientTypes.LicenseType? = nil,
        numberOfRecentAmisToKeep: Swift.Int? = nil,
        roleName: Swift.String? = nil,
        runOnce: Swift.Bool? = nil,
        seedReplicationTime: ClientRuntime.Date? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.description = description
        self.encrypted = encrypted
        self.frequency = frequency
        self.kmsKeyId = kmsKeyId
        self.licenseType = licenseType
        self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
        self.roleName = roleName
        self.runOnce = runOnce
        self.seedReplicationTime = seedReplicationTime
        self.serverId = serverId
    }
}

struct CreateReplicationJobInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let seedReplicationTime: ClientRuntime.Date?
    let frequency: Swift.Int?
    let runOnce: Swift.Bool?
    let licenseType: SMSClientTypes.LicenseType?
    let roleName: Swift.String?
    let description: Swift.String?
    let numberOfRecentAmisToKeep: Swift.Int?
    let encrypted: Swift.Bool?
    let kmsKeyId: Swift.String?
}

extension CreateReplicationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case encrypted
        case frequency
        case kmsKeyId
        case licenseType
        case numberOfRecentAmisToKeep
        case roleName
        case runOnce
        case seedReplicationTime
        case serverId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let seedReplicationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .seedReplicationTime)
        seedReplicationTime = seedReplicationTimeDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .frequency)
        frequency = frequencyDecoded
        let runOnceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .runOnce)
        runOnce = runOnceDecoded
        let licenseTypeDecoded = try containerValues.decodeIfPresent(SMSClientTypes.LicenseType.self, forKey: .licenseType)
        licenseType = licenseTypeDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let numberOfRecentAmisToKeepDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRecentAmisToKeep)
        numberOfRecentAmisToKeep = numberOfRecentAmisToKeepDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension CreateReplicationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateReplicationJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationJobId = output.replicationJobId
        } else {
            self.replicationJobId = nil
        }
    }
}

public struct CreateReplicationJobOutput: Swift.Equatable {
    /// The unique identifier of the replication job.
    public var replicationJobId: Swift.String?

    public init(
        replicationJobId: Swift.String? = nil
    )
    {
        self.replicationJobId = replicationJobId
    }
}

struct CreateReplicationJobOutputBody: Swift.Equatable {
    let replicationJobId: Swift.String?
}

extension CreateReplicationJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationJobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationJobId)
        replicationJobId = replicationJobIdDecoded
    }
}

enum CreateReplicationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoConnectorsAvailable": return try await NoConnectorsAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplicationJobAlreadyExists": return try await ReplicationJobAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerCannotBeReplicated": return try await ServerCannotBeReplicatedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TemporarilyUnavailable": return try await TemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case forceStopAppReplication
        case forceTerminateApp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let forceStopAppReplication = self.forceStopAppReplication {
            try encodeContainer.encode(forceStopAppReplication, forKey: .forceStopAppReplication)
        }
        if let forceTerminateApp = self.forceTerminateApp {
            try encodeContainer.encode(forceTerminateApp, forKey: .forceTerminateApp)
        }
    }
}

extension DeleteAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAppInput: Swift.Equatable {
    /// The ID of the application.
    public var appId: Swift.String?
    /// Indicates whether to stop all replication jobs corresponding to the servers in the application while deleting the application.
    public var forceStopAppReplication: Swift.Bool?
    /// Indicates whether to terminate the stack corresponding to the application while deleting the application.
    public var forceTerminateApp: Swift.Bool?

    public init(
        appId: Swift.String? = nil,
        forceStopAppReplication: Swift.Bool? = nil,
        forceTerminateApp: Swift.Bool? = nil
    )
    {
        self.appId = appId
        self.forceStopAppReplication = forceStopAppReplication
        self.forceTerminateApp = forceTerminateApp
    }
}

struct DeleteAppInputBody: Swift.Equatable {
    let appId: Swift.String?
    let forceStopAppReplication: Swift.Bool?
    let forceTerminateApp: Swift.Bool?
}

extension DeleteAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case forceStopAppReplication
        case forceTerminateApp
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let forceStopAppReplicationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceStopAppReplication)
        forceStopAppReplication = forceStopAppReplicationDecoded
        let forceTerminateAppDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceTerminateApp)
        forceTerminateApp = forceTerminateAppDecoded
    }
}

extension DeleteAppLaunchConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

extension DeleteAppLaunchConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAppLaunchConfigurationInput: Swift.Equatable {
    /// The ID of the application.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct DeleteAppLaunchConfigurationInputBody: Swift.Equatable {
    let appId: Swift.String?
}

extension DeleteAppLaunchConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension DeleteAppLaunchConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAppLaunchConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAppLaunchConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAppOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAppOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAppReplicationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

extension DeleteAppReplicationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAppReplicationConfigurationInput: Swift.Equatable {
    /// The ID of the application.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct DeleteAppReplicationConfigurationInputBody: Swift.Equatable {
    let appId: Swift.String?
}

extension DeleteAppReplicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension DeleteAppReplicationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAppReplicationConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAppReplicationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAppValidationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

extension DeleteAppValidationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAppValidationConfigurationInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct DeleteAppValidationConfigurationInputBody: Swift.Equatable {
    let appId: Swift.String?
}

extension DeleteAppValidationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension DeleteAppValidationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAppValidationConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAppValidationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteReplicationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationJobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationJobId = self.replicationJobId {
            try encodeContainer.encode(replicationJobId, forKey: .replicationJobId)
        }
    }
}

extension DeleteReplicationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteReplicationJobInput: Swift.Equatable {
    /// The ID of the replication job.
    /// This member is required.
    public var replicationJobId: Swift.String?

    public init(
        replicationJobId: Swift.String? = nil
    )
    {
        self.replicationJobId = replicationJobId
    }
}

struct DeleteReplicationJobInputBody: Swift.Equatable {
    let replicationJobId: Swift.String?
}

extension DeleteReplicationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationJobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationJobId)
        replicationJobId = replicationJobIdDecoded
    }
}

extension DeleteReplicationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteReplicationJobOutput: Swift.Equatable {

    public init() { }
}

enum DeleteReplicationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplicationJobNotFound": return try await ReplicationJobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteServerCatalogInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteServerCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteServerCatalogInput: Swift.Equatable {

    public init() { }
}

struct DeleteServerCatalogInputBody: Swift.Equatable {
}

extension DeleteServerCatalogInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteServerCatalogOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteServerCatalogOutput: Swift.Equatable {

    public init() { }
}

enum DeleteServerCatalogOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateConnectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectorId = self.connectorId {
            try encodeContainer.encode(connectorId, forKey: .connectorId)
        }
    }
}

extension DisassociateConnectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisassociateConnectorInput: Swift.Equatable {
    /// The ID of the connector.
    /// This member is required.
    public var connectorId: Swift.String?

    public init(
        connectorId: Swift.String? = nil
    )
    {
        self.connectorId = connectorId
    }
}

struct DisassociateConnectorInputBody: Swift.Equatable {
    let connectorId: Swift.String?
}

extension DisassociateConnectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectorId)
        connectorId = connectorIdDecoded
    }
}

extension DisassociateConnectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateConnectorOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateConnectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DryRunOperationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DryRunOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The user has the required permissions, so the request would have succeeded, but a dry run was performed.
public struct DryRunOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DryRunOperationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DryRunOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DryRunOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GenerateChangeSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case changesetFormat
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let changesetFormat = self.changesetFormat {
            try encodeContainer.encode(changesetFormat.rawValue, forKey: .changesetFormat)
        }
    }
}

extension GenerateChangeSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GenerateChangeSetInput: Swift.Equatable {
    /// The ID of the application associated with the change set.
    public var appId: Swift.String?
    /// The format for the change set.
    public var changesetFormat: SMSClientTypes.OutputFormat?

    public init(
        appId: Swift.String? = nil,
        changesetFormat: SMSClientTypes.OutputFormat? = nil
    )
    {
        self.appId = appId
        self.changesetFormat = changesetFormat
    }
}

struct GenerateChangeSetInputBody: Swift.Equatable {
    let appId: Swift.String?
    let changesetFormat: SMSClientTypes.OutputFormat?
}

extension GenerateChangeSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case changesetFormat
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let changesetFormatDecoded = try containerValues.decodeIfPresent(SMSClientTypes.OutputFormat.self, forKey: .changesetFormat)
        changesetFormat = changesetFormatDecoded
    }
}

extension GenerateChangeSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GenerateChangeSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.s3Location = output.s3Location
        } else {
            self.s3Location = nil
        }
    }
}

public struct GenerateChangeSetOutput: Swift.Equatable {
    /// The location of the Amazon S3 object.
    public var s3Location: SMSClientTypes.S3Location?

    public init(
        s3Location: SMSClientTypes.S3Location? = nil
    )
    {
        self.s3Location = s3Location
    }
}

struct GenerateChangeSetOutputBody: Swift.Equatable {
    let s3Location: SMSClientTypes.S3Location?
}

extension GenerateChangeSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Location
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationDecoded = try containerValues.decodeIfPresent(SMSClientTypes.S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

enum GenerateChangeSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GenerateTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case templateFormat
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let templateFormat = self.templateFormat {
            try encodeContainer.encode(templateFormat.rawValue, forKey: .templateFormat)
        }
    }
}

extension GenerateTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GenerateTemplateInput: Swift.Equatable {
    /// The ID of the application associated with the CloudFormation template.
    public var appId: Swift.String?
    /// The format for generating the CloudFormation template.
    public var templateFormat: SMSClientTypes.OutputFormat?

    public init(
        appId: Swift.String? = nil,
        templateFormat: SMSClientTypes.OutputFormat? = nil
    )
    {
        self.appId = appId
        self.templateFormat = templateFormat
    }
}

struct GenerateTemplateInputBody: Swift.Equatable {
    let appId: Swift.String?
    let templateFormat: SMSClientTypes.OutputFormat?
}

extension GenerateTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case templateFormat
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let templateFormatDecoded = try containerValues.decodeIfPresent(SMSClientTypes.OutputFormat.self, forKey: .templateFormat)
        templateFormat = templateFormatDecoded
    }
}

extension GenerateTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GenerateTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.s3Location = output.s3Location
        } else {
            self.s3Location = nil
        }
    }
}

public struct GenerateTemplateOutput: Swift.Equatable {
    /// The location of the Amazon S3 object.
    public var s3Location: SMSClientTypes.S3Location?

    public init(
        s3Location: SMSClientTypes.S3Location? = nil
    )
    {
        self.s3Location = s3Location
    }
}

struct GenerateTemplateOutputBody: Swift.Equatable {
    let s3Location: SMSClientTypes.S3Location?
}

extension GenerateTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Location
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationDecoded = try containerValues.decodeIfPresent(SMSClientTypes.S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

enum GenerateTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

extension GetAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAppInput: Swift.Equatable {
    /// The ID of the application.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct GetAppInputBody: Swift.Equatable {
    let appId: Swift.String?
}

extension GetAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension GetAppLaunchConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

extension GetAppLaunchConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAppLaunchConfigurationInput: Swift.Equatable {
    /// The ID of the application.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct GetAppLaunchConfigurationInputBody: Swift.Equatable {
    let appId: Swift.String?
}

extension GetAppLaunchConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension GetAppLaunchConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAppLaunchConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.appId = output.appId
            self.autoLaunch = output.autoLaunch
            self.roleName = output.roleName
            self.serverGroupLaunchConfigurations = output.serverGroupLaunchConfigurations
        } else {
            self.appId = nil
            self.autoLaunch = nil
            self.roleName = nil
            self.serverGroupLaunchConfigurations = nil
        }
    }
}

public struct GetAppLaunchConfigurationOutput: Swift.Equatable {
    /// The ID of the application.
    public var appId: Swift.String?
    /// Indicates whether the application is configured to launch automatically after replication is complete.
    public var autoLaunch: Swift.Bool?
    /// The name of the service role in the customer's account that CloudFormation uses to launch the application.
    public var roleName: Swift.String?
    /// The launch configurations for server groups in this application.
    public var serverGroupLaunchConfigurations: [SMSClientTypes.ServerGroupLaunchConfiguration]?

    public init(
        appId: Swift.String? = nil,
        autoLaunch: Swift.Bool? = nil,
        roleName: Swift.String? = nil,
        serverGroupLaunchConfigurations: [SMSClientTypes.ServerGroupLaunchConfiguration]? = nil
    )
    {
        self.appId = appId
        self.autoLaunch = autoLaunch
        self.roleName = roleName
        self.serverGroupLaunchConfigurations = serverGroupLaunchConfigurations
    }
}

struct GetAppLaunchConfigurationOutputBody: Swift.Equatable {
    let appId: Swift.String?
    let roleName: Swift.String?
    let autoLaunch: Swift.Bool?
    let serverGroupLaunchConfigurations: [SMSClientTypes.ServerGroupLaunchConfiguration]?
}

extension GetAppLaunchConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case autoLaunch
        case roleName
        case serverGroupLaunchConfigurations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let autoLaunchDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoLaunch)
        autoLaunch = autoLaunchDecoded
        let serverGroupLaunchConfigurationsContainer = try containerValues.decodeIfPresent([SMSClientTypes.ServerGroupLaunchConfiguration?].self, forKey: .serverGroupLaunchConfigurations)
        var serverGroupLaunchConfigurationsDecoded0:[SMSClientTypes.ServerGroupLaunchConfiguration]? = nil
        if let serverGroupLaunchConfigurationsContainer = serverGroupLaunchConfigurationsContainer {
            serverGroupLaunchConfigurationsDecoded0 = [SMSClientTypes.ServerGroupLaunchConfiguration]()
            for structure0 in serverGroupLaunchConfigurationsContainer {
                if let structure0 = structure0 {
                    serverGroupLaunchConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        serverGroupLaunchConfigurations = serverGroupLaunchConfigurationsDecoded0
    }
}

enum GetAppLaunchConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAppOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAppOutputBody = try responseDecoder.decode(responseBody: data)
            self.appSummary = output.appSummary
            self.serverGroups = output.serverGroups
            self.tags = output.tags
        } else {
            self.appSummary = nil
            self.serverGroups = nil
            self.tags = nil
        }
    }
}

public struct GetAppOutput: Swift.Equatable {
    /// Information about the application.
    public var appSummary: SMSClientTypes.AppSummary?
    /// The server groups that belong to the application.
    public var serverGroups: [SMSClientTypes.ServerGroup]?
    /// The tags associated with the application.
    public var tags: [SMSClientTypes.Tag]?

    public init(
        appSummary: SMSClientTypes.AppSummary? = nil,
        serverGroups: [SMSClientTypes.ServerGroup]? = nil,
        tags: [SMSClientTypes.Tag]? = nil
    )
    {
        self.appSummary = appSummary
        self.serverGroups = serverGroups
        self.tags = tags
    }
}

struct GetAppOutputBody: Swift.Equatable {
    let appSummary: SMSClientTypes.AppSummary?
    let serverGroups: [SMSClientTypes.ServerGroup]?
    let tags: [SMSClientTypes.Tag]?
}

extension GetAppOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appSummary
        case serverGroups
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appSummaryDecoded = try containerValues.decodeIfPresent(SMSClientTypes.AppSummary.self, forKey: .appSummary)
        appSummary = appSummaryDecoded
        let serverGroupsContainer = try containerValues.decodeIfPresent([SMSClientTypes.ServerGroup?].self, forKey: .serverGroups)
        var serverGroupsDecoded0:[SMSClientTypes.ServerGroup]? = nil
        if let serverGroupsContainer = serverGroupsContainer {
            serverGroupsDecoded0 = [SMSClientTypes.ServerGroup]()
            for structure0 in serverGroupsContainer {
                if let structure0 = structure0 {
                    serverGroupsDecoded0?.append(structure0)
                }
            }
        }
        serverGroups = serverGroupsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([SMSClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SMSClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SMSClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAppReplicationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

extension GetAppReplicationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAppReplicationConfigurationInput: Swift.Equatable {
    /// The ID of the application.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct GetAppReplicationConfigurationInputBody: Swift.Equatable {
    let appId: Swift.String?
}

extension GetAppReplicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension GetAppReplicationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAppReplicationConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.serverGroupReplicationConfigurations = output.serverGroupReplicationConfigurations
        } else {
            self.serverGroupReplicationConfigurations = nil
        }
    }
}

public struct GetAppReplicationConfigurationOutput: Swift.Equatable {
    /// The replication configurations associated with server groups in this application.
    public var serverGroupReplicationConfigurations: [SMSClientTypes.ServerGroupReplicationConfiguration]?

    public init(
        serverGroupReplicationConfigurations: [SMSClientTypes.ServerGroupReplicationConfiguration]? = nil
    )
    {
        self.serverGroupReplicationConfigurations = serverGroupReplicationConfigurations
    }
}

struct GetAppReplicationConfigurationOutputBody: Swift.Equatable {
    let serverGroupReplicationConfigurations: [SMSClientTypes.ServerGroupReplicationConfiguration]?
}

extension GetAppReplicationConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverGroupReplicationConfigurations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverGroupReplicationConfigurationsContainer = try containerValues.decodeIfPresent([SMSClientTypes.ServerGroupReplicationConfiguration?].self, forKey: .serverGroupReplicationConfigurations)
        var serverGroupReplicationConfigurationsDecoded0:[SMSClientTypes.ServerGroupReplicationConfiguration]? = nil
        if let serverGroupReplicationConfigurationsContainer = serverGroupReplicationConfigurationsContainer {
            serverGroupReplicationConfigurationsDecoded0 = [SMSClientTypes.ServerGroupReplicationConfiguration]()
            for structure0 in serverGroupReplicationConfigurationsContainer {
                if let structure0 = structure0 {
                    serverGroupReplicationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        serverGroupReplicationConfigurations = serverGroupReplicationConfigurationsDecoded0
    }
}

enum GetAppReplicationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAppValidationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

extension GetAppValidationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAppValidationConfigurationInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct GetAppValidationConfigurationInputBody: Swift.Equatable {
    let appId: Swift.String?
}

extension GetAppValidationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension GetAppValidationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAppValidationConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.appValidationConfigurations = output.appValidationConfigurations
            self.serverGroupValidationConfigurations = output.serverGroupValidationConfigurations
        } else {
            self.appValidationConfigurations = nil
            self.serverGroupValidationConfigurations = nil
        }
    }
}

public struct GetAppValidationConfigurationOutput: Swift.Equatable {
    /// The configuration for application validation.
    public var appValidationConfigurations: [SMSClientTypes.AppValidationConfiguration]?
    /// The configuration for instance validation.
    public var serverGroupValidationConfigurations: [SMSClientTypes.ServerGroupValidationConfiguration]?

    public init(
        appValidationConfigurations: [SMSClientTypes.AppValidationConfiguration]? = nil,
        serverGroupValidationConfigurations: [SMSClientTypes.ServerGroupValidationConfiguration]? = nil
    )
    {
        self.appValidationConfigurations = appValidationConfigurations
        self.serverGroupValidationConfigurations = serverGroupValidationConfigurations
    }
}

struct GetAppValidationConfigurationOutputBody: Swift.Equatable {
    let appValidationConfigurations: [SMSClientTypes.AppValidationConfiguration]?
    let serverGroupValidationConfigurations: [SMSClientTypes.ServerGroupValidationConfiguration]?
}

extension GetAppValidationConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appValidationConfigurations
        case serverGroupValidationConfigurations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appValidationConfigurationsContainer = try containerValues.decodeIfPresent([SMSClientTypes.AppValidationConfiguration?].self, forKey: .appValidationConfigurations)
        var appValidationConfigurationsDecoded0:[SMSClientTypes.AppValidationConfiguration]? = nil
        if let appValidationConfigurationsContainer = appValidationConfigurationsContainer {
            appValidationConfigurationsDecoded0 = [SMSClientTypes.AppValidationConfiguration]()
            for structure0 in appValidationConfigurationsContainer {
                if let structure0 = structure0 {
                    appValidationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        appValidationConfigurations = appValidationConfigurationsDecoded0
        let serverGroupValidationConfigurationsContainer = try containerValues.decodeIfPresent([SMSClientTypes.ServerGroupValidationConfiguration?].self, forKey: .serverGroupValidationConfigurations)
        var serverGroupValidationConfigurationsDecoded0:[SMSClientTypes.ServerGroupValidationConfiguration]? = nil
        if let serverGroupValidationConfigurationsContainer = serverGroupValidationConfigurationsContainer {
            serverGroupValidationConfigurationsDecoded0 = [SMSClientTypes.ServerGroupValidationConfiguration]()
            for structure0 in serverGroupValidationConfigurationsContainer {
                if let structure0 = structure0 {
                    serverGroupValidationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        serverGroupValidationConfigurations = serverGroupValidationConfigurationsDecoded0
    }
}

enum GetAppValidationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAppValidationOutputInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

extension GetAppValidationOutputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAppValidationOutputInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct GetAppValidationOutputInputBody: Swift.Equatable {
    let appId: Swift.String?
}

extension GetAppValidationOutputInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension GetAppValidationOutputOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAppValidationOutputOutputBody = try responseDecoder.decode(responseBody: data)
            self.validationOutputList = output.validationOutputList
        } else {
            self.validationOutputList = nil
        }
    }
}

public struct GetAppValidationOutputOutput: Swift.Equatable {
    /// The validation output.
    public var validationOutputList: [SMSClientTypes.ValidationOutput]?

    public init(
        validationOutputList: [SMSClientTypes.ValidationOutput]? = nil
    )
    {
        self.validationOutputList = validationOutputList
    }
}

struct GetAppValidationOutputOutputBody: Swift.Equatable {
    let validationOutputList: [SMSClientTypes.ValidationOutput]?
}

extension GetAppValidationOutputOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case validationOutputList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validationOutputListContainer = try containerValues.decodeIfPresent([SMSClientTypes.ValidationOutput?].self, forKey: .validationOutputList)
        var validationOutputListDecoded0:[SMSClientTypes.ValidationOutput]? = nil
        if let validationOutputListContainer = validationOutputListContainer {
            validationOutputListDecoded0 = [SMSClientTypes.ValidationOutput]()
            for structure0 in validationOutputListContainer {
                if let structure0 = structure0 {
                    validationOutputListDecoded0?.append(structure0)
                }
            }
        }
        validationOutputList = validationOutputListDecoded0
    }
}

enum GetAppValidationOutputOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetConnectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension GetConnectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetConnectorsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct GetConnectorsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetConnectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetConnectorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConnectorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectorList = output.connectorList
            self.nextToken = output.nextToken
        } else {
            self.connectorList = nil
            self.nextToken = nil
        }
    }
}

public struct GetConnectorsOutput: Swift.Equatable {
    /// Information about the registered connectors.
    public var connectorList: [SMSClientTypes.Connector]?
    /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        connectorList: [SMSClientTypes.Connector]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.connectorList = connectorList
        self.nextToken = nextToken
    }
}

struct GetConnectorsOutputBody: Swift.Equatable {
    let connectorList: [SMSClientTypes.Connector]?
    let nextToken: Swift.String?
}

extension GetConnectorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectorList
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectorListContainer = try containerValues.decodeIfPresent([SMSClientTypes.Connector?].self, forKey: .connectorList)
        var connectorListDecoded0:[SMSClientTypes.Connector]? = nil
        if let connectorListContainer = connectorListContainer {
            connectorListDecoded0 = [SMSClientTypes.Connector]()
            for structure0 in connectorListContainer {
                if let structure0 = structure0 {
                    connectorListDecoded0?.append(structure0)
                }
            }
        }
        connectorList = connectorListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetConnectorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReplicationJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case replicationJobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let replicationJobId = self.replicationJobId {
            try encodeContainer.encode(replicationJobId, forKey: .replicationJobId)
        }
    }
}

extension GetReplicationJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetReplicationJobsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The ID of the replication job.
    public var replicationJobId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        replicationJobId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.replicationJobId = replicationJobId
    }
}

struct GetReplicationJobsInputBody: Swift.Equatable {
    let replicationJobId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetReplicationJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case replicationJobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationJobId)
        replicationJobId = replicationJobIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetReplicationJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReplicationJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.replicationJobList = output.replicationJobList
        } else {
            self.nextToken = nil
            self.replicationJobList = nil
        }
    }
}

public struct GetReplicationJobsOutput: Swift.Equatable {
    /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the replication jobs.
    public var replicationJobList: [SMSClientTypes.ReplicationJob]?

    public init(
        nextToken: Swift.String? = nil,
        replicationJobList: [SMSClientTypes.ReplicationJob]? = nil
    )
    {
        self.nextToken = nextToken
        self.replicationJobList = replicationJobList
    }
}

struct GetReplicationJobsOutputBody: Swift.Equatable {
    let replicationJobList: [SMSClientTypes.ReplicationJob]?
    let nextToken: Swift.String?
}

extension GetReplicationJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case replicationJobList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationJobListContainer = try containerValues.decodeIfPresent([SMSClientTypes.ReplicationJob?].self, forKey: .replicationJobList)
        var replicationJobListDecoded0:[SMSClientTypes.ReplicationJob]? = nil
        if let replicationJobListContainer = replicationJobListContainer {
            replicationJobListDecoded0 = [SMSClientTypes.ReplicationJob]()
            for structure0 in replicationJobListContainer {
                if let structure0 = structure0 {
                    replicationJobListDecoded0?.append(structure0)
                }
            }
        }
        replicationJobList = replicationJobListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetReplicationJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReplicationRunsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case replicationJobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let replicationJobId = self.replicationJobId {
            try encodeContainer.encode(replicationJobId, forKey: .replicationJobId)
        }
    }
}

extension GetReplicationRunsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetReplicationRunsInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The ID of the replication job.
    /// This member is required.
    public var replicationJobId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        replicationJobId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.replicationJobId = replicationJobId
    }
}

struct GetReplicationRunsInputBody: Swift.Equatable {
    let replicationJobId: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension GetReplicationRunsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case replicationJobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationJobId)
        replicationJobId = replicationJobIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension GetReplicationRunsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReplicationRunsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.replicationJob = output.replicationJob
            self.replicationRunList = output.replicationRunList
        } else {
            self.nextToken = nil
            self.replicationJob = nil
            self.replicationRunList = nil
        }
    }
}

public struct GetReplicationRunsOutput: Swift.Equatable {
    /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// Information about the replication job.
    public var replicationJob: SMSClientTypes.ReplicationJob?
    /// Information about the replication runs.
    public var replicationRunList: [SMSClientTypes.ReplicationRun]?

    public init(
        nextToken: Swift.String? = nil,
        replicationJob: SMSClientTypes.ReplicationJob? = nil,
        replicationRunList: [SMSClientTypes.ReplicationRun]? = nil
    )
    {
        self.nextToken = nextToken
        self.replicationJob = replicationJob
        self.replicationRunList = replicationRunList
    }
}

struct GetReplicationRunsOutputBody: Swift.Equatable {
    let replicationJob: SMSClientTypes.ReplicationJob?
    let replicationRunList: [SMSClientTypes.ReplicationRun]?
    let nextToken: Swift.String?
}

extension GetReplicationRunsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case replicationJob
        case replicationRunList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationJobDecoded = try containerValues.decodeIfPresent(SMSClientTypes.ReplicationJob.self, forKey: .replicationJob)
        replicationJob = replicationJobDecoded
        let replicationRunListContainer = try containerValues.decodeIfPresent([SMSClientTypes.ReplicationRun?].self, forKey: .replicationRunList)
        var replicationRunListDecoded0:[SMSClientTypes.ReplicationRun]? = nil
        if let replicationRunListContainer = replicationRunListContainer {
            replicationRunListDecoded0 = [SMSClientTypes.ReplicationRun]()
            for structure0 in replicationRunListContainer {
                if let structure0 = structure0 {
                    replicationRunListDecoded0?.append(structure0)
                }
            }
        }
        replicationRunList = replicationRunListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetReplicationRunsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case vmServerAddressList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let vmServerAddressList = vmServerAddressList {
            var vmServerAddressListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vmServerAddressList)
            for vmserveraddress0 in vmServerAddressList {
                try vmServerAddressListContainer.encode(vmserveraddress0)
            }
        }
    }
}

extension GetServersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetServersInput: Swift.Equatable {
    /// The maximum number of results to return in a single call. The default value is 50. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?
    /// The server addresses.
    public var vmServerAddressList: [SMSClientTypes.VmServerAddress]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        vmServerAddressList: [SMSClientTypes.VmServerAddress]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.vmServerAddressList = vmServerAddressList
    }
}

struct GetServersInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let vmServerAddressList: [SMSClientTypes.VmServerAddress]?
}

extension GetServersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case vmServerAddressList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let vmServerAddressListContainer = try containerValues.decodeIfPresent([SMSClientTypes.VmServerAddress?].self, forKey: .vmServerAddressList)
        var vmServerAddressListDecoded0:[SMSClientTypes.VmServerAddress]? = nil
        if let vmServerAddressListContainer = vmServerAddressListContainer {
            vmServerAddressListDecoded0 = [SMSClientTypes.VmServerAddress]()
            for structure0 in vmServerAddressListContainer {
                if let structure0 = structure0 {
                    vmServerAddressListDecoded0?.append(structure0)
                }
            }
        }
        vmServerAddressList = vmServerAddressListDecoded0
    }
}

extension GetServersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServersOutputBody = try responseDecoder.decode(responseBody: data)
            self.lastModifiedOn = output.lastModifiedOn
            self.nextToken = output.nextToken
            self.serverCatalogStatus = output.serverCatalogStatus
            self.serverList = output.serverList
        } else {
            self.lastModifiedOn = nil
            self.nextToken = nil
            self.serverCatalogStatus = nil
            self.serverList = nil
        }
    }
}

public struct GetServersOutput: Swift.Equatable {
    /// The time when the server was last modified.
    public var lastModifiedOn: ClientRuntime.Date?
    /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The status of the server catalog.
    public var serverCatalogStatus: SMSClientTypes.ServerCatalogStatus?
    /// Information about the servers.
    public var serverList: [SMSClientTypes.Server]?

    public init(
        lastModifiedOn: ClientRuntime.Date? = nil,
        nextToken: Swift.String? = nil,
        serverCatalogStatus: SMSClientTypes.ServerCatalogStatus? = nil,
        serverList: [SMSClientTypes.Server]? = nil
    )
    {
        self.lastModifiedOn = lastModifiedOn
        self.nextToken = nextToken
        self.serverCatalogStatus = serverCatalogStatus
        self.serverList = serverList
    }
}

struct GetServersOutputBody: Swift.Equatable {
    let lastModifiedOn: ClientRuntime.Date?
    let serverCatalogStatus: SMSClientTypes.ServerCatalogStatus?
    let serverList: [SMSClientTypes.Server]?
    let nextToken: Swift.String?
}

extension GetServersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastModifiedOn
        case nextToken
        case serverCatalogStatus
        case serverList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastModifiedOnDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedOn)
        lastModifiedOn = lastModifiedOnDecoded
        let serverCatalogStatusDecoded = try containerValues.decodeIfPresent(SMSClientTypes.ServerCatalogStatus.self, forKey: .serverCatalogStatus)
        serverCatalogStatus = serverCatalogStatusDecoded
        let serverListContainer = try containerValues.decodeIfPresent([SMSClientTypes.Server?].self, forKey: .serverList)
        var serverListDecoded0:[SMSClientTypes.Server]? = nil
        if let serverListContainer = serverListContainer {
            serverListDecoded0 = [SMSClientTypes.Server]()
            for structure0 in serverListContainer {
                if let structure0 = structure0 {
                    serverListDecoded0?.append(structure0)
                }
            }
        }
        serverList = serverListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetServersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImportAppCatalogInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleName = self.roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
    }
}

extension ImportAppCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportAppCatalogInput: Swift.Equatable {
    /// The name of the service role. If you omit this parameter, we create a service-linked role for Migration Hub in your account. Otherwise, the role that you provide must have the [policy and trust policy](https://docs.aws.amazon.com/migrationhub/latest/ug/new-customer-setup.html#sms-managed) described in the Migration Hub User Guide.
    public var roleName: Swift.String?

    public init(
        roleName: Swift.String? = nil
    )
    {
        self.roleName = roleName
    }
}

struct ImportAppCatalogInputBody: Swift.Equatable {
    let roleName: Swift.String?
}

extension ImportAppCatalogInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
    }
}

extension ImportAppCatalogOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ImportAppCatalogOutput: Swift.Equatable {

    public init() { }
}

enum ImportAppCatalogOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ImportServerCatalogInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension ImportServerCatalogInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ImportServerCatalogInput: Swift.Equatable {

    public init() { }
}

struct ImportServerCatalogInputBody: Swift.Equatable {
}

extension ImportServerCatalogInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ImportServerCatalogOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ImportServerCatalogOutput: Swift.Equatable {

    public init() { }
}

enum ImportServerCatalogOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoConnectorsAvailable": return try await NoConnectorsAvailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalError {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalErrorBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal error occurred.
public struct InternalError: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalError" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalErrorBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalErrorBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A specified parameter is not valid.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameter" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LaunchAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

extension LaunchAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct LaunchAppInput: Swift.Equatable {
    /// The ID of the application.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct LaunchAppInputBody: Swift.Equatable {
    let appId: Swift.String?
}

extension LaunchAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension LaunchAppOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct LaunchAppOutput: Swift.Equatable {

    public init() { }
}

enum LaunchAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SMSClientTypes.LaunchDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case latestLaunchTime
        case stackId
        case stackName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let latestLaunchTime = self.latestLaunchTime {
            try encodeContainer.encodeTimestamp(latestLaunchTime, format: .epochSeconds, forKey: .latestLaunchTime)
        }
        if let stackId = self.stackId {
            try encodeContainer.encode(stackId, forKey: .stackId)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latestLaunchTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .latestLaunchTime)
        latestLaunchTime = latestLaunchTimeDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
        let stackIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackId)
        stackId = stackIdDecoded
    }
}

extension SMSClientTypes {
    /// Details about the latest launch of an application.
    public struct LaunchDetails: Swift.Equatable {
        /// The latest time that this application was launched successfully.
        public var latestLaunchTime: ClientRuntime.Date?
        /// The ID of the latest stack launched for this application.
        public var stackId: Swift.String?
        /// The name of the latest stack launched for this application.
        public var stackName: Swift.String?

        public init(
            latestLaunchTime: ClientRuntime.Date? = nil,
            stackId: Swift.String? = nil,
            stackName: Swift.String? = nil
        )
        {
            self.latestLaunchTime = latestLaunchTime
            self.stackId = stackId
            self.stackName = stackName
        }
    }

}

extension SMSClientTypes {
    public enum LicenseType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aws
        case byol
        case sdkUnknown(Swift.String)

        public static var allCases: [LicenseType] {
            return [
                .aws,
                .byol,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .byol: return "BYOL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LicenseType(rawValue: rawValue) ?? LicenseType.sdkUnknown(rawValue)
        }
    }
}

extension ListAppsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appIds
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appIds = appIds {
            var appIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appIds)
            for appid0 in appIds {
                try appIdsContainer.encode(appid0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAppsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAppsInput: Swift.Equatable {
    /// The unique application IDs.
    public var appIds: [Swift.String]?
    /// The maximum number of results to return in a single call. The default value is 100. To retrieve the remaining results, make another call with the returned NextToken value.
    public var maxResults: Swift.Int?
    /// The token for the next set of results.
    public var nextToken: Swift.String?

    public init(
        appIds: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appIds = appIds
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppsInputBody: Swift.Equatable {
    let appIds: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAppsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appIds
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .appIds)
        var appIdsDecoded0:[Swift.String]? = nil
        if let appIdsContainer = appIdsContainer {
            appIdsDecoded0 = [Swift.String]()
            for string0 in appIdsContainer {
                if let string0 = string0 {
                    appIdsDecoded0?.append(string0)
                }
            }
        }
        appIds = appIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAppsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppsOutputBody = try responseDecoder.decode(responseBody: data)
            self.apps = output.apps
            self.nextToken = output.nextToken
        } else {
            self.apps = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppsOutput: Swift.Equatable {
    /// The application summaries.
    public var apps: [SMSClientTypes.AppSummary]?
    /// The token required to retrieve the next set of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        apps: [SMSClientTypes.AppSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.apps = apps
        self.nextToken = nextToken
    }
}

struct ListAppsOutputBody: Swift.Equatable {
    let apps: [SMSClientTypes.AppSummary]?
    let nextToken: Swift.String?
}

extension ListAppsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apps
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appsContainer = try containerValues.decodeIfPresent([SMSClientTypes.AppSummary?].self, forKey: .apps)
        var appsDecoded0:[SMSClientTypes.AppSummary]? = nil
        if let appsContainer = appsContainer {
            appsDecoded0 = [SMSClientTypes.AppSummary]()
            for structure0 in appsContainer {
                if let structure0 = structure0 {
                    appsDecoded0?.append(structure0)
                }
            }
        }
        apps = appsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MissingRequiredParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: MissingRequiredParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A required parameter is missing.
public struct MissingRequiredParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "MissingRequiredParameter" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct MissingRequiredParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension MissingRequiredParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NoConnectorsAvailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NoConnectorsAvailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There are no connectors available.
public struct NoConnectorsAvailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoConnectorsAvailable" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoConnectorsAvailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoConnectorsAvailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SMSClientTypes.NotificationContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status
        case statusMessage
        case validationId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let validationId = self.validationId {
            try encodeContainer.encode(validationId, forKey: .validationId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validationId)
        validationId = validationIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SMSClientTypes.ValidationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension SMSClientTypes {
    /// Contains the status of validating an application.
    public struct NotificationContext: Swift.Equatable {
        /// The status of the validation.
        public var status: SMSClientTypes.ValidationStatus?
        /// The status message.
        public var statusMessage: Swift.String?
        /// The ID of the validation.
        public var validationId: Swift.String?

        public init(
            status: SMSClientTypes.ValidationStatus? = nil,
            statusMessage: Swift.String? = nil,
            validationId: Swift.String? = nil
        )
        {
            self.status = status
            self.statusMessage = statusMessage
            self.validationId = validationId
        }
    }

}

extension NotifyAppValidationOutputInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case notificationContext
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let notificationContext = self.notificationContext {
            try encodeContainer.encode(notificationContext, forKey: .notificationContext)
        }
    }
}

extension NotifyAppValidationOutputInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct NotifyAppValidationOutputInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var appId: Swift.String?
    /// The notification information.
    public var notificationContext: SMSClientTypes.NotificationContext?

    public init(
        appId: Swift.String? = nil,
        notificationContext: SMSClientTypes.NotificationContext? = nil
    )
    {
        self.appId = appId
        self.notificationContext = notificationContext
    }
}

struct NotifyAppValidationOutputInputBody: Swift.Equatable {
    let appId: Swift.String?
    let notificationContext: SMSClientTypes.NotificationContext?
}

extension NotifyAppValidationOutputInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case notificationContext
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let notificationContextDecoded = try containerValues.decodeIfPresent(SMSClientTypes.NotificationContext.self, forKey: .notificationContext)
        notificationContext = notificationContextDecoded
    }
}

extension NotifyAppValidationOutputOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct NotifyAppValidationOutputOutput: Swift.Equatable {

    public init() { }
}

enum NotifyAppValidationOutputOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension OperationNotPermittedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: OperationNotPermittedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This operation is not allowed.
public struct OperationNotPermittedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "OperationNotPermitted" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct OperationNotPermittedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension OperationNotPermittedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SMSClientTypes {
    public enum OutputFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case json
        case yaml
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputFormat] {
            return [
                .json,
                .yaml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .json: return "JSON"
            case .yaml: return "YAML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OutputFormat(rawValue: rawValue) ?? OutputFormat.sdkUnknown(rawValue)
        }
    }
}

extension PutAppLaunchConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case autoLaunch
        case roleName
        case serverGroupLaunchConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let autoLaunch = self.autoLaunch {
            try encodeContainer.encode(autoLaunch, forKey: .autoLaunch)
        }
        if let roleName = self.roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let serverGroupLaunchConfigurations = serverGroupLaunchConfigurations {
            var serverGroupLaunchConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serverGroupLaunchConfigurations)
            for servergrouplaunchconfiguration0 in serverGroupLaunchConfigurations {
                try serverGroupLaunchConfigurationsContainer.encode(servergrouplaunchconfiguration0)
            }
        }
    }
}

extension PutAppLaunchConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutAppLaunchConfigurationInput: Swift.Equatable {
    /// The ID of the application.
    public var appId: Swift.String?
    /// Indicates whether the application is configured to launch automatically after replication is complete.
    public var autoLaunch: Swift.Bool?
    /// The name of service role in the customer's account that CloudFormation uses to launch the application.
    public var roleName: Swift.String?
    /// Information about the launch configurations for server groups in the application.
    public var serverGroupLaunchConfigurations: [SMSClientTypes.ServerGroupLaunchConfiguration]?

    public init(
        appId: Swift.String? = nil,
        autoLaunch: Swift.Bool? = nil,
        roleName: Swift.String? = nil,
        serverGroupLaunchConfigurations: [SMSClientTypes.ServerGroupLaunchConfiguration]? = nil
    )
    {
        self.appId = appId
        self.autoLaunch = autoLaunch
        self.roleName = roleName
        self.serverGroupLaunchConfigurations = serverGroupLaunchConfigurations
    }
}

struct PutAppLaunchConfigurationInputBody: Swift.Equatable {
    let appId: Swift.String?
    let roleName: Swift.String?
    let autoLaunch: Swift.Bool?
    let serverGroupLaunchConfigurations: [SMSClientTypes.ServerGroupLaunchConfiguration]?
}

extension PutAppLaunchConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case autoLaunch
        case roleName
        case serverGroupLaunchConfigurations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let autoLaunchDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoLaunch)
        autoLaunch = autoLaunchDecoded
        let serverGroupLaunchConfigurationsContainer = try containerValues.decodeIfPresent([SMSClientTypes.ServerGroupLaunchConfiguration?].self, forKey: .serverGroupLaunchConfigurations)
        var serverGroupLaunchConfigurationsDecoded0:[SMSClientTypes.ServerGroupLaunchConfiguration]? = nil
        if let serverGroupLaunchConfigurationsContainer = serverGroupLaunchConfigurationsContainer {
            serverGroupLaunchConfigurationsDecoded0 = [SMSClientTypes.ServerGroupLaunchConfiguration]()
            for structure0 in serverGroupLaunchConfigurationsContainer {
                if let structure0 = structure0 {
                    serverGroupLaunchConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        serverGroupLaunchConfigurations = serverGroupLaunchConfigurationsDecoded0
    }
}

extension PutAppLaunchConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutAppLaunchConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum PutAppLaunchConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutAppReplicationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case serverGroupReplicationConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let serverGroupReplicationConfigurations = serverGroupReplicationConfigurations {
            var serverGroupReplicationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serverGroupReplicationConfigurations)
            for servergroupreplicationconfiguration0 in serverGroupReplicationConfigurations {
                try serverGroupReplicationConfigurationsContainer.encode(servergroupreplicationconfiguration0)
            }
        }
    }
}

extension PutAppReplicationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutAppReplicationConfigurationInput: Swift.Equatable {
    /// The ID of the application.
    public var appId: Swift.String?
    /// Information about the replication configurations for server groups in the application.
    public var serverGroupReplicationConfigurations: [SMSClientTypes.ServerGroupReplicationConfiguration]?

    public init(
        appId: Swift.String? = nil,
        serverGroupReplicationConfigurations: [SMSClientTypes.ServerGroupReplicationConfiguration]? = nil
    )
    {
        self.appId = appId
        self.serverGroupReplicationConfigurations = serverGroupReplicationConfigurations
    }
}

struct PutAppReplicationConfigurationInputBody: Swift.Equatable {
    let appId: Swift.String?
    let serverGroupReplicationConfigurations: [SMSClientTypes.ServerGroupReplicationConfiguration]?
}

extension PutAppReplicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case serverGroupReplicationConfigurations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let serverGroupReplicationConfigurationsContainer = try containerValues.decodeIfPresent([SMSClientTypes.ServerGroupReplicationConfiguration?].self, forKey: .serverGroupReplicationConfigurations)
        var serverGroupReplicationConfigurationsDecoded0:[SMSClientTypes.ServerGroupReplicationConfiguration]? = nil
        if let serverGroupReplicationConfigurationsContainer = serverGroupReplicationConfigurationsContainer {
            serverGroupReplicationConfigurationsDecoded0 = [SMSClientTypes.ServerGroupReplicationConfiguration]()
            for structure0 in serverGroupReplicationConfigurationsContainer {
                if let structure0 = structure0 {
                    serverGroupReplicationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        serverGroupReplicationConfigurations = serverGroupReplicationConfigurationsDecoded0
    }
}

extension PutAppReplicationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutAppReplicationConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum PutAppReplicationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutAppValidationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case appValidationConfigurations
        case serverGroupValidationConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let appValidationConfigurations = appValidationConfigurations {
            var appValidationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appValidationConfigurations)
            for appvalidationconfiguration0 in appValidationConfigurations {
                try appValidationConfigurationsContainer.encode(appvalidationconfiguration0)
            }
        }
        if let serverGroupValidationConfigurations = serverGroupValidationConfigurations {
            var serverGroupValidationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serverGroupValidationConfigurations)
            for servergroupvalidationconfiguration0 in serverGroupValidationConfigurations {
                try serverGroupValidationConfigurationsContainer.encode(servergroupvalidationconfiguration0)
            }
        }
    }
}

extension PutAppValidationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutAppValidationConfigurationInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var appId: Swift.String?
    /// The configuration for application validation.
    public var appValidationConfigurations: [SMSClientTypes.AppValidationConfiguration]?
    /// The configuration for instance validation.
    public var serverGroupValidationConfigurations: [SMSClientTypes.ServerGroupValidationConfiguration]?

    public init(
        appId: Swift.String? = nil,
        appValidationConfigurations: [SMSClientTypes.AppValidationConfiguration]? = nil,
        serverGroupValidationConfigurations: [SMSClientTypes.ServerGroupValidationConfiguration]? = nil
    )
    {
        self.appId = appId
        self.appValidationConfigurations = appValidationConfigurations
        self.serverGroupValidationConfigurations = serverGroupValidationConfigurations
    }
}

struct PutAppValidationConfigurationInputBody: Swift.Equatable {
    let appId: Swift.String?
    let appValidationConfigurations: [SMSClientTypes.AppValidationConfiguration]?
    let serverGroupValidationConfigurations: [SMSClientTypes.ServerGroupValidationConfiguration]?
}

extension PutAppValidationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case appValidationConfigurations
        case serverGroupValidationConfigurations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let appValidationConfigurationsContainer = try containerValues.decodeIfPresent([SMSClientTypes.AppValidationConfiguration?].self, forKey: .appValidationConfigurations)
        var appValidationConfigurationsDecoded0:[SMSClientTypes.AppValidationConfiguration]? = nil
        if let appValidationConfigurationsContainer = appValidationConfigurationsContainer {
            appValidationConfigurationsDecoded0 = [SMSClientTypes.AppValidationConfiguration]()
            for structure0 in appValidationConfigurationsContainer {
                if let structure0 = structure0 {
                    appValidationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        appValidationConfigurations = appValidationConfigurationsDecoded0
        let serverGroupValidationConfigurationsContainer = try containerValues.decodeIfPresent([SMSClientTypes.ServerGroupValidationConfiguration?].self, forKey: .serverGroupValidationConfigurations)
        var serverGroupValidationConfigurationsDecoded0:[SMSClientTypes.ServerGroupValidationConfiguration]? = nil
        if let serverGroupValidationConfigurationsContainer = serverGroupValidationConfigurationsContainer {
            serverGroupValidationConfigurationsDecoded0 = [SMSClientTypes.ServerGroupValidationConfiguration]()
            for structure0 in serverGroupValidationConfigurationsContainer {
                if let structure0 = structure0 {
                    serverGroupValidationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        serverGroupValidationConfigurations = serverGroupValidationConfigurationsDecoded0
    }
}

extension PutAppValidationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutAppValidationConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum PutAppValidationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SMSClientTypes.ReplicationJob: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case encrypted
        case frequency
        case kmsKeyId
        case latestAmiId
        case licenseType
        case nextReplicationRunStartTime
        case numberOfRecentAmisToKeep
        case replicationJobId
        case replicationRunList
        case roleName
        case runOnce
        case seedReplicationTime
        case serverId
        case serverType
        case state
        case statusMessage
        case vmServer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encrypted = self.encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let frequency = self.frequency {
            try encodeContainer.encode(frequency, forKey: .frequency)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let latestAmiId = self.latestAmiId {
            try encodeContainer.encode(latestAmiId, forKey: .latestAmiId)
        }
        if let licenseType = self.licenseType {
            try encodeContainer.encode(licenseType.rawValue, forKey: .licenseType)
        }
        if let nextReplicationRunStartTime = self.nextReplicationRunStartTime {
            try encodeContainer.encodeTimestamp(nextReplicationRunStartTime, format: .epochSeconds, forKey: .nextReplicationRunStartTime)
        }
        if let numberOfRecentAmisToKeep = self.numberOfRecentAmisToKeep {
            try encodeContainer.encode(numberOfRecentAmisToKeep, forKey: .numberOfRecentAmisToKeep)
        }
        if let replicationJobId = self.replicationJobId {
            try encodeContainer.encode(replicationJobId, forKey: .replicationJobId)
        }
        if let replicationRunList = replicationRunList {
            var replicationRunListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationRunList)
            for replicationrun0 in replicationRunList {
                try replicationRunListContainer.encode(replicationrun0)
            }
        }
        if let roleName = self.roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let runOnce = self.runOnce {
            try encodeContainer.encode(runOnce, forKey: .runOnce)
        }
        if let seedReplicationTime = self.seedReplicationTime {
            try encodeContainer.encodeTimestamp(seedReplicationTime, format: .epochSeconds, forKey: .seedReplicationTime)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let serverType = self.serverType {
            try encodeContainer.encode(serverType.rawValue, forKey: .serverType)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let vmServer = self.vmServer {
            try encodeContainer.encode(vmServer, forKey: .vmServer)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationJobId)
        replicationJobId = replicationJobIdDecoded
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let serverTypeDecoded = try containerValues.decodeIfPresent(SMSClientTypes.ServerType.self, forKey: .serverType)
        serverType = serverTypeDecoded
        let vmServerDecoded = try containerValues.decodeIfPresent(SMSClientTypes.VmServer.self, forKey: .vmServer)
        vmServer = vmServerDecoded
        let seedReplicationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .seedReplicationTime)
        seedReplicationTime = seedReplicationTimeDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .frequency)
        frequency = frequencyDecoded
        let runOnceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .runOnce)
        runOnce = runOnceDecoded
        let nextReplicationRunStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .nextReplicationRunStartTime)
        nextReplicationRunStartTime = nextReplicationRunStartTimeDecoded
        let licenseTypeDecoded = try containerValues.decodeIfPresent(SMSClientTypes.LicenseType.self, forKey: .licenseType)
        licenseType = licenseTypeDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let latestAmiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestAmiId)
        latestAmiId = latestAmiIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SMSClientTypes.ReplicationJobState.self, forKey: .state)
        state = stateDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let numberOfRecentAmisToKeepDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRecentAmisToKeep)
        numberOfRecentAmisToKeep = numberOfRecentAmisToKeepDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let replicationRunListContainer = try containerValues.decodeIfPresent([SMSClientTypes.ReplicationRun?].self, forKey: .replicationRunList)
        var replicationRunListDecoded0:[SMSClientTypes.ReplicationRun]? = nil
        if let replicationRunListContainer = replicationRunListContainer {
            replicationRunListDecoded0 = [SMSClientTypes.ReplicationRun]()
            for structure0 in replicationRunListContainer {
                if let structure0 = structure0 {
                    replicationRunListDecoded0?.append(structure0)
                }
            }
        }
        replicationRunList = replicationRunListDecoded0
    }
}

extension SMSClientTypes {
    /// Represents a replication job.
    public struct ReplicationJob: Swift.Equatable {
        /// The description of the replication job.
        public var description: Swift.String?
        /// Indicates whether the replication job should produce encrypted AMIs.
        public var encrypted: Swift.Bool?
        /// The time between consecutive replication runs, in hours.
        public var frequency: Swift.Int?
        /// The ID of the KMS key for replication jobs that produce encrypted AMIs. This value can be any of the following:
        ///
        /// * KMS key ID
        ///
        /// * KMS key alias
        ///
        /// * ARN referring to the KMS key ID
        ///
        /// * ARN referring to the KMS key alias
        ///
        ///
        /// If encrypted is enabled but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
        public var kmsKeyId: Swift.String?
        /// The ID of the latest Amazon Machine Image (AMI).
        public var latestAmiId: Swift.String?
        /// The license type to be used for the AMI created by a successful replication run.
        public var licenseType: SMSClientTypes.LicenseType?
        /// The start time of the next replication run.
        public var nextReplicationRunStartTime: ClientRuntime.Date?
        /// The number of recent AMIs to keep in the customer's account for a replication job. By default, the value is set to zero, meaning that all AMIs are kept.
        public var numberOfRecentAmisToKeep: Swift.Int?
        /// The ID of the replication job.
        public var replicationJobId: Swift.String?
        /// Information about the replication runs.
        public var replicationRunList: [SMSClientTypes.ReplicationRun]?
        /// The name of the IAM role to be used by Server Migration Service.
        public var roleName: Swift.String?
        /// Indicates whether to run the replication job one time.
        public var runOnce: Swift.Bool?
        /// The seed replication time.
        public var seedReplicationTime: ClientRuntime.Date?
        /// The ID of the server.
        public var serverId: Swift.String?
        /// The type of server.
        public var serverType: SMSClientTypes.ServerType?
        /// The state of the replication job.
        public var state: SMSClientTypes.ReplicationJobState?
        /// The description of the current status of the replication job.
        public var statusMessage: Swift.String?
        /// Information about the VM server.
        public var vmServer: SMSClientTypes.VmServer?

        public init(
            description: Swift.String? = nil,
            encrypted: Swift.Bool? = nil,
            frequency: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            latestAmiId: Swift.String? = nil,
            licenseType: SMSClientTypes.LicenseType? = nil,
            nextReplicationRunStartTime: ClientRuntime.Date? = nil,
            numberOfRecentAmisToKeep: Swift.Int? = nil,
            replicationJobId: Swift.String? = nil,
            replicationRunList: [SMSClientTypes.ReplicationRun]? = nil,
            roleName: Swift.String? = nil,
            runOnce: Swift.Bool? = nil,
            seedReplicationTime: ClientRuntime.Date? = nil,
            serverId: Swift.String? = nil,
            serverType: SMSClientTypes.ServerType? = nil,
            state: SMSClientTypes.ReplicationJobState? = nil,
            statusMessage: Swift.String? = nil,
            vmServer: SMSClientTypes.VmServer? = nil
        )
        {
            self.description = description
            self.encrypted = encrypted
            self.frequency = frequency
            self.kmsKeyId = kmsKeyId
            self.latestAmiId = latestAmiId
            self.licenseType = licenseType
            self.nextReplicationRunStartTime = nextReplicationRunStartTime
            self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
            self.replicationJobId = replicationJobId
            self.replicationRunList = replicationRunList
            self.roleName = roleName
            self.runOnce = runOnce
            self.seedReplicationTime = seedReplicationTime
            self.serverId = serverId
            self.serverType = serverType
            self.state = state
            self.statusMessage = statusMessage
            self.vmServer = vmServer
        }
    }

}

extension ReplicationJobAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReplicationJobAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified replication job already exists.
public struct ReplicationJobAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReplicationJobAlreadyExists" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ReplicationJobAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReplicationJobAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ReplicationJobNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReplicationJobNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified replication job does not exist.
public struct ReplicationJobNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReplicationJobNotFound" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ReplicationJobNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReplicationJobNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SMSClientTypes {
    public enum ReplicationJobState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case completed
        case deleted
        case deleting
        case failed
        case failing
        case pausedonfailure
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationJobState] {
            return [
                .active,
                .completed,
                .deleted,
                .deleting,
                .failed,
                .failing,
                .pausedonfailure,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .completed: return "COMPLETED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .failing: return "FAILING"
            case .pausedonfailure: return "PAUSED_ON_FAILURE"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationJobState(rawValue: rawValue) ?? ReplicationJobState.sdkUnknown(rawValue)
        }
    }
}

extension SMSClientTypes.ReplicationRun: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amiId
        case completedTime
        case description
        case encrypted
        case kmsKeyId
        case replicationRunId
        case scheduledStartTime
        case stageDetails
        case state
        case statusMessage
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amiId = self.amiId {
            try encodeContainer.encode(amiId, forKey: .amiId)
        }
        if let completedTime = self.completedTime {
            try encodeContainer.encodeTimestamp(completedTime, format: .epochSeconds, forKey: .completedTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encrypted = self.encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let replicationRunId = self.replicationRunId {
            try encodeContainer.encode(replicationRunId, forKey: .replicationRunId)
        }
        if let scheduledStartTime = self.scheduledStartTime {
            try encodeContainer.encodeTimestamp(scheduledStartTime, format: .epochSeconds, forKey: .scheduledStartTime)
        }
        if let stageDetails = self.stageDetails {
            try encodeContainer.encode(stageDetails, forKey: .stageDetails)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationRunId)
        replicationRunId = replicationRunIdDecoded
        let stateDecoded = try containerValues.decodeIfPresent(SMSClientTypes.ReplicationRunState.self, forKey: .state)
        state = stateDecoded
        let typeDecoded = try containerValues.decodeIfPresent(SMSClientTypes.ReplicationRunType.self, forKey: .type)
        type = typeDecoded
        let stageDetailsDecoded = try containerValues.decodeIfPresent(SMSClientTypes.ReplicationRunStageDetails.self, forKey: .stageDetails)
        stageDetails = stageDetailsDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let amiIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amiId)
        amiId = amiIdDecoded
        let scheduledStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .scheduledStartTime)
        scheduledStartTime = scheduledStartTimeDecoded
        let completedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completedTime)
        completedTime = completedTimeDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension SMSClientTypes {
    /// Represents a replication run.
    public struct ReplicationRun: Swift.Equatable {
        /// The ID of the Amazon Machine Image (AMI) from the replication run.
        public var amiId: Swift.String?
        /// The completion time of the last replication run.
        public var completedTime: ClientRuntime.Date?
        /// The description of the replication run.
        public var description: Swift.String?
        /// Indicates whether the replication run should produce an encrypted AMI.
        public var encrypted: Swift.Bool?
        /// The ID of the KMS key for replication jobs that produce encrypted AMIs. This value can be any of the following:
        ///
        /// * KMS key ID
        ///
        /// * KMS key alias
        ///
        /// * ARN referring to the KMS key ID
        ///
        /// * ARN referring to the KMS key alias
        ///
        ///
        /// If encrypted is true but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
        public var kmsKeyId: Swift.String?
        /// The ID of the replication run.
        public var replicationRunId: Swift.String?
        /// The start time of the next replication run.
        public var scheduledStartTime: ClientRuntime.Date?
        /// Details about the current stage of the replication run.
        public var stageDetails: SMSClientTypes.ReplicationRunStageDetails?
        /// The state of the replication run.
        public var state: SMSClientTypes.ReplicationRunState?
        /// The description of the current status of the replication job.
        public var statusMessage: Swift.String?
        /// The type of replication run.
        public var type: SMSClientTypes.ReplicationRunType?

        public init(
            amiId: Swift.String? = nil,
            completedTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            encrypted: Swift.Bool? = nil,
            kmsKeyId: Swift.String? = nil,
            replicationRunId: Swift.String? = nil,
            scheduledStartTime: ClientRuntime.Date? = nil,
            stageDetails: SMSClientTypes.ReplicationRunStageDetails? = nil,
            state: SMSClientTypes.ReplicationRunState? = nil,
            statusMessage: Swift.String? = nil,
            type: SMSClientTypes.ReplicationRunType? = nil
        )
        {
            self.amiId = amiId
            self.completedTime = completedTime
            self.description = description
            self.encrypted = encrypted
            self.kmsKeyId = kmsKeyId
            self.replicationRunId = replicationRunId
            self.scheduledStartTime = scheduledStartTime
            self.stageDetails = stageDetails
            self.state = state
            self.statusMessage = statusMessage
            self.type = type
        }
    }

}

extension ReplicationRunLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReplicationRunLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have exceeded the number of on-demand replication runs you can request in a 24-hour period.
public struct ReplicationRunLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReplicationRunLimitExceeded" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ReplicationRunLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReplicationRunLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SMSClientTypes.ReplicationRunStageDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stage
        case stageProgress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let stage = self.stage {
            try encodeContainer.encode(stage, forKey: .stage)
        }
        if let stageProgress = self.stageProgress {
            try encodeContainer.encode(stageProgress, forKey: .stageProgress)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stage)
        stage = stageDecoded
        let stageProgressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stageProgress)
        stageProgress = stageProgressDecoded
    }
}

extension SMSClientTypes {
    /// Details of the current stage of a replication run.
    public struct ReplicationRunStageDetails: Swift.Equatable {
        /// The current stage of a replication run.
        public var stage: Swift.String?
        /// The progress of the current stage of a replication run.
        public var stageProgress: Swift.String?

        public init(
            stage: Swift.String? = nil,
            stageProgress: Swift.String? = nil
        )
        {
            self.stage = stage
            self.stageProgress = stageProgress
        }
    }

}

extension SMSClientTypes {
    public enum ReplicationRunState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case completed
        case deleted
        case deleting
        case failed
        case missed
        case pending
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationRunState] {
            return [
                .active,
                .completed,
                .deleted,
                .deleting,
                .failed,
                .missed,
                .pending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .completed: return "COMPLETED"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .missed: return "MISSED"
            case .pending: return "PENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationRunState(rawValue: rawValue) ?? ReplicationRunState.sdkUnknown(rawValue)
        }
    }
}

extension SMSClientTypes {
    public enum ReplicationRunType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case automatic
        case ondemand
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationRunType] {
            return [
                .automatic,
                .ondemand,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .automatic: return "AUTOMATIC"
            case .ondemand: return "ON_DEMAND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationRunType(rawValue: rawValue) ?? ReplicationRunType.sdkUnknown(rawValue)
        }
    }
}

extension SMSClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension SMSClientTypes {
    /// Location of an Amazon S3 object.
    public struct S3Location: Swift.Equatable {
        /// The Amazon S3 bucket name.
        public var bucket: Swift.String?
        /// The Amazon S3 bucket key.
        public var key: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }

}

extension SMSClientTypes.SSMOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Location
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = self.s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationDecoded = try containerValues.decodeIfPresent(SMSClientTypes.S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension SMSClientTypes {
    /// Contains the location of validation output.
    public struct SSMOutput: Swift.Equatable {
        /// Location of an Amazon S3 object.
        public var s3Location: SMSClientTypes.S3Location?

        public init(
            s3Location: SMSClientTypes.S3Location? = nil
        )
        {
            self.s3Location = s3Location
        }
    }

}

extension SMSClientTypes.SSMValidationParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case command
        case executionTimeoutSeconds
        case instanceId
        case outputS3BucketName
        case scriptType
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let command = self.command {
            try encodeContainer.encode(command, forKey: .command)
        }
        if executionTimeoutSeconds != 0 {
            try encodeContainer.encode(executionTimeoutSeconds, forKey: .executionTimeoutSeconds)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let outputS3BucketName = self.outputS3BucketName {
            try encodeContainer.encode(outputS3BucketName, forKey: .outputS3BucketName)
        }
        if let scriptType = self.scriptType {
            try encodeContainer.encode(scriptType.rawValue, forKey: .scriptType)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(SMSClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let scriptTypeDecoded = try containerValues.decodeIfPresent(SMSClientTypes.ScriptType.self, forKey: .scriptType)
        scriptType = scriptTypeDecoded
        let commandDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .command)
        command = commandDecoded
        let executionTimeoutSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .executionTimeoutSeconds) ?? 0
        executionTimeoutSeconds = executionTimeoutSecondsDecoded
        let outputS3BucketNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outputS3BucketName)
        outputS3BucketName = outputS3BucketNameDecoded
    }
}

extension SMSClientTypes {
    /// Contains validation parameters.
    public struct SSMValidationParameters: Swift.Equatable {
        /// The command to run the validation script.
        public var command: Swift.String?
        /// The timeout interval, in seconds.
        public var executionTimeoutSeconds: Swift.Int
        /// The ID of the instance. The instance must have the following tag: UserForSMSApplicationValidation=true.
        public var instanceId: Swift.String?
        /// The name of the S3 bucket for output.
        public var outputS3BucketName: Swift.String?
        /// The type of validation script.
        public var scriptType: SMSClientTypes.ScriptType?
        /// The location of the validation script.
        public var source: SMSClientTypes.Source?

        public init(
            command: Swift.String? = nil,
            executionTimeoutSeconds: Swift.Int = 0,
            instanceId: Swift.String? = nil,
            outputS3BucketName: Swift.String? = nil,
            scriptType: SMSClientTypes.ScriptType? = nil,
            source: SMSClientTypes.Source? = nil
        )
        {
            self.command = command
            self.executionTimeoutSeconds = executionTimeoutSeconds
            self.instanceId = instanceId
            self.outputS3BucketName = outputS3BucketName
            self.scriptType = scriptType
            self.source = source
        }
    }

}

extension SMSClientTypes {
    public enum ScriptType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case powershellScript
        case shellScript
        case sdkUnknown(Swift.String)

        public static var allCases: [ScriptType] {
            return [
                .powershellScript,
                .shellScript,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .powershellScript: return "POWERSHELL_SCRIPT"
            case .shellScript: return "SHELL_SCRIPT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScriptType(rawValue: rawValue) ?? ScriptType.sdkUnknown(rawValue)
        }
    }
}

extension SMSClientTypes.Server: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationJobId
        case replicationJobTerminated
        case serverId
        case serverType
        case vmServer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationJobId = self.replicationJobId {
            try encodeContainer.encode(replicationJobId, forKey: .replicationJobId)
        }
        if let replicationJobTerminated = self.replicationJobTerminated {
            try encodeContainer.encode(replicationJobTerminated, forKey: .replicationJobTerminated)
        }
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let serverType = self.serverType {
            try encodeContainer.encode(serverType.rawValue, forKey: .serverType)
        }
        if let vmServer = self.vmServer {
            try encodeContainer.encode(vmServer, forKey: .vmServer)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let serverTypeDecoded = try containerValues.decodeIfPresent(SMSClientTypes.ServerType.self, forKey: .serverType)
        serverType = serverTypeDecoded
        let vmServerDecoded = try containerValues.decodeIfPresent(SMSClientTypes.VmServer.self, forKey: .vmServer)
        vmServer = vmServerDecoded
        let replicationJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationJobId)
        replicationJobId = replicationJobIdDecoded
        let replicationJobTerminatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .replicationJobTerminated)
        replicationJobTerminated = replicationJobTerminatedDecoded
    }
}

extension SMSClientTypes {
    /// Represents a server.
    public struct Server: Swift.Equatable {
        /// The ID of the replication job.
        public var replicationJobId: Swift.String?
        /// Indicates whether the replication job is deleted or failed.
        public var replicationJobTerminated: Swift.Bool?
        /// The ID of the server.
        public var serverId: Swift.String?
        /// The type of server.
        public var serverType: SMSClientTypes.ServerType?
        /// Information about the VM server.
        public var vmServer: SMSClientTypes.VmServer?

        public init(
            replicationJobId: Swift.String? = nil,
            replicationJobTerminated: Swift.Bool? = nil,
            serverId: Swift.String? = nil,
            serverType: SMSClientTypes.ServerType? = nil,
            vmServer: SMSClientTypes.VmServer? = nil
        )
        {
            self.replicationJobId = replicationJobId
            self.replicationJobTerminated = replicationJobTerminated
            self.serverId = serverId
            self.serverType = serverType
            self.vmServer = vmServer
        }
    }

}

extension ServerCannotBeReplicatedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServerCannotBeReplicatedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified server cannot be replicated.
public struct ServerCannotBeReplicatedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServerCannotBeReplicated" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServerCannotBeReplicatedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServerCannotBeReplicatedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SMSClientTypes {
    public enum ServerCatalogStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case deleted
        case expired
        case importing
        case notimported
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerCatalogStatus] {
            return [
                .available,
                .deleted,
                .expired,
                .importing,
                .notimported,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .deleted: return "DELETED"
            case .expired: return "EXPIRED"
            case .importing: return "IMPORTING"
            case .notimported: return "NOT_IMPORTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServerCatalogStatus(rawValue: rawValue) ?? ServerCatalogStatus.sdkUnknown(rawValue)
        }
    }
}

extension SMSClientTypes.ServerGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case serverGroupId
        case serverList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverGroupId = self.serverGroupId {
            try encodeContainer.encode(serverGroupId, forKey: .serverGroupId)
        }
        if let serverList = serverList {
            var serverListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serverList)
            for server0 in serverList {
                try serverListContainer.encode(server0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverGroupId)
        serverGroupId = serverGroupIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let serverListContainer = try containerValues.decodeIfPresent([SMSClientTypes.Server?].self, forKey: .serverList)
        var serverListDecoded0:[SMSClientTypes.Server]? = nil
        if let serverListContainer = serverListContainer {
            serverListDecoded0 = [SMSClientTypes.Server]()
            for structure0 in serverListContainer {
                if let structure0 = structure0 {
                    serverListDecoded0?.append(structure0)
                }
            }
        }
        serverList = serverListDecoded0
    }
}

extension SMSClientTypes {
    /// Logical grouping of servers.
    public struct ServerGroup: Swift.Equatable {
        /// The name of a server group.
        public var name: Swift.String?
        /// The ID of a server group.
        public var serverGroupId: Swift.String?
        /// The servers that belong to a server group.
        public var serverList: [SMSClientTypes.Server]?

        public init(
            name: Swift.String? = nil,
            serverGroupId: Swift.String? = nil,
            serverList: [SMSClientTypes.Server]? = nil
        )
        {
            self.name = name
            self.serverGroupId = serverGroupId
            self.serverList = serverList
        }
    }

}

extension SMSClientTypes.ServerGroupLaunchConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchOrder
        case serverGroupId
        case serverLaunchConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchOrder = self.launchOrder {
            try encodeContainer.encode(launchOrder, forKey: .launchOrder)
        }
        if let serverGroupId = self.serverGroupId {
            try encodeContainer.encode(serverGroupId, forKey: .serverGroupId)
        }
        if let serverLaunchConfigurations = serverLaunchConfigurations {
            var serverLaunchConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serverLaunchConfigurations)
            for serverlaunchconfiguration0 in serverLaunchConfigurations {
                try serverLaunchConfigurationsContainer.encode(serverlaunchconfiguration0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverGroupId)
        serverGroupId = serverGroupIdDecoded
        let launchOrderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .launchOrder)
        launchOrder = launchOrderDecoded
        let serverLaunchConfigurationsContainer = try containerValues.decodeIfPresent([SMSClientTypes.ServerLaunchConfiguration?].self, forKey: .serverLaunchConfigurations)
        var serverLaunchConfigurationsDecoded0:[SMSClientTypes.ServerLaunchConfiguration]? = nil
        if let serverLaunchConfigurationsContainer = serverLaunchConfigurationsContainer {
            serverLaunchConfigurationsDecoded0 = [SMSClientTypes.ServerLaunchConfiguration]()
            for structure0 in serverLaunchConfigurationsContainer {
                if let structure0 = structure0 {
                    serverLaunchConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        serverLaunchConfigurations = serverLaunchConfigurationsDecoded0
    }
}

extension SMSClientTypes {
    /// Launch configuration for a server group.
    public struct ServerGroupLaunchConfiguration: Swift.Equatable {
        /// The launch order of servers in the server group.
        public var launchOrder: Swift.Int?
        /// The ID of the server group with which the launch configuration is associated.
        public var serverGroupId: Swift.String?
        /// The launch configuration for servers in the server group.
        public var serverLaunchConfigurations: [SMSClientTypes.ServerLaunchConfiguration]?

        public init(
            launchOrder: Swift.Int? = nil,
            serverGroupId: Swift.String? = nil,
            serverLaunchConfigurations: [SMSClientTypes.ServerLaunchConfiguration]? = nil
        )
        {
            self.launchOrder = launchOrder
            self.serverGroupId = serverGroupId
            self.serverLaunchConfigurations = serverLaunchConfigurations
        }
    }

}

extension SMSClientTypes.ServerGroupReplicationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverGroupId
        case serverReplicationConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverGroupId = self.serverGroupId {
            try encodeContainer.encode(serverGroupId, forKey: .serverGroupId)
        }
        if let serverReplicationConfigurations = serverReplicationConfigurations {
            var serverReplicationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serverReplicationConfigurations)
            for serverreplicationconfiguration0 in serverReplicationConfigurations {
                try serverReplicationConfigurationsContainer.encode(serverreplicationconfiguration0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverGroupId)
        serverGroupId = serverGroupIdDecoded
        let serverReplicationConfigurationsContainer = try containerValues.decodeIfPresent([SMSClientTypes.ServerReplicationConfiguration?].self, forKey: .serverReplicationConfigurations)
        var serverReplicationConfigurationsDecoded0:[SMSClientTypes.ServerReplicationConfiguration]? = nil
        if let serverReplicationConfigurationsContainer = serverReplicationConfigurationsContainer {
            serverReplicationConfigurationsDecoded0 = [SMSClientTypes.ServerReplicationConfiguration]()
            for structure0 in serverReplicationConfigurationsContainer {
                if let structure0 = structure0 {
                    serverReplicationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        serverReplicationConfigurations = serverReplicationConfigurationsDecoded0
    }
}

extension SMSClientTypes {
    /// Replication configuration for a server group.
    public struct ServerGroupReplicationConfiguration: Swift.Equatable {
        /// The ID of the server group with which this replication configuration is associated.
        public var serverGroupId: Swift.String?
        /// The replication configuration for servers in the server group.
        public var serverReplicationConfigurations: [SMSClientTypes.ServerReplicationConfiguration]?

        public init(
            serverGroupId: Swift.String? = nil,
            serverReplicationConfigurations: [SMSClientTypes.ServerReplicationConfiguration]? = nil
        )
        {
            self.serverGroupId = serverGroupId
            self.serverReplicationConfigurations = serverReplicationConfigurations
        }
    }

}

extension SMSClientTypes.ServerGroupValidationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverGroupId
        case serverValidationConfigurations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverGroupId = self.serverGroupId {
            try encodeContainer.encode(serverGroupId, forKey: .serverGroupId)
        }
        if let serverValidationConfigurations = serverValidationConfigurations {
            var serverValidationConfigurationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serverValidationConfigurations)
            for servervalidationconfiguration0 in serverValidationConfigurations {
                try serverValidationConfigurationsContainer.encode(servervalidationconfiguration0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverGroupId)
        serverGroupId = serverGroupIdDecoded
        let serverValidationConfigurationsContainer = try containerValues.decodeIfPresent([SMSClientTypes.ServerValidationConfiguration?].self, forKey: .serverValidationConfigurations)
        var serverValidationConfigurationsDecoded0:[SMSClientTypes.ServerValidationConfiguration]? = nil
        if let serverValidationConfigurationsContainer = serverValidationConfigurationsContainer {
            serverValidationConfigurationsDecoded0 = [SMSClientTypes.ServerValidationConfiguration]()
            for structure0 in serverValidationConfigurationsContainer {
                if let structure0 = structure0 {
                    serverValidationConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        serverValidationConfigurations = serverValidationConfigurationsDecoded0
    }
}

extension SMSClientTypes {
    /// Configuration for validating an instance.
    public struct ServerGroupValidationConfiguration: Swift.Equatable {
        /// The ID of the server group.
        public var serverGroupId: Swift.String?
        /// The validation configuration.
        public var serverValidationConfigurations: [SMSClientTypes.ServerValidationConfiguration]?

        public init(
            serverGroupId: Swift.String? = nil,
            serverValidationConfigurations: [SMSClientTypes.ServerValidationConfiguration]? = nil
        )
        {
            self.serverGroupId = serverGroupId
            self.serverValidationConfigurations = serverValidationConfigurations
        }
    }

}

extension SMSClientTypes.ServerLaunchConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatePublicIpAddress
        case configureScript
        case configureScriptType
        case ec2KeyName
        case iamInstanceProfileName
        case instanceType
        case logicalId
        case securityGroup
        case server
        case subnet
        case userData
        case vpc
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associatePublicIpAddress = self.associatePublicIpAddress {
            try encodeContainer.encode(associatePublicIpAddress, forKey: .associatePublicIpAddress)
        }
        if let configureScript = self.configureScript {
            try encodeContainer.encode(configureScript, forKey: .configureScript)
        }
        if let configureScriptType = self.configureScriptType {
            try encodeContainer.encode(configureScriptType.rawValue, forKey: .configureScriptType)
        }
        if let ec2KeyName = self.ec2KeyName {
            try encodeContainer.encode(ec2KeyName, forKey: .ec2KeyName)
        }
        if let iamInstanceProfileName = self.iamInstanceProfileName {
            try encodeContainer.encode(iamInstanceProfileName, forKey: .iamInstanceProfileName)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let logicalId = self.logicalId {
            try encodeContainer.encode(logicalId, forKey: .logicalId)
        }
        if let securityGroup = self.securityGroup {
            try encodeContainer.encode(securityGroup, forKey: .securityGroup)
        }
        if let server = self.server {
            try encodeContainer.encode(server, forKey: .server)
        }
        if let subnet = self.subnet {
            try encodeContainer.encode(subnet, forKey: .subnet)
        }
        if let userData = self.userData {
            try encodeContainer.encode(userData, forKey: .userData)
        }
        if let vpc = self.vpc {
            try encodeContainer.encode(vpc, forKey: .vpc)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(SMSClientTypes.Server.self, forKey: .server)
        server = serverDecoded
        let logicalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logicalId)
        logicalId = logicalIdDecoded
        let vpcDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpc)
        vpc = vpcDecoded
        let subnetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnet)
        subnet = subnetDecoded
        let securityGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .securityGroup)
        securityGroup = securityGroupDecoded
        let ec2KeyNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2KeyName)
        ec2KeyName = ec2KeyNameDecoded
        let userDataDecoded = try containerValues.decodeIfPresent(SMSClientTypes.UserData.self, forKey: .userData)
        userData = userDataDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let associatePublicIpAddressDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associatePublicIpAddress)
        associatePublicIpAddress = associatePublicIpAddressDecoded
        let iamInstanceProfileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iamInstanceProfileName)
        iamInstanceProfileName = iamInstanceProfileNameDecoded
        let configureScriptDecoded = try containerValues.decodeIfPresent(SMSClientTypes.S3Location.self, forKey: .configureScript)
        configureScript = configureScriptDecoded
        let configureScriptTypeDecoded = try containerValues.decodeIfPresent(SMSClientTypes.ScriptType.self, forKey: .configureScriptType)
        configureScriptType = configureScriptTypeDecoded
    }
}

extension SMSClientTypes {
    /// Launch configuration for a server.
    public struct ServerLaunchConfiguration: Swift.Equatable {
        /// Indicates whether a publicly accessible IP address is created when launching the server.
        public var associatePublicIpAddress: Swift.Bool?
        /// Location of an Amazon S3 object.
        public var configureScript: SMSClientTypes.S3Location?
        /// The type of configuration script.
        public var configureScriptType: SMSClientTypes.ScriptType?
        /// The name of the Amazon EC2 SSH key to be used for connecting to the launched server.
        public var ec2KeyName: Swift.String?
        /// The name of the IAM instance profile.
        public var iamInstanceProfileName: Swift.String?
        /// The instance type to use when launching the server.
        public var instanceType: Swift.String?
        /// The logical ID of the server in the CloudFormation template.
        public var logicalId: Swift.String?
        /// The ID of the security group that applies to the launched server.
        public var securityGroup: Swift.String?
        /// The ID of the server with which the launch configuration is associated.
        public var server: SMSClientTypes.Server?
        /// The ID of the subnet the server should be launched into.
        public var subnet: Swift.String?
        /// Location of the user-data script to be executed when launching the server.
        public var userData: SMSClientTypes.UserData?
        /// The ID of the VPC into which the server should be launched.
        public var vpc: Swift.String?

        public init(
            associatePublicIpAddress: Swift.Bool? = nil,
            configureScript: SMSClientTypes.S3Location? = nil,
            configureScriptType: SMSClientTypes.ScriptType? = nil,
            ec2KeyName: Swift.String? = nil,
            iamInstanceProfileName: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            logicalId: Swift.String? = nil,
            securityGroup: Swift.String? = nil,
            server: SMSClientTypes.Server? = nil,
            subnet: Swift.String? = nil,
            userData: SMSClientTypes.UserData? = nil,
            vpc: Swift.String? = nil
        )
        {
            self.associatePublicIpAddress = associatePublicIpAddress
            self.configureScript = configureScript
            self.configureScriptType = configureScriptType
            self.ec2KeyName = ec2KeyName
            self.iamInstanceProfileName = iamInstanceProfileName
            self.instanceType = instanceType
            self.logicalId = logicalId
            self.securityGroup = securityGroup
            self.server = server
            self.subnet = subnet
            self.userData = userData
            self.vpc = vpc
        }
    }

}

extension SMSClientTypes.ServerReplicationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case server
        case serverReplicationParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let server = self.server {
            try encodeContainer.encode(server, forKey: .server)
        }
        if let serverReplicationParameters = self.serverReplicationParameters {
            try encodeContainer.encode(serverReplicationParameters, forKey: .serverReplicationParameters)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(SMSClientTypes.Server.self, forKey: .server)
        server = serverDecoded
        let serverReplicationParametersDecoded = try containerValues.decodeIfPresent(SMSClientTypes.ServerReplicationParameters.self, forKey: .serverReplicationParameters)
        serverReplicationParameters = serverReplicationParametersDecoded
    }
}

extension SMSClientTypes {
    /// Replication configuration of a server.
    public struct ServerReplicationConfiguration: Swift.Equatable {
        /// The ID of the server with which this replication configuration is associated.
        public var server: SMSClientTypes.Server?
        /// The parameters for replicating the server.
        public var serverReplicationParameters: SMSClientTypes.ServerReplicationParameters?

        public init(
            server: SMSClientTypes.Server? = nil,
            serverReplicationParameters: SMSClientTypes.ServerReplicationParameters? = nil
        )
        {
            self.server = server
            self.serverReplicationParameters = serverReplicationParameters
        }
    }

}

extension SMSClientTypes.ServerReplicationParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encrypted
        case frequency
        case kmsKeyId
        case licenseType
        case numberOfRecentAmisToKeep
        case runOnce
        case seedTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encrypted = self.encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let frequency = self.frequency {
            try encodeContainer.encode(frequency, forKey: .frequency)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let licenseType = self.licenseType {
            try encodeContainer.encode(licenseType.rawValue, forKey: .licenseType)
        }
        if let numberOfRecentAmisToKeep = self.numberOfRecentAmisToKeep {
            try encodeContainer.encode(numberOfRecentAmisToKeep, forKey: .numberOfRecentAmisToKeep)
        }
        if let runOnce = self.runOnce {
            try encodeContainer.encode(runOnce, forKey: .runOnce)
        }
        if let seedTime = self.seedTime {
            try encodeContainer.encodeTimestamp(seedTime, format: .epochSeconds, forKey: .seedTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let seedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .seedTime)
        seedTime = seedTimeDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .frequency)
        frequency = frequencyDecoded
        let runOnceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .runOnce)
        runOnce = runOnceDecoded
        let licenseTypeDecoded = try containerValues.decodeIfPresent(SMSClientTypes.LicenseType.self, forKey: .licenseType)
        licenseType = licenseTypeDecoded
        let numberOfRecentAmisToKeepDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRecentAmisToKeep)
        numberOfRecentAmisToKeep = numberOfRecentAmisToKeepDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension SMSClientTypes {
    /// The replication parameters for replicating a server.
    public struct ServerReplicationParameters: Swift.Equatable {
        /// Indicates whether the replication job produces encrypted AMIs.
        public var encrypted: Swift.Bool?
        /// The frequency of creating replication jobs for the server.
        public var frequency: Swift.Int?
        /// The ID of the KMS key for replication jobs that produce encrypted AMIs. This value can be any of the following:
        ///
        /// * KMS key ID
        ///
        /// * KMS key alias
        ///
        /// * ARN referring to the KMS key ID
        ///
        /// * ARN referring to the KMS key alias
        ///
        ///
        /// If encrypted is enabled but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
        public var kmsKeyId: Swift.String?
        /// The license type for creating a replication job for the server.
        public var licenseType: SMSClientTypes.LicenseType?
        /// The number of recent AMIs to keep when creating a replication job for this server.
        public var numberOfRecentAmisToKeep: Swift.Int?
        /// Indicates whether to run the replication job one time.
        public var runOnce: Swift.Bool?
        /// The seed time for creating a replication job for the server.
        public var seedTime: ClientRuntime.Date?

        public init(
            encrypted: Swift.Bool? = nil,
            frequency: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            licenseType: SMSClientTypes.LicenseType? = nil,
            numberOfRecentAmisToKeep: Swift.Int? = nil,
            runOnce: Swift.Bool? = nil,
            seedTime: ClientRuntime.Date? = nil
        )
        {
            self.encrypted = encrypted
            self.frequency = frequency
            self.kmsKeyId = kmsKeyId
            self.licenseType = licenseType
            self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
            self.runOnce = runOnce
            self.seedTime = seedTime
        }
    }

}

extension SMSClientTypes {
    public enum ServerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case virtualmachine
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerType] {
            return [
                .virtualmachine,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .virtualmachine: return "VIRTUAL_MACHINE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServerType(rawValue: rawValue) ?? ServerType.sdkUnknown(rawValue)
        }
    }
}

extension SMSClientTypes.ServerValidationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case server
        case serverValidationStrategy
        case userDataValidationParameters
        case validationId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let server = self.server {
            try encodeContainer.encode(server, forKey: .server)
        }
        if let serverValidationStrategy = self.serverValidationStrategy {
            try encodeContainer.encode(serverValidationStrategy.rawValue, forKey: .serverValidationStrategy)
        }
        if let userDataValidationParameters = self.userDataValidationParameters {
            try encodeContainer.encode(userDataValidationParameters, forKey: .userDataValidationParameters)
        }
        if let validationId = self.validationId {
            try encodeContainer.encode(validationId, forKey: .validationId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(SMSClientTypes.Server.self, forKey: .server)
        server = serverDecoded
        let validationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validationId)
        validationId = validationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let serverValidationStrategyDecoded = try containerValues.decodeIfPresent(SMSClientTypes.ServerValidationStrategy.self, forKey: .serverValidationStrategy)
        serverValidationStrategy = serverValidationStrategyDecoded
        let userDataValidationParametersDecoded = try containerValues.decodeIfPresent(SMSClientTypes.UserDataValidationParameters.self, forKey: .userDataValidationParameters)
        userDataValidationParameters = userDataValidationParametersDecoded
    }
}

extension SMSClientTypes {
    /// Configuration for validating an instance.
    public struct ServerValidationConfiguration: Swift.Equatable {
        /// The name of the configuration.
        public var name: Swift.String?
        /// Represents a server.
        public var server: SMSClientTypes.Server?
        /// The validation strategy.
        public var serverValidationStrategy: SMSClientTypes.ServerValidationStrategy?
        /// The validation parameters.
        public var userDataValidationParameters: SMSClientTypes.UserDataValidationParameters?
        /// The ID of the validation.
        public var validationId: Swift.String?

        public init(
            name: Swift.String? = nil,
            server: SMSClientTypes.Server? = nil,
            serverValidationStrategy: SMSClientTypes.ServerValidationStrategy? = nil,
            userDataValidationParameters: SMSClientTypes.UserDataValidationParameters? = nil,
            validationId: Swift.String? = nil
        )
        {
            self.name = name
            self.server = server
            self.serverValidationStrategy = serverValidationStrategy
            self.userDataValidationParameters = userDataValidationParameters
            self.validationId = validationId
        }
    }

}

extension SMSClientTypes.ServerValidationOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case server
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let server = self.server {
            try encodeContainer.encode(server, forKey: .server)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverDecoded = try containerValues.decodeIfPresent(SMSClientTypes.Server.self, forKey: .server)
        server = serverDecoded
    }
}

extension SMSClientTypes {
    /// Contains output from validating an instance.
    public struct ServerValidationOutput: Swift.Equatable {
        /// Represents a server.
        public var server: SMSClientTypes.Server?

        public init(
            server: SMSClientTypes.Server? = nil
        )
        {
            self.server = server
        }
    }

}

extension SMSClientTypes {
    public enum ServerValidationStrategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case userdata
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerValidationStrategy] {
            return [
                .userdata,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .userdata: return "USERDATA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServerValidationStrategy(rawValue: rawValue) ?? ServerValidationStrategy.sdkUnknown(rawValue)
        }
    }
}

extension SMSClientTypes.Source: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Location
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = self.s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationDecoded = try containerValues.decodeIfPresent(SMSClientTypes.S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension SMSClientTypes {
    /// Contains the location of a validation script.
    public struct Source: Swift.Equatable {
        /// Location of an Amazon S3 object.
        public var s3Location: SMSClientTypes.S3Location?

        public init(
            s3Location: SMSClientTypes.S3Location? = nil
        )
        {
            self.s3Location = s3Location
        }
    }

}

extension StartAppReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

extension StartAppReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartAppReplicationInput: Swift.Equatable {
    /// The ID of the application.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct StartAppReplicationInputBody: Swift.Equatable {
    let appId: Swift.String?
}

extension StartAppReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension StartAppReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartAppReplicationOutput: Swift.Equatable {

    public init() { }
}

enum StartAppReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartOnDemandAppReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension StartOnDemandAppReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartOnDemandAppReplicationInput: Swift.Equatable {
    /// The ID of the application.
    /// This member is required.
    public var appId: Swift.String?
    /// The description of the replication run.
    public var description: Swift.String?

    public init(
        appId: Swift.String? = nil,
        description: Swift.String? = nil
    )
    {
        self.appId = appId
        self.description = description
    }
}

struct StartOnDemandAppReplicationInputBody: Swift.Equatable {
    let appId: Swift.String?
    let description: Swift.String?
}

extension StartOnDemandAppReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension StartOnDemandAppReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StartOnDemandAppReplicationOutput: Swift.Equatable {

    public init() { }
}

enum StartOnDemandAppReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartOnDemandReplicationRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case replicationJobId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let replicationJobId = self.replicationJobId {
            try encodeContainer.encode(replicationJobId, forKey: .replicationJobId)
        }
    }
}

extension StartOnDemandReplicationRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartOnDemandReplicationRunInput: Swift.Equatable {
    /// The description of the replication run.
    public var description: Swift.String?
    /// The ID of the replication job.
    /// This member is required.
    public var replicationJobId: Swift.String?

    public init(
        description: Swift.String? = nil,
        replicationJobId: Swift.String? = nil
    )
    {
        self.description = description
        self.replicationJobId = replicationJobId
    }
}

struct StartOnDemandReplicationRunInputBody: Swift.Equatable {
    let replicationJobId: Swift.String?
    let description: Swift.String?
}

extension StartOnDemandReplicationRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case replicationJobId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationJobId)
        replicationJobId = replicationJobIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension StartOnDemandReplicationRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartOnDemandReplicationRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationRunId = output.replicationRunId
        } else {
            self.replicationRunId = nil
        }
    }
}

public struct StartOnDemandReplicationRunOutput: Swift.Equatable {
    /// The ID of the replication run.
    public var replicationRunId: Swift.String?

    public init(
        replicationRunId: Swift.String? = nil
    )
    {
        self.replicationRunId = replicationRunId
    }
}

struct StartOnDemandReplicationRunOutputBody: Swift.Equatable {
    let replicationRunId: Swift.String?
}

extension StartOnDemandReplicationRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationRunId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationRunId)
        replicationRunId = replicationRunIdDecoded
    }
}

enum StartOnDemandReplicationRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "DryRunOperationException": return try await DryRunOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplicationRunLimitExceeded": return try await ReplicationRunLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopAppReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

extension StopAppReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StopAppReplicationInput: Swift.Equatable {
    /// The ID of the application.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct StopAppReplicationInputBody: Swift.Equatable {
    let appId: Swift.String?
}

extension StopAppReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension StopAppReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopAppReplicationOutput: Swift.Equatable {

    public init() { }
}

enum StopAppReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SMSClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SMSClientTypes {
    /// Key/value pair that can be assigned to an application.
    public struct Tag: Swift.Equatable {
        /// The tag key.
        public var key: Swift.String?
        /// The tag value.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TemporarilyUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service is temporarily unavailable.
public struct TemporarilyUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "TemporarilyUnavailable" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

extension TerminateAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
    }
}

extension TerminateAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TerminateAppInput: Swift.Equatable {
    /// The ID of the application.
    public var appId: Swift.String?

    public init(
        appId: Swift.String? = nil
    )
    {
        self.appId = appId
    }
}

struct TerminateAppInputBody: Swift.Equatable {
    let appId: Swift.String?
}

extension TerminateAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
    }
}

extension TerminateAppOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TerminateAppOutput: Swift.Equatable {

    public init() { }
}

enum TerminateAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UnauthorizedOperationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You lack permissions needed to perform this operation. Check your IAM policies, and ensure that you are using the correct access keys.
public struct UnauthorizedOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedOperation" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnauthorizedOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateAppInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case description
        case name
        case roleName
        case serverGroups
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleName = self.roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
        if let serverGroups = serverGroups {
            var serverGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .serverGroups)
            for servergroup0 in serverGroups {
                try serverGroupsContainer.encode(servergroup0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension UpdateAppInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateAppInput: Swift.Equatable {
    /// The ID of the application.
    public var appId: Swift.String?
    /// The new description of the application.
    public var description: Swift.String?
    /// The new name of the application.
    public var name: Swift.String?
    /// The name of the service role in the customer's account used by Server Migration Service.
    public var roleName: Swift.String?
    /// The server groups in the application to update.
    public var serverGroups: [SMSClientTypes.ServerGroup]?
    /// The tags to associate with the application.
    public var tags: [SMSClientTypes.Tag]?

    public init(
        appId: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        roleName: Swift.String? = nil,
        serverGroups: [SMSClientTypes.ServerGroup]? = nil,
        tags: [SMSClientTypes.Tag]? = nil
    )
    {
        self.appId = appId
        self.description = description
        self.name = name
        self.roleName = roleName
        self.serverGroups = serverGroups
        self.tags = tags
    }
}

struct UpdateAppInputBody: Swift.Equatable {
    let appId: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let roleName: Swift.String?
    let serverGroups: [SMSClientTypes.ServerGroup]?
    let tags: [SMSClientTypes.Tag]?
}

extension UpdateAppInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case description
        case name
        case roleName
        case serverGroups
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let serverGroupsContainer = try containerValues.decodeIfPresent([SMSClientTypes.ServerGroup?].self, forKey: .serverGroups)
        var serverGroupsDecoded0:[SMSClientTypes.ServerGroup]? = nil
        if let serverGroupsContainer = serverGroupsContainer {
            serverGroupsDecoded0 = [SMSClientTypes.ServerGroup]()
            for structure0 in serverGroupsContainer {
                if let structure0 = structure0 {
                    serverGroupsDecoded0?.append(structure0)
                }
            }
        }
        serverGroups = serverGroupsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([SMSClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SMSClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SMSClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension UpdateAppOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAppOutputBody = try responseDecoder.decode(responseBody: data)
            self.appSummary = output.appSummary
            self.serverGroups = output.serverGroups
            self.tags = output.tags
        } else {
            self.appSummary = nil
            self.serverGroups = nil
            self.tags = nil
        }
    }
}

public struct UpdateAppOutput: Swift.Equatable {
    /// A summary description of the application.
    public var appSummary: SMSClientTypes.AppSummary?
    /// The updated server groups in the application.
    public var serverGroups: [SMSClientTypes.ServerGroup]?
    /// The tags associated with the application.
    public var tags: [SMSClientTypes.Tag]?

    public init(
        appSummary: SMSClientTypes.AppSummary? = nil,
        serverGroups: [SMSClientTypes.ServerGroup]? = nil,
        tags: [SMSClientTypes.Tag]? = nil
    )
    {
        self.appSummary = appSummary
        self.serverGroups = serverGroups
        self.tags = tags
    }
}

struct UpdateAppOutputBody: Swift.Equatable {
    let appSummary: SMSClientTypes.AppSummary?
    let serverGroups: [SMSClientTypes.ServerGroup]?
    let tags: [SMSClientTypes.Tag]?
}

extension UpdateAppOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appSummary
        case serverGroups
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appSummaryDecoded = try containerValues.decodeIfPresent(SMSClientTypes.AppSummary.self, forKey: .appSummary)
        appSummary = appSummaryDecoded
        let serverGroupsContainer = try containerValues.decodeIfPresent([SMSClientTypes.ServerGroup?].self, forKey: .serverGroups)
        var serverGroupsDecoded0:[SMSClientTypes.ServerGroup]? = nil
        if let serverGroupsContainer = serverGroupsContainer {
            serverGroupsDecoded0 = [SMSClientTypes.ServerGroup]()
            for structure0 in serverGroupsContainer {
                if let structure0 = structure0 {
                    serverGroupsDecoded0?.append(structure0)
                }
            }
        }
        serverGroups = serverGroupsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([SMSClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SMSClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SMSClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum UpdateAppOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateReplicationJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case encrypted
        case frequency
        case kmsKeyId
        case licenseType
        case nextReplicationRunStartTime
        case numberOfRecentAmisToKeep
        case replicationJobId
        case roleName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let encrypted = self.encrypted {
            try encodeContainer.encode(encrypted, forKey: .encrypted)
        }
        if let frequency = self.frequency {
            try encodeContainer.encode(frequency, forKey: .frequency)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let licenseType = self.licenseType {
            try encodeContainer.encode(licenseType.rawValue, forKey: .licenseType)
        }
        if let nextReplicationRunStartTime = self.nextReplicationRunStartTime {
            try encodeContainer.encodeTimestamp(nextReplicationRunStartTime, format: .epochSeconds, forKey: .nextReplicationRunStartTime)
        }
        if let numberOfRecentAmisToKeep = self.numberOfRecentAmisToKeep {
            try encodeContainer.encode(numberOfRecentAmisToKeep, forKey: .numberOfRecentAmisToKeep)
        }
        if let replicationJobId = self.replicationJobId {
            try encodeContainer.encode(replicationJobId, forKey: .replicationJobId)
        }
        if let roleName = self.roleName {
            try encodeContainer.encode(roleName, forKey: .roleName)
        }
    }
}

extension UpdateReplicationJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateReplicationJobInput: Swift.Equatable {
    /// The description of the replication job.
    public var description: Swift.String?
    /// When true, the replication job produces encrypted AMIs. For more information, KmsKeyId.
    public var encrypted: Swift.Bool?
    /// The time between consecutive replication runs, in hours.
    public var frequency: Swift.Int?
    /// The ID of the KMS key for replication jobs that produce encrypted AMIs. This value can be any of the following:
    ///
    /// * KMS key ID
    ///
    /// * KMS key alias
    ///
    /// * ARN referring to the KMS key ID
    ///
    /// * ARN referring to the KMS key alias
    ///
    ///
    /// If encrypted is enabled but a KMS key ID is not specified, the customer's default KMS key for Amazon EBS is used.
    public var kmsKeyId: Swift.String?
    /// The license type to be used for the AMI created by a successful replication run.
    public var licenseType: SMSClientTypes.LicenseType?
    /// The start time of the next replication run.
    public var nextReplicationRunStartTime: ClientRuntime.Date?
    /// The maximum number of SMS-created AMIs to retain. The oldest is deleted after the maximum number is reached and a new AMI is created.
    public var numberOfRecentAmisToKeep: Swift.Int?
    /// The ID of the replication job.
    /// This member is required.
    public var replicationJobId: Swift.String?
    /// The name of the IAM role to be used by Server Migration Service.
    public var roleName: Swift.String?

    public init(
        description: Swift.String? = nil,
        encrypted: Swift.Bool? = nil,
        frequency: Swift.Int? = nil,
        kmsKeyId: Swift.String? = nil,
        licenseType: SMSClientTypes.LicenseType? = nil,
        nextReplicationRunStartTime: ClientRuntime.Date? = nil,
        numberOfRecentAmisToKeep: Swift.Int? = nil,
        replicationJobId: Swift.String? = nil,
        roleName: Swift.String? = nil
    )
    {
        self.description = description
        self.encrypted = encrypted
        self.frequency = frequency
        self.kmsKeyId = kmsKeyId
        self.licenseType = licenseType
        self.nextReplicationRunStartTime = nextReplicationRunStartTime
        self.numberOfRecentAmisToKeep = numberOfRecentAmisToKeep
        self.replicationJobId = replicationJobId
        self.roleName = roleName
    }
}

struct UpdateReplicationJobInputBody: Swift.Equatable {
    let replicationJobId: Swift.String?
    let frequency: Swift.Int?
    let nextReplicationRunStartTime: ClientRuntime.Date?
    let licenseType: SMSClientTypes.LicenseType?
    let roleName: Swift.String?
    let description: Swift.String?
    let numberOfRecentAmisToKeep: Swift.Int?
    let encrypted: Swift.Bool?
    let kmsKeyId: Swift.String?
}

extension UpdateReplicationJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case encrypted
        case frequency
        case kmsKeyId
        case licenseType
        case nextReplicationRunStartTime
        case numberOfRecentAmisToKeep
        case replicationJobId
        case roleName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationJobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationJobId)
        replicationJobId = replicationJobIdDecoded
        let frequencyDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .frequency)
        frequency = frequencyDecoded
        let nextReplicationRunStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .nextReplicationRunStartTime)
        nextReplicationRunStartTime = nextReplicationRunStartTimeDecoded
        let licenseTypeDecoded = try containerValues.decodeIfPresent(SMSClientTypes.LicenseType.self, forKey: .licenseType)
        licenseType = licenseTypeDecoded
        let roleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleName)
        roleName = roleNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let numberOfRecentAmisToKeepDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRecentAmisToKeep)
        numberOfRecentAmisToKeep = numberOfRecentAmisToKeepDecoded
        let encryptedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .encrypted)
        encrypted = encryptedDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension UpdateReplicationJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateReplicationJobOutput: Swift.Equatable {

    public init() { }
}

enum UpdateReplicationJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalError": return try await InternalError(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameter": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "MissingRequiredParameter": return try await MissingRequiredParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "OperationNotPermitted": return try await OperationNotPermittedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReplicationJobNotFound": return try await ReplicationJobNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerCannotBeReplicated": return try await ServerCannotBeReplicatedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TemporarilyUnavailable": return try await TemporarilyUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedOperation": return try await UnauthorizedOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SMSClientTypes.UserData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Location
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Location = self.s3Location {
            try encodeContainer.encode(s3Location, forKey: .s3Location)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LocationDecoded = try containerValues.decodeIfPresent(SMSClientTypes.S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension SMSClientTypes {
    /// A script that runs on first launch of an Amazon EC2 instance. Used for configuring the server during launch.
    public struct UserData: Swift.Equatable {
        /// Amazon S3 location of the user-data script.
        public var s3Location: SMSClientTypes.S3Location?

        public init(
            s3Location: SMSClientTypes.S3Location? = nil
        )
        {
            self.s3Location = s3Location
        }
    }

}

extension SMSClientTypes.UserDataValidationParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scriptType
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scriptType = self.scriptType {
            try encodeContainer.encode(scriptType.rawValue, forKey: .scriptType)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceDecoded = try containerValues.decodeIfPresent(SMSClientTypes.Source.self, forKey: .source)
        source = sourceDecoded
        let scriptTypeDecoded = try containerValues.decodeIfPresent(SMSClientTypes.ScriptType.self, forKey: .scriptType)
        scriptType = scriptTypeDecoded
    }
}

extension SMSClientTypes {
    /// Contains validation parameters.
    public struct UserDataValidationParameters: Swift.Equatable {
        /// The type of validation script.
        public var scriptType: SMSClientTypes.ScriptType?
        /// The location of the validation script.
        public var source: SMSClientTypes.Source?

        public init(
            scriptType: SMSClientTypes.ScriptType? = nil,
            source: SMSClientTypes.Source? = nil
        )
        {
            self.scriptType = scriptType
            self.source = source
        }
    }

}

extension SMSClientTypes.ValidationOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appValidationOutput
        case latestValidationTime
        case name
        case serverValidationOutput
        case status
        case statusMessage
        case validationId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appValidationOutput = self.appValidationOutput {
            try encodeContainer.encode(appValidationOutput, forKey: .appValidationOutput)
        }
        if let latestValidationTime = self.latestValidationTime {
            try encodeContainer.encodeTimestamp(latestValidationTime, format: .epochSeconds, forKey: .latestValidationTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let serverValidationOutput = self.serverValidationOutput {
            try encodeContainer.encode(serverValidationOutput, forKey: .serverValidationOutput)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let validationId = self.validationId {
            try encodeContainer.encode(validationId, forKey: .validationId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .validationId)
        validationId = validationIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SMSClientTypes.ValidationStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let latestValidationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .latestValidationTime)
        latestValidationTime = latestValidationTimeDecoded
        let appValidationOutputDecoded = try containerValues.decodeIfPresent(SMSClientTypes.AppValidationOutput.self, forKey: .appValidationOutput)
        appValidationOutput = appValidationOutputDecoded
        let serverValidationOutputDecoded = try containerValues.decodeIfPresent(SMSClientTypes.ServerValidationOutput.self, forKey: .serverValidationOutput)
        serverValidationOutput = serverValidationOutputDecoded
    }
}

extension SMSClientTypes {
    /// Contains validation output.
    public struct ValidationOutput: Swift.Equatable {
        /// The output from validating an application.
        public var appValidationOutput: SMSClientTypes.AppValidationOutput?
        /// The latest time that the validation was performed.
        public var latestValidationTime: ClientRuntime.Date?
        /// The name of the validation.
        public var name: Swift.String?
        /// The output from validation an instance.
        public var serverValidationOutput: SMSClientTypes.ServerValidationOutput?
        /// The status of the validation.
        public var status: SMSClientTypes.ValidationStatus?
        /// The status message.
        public var statusMessage: Swift.String?
        /// The ID of the validation.
        public var validationId: Swift.String?

        public init(
            appValidationOutput: SMSClientTypes.AppValidationOutput? = nil,
            latestValidationTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            serverValidationOutput: SMSClientTypes.ServerValidationOutput? = nil,
            status: SMSClientTypes.ValidationStatus? = nil,
            statusMessage: Swift.String? = nil,
            validationId: Swift.String? = nil
        )
        {
            self.appValidationOutput = appValidationOutput
            self.latestValidationTime = latestValidationTime
            self.name = name
            self.serverValidationOutput = serverValidationOutput
            self.status = status
            self.statusMessage = statusMessage
            self.validationId = validationId
        }
    }

}

extension SMSClientTypes {
    public enum ValidationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inprogress
        case pending
        case readyforvalidation
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationStatus] {
            return [
                .failed,
                .inprogress,
                .pending,
                .readyforvalidation,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inprogress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .readyforvalidation: return "READY_FOR_VALIDATION"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationStatus(rawValue: rawValue) ?? ValidationStatus.sdkUnknown(rawValue)
        }
    }
}

extension SMSClientTypes {
    public enum VmManagerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hypervmanager
        case scvmm
        case vsphere
        case sdkUnknown(Swift.String)

        public static var allCases: [VmManagerType] {
            return [
                .hypervmanager,
                .scvmm,
                .vsphere,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hypervmanager: return "HYPERV-MANAGER"
            case .scvmm: return "SCVMM"
            case .vsphere: return "VSPHERE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VmManagerType(rawValue: rawValue) ?? VmManagerType.sdkUnknown(rawValue)
        }
    }
}

extension SMSClientTypes.VmServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vmManagerName
        case vmManagerType
        case vmName
        case vmPath
        case vmServerAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vmManagerName = self.vmManagerName {
            try encodeContainer.encode(vmManagerName, forKey: .vmManagerName)
        }
        if let vmManagerType = self.vmManagerType {
            try encodeContainer.encode(vmManagerType.rawValue, forKey: .vmManagerType)
        }
        if let vmName = self.vmName {
            try encodeContainer.encode(vmName, forKey: .vmName)
        }
        if let vmPath = self.vmPath {
            try encodeContainer.encode(vmPath, forKey: .vmPath)
        }
        if let vmServerAddress = self.vmServerAddress {
            try encodeContainer.encode(vmServerAddress, forKey: .vmServerAddress)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vmServerAddressDecoded = try containerValues.decodeIfPresent(SMSClientTypes.VmServerAddress.self, forKey: .vmServerAddress)
        vmServerAddress = vmServerAddressDecoded
        let vmNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmName)
        vmName = vmNameDecoded
        let vmManagerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmManagerName)
        vmManagerName = vmManagerNameDecoded
        let vmManagerTypeDecoded = try containerValues.decodeIfPresent(SMSClientTypes.VmManagerType.self, forKey: .vmManagerType)
        vmManagerType = vmManagerTypeDecoded
        let vmPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmPath)
        vmPath = vmPathDecoded
    }
}

extension SMSClientTypes {
    /// Represents a VM server.
    public struct VmServer: Swift.Equatable {
        /// The name of the VM manager.
        public var vmManagerName: Swift.String?
        /// The type of VM management product.
        public var vmManagerType: SMSClientTypes.VmManagerType?
        /// The name of the VM.
        public var vmName: Swift.String?
        /// The VM folder path in the vCenter Server virtual machine inventory tree.
        public var vmPath: Swift.String?
        /// The VM server location.
        public var vmServerAddress: SMSClientTypes.VmServerAddress?

        public init(
            vmManagerName: Swift.String? = nil,
            vmManagerType: SMSClientTypes.VmManagerType? = nil,
            vmName: Swift.String? = nil,
            vmPath: Swift.String? = nil,
            vmServerAddress: SMSClientTypes.VmServerAddress? = nil
        )
        {
            self.vmManagerName = vmManagerName
            self.vmManagerType = vmManagerType
            self.vmName = vmName
            self.vmPath = vmPath
            self.vmServerAddress = vmServerAddress
        }
    }

}

extension SMSClientTypes.VmServerAddress: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case vmId
        case vmManagerId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let vmId = self.vmId {
            try encodeContainer.encode(vmId, forKey: .vmId)
        }
        if let vmManagerId = self.vmManagerId {
            try encodeContainer.encode(vmManagerId, forKey: .vmManagerId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vmManagerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmManagerId)
        vmManagerId = vmManagerIdDecoded
        let vmIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmId)
        vmId = vmIdDecoded
    }
}

extension SMSClientTypes {
    /// Represents a VM server location.
    public struct VmServerAddress: Swift.Equatable {
        /// The ID of the VM.
        public var vmId: Swift.String?
        /// The ID of the VM manager.
        public var vmManagerId: Swift.String?

        public init(
            vmId: Swift.String? = nil,
            vmManagerId: Swift.String? = nil
        )
        {
            self.vmId = vmId
            self.vmManagerId = vmManagerId
        }
    }

}
