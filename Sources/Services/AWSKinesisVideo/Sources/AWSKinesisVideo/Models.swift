//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// You do not have required permissions to perform this operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have reached the maximum limit of active signaling channels for this Amazon Web Services account in this region.
public struct AccountChannelLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccountChannelLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of streams created for the account is too high.
public struct AccountStreamLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccountStreamLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KinesisVideoClientTypes {

    public enum APIName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case getClip
        case getDashStreamingSessionUrl
        case getHlsStreamingSessionUrl
        case getImages
        case getMedia
        case getMediaForFragmentList
        case listFragments
        case putMedia
        case sdkUnknown(Swift.String)

        public static var allCases: [APIName] {
            return [
                .getClip,
                .getDashStreamingSessionUrl,
                .getHlsStreamingSessionUrl,
                .getImages,
                .getMedia,
                .getMediaForFragmentList,
                .listFragments,
                .putMedia
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .getClip: return "GET_CLIP"
            case .getDashStreamingSessionUrl: return "GET_DASH_STREAMING_SESSION_URL"
            case .getHlsStreamingSessionUrl: return "GET_HLS_STREAMING_SESSION_URL"
            case .getImages: return "GET_IMAGES"
            case .getMedia: return "GET_MEDIA"
            case .getMediaForFragmentList: return "GET_MEDIA_FOR_FRAGMENT_LIST"
            case .listFragments: return "LIST_FRAGMENTS"
            case .putMedia: return "PUT_MEDIA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisVideoClientTypes {

    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .active,
                .creating,
                .deleting,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisVideoClientTypes {

    public enum ChannelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fullMesh
        case singleMaster
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelType] {
            return [
                .fullMesh,
                .singleMaster
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fullMesh: return "FULL_MESH"
            case .singleMaster: return "SINGLE_MASTER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisVideoClientTypes {
    /// A structure that contains the configuration for the SINGLE_MASTER channel type.
    public struct SingleMasterConfiguration {
        /// The period of time a signaling channel retains undelivered messages before they are discarded.
        public var messageTtlSeconds: Swift.Int?

        public init(
            messageTtlSeconds: Swift.Int? = nil
        )
        {
            self.messageTtlSeconds = messageTtlSeconds
        }
    }

}

extension KinesisVideoClientTypes {
    /// A structure that encapsulates a signaling channel's metadata and properties.
    public struct ChannelInfo {
        /// The Amazon Resource Name (ARN) of the signaling channel.
        public var channelARN: Swift.String?
        /// The name of the signaling channel.
        public var channelName: Swift.String?
        /// Current status of the signaling channel.
        public var channelStatus: KinesisVideoClientTypes.Status?
        /// The type of the signaling channel.
        public var channelType: KinesisVideoClientTypes.ChannelType?
        /// The time at which the signaling channel was created.
        public var creationTime: Foundation.Date?
        /// A structure that contains the configuration for the SINGLE_MASTER channel type.
        public var singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration?
        /// The current version of the signaling channel.
        public var version: Swift.String?

        public init(
            channelARN: Swift.String? = nil,
            channelName: Swift.String? = nil,
            channelStatus: KinesisVideoClientTypes.Status? = nil,
            channelType: KinesisVideoClientTypes.ChannelType? = nil,
            creationTime: Foundation.Date? = nil,
            singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration? = nil,
            version: Swift.String? = nil
        )
        {
            self.channelARN = channelARN
            self.channelName = channelName
            self.channelStatus = channelStatus
            self.channelType = channelType
            self.creationTime = creationTime
            self.singleMasterConfiguration = singleMasterConfiguration
            self.version = version
        }
    }

}

extension KinesisVideoClientTypes {

    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case beginsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .beginsWith
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .beginsWith: return "BEGINS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisVideoClientTypes {
    /// An optional input parameter for the ListSignalingChannels API. When this parameter is specified while invoking ListSignalingChannels, the API returns only the channels that satisfy a condition specified in ChannelNameCondition.
    public struct ChannelNameCondition {
        /// A comparison operator. Currently, you can only specify the BEGINS_WITH operator, which finds signaling channels whose names begin with a given prefix.
        public var comparisonOperator: KinesisVideoClientTypes.ComparisonOperator?
        /// A value to compare.
        public var comparisonValue: Swift.String?

        public init(
            comparisonOperator: KinesisVideoClientTypes.ComparisonOperator? = nil,
            comparisonValue: Swift.String? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.comparisonValue = comparisonValue
        }
    }

}

extension KinesisVideoClientTypes {

    public enum ChannelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case https
        case webrtc
        case wss
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelProtocol] {
            return [
                .https,
                .webrtc,
                .wss
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .https: return "HTTPS"
            case .webrtc: return "WEBRTC"
            case .wss: return "WSS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisVideoClientTypes {

    public enum ChannelRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case master
        case viewer
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelRole] {
            return [
                .master,
                .viewer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .master: return "MASTER"
            case .viewer: return "VIEWER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Kinesis Video Streams has throttled the request because you have exceeded the limit of allowed client calls. Try making the call later.
public struct ClientLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ClientLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KinesisVideoClientTypes {

    public enum ConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The value for this input parameter is invalid.
public struct InvalidArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidArgumentException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// When the input StreamARN or ChannelARN in CLOUD_STORAGE_MODE is already mapped to a different Kinesis Video Stream resource, or if the provided input StreamARN or ChannelARN is not in Active status, try one of the following :
///
/// * The DescribeMediaStorageConfiguration API to determine what the stream given channel is mapped to.
///
/// * The DescribeMappedResourceConfiguration API to determine the channel that the given stream is mapped to.
///
/// * The DescribeStream or DescribeSignalingChannel API to determine the status of the resource.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You have exceeded the limit of tags that you can associate with the resource. A Kinesis video stream can support up to 50 tags.
public struct TagsPerResourceExceededLimitException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagsPerResourceExceededLimitException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension KinesisVideoClientTypes {
    /// A key and value pair that is associated with the specified signaling channel.
    public struct Tag {
        /// The key of the tag that is associated with the specified signaling channel.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag that is associated with the specified signaling channel.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

public struct CreateSignalingChannelInput {
    /// A name for the signaling channel that you are creating. It must be unique for each Amazon Web Services account and Amazon Web Services Region.
    /// This member is required.
    public var channelName: Swift.String?
    /// A type of the signaling channel that you are creating. Currently, SINGLE_MASTER is the only supported channel type.
    public var channelType: KinesisVideoClientTypes.ChannelType?
    /// A structure containing the configuration for the SINGLE_MASTER channel type.
    public var singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration?
    /// A set of tags (key-value pairs) that you want to associate with this channel.
    public var tags: [KinesisVideoClientTypes.Tag]?

    public init(
        channelName: Swift.String? = nil,
        channelType: KinesisVideoClientTypes.ChannelType? = nil,
        singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration? = nil,
        tags: [KinesisVideoClientTypes.Tag]? = nil
    )
    {
        self.channelName = channelName
        self.channelType = channelType
        self.singleMasterConfiguration = singleMasterConfiguration
        self.tags = tags
    }
}

public struct CreateSignalingChannelOutput {
    /// The Amazon Resource Name (ARN) of the created channel.
    public var channelARN: Swift.String?

    public init(
        channelARN: Swift.String? = nil
    )
    {
        self.channelARN = channelARN
    }
}

/// Not implemented.
public struct DeviceStreamLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeviceStreamLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Not implemented.
public struct InvalidDeviceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDeviceException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateStreamInput {
    /// The number of hours that you want to retain the data in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream. The default value is 0, indicating that the stream does not persist data. When the DataRetentionInHours value is 0, consumers can still consume the fragments that remain in the service host buffer, which has a retention time limit of 5 minutes and a retention memory limit of 200 MB. Fragments are removed from the buffer when either limit is reached.
    public var dataRetentionInHours: Swift.Int?
    /// The name of the device that is writing to the stream. In the current implementation, Kinesis Video Streams does not use this name.
    public var deviceName: Swift.String?
    /// The ID of the Key Management Service (KMS) key that you want Kinesis Video Streams to use to encrypt stream data. If no key ID is specified, the default, Kinesis Video-managed key (Amazon Web Services/kinesisvideo) is used. For more information, see [DescribeKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters).
    public var kmsKeyId: Swift.String?
    /// The media type of the stream. Consumers of the stream can use this information when processing the stream. For more information about media types, see [Media Types](http://www.iana.org/assignments/media-types/media-types.xhtml). If you choose to specify the MediaType, see [Naming Requirements](https://tools.ietf.org/html/rfc6838#section-4.2) for guidelines. Example valid values include "video/h264" and "video/h264,audio/aac". This parameter is optional; the default value is null (or empty in JSON).
    public var mediaType: Swift.String?
    /// A name for the stream that you are creating. The stream name is an identifier for the stream, and must be unique for each account and region.
    /// This member is required.
    public var streamName: Swift.String?
    /// A list of tags to associate with the specified stream. Each tag is a key-value pair (the value is optional).
    public var tags: [Swift.String: Swift.String]?

    public init(
        dataRetentionInHours: Swift.Int? = nil,
        deviceName: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        mediaType: Swift.String? = nil,
        streamName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.dataRetentionInHours = dataRetentionInHours
        self.deviceName = deviceName
        self.kmsKeyId = kmsKeyId
        self.mediaType = mediaType
        self.streamName = streamName
        self.tags = tags
    }
}

public struct CreateStreamOutput {
    /// The Amazon Resource Name (ARN) of the stream.
    public var streamARN: Swift.String?

    public init(
        streamARN: Swift.String? = nil
    )
    {
        self.streamARN = streamARN
    }
}

/// Amazon Kinesis Video Streams can't find the stream that you specified.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The Exception rendered when the Amazon Kinesis Video Stream can't find a stream's edge configuration that you specified.
public struct StreamEdgeConfigurationNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StreamEdgeConfigurationNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteEdgeConfigurationInput {
    /// The Amazon Resource Name (ARN) of the stream. Specify either the StreamName or the StreamARN.
    public var streamARN: Swift.String?
    /// The name of the stream from which to delete the edge configuration. Specify either the StreamName or the StreamARN.
    public var streamName: Swift.String?

    public init(
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

public struct DeleteEdgeConfigurationOutput {

    public init() { }
}

/// The stream version that you specified is not the latest version. To get the latest version, use the [DescribeStream](https://docs.aws.amazon.com/kinesisvideostreams/latest/dg/API_DescribeStream.html) API.
public struct VersionMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "VersionMismatchException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteSignalingChannelInput {
    /// The Amazon Resource Name (ARN) of the signaling channel that you want to delete.
    /// This member is required.
    public var channelARN: Swift.String?
    /// The current version of the signaling channel that you want to delete. You can obtain the current version by invoking the DescribeSignalingChannel or ListSignalingChannels API operations.
    public var currentVersion: Swift.String?

    public init(
        channelARN: Swift.String? = nil,
        currentVersion: Swift.String? = nil
    )
    {
        self.channelARN = channelARN
        self.currentVersion = currentVersion
    }
}

public struct DeleteSignalingChannelOutput {

    public init() { }
}

/// The caller is not authorized to perform this operation.
public struct NotAuthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotAuthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteStreamInput {
    /// Optional: The version of the stream that you want to delete. Specify the version as a safeguard to ensure that your are deleting the correct stream. To get the stream version, use the DescribeStream API. If not specified, only the CreationTime is checked before deleting the stream.
    public var currentVersion: Swift.String?
    /// The Amazon Resource Name (ARN) of the stream that you want to delete.
    /// This member is required.
    public var streamARN: Swift.String?

    public init(
        currentVersion: Swift.String? = nil,
        streamARN: Swift.String? = nil
    )
    {
        self.currentVersion = currentVersion
        self.streamARN = streamARN
    }
}

public struct DeleteStreamOutput {

    public init() { }
}

extension KinesisVideoClientTypes {

    public enum StrategyOnFullSize: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleteOldestMedia
        case denyNewMedia
        case sdkUnknown(Swift.String)

        public static var allCases: [StrategyOnFullSize] {
            return [
                .deleteOldestMedia,
                .denyNewMedia
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleteOldestMedia: return "DELETE_OLDEST_MEDIA"
            case .denyNewMedia: return "DENY_NEW_MEDIA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisVideoClientTypes {
    /// The configuration details that include the maximum size of the media (MaxLocalMediaSizeInMB) that you want to store for a stream on the Edge Agent, as well as the strategy that should be used (StrategyOnFullSize) when a stream's maximum size has been reached.
    public struct LocalSizeConfig {
        /// The overall maximum size of the media that you want to store for a stream on the Edge Agent.
        public var maxLocalMediaSizeInMB: Swift.Int?
        /// The strategy to perform when a stream’s MaxLocalMediaSizeInMB limit is reached.
        public var strategyOnFullSize: KinesisVideoClientTypes.StrategyOnFullSize?

        public init(
            maxLocalMediaSizeInMB: Swift.Int? = nil,
            strategyOnFullSize: KinesisVideoClientTypes.StrategyOnFullSize? = nil
        )
        {
            self.maxLocalMediaSizeInMB = maxLocalMediaSizeInMB
            self.strategyOnFullSize = strategyOnFullSize
        }
    }

}

extension KinesisVideoClientTypes {
    /// The configuration details required to delete the connection of the stream from the Edge Agent.
    public struct DeletionConfig {
        /// The boolean value used to indicate whether or not you want to mark the media for deletion, once it has been uploaded to the Kinesis Video Stream cloud. The media files can be deleted if any of the deletion configuration values are set to true, such as when the limit for the EdgeRetentionInHours, or the MaxLocalMediaSizeInMB, has been reached. Since the default value is set to true, configure the uploader schedule such that the media files are not being deleted before they are initially uploaded to the Amazon Web Services cloud.
        public var deleteAfterUpload: Swift.Bool?
        /// The number of hours that you want to retain the data in the stream on the Edge Agent. The default value of the retention time is 720 hours, which translates to 30 days.
        public var edgeRetentionInHours: Swift.Int?
        /// The value of the local size required in order to delete the edge configuration.
        public var localSizeConfig: KinesisVideoClientTypes.LocalSizeConfig?

        public init(
            deleteAfterUpload: Swift.Bool? = nil,
            edgeRetentionInHours: Swift.Int? = nil,
            localSizeConfig: KinesisVideoClientTypes.LocalSizeConfig? = nil
        )
        {
            self.deleteAfterUpload = deleteAfterUpload
            self.edgeRetentionInHours = edgeRetentionInHours
            self.localSizeConfig = localSizeConfig
        }
    }

}

public struct DescribeEdgeConfigurationInput {
    /// The Amazon Resource Name (ARN) of the stream. Specify either the StreamNameor the StreamARN.
    public var streamARN: Swift.String?
    /// The name of the stream whose edge configuration you want to update. Specify either the StreamName or the StreamARN.
    public var streamName: Swift.String?

    public init(
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

extension KinesisVideoClientTypes {

    public enum RecorderStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case success
        case systemError
        case userError
        case sdkUnknown(Swift.String)

        public static var allCases: [RecorderStatus] {
            return [
                .success,
                .systemError,
                .userError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .success: return "SUCCESS"
            case .systemError: return "SYSTEM_ERROR"
            case .userError: return "USER_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisVideoClientTypes {
    /// The latest status of a stream's edge recording job.
    public struct LastRecorderStatus {
        /// A description of a recorder job’s latest status.
        public var jobStatusDetails: Swift.String?
        /// The timestamp at which the recorder job was last executed and media stored to local disk.
        public var lastCollectedTime: Foundation.Date?
        /// The timestamp at which the recorder status was last updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The status of the latest recorder job.
        public var recorderStatus: KinesisVideoClientTypes.RecorderStatus?

        public init(
            jobStatusDetails: Swift.String? = nil,
            lastCollectedTime: Foundation.Date? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            recorderStatus: KinesisVideoClientTypes.RecorderStatus? = nil
        )
        {
            self.jobStatusDetails = jobStatusDetails
            self.lastCollectedTime = lastCollectedTime
            self.lastUpdatedTime = lastUpdatedTime
            self.recorderStatus = recorderStatus
        }
    }

}

extension KinesisVideoClientTypes {

    public enum UploaderStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case success
        case systemError
        case userError
        case sdkUnknown(Swift.String)

        public static var allCases: [UploaderStatus] {
            return [
                .success,
                .systemError,
                .userError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .success: return "SUCCESS"
            case .systemError: return "SYSTEM_ERROR"
            case .userError: return "USER_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisVideoClientTypes {
    /// The latest status of a stream’s edge to cloud uploader job.
    public struct LastUploaderStatus {
        /// A description of an uploader job’s latest status.
        public var jobStatusDetails: Swift.String?
        /// The timestamp at which the uploader job was last executed and media collected to the cloud.
        public var lastCollectedTime: Foundation.Date?
        /// The timestamp at which the uploader status was last updated.
        public var lastUpdatedTime: Foundation.Date?
        /// The status of the latest uploader job.
        public var uploaderStatus: KinesisVideoClientTypes.UploaderStatus?

        public init(
            jobStatusDetails: Swift.String? = nil,
            lastCollectedTime: Foundation.Date? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            uploaderStatus: KinesisVideoClientTypes.UploaderStatus? = nil
        )
        {
            self.jobStatusDetails = jobStatusDetails
            self.lastCollectedTime = lastCollectedTime
            self.lastUpdatedTime = lastUpdatedTime
            self.uploaderStatus = uploaderStatus
        }
    }

}

extension KinesisVideoClientTypes {
    /// An object that contains the latest status details for an edge agent's recorder and uploader jobs. Use this information to determine the current health of an edge agent.
    public struct EdgeAgentStatus {
        /// The latest status of a stream’s edge recording job.
        public var lastRecorderStatus: KinesisVideoClientTypes.LastRecorderStatus?
        /// The latest status of a stream’s edge to cloud uploader job.
        public var lastUploaderStatus: KinesisVideoClientTypes.LastUploaderStatus?

        public init(
            lastRecorderStatus: KinesisVideoClientTypes.LastRecorderStatus? = nil,
            lastUploaderStatus: KinesisVideoClientTypes.LastUploaderStatus? = nil
        )
        {
            self.lastRecorderStatus = lastRecorderStatus
            self.lastUploaderStatus = lastUploaderStatus
        }
    }

}

extension KinesisVideoClientTypes {

    public enum MediaUriType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fileUri
        case rtspUri
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaUriType] {
            return [
                .fileUri,
                .rtspUri
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fileUri: return "FILE_URI"
            case .rtspUri: return "RTSP_URI"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisVideoClientTypes {
    /// The configuration details that consist of the credentials required (MediaUriSecretArn and MediaUriType) to access the media files that are streamed to the camera.
    public struct MediaSourceConfig {
        /// The Amazon Web Services Secrets Manager ARN for the username and password of the camera, or a local media file location.
        /// This member is required.
        public var mediaUriSecretArn: Swift.String?
        /// The Uniform Resource Identifier (URI) type. The FILE_URI value can be used to stream local media files. Preview only supports the RTSP_URI media source URI format .
        /// This member is required.
        public var mediaUriType: KinesisVideoClientTypes.MediaUriType?

        public init(
            mediaUriSecretArn: Swift.String? = nil,
            mediaUriType: KinesisVideoClientTypes.MediaUriType? = nil
        )
        {
            self.mediaUriSecretArn = mediaUriSecretArn
            self.mediaUriType = mediaUriType
        }
    }

}

extension KinesisVideoClientTypes.MediaSourceConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaSourceConfig(mediaUriType: \(Swift.String(describing: mediaUriType)), mediaUriSecretArn: \"CONTENT_REDACTED\")"}
}

extension KinesisVideoClientTypes {
    /// This API enables you to specify the duration that the camera, or local media file, should record onto the Edge Agent. The ScheduleConfig consists of the ScheduleExpression and the DurationInMinutes attributes. If the ScheduleConfig is not provided in the RecorderConfig, then the Edge Agent will always be set to recording mode. If the ScheduleConfig is not provided in the UploaderConfig, then the Edge Agent will upload at regular intervals (every 1 hour).
    public struct ScheduleConfig {
        /// The total duration to record the media. If the ScheduleExpression attribute is provided, then the DurationInSeconds attribute should also be specified.
        /// This member is required.
        public var durationInSeconds: Swift.Int?
        /// The Quartz cron expression that takes care of scheduling jobs to record from the camera, or local media file, onto the Edge Agent. If the ScheduleExpression is not provided for the RecorderConfig, then the Edge Agent will always be set to recording mode. For more information about Quartz, refer to the [ Cron Trigger Tutorial ](http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) page to understand the valid expressions and its use.
        /// This member is required.
        public var scheduleExpression: Swift.String?

        public init(
            durationInSeconds: Swift.Int? = nil,
            scheduleExpression: Swift.String? = nil
        )
        {
            self.durationInSeconds = durationInSeconds
            self.scheduleExpression = scheduleExpression
        }
    }

}

extension KinesisVideoClientTypes {
    /// The recorder configuration consists of the local MediaSourceConfig details that are used as credentials to accesss the local media files streamed on the camera.
    public struct RecorderConfig {
        /// The configuration details that consist of the credentials required (MediaUriSecretArn and MediaUriType) to access the media files streamed to the camera.
        /// This member is required.
        public var mediaSourceConfig: KinesisVideoClientTypes.MediaSourceConfig?
        /// The configuration that consists of the ScheduleExpression and the DurationInMinutes details that specify the scheduling to record from a camera, or local media file, onto the Edge Agent. If the ScheduleExpression attribute is not provided, then the Edge Agent will always be set to recording mode.
        public var scheduleConfig: KinesisVideoClientTypes.ScheduleConfig?

        public init(
            mediaSourceConfig: KinesisVideoClientTypes.MediaSourceConfig? = nil,
            scheduleConfig: KinesisVideoClientTypes.ScheduleConfig? = nil
        )
        {
            self.mediaSourceConfig = mediaSourceConfig
            self.scheduleConfig = scheduleConfig
        }
    }

}

extension KinesisVideoClientTypes {
    /// The configuration that consists of the ScheduleExpression and the DurationInMinutes details that specify the scheduling to record from a camera, or local media file, onto the Edge Agent. If the ScheduleConfig is not provided in the UploaderConfig, then the Edge Agent will upload at regular intervals (every 1 hour).
    public struct UploaderConfig {
        /// The configuration that consists of the ScheduleExpression and the DurationInMinutes details that specify the scheduling to record from a camera, or local media file, onto the Edge Agent. If the ScheduleConfig is not provided in this UploaderConfig, then the Edge Agent will upload at regular intervals (every 1 hour).
        /// This member is required.
        public var scheduleConfig: KinesisVideoClientTypes.ScheduleConfig?

        public init(
            scheduleConfig: KinesisVideoClientTypes.ScheduleConfig? = nil
        )
        {
            self.scheduleConfig = scheduleConfig
        }
    }

}

extension KinesisVideoClientTypes {
    /// A description of the stream's edge configuration that will be used to sync with the Edge Agent IoT Greengrass component. The Edge Agent component will run on an IoT Hub Device setup at your premise.
    public struct EdgeConfig {
        /// The deletion configuration is made up of the retention time (EdgeRetentionInHours) and local size configuration (LocalSizeConfig) details that are used to make the deletion.
        public var deletionConfig: KinesisVideoClientTypes.DeletionConfig?
        /// The "Internet of Things (IoT) Thing" Arn of the stream.
        /// This member is required.
        public var hubDeviceArn: Swift.String?
        /// The recorder configuration consists of the local MediaSourceConfig details, that are used as credentials to access the local media files streamed on the camera.
        /// This member is required.
        public var recorderConfig: KinesisVideoClientTypes.RecorderConfig?
        /// The uploader configuration contains the ScheduleExpression details that are used to schedule upload jobs for the recorded media files from the Edge Agent to a Kinesis Video Stream.
        public var uploaderConfig: KinesisVideoClientTypes.UploaderConfig?

        public init(
            deletionConfig: KinesisVideoClientTypes.DeletionConfig? = nil,
            hubDeviceArn: Swift.String? = nil,
            recorderConfig: KinesisVideoClientTypes.RecorderConfig? = nil,
            uploaderConfig: KinesisVideoClientTypes.UploaderConfig? = nil
        )
        {
            self.deletionConfig = deletionConfig
            self.hubDeviceArn = hubDeviceArn
            self.recorderConfig = recorderConfig
            self.uploaderConfig = uploaderConfig
        }
    }

}

extension KinesisVideoClientTypes {

    public enum SyncStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case acknowledged
        case deleteFailed
        case deleting
        case deletingAcknowledged
        case inSync
        case syncing
        case syncFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncStatus] {
            return [
                .acknowledged,
                .deleteFailed,
                .deleting,
                .deletingAcknowledged,
                .inSync,
                .syncing,
                .syncFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .acknowledged: return "ACKNOWLEDGED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .deletingAcknowledged: return "DELETING_ACKNOWLEDGED"
            case .inSync: return "IN_SYNC"
            case .syncing: return "SYNCING"
            case .syncFailed: return "SYNC_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeEdgeConfigurationOutput {
    /// The timestamp at which a stream’s edge configuration was first created.
    public var creationTime: Foundation.Date?
    /// An object that contains the latest status details for an edge agent's recorder and uploader jobs. Use this information to determine the current health of an edge agent.
    public var edgeAgentStatus: KinesisVideoClientTypes.EdgeAgentStatus?
    /// A description of the stream's edge configuration that will be used to sync with the Edge Agent IoT Greengrass component. The Edge Agent component will run on an IoT Hub Device setup at your premise.
    public var edgeConfig: KinesisVideoClientTypes.EdgeConfig?
    /// A description of the generated failure status.
    public var failedStatusDetails: Swift.String?
    /// The timestamp at which a stream’s edge configuration was last updated.
    public var lastUpdatedTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the stream.
    public var streamARN: Swift.String?
    /// The name of the stream from which the edge configuration was updated.
    public var streamName: Swift.String?
    /// The latest status of the edge configuration update.
    public var syncStatus: KinesisVideoClientTypes.SyncStatus?

    public init(
        creationTime: Foundation.Date? = nil,
        edgeAgentStatus: KinesisVideoClientTypes.EdgeAgentStatus? = nil,
        edgeConfig: KinesisVideoClientTypes.EdgeConfig? = nil,
        failedStatusDetails: Swift.String? = nil,
        lastUpdatedTime: Foundation.Date? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil,
        syncStatus: KinesisVideoClientTypes.SyncStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.edgeAgentStatus = edgeAgentStatus
        self.edgeConfig = edgeConfig
        self.failedStatusDetails = failedStatusDetails
        self.lastUpdatedTime = lastUpdatedTime
        self.streamARN = streamARN
        self.streamName = streamName
        self.syncStatus = syncStatus
    }
}

public struct DescribeImageGenerationConfigurationInput {
    /// The Amazon Resource Name (ARN) of the Kinesis video stream from which to retrieve the image generation configuration. You must specify either the StreamName or the StreamARN.
    public var streamARN: Swift.String?
    /// The name of the stream from which to retrieve the image generation configuration. You must specify either the StreamName or the StreamARN.
    public var streamName: Swift.String?

    public init(
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

extension KinesisVideoClientTypes {
    /// The structure that contains the information required to deliver images to a customer.
    public struct ImageGenerationDestinationConfig {
        /// The Amazon Web Services Region of the S3 bucket where images will be delivered. This DestinationRegion must match the Region where the stream is located.
        /// This member is required.
        public var destinationRegion: Swift.String?
        /// The Uniform Resource Identifier (URI) that identifies where the images will be delivered.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            destinationRegion: Swift.String? = nil,
            uri: Swift.String? = nil
        )
        {
            self.destinationRegion = destinationRegion
            self.uri = uri
        }
    }

}

extension KinesisVideoClientTypes {

    public enum Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jpeg
        case png
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .jpeg,
                .png
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jpeg: return "JPEG"
            case .png: return "PNG"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisVideoClientTypes {

    public enum FormatConfigKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case jpegquality
        case sdkUnknown(Swift.String)

        public static var allCases: [FormatConfigKey] {
            return [
                .jpegquality
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .jpegquality: return "JPEGQuality"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisVideoClientTypes {

    public enum ImageSelectorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case producerTimestamp
        case serverTimestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageSelectorType] {
            return [
                .producerTimestamp,
                .serverTimestamp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .producerTimestamp: return "PRODUCER_TIMESTAMP"
            case .serverTimestamp: return "SERVER_TIMESTAMP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisVideoClientTypes {
    /// The structure that contains the information required for the KVS images delivery. If null, the configuration will be deleted from the stream.
    public struct ImageGenerationConfiguration {
        /// The structure that contains the information required to deliver images to a customer.
        /// This member is required.
        public var destinationConfig: KinesisVideoClientTypes.ImageGenerationDestinationConfig?
        /// The accepted image format.
        /// This member is required.
        public var format: KinesisVideoClientTypes.Format?
        /// The list of a key-value pair structure that contains extra parameters that can be applied when the image is generated. The FormatConfig key is the JPEGQuality, which indicates the JPEG quality key to be used to generate the image. The FormatConfig value accepts ints from 1 to 100. If the value is 1, the image will be generated with less quality and the best compression. If the value is 100, the image will be generated with the best quality and less compression. If no value is provided, the default value of the JPEGQuality key will be set to 80.
        public var formatConfig: [Swift.String: Swift.String]?
        /// The height of the output image that is used in conjunction with the WidthPixels parameter. When both HeightPixels and WidthPixels parameters are provided, the image will be stretched to fit the specified aspect ratio. If only the HeightPixels parameter is provided, its original aspect ratio will be used to calculate the WidthPixels ratio. If neither parameter is provided, the original image size will be returned.
        public var heightPixels: Swift.Int?
        /// The origin of the Server or Producer timestamps to use to generate the images.
        /// This member is required.
        public var imageSelectorType: KinesisVideoClientTypes.ImageSelectorType?
        /// The time interval in milliseconds (ms) at which the images need to be generated from the stream. The minimum value that can be provided is 200 ms. If the timestamp range is less than the sampling interval, the Image from the StartTimestamp will be returned if available.
        /// This member is required.
        public var samplingInterval: Swift.Int?
        /// Indicates whether the ContinuousImageGenerationConfigurations API is enabled or disabled.
        /// This member is required.
        public var status: KinesisVideoClientTypes.ConfigurationStatus?
        /// The width of the output image that is used in conjunction with the HeightPixels parameter. When both WidthPixels and HeightPixels parameters are provided, the image will be stretched to fit the specified aspect ratio. If only the WidthPixels parameter is provided, its original aspect ratio will be used to calculate the HeightPixels ratio. If neither parameter is provided, the original image size will be returned.
        public var widthPixels: Swift.Int?

        public init(
            destinationConfig: KinesisVideoClientTypes.ImageGenerationDestinationConfig? = nil,
            format: KinesisVideoClientTypes.Format? = nil,
            formatConfig: [Swift.String: Swift.String]? = nil,
            heightPixels: Swift.Int? = nil,
            imageSelectorType: KinesisVideoClientTypes.ImageSelectorType? = nil,
            samplingInterval: Swift.Int? = nil,
            status: KinesisVideoClientTypes.ConfigurationStatus? = nil,
            widthPixels: Swift.Int? = nil
        )
        {
            self.destinationConfig = destinationConfig
            self.format = format
            self.formatConfig = formatConfig
            self.heightPixels = heightPixels
            self.imageSelectorType = imageSelectorType
            self.samplingInterval = samplingInterval
            self.status = status
            self.widthPixels = widthPixels
        }
    }

}

public struct DescribeImageGenerationConfigurationOutput {
    /// The structure that contains the information required for the Kinesis video stream (KVS) images delivery. If this structure is null, the configuration will be deleted from the stream.
    public var imageGenerationConfiguration: KinesisVideoClientTypes.ImageGenerationConfiguration?

    public init(
        imageGenerationConfiguration: KinesisVideoClientTypes.ImageGenerationConfiguration? = nil
    )
    {
        self.imageGenerationConfiguration = imageGenerationConfiguration
    }
}

public struct DescribeMappedResourceConfigurationInput {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The token to provide in your next request, to get another batch of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the stream.
    public var streamARN: Swift.String?
    /// The name of the stream.
    public var streamName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

extension KinesisVideoClientTypes {
    /// A structure that encapsulates, or contains, the media storage configuration properties.
    public struct MappedResourceConfigurationListItem {
        /// The Amazon Resource Name (ARN) of the Kinesis Video Stream resource, associated with the stream.
        public var arn: Swift.String?
        /// The type of the associated resource for the kinesis video stream.
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.type = type
        }
    }

}

public struct DescribeMappedResourceConfigurationOutput {
    /// A structure that encapsulates, or contains, the media storage configuration properties.
    public var mappedResourceConfigurationList: [KinesisVideoClientTypes.MappedResourceConfigurationListItem]?
    /// The token that was used in the NextTokenrequest to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        mappedResourceConfigurationList: [KinesisVideoClientTypes.MappedResourceConfigurationListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mappedResourceConfigurationList = mappedResourceConfigurationList
        self.nextToken = nextToken
    }
}

public struct DescribeMediaStorageConfigurationInput {
    /// The Amazon Resource Name (ARN) of the channel.
    public var channelARN: Swift.String?
    /// The name of the channel.
    public var channelName: Swift.String?

    public init(
        channelARN: Swift.String? = nil,
        channelName: Swift.String? = nil
    )
    {
        self.channelARN = channelARN
        self.channelName = channelName
    }
}

extension KinesisVideoClientTypes {

    public enum MediaStorageConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaStorageConfigurationStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension KinesisVideoClientTypes {
    /// A structure that encapsulates, or contains, the media storage configuration properties.
    ///
    /// * If StorageStatus is enabled, the data will be stored in the StreamARN provided. In order for WebRTC Ingestion to work, the stream must have data retention enabled.
    ///
    /// * If StorageStatus is disabled, no data will be stored, and the StreamARN parameter will not be needed.
    public struct MediaStorageConfiguration {
        /// The status of the media storage configuration.
        /// This member is required.
        public var status: KinesisVideoClientTypes.MediaStorageConfigurationStatus?
        /// The Amazon Resource Name (ARN) of the stream.
        public var streamARN: Swift.String?

        public init(
            status: KinesisVideoClientTypes.MediaStorageConfigurationStatus? = nil,
            streamARN: Swift.String? = nil
        )
        {
            self.status = status
            self.streamARN = streamARN
        }
    }

}

public struct DescribeMediaStorageConfigurationOutput {
    /// A structure that encapsulates, or contains, the media storage configuration properties.
    public var mediaStorageConfiguration: KinesisVideoClientTypes.MediaStorageConfiguration?

    public init(
        mediaStorageConfiguration: KinesisVideoClientTypes.MediaStorageConfiguration? = nil
    )
    {
        self.mediaStorageConfiguration = mediaStorageConfiguration
    }
}

public struct DescribeNotificationConfigurationInput {
    /// The Amazon Resource Name (ARN) of the Kinesis video stream from where you want to retrieve the notification configuration. You must specify either the StreamName or the StreamARN.
    public var streamARN: Swift.String?
    /// The name of the stream from which to retrieve the notification configuration. You must specify either the StreamName or the StreamARN.
    public var streamName: Swift.String?

    public init(
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

extension KinesisVideoClientTypes {
    /// The structure that contains the information required to deliver a notification to a customer.
    public struct NotificationDestinationConfig {
        /// The Uniform Resource Identifier (URI) that identifies where the images will be delivered.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            uri: Swift.String? = nil
        )
        {
            self.uri = uri
        }
    }

}

extension KinesisVideoClientTypes {
    /// The structure that contains the notification information for the KVS images delivery. If this parameter is null, the configuration will be deleted from the stream.
    public struct NotificationConfiguration {
        /// The destination information required to deliver a notification to a customer.
        /// This member is required.
        public var destinationConfig: KinesisVideoClientTypes.NotificationDestinationConfig?
        /// Indicates if a notification configuration is enabled or disabled.
        /// This member is required.
        public var status: KinesisVideoClientTypes.ConfigurationStatus?

        public init(
            destinationConfig: KinesisVideoClientTypes.NotificationDestinationConfig? = nil,
            status: KinesisVideoClientTypes.ConfigurationStatus? = nil
        )
        {
            self.destinationConfig = destinationConfig
            self.status = status
        }
    }

}

public struct DescribeNotificationConfigurationOutput {
    /// The structure that contains the information required for notifications. If the structure is null, the configuration will be deleted from the stream.
    public var notificationConfiguration: KinesisVideoClientTypes.NotificationConfiguration?

    public init(
        notificationConfiguration: KinesisVideoClientTypes.NotificationConfiguration? = nil
    )
    {
        self.notificationConfiguration = notificationConfiguration
    }
}

public struct DescribeSignalingChannelInput {
    /// The ARN of the signaling channel that you want to describe.
    public var channelARN: Swift.String?
    /// The name of the signaling channel that you want to describe.
    public var channelName: Swift.String?

    public init(
        channelARN: Swift.String? = nil,
        channelName: Swift.String? = nil
    )
    {
        self.channelARN = channelARN
        self.channelName = channelName
    }
}

public struct DescribeSignalingChannelOutput {
    /// A structure that encapsulates the specified signaling channel's metadata and properties.
    public var channelInfo: KinesisVideoClientTypes.ChannelInfo?

    public init(
        channelInfo: KinesisVideoClientTypes.ChannelInfo? = nil
    )
    {
        self.channelInfo = channelInfo
    }
}

public struct DescribeStreamInput {
    /// The Amazon Resource Name (ARN) of the stream.
    public var streamARN: Swift.String?
    /// The name of the stream.
    public var streamName: Swift.String?

    public init(
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

extension KinesisVideoClientTypes {
    /// An object describing a Kinesis video stream.
    public struct StreamInfo {
        /// A time stamp that indicates when the stream was created.
        public var creationTime: Foundation.Date?
        /// How long the stream retains data, in hours.
        public var dataRetentionInHours: Swift.Int?
        /// The name of the device that is associated with the stream.
        public var deviceName: Swift.String?
        /// The ID of the Key Management Service (KMS) key that Kinesis Video Streams uses to encrypt data on the stream.
        public var kmsKeyId: Swift.String?
        /// The MediaType of the stream.
        public var mediaType: Swift.String?
        /// The status of the stream.
        public var status: KinesisVideoClientTypes.Status?
        /// The Amazon Resource Name (ARN) of the stream.
        public var streamARN: Swift.String?
        /// The name of the stream.
        public var streamName: Swift.String?
        /// The version of the stream.
        public var version: Swift.String?

        public init(
            creationTime: Foundation.Date? = nil,
            dataRetentionInHours: Swift.Int? = nil,
            deviceName: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            mediaType: Swift.String? = nil,
            status: KinesisVideoClientTypes.Status? = nil,
            streamARN: Swift.String? = nil,
            streamName: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.dataRetentionInHours = dataRetentionInHours
            self.deviceName = deviceName
            self.kmsKeyId = kmsKeyId
            self.mediaType = mediaType
            self.status = status
            self.streamARN = streamARN
            self.streamName = streamName
            self.version = version
        }
    }

}

public struct DescribeStreamOutput {
    /// An object that describes the stream.
    public var streamInfo: KinesisVideoClientTypes.StreamInfo?

    public init(
        streamInfo: KinesisVideoClientTypes.StreamInfo? = nil
    )
    {
        self.streamInfo = streamInfo
    }
}

public struct GetDataEndpointInput {
    /// The name of the API action for which to get an endpoint.
    /// This member is required.
    public var apiName: KinesisVideoClientTypes.APIName?
    /// The Amazon Resource Name (ARN) of the stream that you want to get the endpoint for. You must specify either this parameter or a StreamName in the request.
    public var streamARN: Swift.String?
    /// The name of the stream that you want to get the endpoint for. You must specify either this parameter or a StreamARN in the request.
    public var streamName: Swift.String?

    public init(
        apiName: KinesisVideoClientTypes.APIName? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.apiName = apiName
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

public struct GetDataEndpointOutput {
    /// The endpoint value. To read data from the stream or to write data to it, specify this endpoint in your application.
    public var dataEndpoint: Swift.String?

    public init(
        dataEndpoint: Swift.String? = nil
    )
    {
        self.dataEndpoint = dataEndpoint
    }
}

extension KinesisVideoClientTypes {
    /// An object that contains the endpoint configuration for the SINGLE_MASTER channel type.
    public struct SingleMasterChannelEndpointConfiguration {
        /// This property is used to determine the nature of communication over this SINGLE_MASTER signaling channel. If WSS is specified, this API returns a websocket endpoint. If HTTPS is specified, this API returns an HTTPS endpoint.
        public var protocols: [KinesisVideoClientTypes.ChannelProtocol]?
        /// This property is used to determine messaging permissions in this SINGLE_MASTER signaling channel. If MASTER is specified, this API returns an endpoint that a client can use to receive offers from and send answers to any of the viewers on this signaling channel. If VIEWER is specified, this API returns an endpoint that a client can use only to send offers to another MASTER client on this signaling channel.
        public var role: KinesisVideoClientTypes.ChannelRole?

        public init(
            protocols: [KinesisVideoClientTypes.ChannelProtocol]? = nil,
            role: KinesisVideoClientTypes.ChannelRole? = nil
        )
        {
            self.protocols = protocols
            self.role = role
        }
    }

}

public struct GetSignalingChannelEndpointInput {
    /// The Amazon Resource Name (ARN) of the signalling channel for which you want to get an endpoint.
    /// This member is required.
    public var channelARN: Swift.String?
    /// A structure containing the endpoint configuration for the SINGLE_MASTER channel type.
    public var singleMasterChannelEndpointConfiguration: KinesisVideoClientTypes.SingleMasterChannelEndpointConfiguration?

    public init(
        channelARN: Swift.String? = nil,
        singleMasterChannelEndpointConfiguration: KinesisVideoClientTypes.SingleMasterChannelEndpointConfiguration? = nil
    )
    {
        self.channelARN = channelARN
        self.singleMasterChannelEndpointConfiguration = singleMasterChannelEndpointConfiguration
    }
}

extension KinesisVideoClientTypes {
    /// An object that describes the endpoint of the signaling channel returned by the GetSignalingChannelEndpoint API. The media server endpoint will correspond to the WEBRTC Protocol.
    public struct ResourceEndpointListItem {
        /// The protocol of the signaling channel returned by the GetSignalingChannelEndpoint API.
        public var `protocol`: KinesisVideoClientTypes.ChannelProtocol?
        /// The endpoint of the signaling channel returned by the GetSignalingChannelEndpoint API.
        public var resourceEndpoint: Swift.String?

        public init(
            `protocol`: KinesisVideoClientTypes.ChannelProtocol? = nil,
            resourceEndpoint: Swift.String? = nil
        )
        {
            self.`protocol` = `protocol`
            self.resourceEndpoint = resourceEndpoint
        }
    }

}

public struct GetSignalingChannelEndpointOutput {
    /// A list of endpoints for the specified signaling channel.
    public var resourceEndpointList: [KinesisVideoClientTypes.ResourceEndpointListItem]?

    public init(
        resourceEndpointList: [KinesisVideoClientTypes.ResourceEndpointListItem]? = nil
    )
    {
        self.resourceEndpointList = resourceEndpointList
    }
}

/// The format of the StreamARN is invalid.
public struct InvalidResourceFormatException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceFormatException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListEdgeAgentConfigurationsInput {
    /// The "Internet of Things (IoT) Thing" Arn of the edge agent.
    /// This member is required.
    public var hubDeviceArn: Swift.String?
    /// The maximum number of edge configurations to return in the response. The default is 5.
    public var maxResults: Swift.Int?
    /// If you specify this parameter, when the result of a ListEdgeAgentConfigurations operation is truncated, the call returns the NextToken in the response. To get another batch of edge configurations, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        hubDeviceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.hubDeviceArn = hubDeviceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension KinesisVideoClientTypes {
    /// A description of a single stream's edge configuration.
    public struct ListEdgeAgentConfigurationsEdgeConfig {
        /// The timestamp when the stream first created the edge config.
        public var creationTime: Foundation.Date?
        /// A description of the stream's edge configuration that will be used to sync with the Edge Agent IoT Greengrass component. The Edge Agent component will run on an IoT Hub Device setup at your premise.
        public var edgeConfig: KinesisVideoClientTypes.EdgeConfig?
        /// A description of the generated failure status.
        public var failedStatusDetails: Swift.String?
        /// The timestamp when the stream last updated the edge config.
        public var lastUpdatedTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the stream.
        public var streamARN: Swift.String?
        /// The name of the stream.
        public var streamName: Swift.String?
        /// The current sync status of the stream's edge configuration.
        public var syncStatus: KinesisVideoClientTypes.SyncStatus?

        public init(
            creationTime: Foundation.Date? = nil,
            edgeConfig: KinesisVideoClientTypes.EdgeConfig? = nil,
            failedStatusDetails: Swift.String? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            streamARN: Swift.String? = nil,
            streamName: Swift.String? = nil,
            syncStatus: KinesisVideoClientTypes.SyncStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.edgeConfig = edgeConfig
            self.failedStatusDetails = failedStatusDetails
            self.lastUpdatedTime = lastUpdatedTime
            self.streamARN = streamARN
            self.streamName = streamName
            self.syncStatus = syncStatus
        }
    }

}

public struct ListEdgeAgentConfigurationsOutput {
    /// A description of a single stream's edge configuration.
    public var edgeConfigs: [KinesisVideoClientTypes.ListEdgeAgentConfigurationsEdgeConfig]?
    /// If the response is truncated, the call returns this element with a given token. To get the next batch of edge configurations, use this token in your next request.
    public var nextToken: Swift.String?

    public init(
        edgeConfigs: [KinesisVideoClientTypes.ListEdgeAgentConfigurationsEdgeConfig]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.edgeConfigs = edgeConfigs
        self.nextToken = nextToken
    }
}

public struct ListSignalingChannelsInput {
    /// Optional: Returns only the channels that satisfy a specific condition.
    public var channelNameCondition: KinesisVideoClientTypes.ChannelNameCondition?
    /// The maximum number of channels to return in the response. The default is 500.
    public var maxResults: Swift.Int?
    /// If you specify this parameter, when the result of a ListSignalingChannels operation is truncated, the call returns the NextToken in the response. To get another batch of channels, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        channelNameCondition: KinesisVideoClientTypes.ChannelNameCondition? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelNameCondition = channelNameCondition
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListSignalingChannelsOutput {
    /// An array of ChannelInfo objects.
    public var channelInfoList: [KinesisVideoClientTypes.ChannelInfo]?
    /// If the response is truncated, the call returns this element with a token. To get the next batch of streams, use this token in your next request.
    public var nextToken: Swift.String?

    public init(
        channelInfoList: [KinesisVideoClientTypes.ChannelInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelInfoList = channelInfoList
        self.nextToken = nextToken
    }
}

extension KinesisVideoClientTypes {
    /// Specifies the condition that streams must satisfy to be returned when you list streams (see the ListStreams API). A condition has a comparison operation and a value. Currently, you can specify only the BEGINS_WITH operator, which finds streams whose names start with a given prefix.
    public struct StreamNameCondition {
        /// A comparison operator. Currently, you can specify only the BEGINS_WITH operator, which finds streams whose names start with a given prefix.
        public var comparisonOperator: KinesisVideoClientTypes.ComparisonOperator?
        /// A value to compare.
        public var comparisonValue: Swift.String?

        public init(
            comparisonOperator: KinesisVideoClientTypes.ComparisonOperator? = nil,
            comparisonValue: Swift.String? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.comparisonValue = comparisonValue
        }
    }

}

public struct ListStreamsInput {
    /// The maximum number of streams to return in the response. The default is 10,000.
    public var maxResults: Swift.Int?
    /// If you specify this parameter, when the result of a ListStreams operation is truncated, the call returns the NextToken in the response. To get another batch of streams, provide this token in your next request.
    public var nextToken: Swift.String?
    /// Optional: Returns only streams that satisfy a specific condition. Currently, you can specify only the prefix of a stream name as a condition.
    public var streamNameCondition: KinesisVideoClientTypes.StreamNameCondition?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        streamNameCondition: KinesisVideoClientTypes.StreamNameCondition? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.streamNameCondition = streamNameCondition
    }
}

public struct ListStreamsOutput {
    /// If the response is truncated, the call returns this element with a token. To get the next batch of streams, use this token in your next request.
    public var nextToken: Swift.String?
    /// An array of StreamInfo objects.
    public var streamInfoList: [KinesisVideoClientTypes.StreamInfo]?

    public init(
        nextToken: Swift.String? = nil,
        streamInfoList: [KinesisVideoClientTypes.StreamInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.streamInfoList = streamInfoList
    }
}

public struct ListTagsForResourceInput {
    /// If you specify this parameter and the result of a ListTagsForResource call is truncated, the response includes a token that you can use in the next request to fetch the next batch of tags.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the signaling channel for which you want to list tags.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput {
    /// If you specify this parameter and the result of a ListTagsForResource call is truncated, the response includes a token that you can use in the next request to fetch the next set of tags.
    public var nextToken: Swift.String?
    /// A map of tag keys and values associated with the specified signaling channel.
    public var tags: [Swift.String: Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

public struct ListTagsForStreamInput {
    /// If you specify this parameter and the result of a ListTagsForStream call is truncated, the response includes a token that you can use in the next request to fetch the next batch of tags.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the stream that you want to list tags for.
    public var streamARN: Swift.String?
    /// The name of the stream that you want to list tags for.
    public var streamName: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

public struct ListTagsForStreamOutput {
    /// If you specify this parameter and the result of a ListTags call is truncated, the response includes a token that you can use in the next request to fetch the next set of tags.
    public var nextToken: Swift.String?
    /// A map of tag keys and values associated with the specified stream.
    public var tags: [Swift.String: Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

/// The Stream data retention in hours is equal to zero.
public struct NoDataRetentionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoDataRetentionException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StartEdgeConfigurationUpdateInput {
    /// The edge configuration details required to invoke the update process.
    /// This member is required.
    public var edgeConfig: KinesisVideoClientTypes.EdgeConfig?
    /// The Amazon Resource Name (ARN) of the stream. Specify either the StreamName or the StreamARN.
    public var streamARN: Swift.String?
    /// The name of the stream whose edge configuration you want to update. Specify either the StreamName or the StreamARN.
    public var streamName: Swift.String?

    public init(
        edgeConfig: KinesisVideoClientTypes.EdgeConfig? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.edgeConfig = edgeConfig
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

public struct StartEdgeConfigurationUpdateOutput {
    /// The timestamp at which a stream’s edge configuration was first created.
    public var creationTime: Foundation.Date?
    /// A description of the stream's edge configuration that will be used to sync with the Edge Agent IoT Greengrass component. The Edge Agent component will run on an IoT Hub Device setup at your premise.
    public var edgeConfig: KinesisVideoClientTypes.EdgeConfig?
    /// A description of the generated failure status.
    public var failedStatusDetails: Swift.String?
    /// The timestamp at which a stream’s edge configuration was last updated.
    public var lastUpdatedTime: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the stream.
    public var streamARN: Swift.String?
    /// The name of the stream from which the edge configuration was updated.
    public var streamName: Swift.String?
    /// The current sync status of the stream's edge configuration. When you invoke this API, the sync status will be set to the SYNCING state. Use the DescribeEdgeConfiguration API to get the latest status of the edge configuration.
    public var syncStatus: KinesisVideoClientTypes.SyncStatus?

    public init(
        creationTime: Foundation.Date? = nil,
        edgeConfig: KinesisVideoClientTypes.EdgeConfig? = nil,
        failedStatusDetails: Swift.String? = nil,
        lastUpdatedTime: Foundation.Date? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil,
        syncStatus: KinesisVideoClientTypes.SyncStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.edgeConfig = edgeConfig
        self.failedStatusDetails = failedStatusDetails
        self.lastUpdatedTime = lastUpdatedTime
        self.streamARN = streamARN
        self.streamName = streamName
        self.syncStatus = syncStatus
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) of the signaling channel to which you want to add tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tags to associate with the specified signaling channel. Each tag is a key-value pair.
    /// This member is required.
    public var tags: [KinesisVideoClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [KinesisVideoClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct TagStreamInput {
    /// The Amazon Resource Name (ARN) of the resource that you want to add the tag or tags to.
    public var streamARN: Swift.String?
    /// The name of the stream that you want to add the tag or tags to.
    public var streamName: Swift.String?
    /// A list of tags to associate with the specified stream. Each tag is a key-value pair (the value is optional).
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
        self.tags = tags
    }
}

public struct TagStreamOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) of the signaling channel from which you want to remove tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of the keys of the tags that you want to remove.
    /// This member is required.
    public var tagKeyList: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeyList: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeyList = tagKeyList
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UntagStreamInput {
    /// The Amazon Resource Name (ARN) of the stream that you want to remove tags from.
    public var streamARN: Swift.String?
    /// The name of the stream that you want to remove tags from.
    public var streamName: Swift.String?
    /// A list of the keys of the tags that you want to remove.
    /// This member is required.
    public var tagKeyList: [Swift.String]?

    public init(
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil,
        tagKeyList: [Swift.String]? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
        self.tagKeyList = tagKeyList
    }
}

public struct UntagStreamOutput {

    public init() { }
}

extension KinesisVideoClientTypes {

    public enum UpdateDataRetentionOperation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case decreaseDataRetention
        case increaseDataRetention
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateDataRetentionOperation] {
            return [
                .decreaseDataRetention,
                .increaseDataRetention
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .decreaseDataRetention: return "DECREASE_DATA_RETENTION"
            case .increaseDataRetention: return "INCREASE_DATA_RETENTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateDataRetentionInput {
    /// The version of the stream whose retention period you want to change. To get the version, call either the DescribeStream or the ListStreams API.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// The number of hours to adjust the current retention by. The value you specify is added to or subtracted from the current value, depending on the operation. The minimum value for data retention is 0 and the maximum value is 87600 (ten years).
    /// This member is required.
    public var dataRetentionChangeInHours: Swift.Int?
    /// Indicates whether you want to increase or decrease the retention period.
    /// This member is required.
    public var operation: KinesisVideoClientTypes.UpdateDataRetentionOperation?
    /// The Amazon Resource Name (ARN) of the stream whose retention period you want to change.
    public var streamARN: Swift.String?
    /// The name of the stream whose retention period you want to change.
    public var streamName: Swift.String?

    public init(
        currentVersion: Swift.String? = nil,
        dataRetentionChangeInHours: Swift.Int? = nil,
        operation: KinesisVideoClientTypes.UpdateDataRetentionOperation? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.currentVersion = currentVersion
        self.dataRetentionChangeInHours = dataRetentionChangeInHours
        self.operation = operation
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

public struct UpdateDataRetentionOutput {

    public init() { }
}

public struct UpdateImageGenerationConfigurationInput {
    /// The structure that contains the information required for the KVS images delivery. If the structure is null, the configuration will be deleted from the stream.
    public var imageGenerationConfiguration: KinesisVideoClientTypes.ImageGenerationConfiguration?
    /// The Amazon Resource Name (ARN) of the Kinesis video stream from where you want to update the image generation configuration. You must specify either the StreamName or the StreamARN.
    public var streamARN: Swift.String?
    /// The name of the stream from which to update the image generation configuration. You must specify either the StreamName or the StreamARN.
    public var streamName: Swift.String?

    public init(
        imageGenerationConfiguration: KinesisVideoClientTypes.ImageGenerationConfiguration? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.imageGenerationConfiguration = imageGenerationConfiguration
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

public struct UpdateImageGenerationConfigurationOutput {

    public init() { }
}

public struct UpdateMediaStorageConfigurationInput {
    /// The Amazon Resource Name (ARN) of the channel.
    /// This member is required.
    public var channelARN: Swift.String?
    /// A structure that encapsulates, or contains, the media storage configuration properties.
    /// This member is required.
    public var mediaStorageConfiguration: KinesisVideoClientTypes.MediaStorageConfiguration?

    public init(
        channelARN: Swift.String? = nil,
        mediaStorageConfiguration: KinesisVideoClientTypes.MediaStorageConfiguration? = nil
    )
    {
        self.channelARN = channelARN
        self.mediaStorageConfiguration = mediaStorageConfiguration
    }
}

public struct UpdateMediaStorageConfigurationOutput {

    public init() { }
}

public struct UpdateNotificationConfigurationInput {
    /// The structure containing the information required for notifications. If the structure is null, the configuration will be deleted from the stream.
    public var notificationConfiguration: KinesisVideoClientTypes.NotificationConfiguration?
    /// The Amazon Resource Name (ARN) of the Kinesis video stream from where you want to update the notification configuration. You must specify either the StreamName or the StreamARN.
    public var streamARN: Swift.String?
    /// The name of the stream from which to update the notification configuration. You must specify either the StreamName or the StreamARN.
    public var streamName: Swift.String?

    public init(
        notificationConfiguration: KinesisVideoClientTypes.NotificationConfiguration? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.notificationConfiguration = notificationConfiguration
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

public struct UpdateNotificationConfigurationOutput {

    public init() { }
}

public struct UpdateSignalingChannelInput {
    /// The Amazon Resource Name (ARN) of the signaling channel that you want to update.
    /// This member is required.
    public var channelARN: Swift.String?
    /// The current version of the signaling channel that you want to update.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// The structure containing the configuration for the SINGLE_MASTER type of the signaling channel that you want to update.
    public var singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration?

    public init(
        channelARN: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration? = nil
    )
    {
        self.channelARN = channelARN
        self.currentVersion = currentVersion
        self.singleMasterConfiguration = singleMasterConfiguration
    }
}

public struct UpdateSignalingChannelOutput {

    public init() { }
}

public struct UpdateStreamInput {
    /// The version of the stream whose metadata you want to update.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// The name of the device that is writing to the stream. In the current implementation, Kinesis Video Streams does not use this name.
    public var deviceName: Swift.String?
    /// The stream's media type. Use MediaType to specify the type of content that the stream contains to the consumers of the stream. For more information about media types, see [Media Types](http://www.iana.org/assignments/media-types/media-types.xhtml). If you choose to specify the MediaType, see [Naming Requirements](https://tools.ietf.org/html/rfc6838#section-4.2). To play video on the console, you must specify the correct video type. For example, if the video in the stream is H.264, specify video/h264 as the MediaType.
    public var mediaType: Swift.String?
    /// The ARN of the stream whose metadata you want to update.
    public var streamARN: Swift.String?
    /// The name of the stream whose metadata you want to update. The stream name is an identifier for the stream, and must be unique for each account and region.
    public var streamName: Swift.String?

    public init(
        currentVersion: Swift.String? = nil,
        deviceName: Swift.String? = nil,
        mediaType: Swift.String? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.currentVersion = currentVersion
        self.deviceName = deviceName
        self.mediaType = mediaType
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

public struct UpdateStreamOutput {

    public init() { }
}

extension CreateSignalingChannelInput {

    static func urlPathProvider(_ value: CreateSignalingChannelInput) -> Swift.String? {
        return "/createSignalingChannel"
    }
}

extension CreateStreamInput {

    static func urlPathProvider(_ value: CreateStreamInput) -> Swift.String? {
        return "/createStream"
    }
}

extension DeleteEdgeConfigurationInput {

    static func urlPathProvider(_ value: DeleteEdgeConfigurationInput) -> Swift.String? {
        return "/deleteEdgeConfiguration"
    }
}

extension DeleteSignalingChannelInput {

    static func urlPathProvider(_ value: DeleteSignalingChannelInput) -> Swift.String? {
        return "/deleteSignalingChannel"
    }
}

extension DeleteStreamInput {

    static func urlPathProvider(_ value: DeleteStreamInput) -> Swift.String? {
        return "/deleteStream"
    }
}

extension DescribeEdgeConfigurationInput {

    static func urlPathProvider(_ value: DescribeEdgeConfigurationInput) -> Swift.String? {
        return "/describeEdgeConfiguration"
    }
}

extension DescribeImageGenerationConfigurationInput {

    static func urlPathProvider(_ value: DescribeImageGenerationConfigurationInput) -> Swift.String? {
        return "/describeImageGenerationConfiguration"
    }
}

extension DescribeMappedResourceConfigurationInput {

    static func urlPathProvider(_ value: DescribeMappedResourceConfigurationInput) -> Swift.String? {
        return "/describeMappedResourceConfiguration"
    }
}

extension DescribeMediaStorageConfigurationInput {

    static func urlPathProvider(_ value: DescribeMediaStorageConfigurationInput) -> Swift.String? {
        return "/describeMediaStorageConfiguration"
    }
}

extension DescribeNotificationConfigurationInput {

    static func urlPathProvider(_ value: DescribeNotificationConfigurationInput) -> Swift.String? {
        return "/describeNotificationConfiguration"
    }
}

extension DescribeSignalingChannelInput {

    static func urlPathProvider(_ value: DescribeSignalingChannelInput) -> Swift.String? {
        return "/describeSignalingChannel"
    }
}

extension DescribeStreamInput {

    static func urlPathProvider(_ value: DescribeStreamInput) -> Swift.String? {
        return "/describeStream"
    }
}

extension GetDataEndpointInput {

    static func urlPathProvider(_ value: GetDataEndpointInput) -> Swift.String? {
        return "/getDataEndpoint"
    }
}

extension GetSignalingChannelEndpointInput {

    static func urlPathProvider(_ value: GetSignalingChannelEndpointInput) -> Swift.String? {
        return "/getSignalingChannelEndpoint"
    }
}

extension ListEdgeAgentConfigurationsInput {

    static func urlPathProvider(_ value: ListEdgeAgentConfigurationsInput) -> Swift.String? {
        return "/listEdgeAgentConfigurations"
    }
}

extension ListSignalingChannelsInput {

    static func urlPathProvider(_ value: ListSignalingChannelsInput) -> Swift.String? {
        return "/listSignalingChannels"
    }
}

extension ListStreamsInput {

    static func urlPathProvider(_ value: ListStreamsInput) -> Swift.String? {
        return "/listStreams"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/ListTagsForResource"
    }
}

extension ListTagsForStreamInput {

    static func urlPathProvider(_ value: ListTagsForStreamInput) -> Swift.String? {
        return "/listTagsForStream"
    }
}

extension StartEdgeConfigurationUpdateInput {

    static func urlPathProvider(_ value: StartEdgeConfigurationUpdateInput) -> Swift.String? {
        return "/startEdgeConfigurationUpdate"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/TagResource"
    }
}

extension TagStreamInput {

    static func urlPathProvider(_ value: TagStreamInput) -> Swift.String? {
        return "/tagStream"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/UntagResource"
    }
}

extension UntagStreamInput {

    static func urlPathProvider(_ value: UntagStreamInput) -> Swift.String? {
        return "/untagStream"
    }
}

extension UpdateDataRetentionInput {

    static func urlPathProvider(_ value: UpdateDataRetentionInput) -> Swift.String? {
        return "/updateDataRetention"
    }
}

extension UpdateImageGenerationConfigurationInput {

    static func urlPathProvider(_ value: UpdateImageGenerationConfigurationInput) -> Swift.String? {
        return "/updateImageGenerationConfiguration"
    }
}

extension UpdateMediaStorageConfigurationInput {

    static func urlPathProvider(_ value: UpdateMediaStorageConfigurationInput) -> Swift.String? {
        return "/updateMediaStorageConfiguration"
    }
}

extension UpdateNotificationConfigurationInput {

    static func urlPathProvider(_ value: UpdateNotificationConfigurationInput) -> Swift.String? {
        return "/updateNotificationConfiguration"
    }
}

extension UpdateSignalingChannelInput {

    static func urlPathProvider(_ value: UpdateSignalingChannelInput) -> Swift.String? {
        return "/updateSignalingChannel"
    }
}

extension UpdateStreamInput {

    static func urlPathProvider(_ value: UpdateStreamInput) -> Swift.String? {
        return "/updateStream"
    }
}

extension CreateSignalingChannelInput {

    static func write(value: CreateSignalingChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelName"].write(value.channelName)
        try writer["ChannelType"].write(value.channelType)
        try writer["SingleMasterConfiguration"].write(value.singleMasterConfiguration, with: KinesisVideoClientTypes.SingleMasterConfiguration.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: KinesisVideoClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateStreamInput {

    static func write(value: CreateStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DataRetentionInHours"].write(value.dataRetentionInHours)
        try writer["DeviceName"].write(value.deviceName)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["MediaType"].write(value.mediaType)
        try writer["StreamName"].write(value.streamName)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension DeleteEdgeConfigurationInput {

    static func write(value: DeleteEdgeConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StreamARN"].write(value.streamARN)
        try writer["StreamName"].write(value.streamName)
    }
}

extension DeleteSignalingChannelInput {

    static func write(value: DeleteSignalingChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelARN"].write(value.channelARN)
        try writer["CurrentVersion"].write(value.currentVersion)
    }
}

extension DeleteStreamInput {

    static func write(value: DeleteStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CurrentVersion"].write(value.currentVersion)
        try writer["StreamARN"].write(value.streamARN)
    }
}

extension DescribeEdgeConfigurationInput {

    static func write(value: DescribeEdgeConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StreamARN"].write(value.streamARN)
        try writer["StreamName"].write(value.streamName)
    }
}

extension DescribeImageGenerationConfigurationInput {

    static func write(value: DescribeImageGenerationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StreamARN"].write(value.streamARN)
        try writer["StreamName"].write(value.streamName)
    }
}

extension DescribeMappedResourceConfigurationInput {

    static func write(value: DescribeMappedResourceConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["StreamARN"].write(value.streamARN)
        try writer["StreamName"].write(value.streamName)
    }
}

extension DescribeMediaStorageConfigurationInput {

    static func write(value: DescribeMediaStorageConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelARN"].write(value.channelARN)
        try writer["ChannelName"].write(value.channelName)
    }
}

extension DescribeNotificationConfigurationInput {

    static func write(value: DescribeNotificationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StreamARN"].write(value.streamARN)
        try writer["StreamName"].write(value.streamName)
    }
}

extension DescribeSignalingChannelInput {

    static func write(value: DescribeSignalingChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelARN"].write(value.channelARN)
        try writer["ChannelName"].write(value.channelName)
    }
}

extension DescribeStreamInput {

    static func write(value: DescribeStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StreamARN"].write(value.streamARN)
        try writer["StreamName"].write(value.streamName)
    }
}

extension GetDataEndpointInput {

    static func write(value: GetDataEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["APIName"].write(value.apiName)
        try writer["StreamARN"].write(value.streamARN)
        try writer["StreamName"].write(value.streamName)
    }
}

extension GetSignalingChannelEndpointInput {

    static func write(value: GetSignalingChannelEndpointInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelARN"].write(value.channelARN)
        try writer["SingleMasterChannelEndpointConfiguration"].write(value.singleMasterChannelEndpointConfiguration, with: KinesisVideoClientTypes.SingleMasterChannelEndpointConfiguration.write(value:to:))
    }
}

extension ListEdgeAgentConfigurationsInput {

    static func write(value: ListEdgeAgentConfigurationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HubDeviceArn"].write(value.hubDeviceArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListSignalingChannelsInput {

    static func write(value: ListSignalingChannelsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelNameCondition"].write(value.channelNameCondition, with: KinesisVideoClientTypes.ChannelNameCondition.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListStreamsInput {

    static func write(value: ListStreamsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["StreamNameCondition"].write(value.streamNameCondition, with: KinesisVideoClientTypes.StreamNameCondition.write(value:to:))
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension ListTagsForStreamInput {

    static func write(value: ListTagsForStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NextToken"].write(value.nextToken)
        try writer["StreamARN"].write(value.streamARN)
        try writer["StreamName"].write(value.streamName)
    }
}

extension StartEdgeConfigurationUpdateInput {

    static func write(value: StartEdgeConfigurationUpdateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EdgeConfig"].write(value.edgeConfig, with: KinesisVideoClientTypes.EdgeConfig.write(value:to:))
        try writer["StreamARN"].write(value.streamARN)
        try writer["StreamName"].write(value.streamName)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: KinesisVideoClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagStreamInput {

    static func write(value: TagStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StreamARN"].write(value.streamARN)
        try writer["StreamName"].write(value.streamName)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["TagKeyList"].writeList(value.tagKeyList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagStreamInput {

    static func write(value: UntagStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["StreamARN"].write(value.streamARN)
        try writer["StreamName"].write(value.streamName)
        try writer["TagKeyList"].writeList(value.tagKeyList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDataRetentionInput {

    static func write(value: UpdateDataRetentionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CurrentVersion"].write(value.currentVersion)
        try writer["DataRetentionChangeInHours"].write(value.dataRetentionChangeInHours)
        try writer["Operation"].write(value.operation)
        try writer["StreamARN"].write(value.streamARN)
        try writer["StreamName"].write(value.streamName)
    }
}

extension UpdateImageGenerationConfigurationInput {

    static func write(value: UpdateImageGenerationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ImageGenerationConfiguration"].write(value.imageGenerationConfiguration, with: KinesisVideoClientTypes.ImageGenerationConfiguration.write(value:to:))
        try writer["StreamARN"].write(value.streamARN)
        try writer["StreamName"].write(value.streamName)
    }
}

extension UpdateMediaStorageConfigurationInput {

    static func write(value: UpdateMediaStorageConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelARN"].write(value.channelARN)
        try writer["MediaStorageConfiguration"].write(value.mediaStorageConfiguration, with: KinesisVideoClientTypes.MediaStorageConfiguration.write(value:to:))
    }
}

extension UpdateNotificationConfigurationInput {

    static func write(value: UpdateNotificationConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["NotificationConfiguration"].write(value.notificationConfiguration, with: KinesisVideoClientTypes.NotificationConfiguration.write(value:to:))
        try writer["StreamARN"].write(value.streamARN)
        try writer["StreamName"].write(value.streamName)
    }
}

extension UpdateSignalingChannelInput {

    static func write(value: UpdateSignalingChannelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ChannelARN"].write(value.channelARN)
        try writer["CurrentVersion"].write(value.currentVersion)
        try writer["SingleMasterConfiguration"].write(value.singleMasterConfiguration, with: KinesisVideoClientTypes.SingleMasterConfiguration.write(value:to:))
    }
}

extension UpdateStreamInput {

    static func write(value: UpdateStreamInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CurrentVersion"].write(value.currentVersion)
        try writer["DeviceName"].write(value.deviceName)
        try writer["MediaType"].write(value.mediaType)
        try writer["StreamARN"].write(value.streamARN)
        try writer["StreamName"].write(value.streamName)
    }
}

extension CreateSignalingChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSignalingChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSignalingChannelOutput()
        value.channelARN = try reader["ChannelARN"].readIfPresent()
        return value
    }
}

extension CreateStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateStreamOutput()
        value.streamARN = try reader["StreamARN"].readIfPresent()
        return value
    }
}

extension DeleteEdgeConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEdgeConfigurationOutput {
        return DeleteEdgeConfigurationOutput()
    }
}

extension DeleteSignalingChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSignalingChannelOutput {
        return DeleteSignalingChannelOutput()
    }
}

extension DeleteStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteStreamOutput {
        return DeleteStreamOutput()
    }
}

extension DescribeEdgeConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeEdgeConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeEdgeConfigurationOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.edgeAgentStatus = try reader["EdgeAgentStatus"].readIfPresent(with: KinesisVideoClientTypes.EdgeAgentStatus.read(from:))
        value.edgeConfig = try reader["EdgeConfig"].readIfPresent(with: KinesisVideoClientTypes.EdgeConfig.read(from:))
        value.failedStatusDetails = try reader["FailedStatusDetails"].readIfPresent()
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.streamARN = try reader["StreamARN"].readIfPresent()
        value.streamName = try reader["StreamName"].readIfPresent()
        value.syncStatus = try reader["SyncStatus"].readIfPresent()
        return value
    }
}

extension DescribeImageGenerationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeImageGenerationConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeImageGenerationConfigurationOutput()
        value.imageGenerationConfiguration = try reader["ImageGenerationConfiguration"].readIfPresent(with: KinesisVideoClientTypes.ImageGenerationConfiguration.read(from:))
        return value
    }
}

extension DescribeMappedResourceConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMappedResourceConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMappedResourceConfigurationOutput()
        value.mappedResourceConfigurationList = try reader["MappedResourceConfigurationList"].readListIfPresent(memberReadingClosure: KinesisVideoClientTypes.MappedResourceConfigurationListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeMediaStorageConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeMediaStorageConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeMediaStorageConfigurationOutput()
        value.mediaStorageConfiguration = try reader["MediaStorageConfiguration"].readIfPresent(with: KinesisVideoClientTypes.MediaStorageConfiguration.read(from:))
        return value
    }
}

extension DescribeNotificationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeNotificationConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeNotificationConfigurationOutput()
        value.notificationConfiguration = try reader["NotificationConfiguration"].readIfPresent(with: KinesisVideoClientTypes.NotificationConfiguration.read(from:))
        return value
    }
}

extension DescribeSignalingChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSignalingChannelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSignalingChannelOutput()
        value.channelInfo = try reader["ChannelInfo"].readIfPresent(with: KinesisVideoClientTypes.ChannelInfo.read(from:))
        return value
    }
}

extension DescribeStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeStreamOutput()
        value.streamInfo = try reader["StreamInfo"].readIfPresent(with: KinesisVideoClientTypes.StreamInfo.read(from:))
        return value
    }
}

extension GetDataEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDataEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDataEndpointOutput()
        value.dataEndpoint = try reader["DataEndpoint"].readIfPresent()
        return value
    }
}

extension GetSignalingChannelEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSignalingChannelEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSignalingChannelEndpointOutput()
        value.resourceEndpointList = try reader["ResourceEndpointList"].readListIfPresent(memberReadingClosure: KinesisVideoClientTypes.ResourceEndpointListItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListEdgeAgentConfigurationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEdgeAgentConfigurationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEdgeAgentConfigurationsOutput()
        value.edgeConfigs = try reader["EdgeConfigs"].readListIfPresent(memberReadingClosure: KinesisVideoClientTypes.ListEdgeAgentConfigurationsEdgeConfig.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListSignalingChannelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSignalingChannelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSignalingChannelsOutput()
        value.channelInfoList = try reader["ChannelInfoList"].readListIfPresent(memberReadingClosure: KinesisVideoClientTypes.ChannelInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListStreamsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListStreamsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListStreamsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.streamInfoList = try reader["StreamInfoList"].readListIfPresent(memberReadingClosure: KinesisVideoClientTypes.StreamInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListTagsForStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForStreamOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension StartEdgeConfigurationUpdateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartEdgeConfigurationUpdateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartEdgeConfigurationUpdateOutput()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.edgeConfig = try reader["EdgeConfig"].readIfPresent(with: KinesisVideoClientTypes.EdgeConfig.read(from:))
        value.failedStatusDetails = try reader["FailedStatusDetails"].readIfPresent()
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.streamARN = try reader["StreamARN"].readIfPresent()
        value.streamName = try reader["StreamName"].readIfPresent()
        value.syncStatus = try reader["SyncStatus"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension TagStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagStreamOutput {
        return TagStreamOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UntagStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagStreamOutput {
        return UntagStreamOutput()
    }
}

extension UpdateDataRetentionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDataRetentionOutput {
        return UpdateDataRetentionOutput()
    }
}

extension UpdateImageGenerationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateImageGenerationConfigurationOutput {
        return UpdateImageGenerationConfigurationOutput()
    }
}

extension UpdateMediaStorageConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMediaStorageConfigurationOutput {
        return UpdateMediaStorageConfigurationOutput()
    }
}

extension UpdateNotificationConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateNotificationConfigurationOutput {
        return UpdateNotificationConfigurationOutput()
    }
}

extension UpdateSignalingChannelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSignalingChannelOutput {
        return UpdateSignalingChannelOutput()
    }
}

extension UpdateStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateStreamOutput {
        return UpdateStreamOutput()
    }
}

enum CreateSignalingChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "AccountChannelLimitExceededException": return try AccountChannelLimitExceededException.makeError(baseError: baseError)
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "TagsPerResourceExceededLimitException": return try TagsPerResourceExceededLimitException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccountStreamLimitExceededException": return try AccountStreamLimitExceededException.makeError(baseError: baseError)
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "DeviceStreamLimitExceededException": return try DeviceStreamLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidDeviceException": return try InvalidDeviceException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "TagsPerResourceExceededLimitException": return try TagsPerResourceExceededLimitException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEdgeConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "StreamEdgeConfigurationNotFoundException": return try StreamEdgeConfigurationNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSignalingChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "VersionMismatchException": return try VersionMismatchException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "VersionMismatchException": return try VersionMismatchException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeEdgeConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "StreamEdgeConfigurationNotFoundException": return try StreamEdgeConfigurationNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeImageGenerationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMappedResourceConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeMediaStorageConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeNotificationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSignalingChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDataEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSignalingChannelEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEdgeAgentConfigurationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSignalingChannelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListStreamsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidResourceFormatException": return try InvalidResourceFormatException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartEdgeConfigurationUpdateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NoDataRetentionException": return try NoDataRetentionException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TagsPerResourceExceededLimitException": return try TagsPerResourceExceededLimitException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidResourceFormatException": return try InvalidResourceFormatException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TagsPerResourceExceededLimitException": return try TagsPerResourceExceededLimitException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "InvalidResourceFormatException": return try InvalidResourceFormatException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDataRetentionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "VersionMismatchException": return try VersionMismatchException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateImageGenerationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NoDataRetentionException": return try NoDataRetentionException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMediaStorageConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NoDataRetentionException": return try NoDataRetentionException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateNotificationConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NoDataRetentionException": return try NoDataRetentionException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSignalingChannelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "VersionMismatchException": return try VersionMismatchException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ClientLimitExceededException": return try ClientLimitExceededException.makeError(baseError: baseError)
            case "InvalidArgumentException": return try InvalidArgumentException.makeError(baseError: baseError)
            case "NotAuthorizedException": return try NotAuthorizedException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "VersionMismatchException": return try VersionMismatchException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InvalidArgumentException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidArgumentException {
        let reader = baseError.errorBodyReader
        var value = InvalidArgumentException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ClientLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ClientLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = ClientLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TagsPerResourceExceededLimitException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TagsPerResourceExceededLimitException {
        let reader = baseError.errorBodyReader
        var value = TagsPerResourceExceededLimitException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccountChannelLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccountChannelLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = AccountChannelLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccountStreamLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccountStreamLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = AccountStreamLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidDeviceException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidDeviceException {
        let reader = baseError.errorBodyReader
        var value = InvalidDeviceException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DeviceStreamLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DeviceStreamLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = DeviceStreamLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension StreamEdgeConfigurationNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> StreamEdgeConfigurationNotFoundException {
        let reader = baseError.errorBodyReader
        var value = StreamEdgeConfigurationNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension VersionMismatchException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> VersionMismatchException {
        let reader = baseError.errorBodyReader
        var value = VersionMismatchException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotAuthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotAuthorizedException {
        let reader = baseError.errorBodyReader
        var value = NotAuthorizedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidResourceFormatException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidResourceFormatException {
        let reader = baseError.errorBodyReader
        var value = InvalidResourceFormatException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NoDataRetentionException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NoDataRetentionException {
        let reader = baseError.errorBodyReader
        var value = NoDataRetentionException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension KinesisVideoClientTypes.EdgeConfig {

    static func write(value: KinesisVideoClientTypes.EdgeConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeletionConfig"].write(value.deletionConfig, with: KinesisVideoClientTypes.DeletionConfig.write(value:to:))
        try writer["HubDeviceArn"].write(value.hubDeviceArn)
        try writer["RecorderConfig"].write(value.recorderConfig, with: KinesisVideoClientTypes.RecorderConfig.write(value:to:))
        try writer["UploaderConfig"].write(value.uploaderConfig, with: KinesisVideoClientTypes.UploaderConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.EdgeConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.EdgeConfig()
        value.hubDeviceArn = try reader["HubDeviceArn"].readIfPresent() ?? ""
        value.recorderConfig = try reader["RecorderConfig"].readIfPresent(with: KinesisVideoClientTypes.RecorderConfig.read(from:))
        value.uploaderConfig = try reader["UploaderConfig"].readIfPresent(with: KinesisVideoClientTypes.UploaderConfig.read(from:))
        value.deletionConfig = try reader["DeletionConfig"].readIfPresent(with: KinesisVideoClientTypes.DeletionConfig.read(from:))
        return value
    }
}

extension KinesisVideoClientTypes.DeletionConfig {

    static func write(value: KinesisVideoClientTypes.DeletionConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeleteAfterUpload"].write(value.deleteAfterUpload)
        try writer["EdgeRetentionInHours"].write(value.edgeRetentionInHours)
        try writer["LocalSizeConfig"].write(value.localSizeConfig, with: KinesisVideoClientTypes.LocalSizeConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.DeletionConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.DeletionConfig()
        value.edgeRetentionInHours = try reader["EdgeRetentionInHours"].readIfPresent()
        value.localSizeConfig = try reader["LocalSizeConfig"].readIfPresent(with: KinesisVideoClientTypes.LocalSizeConfig.read(from:))
        value.deleteAfterUpload = try reader["DeleteAfterUpload"].readIfPresent()
        return value
    }
}

extension KinesisVideoClientTypes.LocalSizeConfig {

    static func write(value: KinesisVideoClientTypes.LocalSizeConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxLocalMediaSizeInMB"].write(value.maxLocalMediaSizeInMB)
        try writer["StrategyOnFullSize"].write(value.strategyOnFullSize)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.LocalSizeConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.LocalSizeConfig()
        value.maxLocalMediaSizeInMB = try reader["MaxLocalMediaSizeInMB"].readIfPresent()
        value.strategyOnFullSize = try reader["StrategyOnFullSize"].readIfPresent()
        return value
    }
}

extension KinesisVideoClientTypes.UploaderConfig {

    static func write(value: KinesisVideoClientTypes.UploaderConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ScheduleConfig"].write(value.scheduleConfig, with: KinesisVideoClientTypes.ScheduleConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.UploaderConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.UploaderConfig()
        value.scheduleConfig = try reader["ScheduleConfig"].readIfPresent(with: KinesisVideoClientTypes.ScheduleConfig.read(from:))
        return value
    }
}

extension KinesisVideoClientTypes.ScheduleConfig {

    static func write(value: KinesisVideoClientTypes.ScheduleConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DurationInSeconds"].write(value.durationInSeconds)
        try writer["ScheduleExpression"].write(value.scheduleExpression)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.ScheduleConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.ScheduleConfig()
        value.scheduleExpression = try reader["ScheduleExpression"].readIfPresent() ?? ""
        value.durationInSeconds = try reader["DurationInSeconds"].readIfPresent() ?? 0
        return value
    }
}

extension KinesisVideoClientTypes.RecorderConfig {

    static func write(value: KinesisVideoClientTypes.RecorderConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MediaSourceConfig"].write(value.mediaSourceConfig, with: KinesisVideoClientTypes.MediaSourceConfig.write(value:to:))
        try writer["ScheduleConfig"].write(value.scheduleConfig, with: KinesisVideoClientTypes.ScheduleConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.RecorderConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.RecorderConfig()
        value.mediaSourceConfig = try reader["MediaSourceConfig"].readIfPresent(with: KinesisVideoClientTypes.MediaSourceConfig.read(from:))
        value.scheduleConfig = try reader["ScheduleConfig"].readIfPresent(with: KinesisVideoClientTypes.ScheduleConfig.read(from:))
        return value
    }
}

extension KinesisVideoClientTypes.MediaSourceConfig {

    static func write(value: KinesisVideoClientTypes.MediaSourceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MediaUriSecretArn"].write(value.mediaUriSecretArn)
        try writer["MediaUriType"].write(value.mediaUriType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.MediaSourceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.MediaSourceConfig()
        value.mediaUriSecretArn = try reader["MediaUriSecretArn"].readIfPresent() ?? ""
        value.mediaUriType = try reader["MediaUriType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension KinesisVideoClientTypes.EdgeAgentStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.EdgeAgentStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.EdgeAgentStatus()
        value.lastRecorderStatus = try reader["LastRecorderStatus"].readIfPresent(with: KinesisVideoClientTypes.LastRecorderStatus.read(from:))
        value.lastUploaderStatus = try reader["LastUploaderStatus"].readIfPresent(with: KinesisVideoClientTypes.LastUploaderStatus.read(from:))
        return value
    }
}

extension KinesisVideoClientTypes.LastUploaderStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.LastUploaderStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.LastUploaderStatus()
        value.jobStatusDetails = try reader["JobStatusDetails"].readIfPresent()
        value.lastCollectedTime = try reader["LastCollectedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.uploaderStatus = try reader["UploaderStatus"].readIfPresent()
        return value
    }
}

extension KinesisVideoClientTypes.LastRecorderStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.LastRecorderStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.LastRecorderStatus()
        value.jobStatusDetails = try reader["JobStatusDetails"].readIfPresent()
        value.lastCollectedTime = try reader["LastCollectedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.recorderStatus = try reader["RecorderStatus"].readIfPresent()
        return value
    }
}

extension KinesisVideoClientTypes.ImageGenerationConfiguration {

    static func write(value: KinesisVideoClientTypes.ImageGenerationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationConfig"].write(value.destinationConfig, with: KinesisVideoClientTypes.ImageGenerationDestinationConfig.write(value:to:))
        try writer["Format"].write(value.format)
        try writer["FormatConfig"].writeMap(value.formatConfig, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["HeightPixels"].write(value.heightPixels)
        try writer["ImageSelectorType"].write(value.imageSelectorType)
        try writer["SamplingInterval"].write(value.samplingInterval)
        try writer["Status"].write(value.status)
        try writer["WidthPixels"].write(value.widthPixels)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.ImageGenerationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.ImageGenerationConfiguration()
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.imageSelectorType = try reader["ImageSelectorType"].readIfPresent() ?? .sdkUnknown("")
        value.destinationConfig = try reader["DestinationConfig"].readIfPresent(with: KinesisVideoClientTypes.ImageGenerationDestinationConfig.read(from:))
        value.samplingInterval = try reader["SamplingInterval"].readIfPresent() ?? 0
        value.format = try reader["Format"].readIfPresent() ?? .sdkUnknown("")
        value.formatConfig = try reader["FormatConfig"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.widthPixels = try reader["WidthPixels"].readIfPresent()
        value.heightPixels = try reader["HeightPixels"].readIfPresent()
        return value
    }
}

extension KinesisVideoClientTypes.ImageGenerationDestinationConfig {

    static func write(value: KinesisVideoClientTypes.ImageGenerationDestinationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationRegion"].write(value.destinationRegion)
        try writer["Uri"].write(value.uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.ImageGenerationDestinationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.ImageGenerationDestinationConfig()
        value.uri = try reader["Uri"].readIfPresent() ?? ""
        value.destinationRegion = try reader["DestinationRegion"].readIfPresent() ?? ""
        return value
    }
}

extension KinesisVideoClientTypes.MappedResourceConfigurationListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.MappedResourceConfigurationListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.MappedResourceConfigurationListItem()
        value.type = try reader["Type"].readIfPresent()
        value.arn = try reader["ARN"].readIfPresent()
        return value
    }
}

extension KinesisVideoClientTypes.MediaStorageConfiguration {

    static func write(value: KinesisVideoClientTypes.MediaStorageConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Status"].write(value.status)
        try writer["StreamARN"].write(value.streamARN)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.MediaStorageConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.MediaStorageConfiguration()
        value.streamARN = try reader["StreamARN"].readIfPresent()
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension KinesisVideoClientTypes.NotificationConfiguration {

    static func write(value: KinesisVideoClientTypes.NotificationConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DestinationConfig"].write(value.destinationConfig, with: KinesisVideoClientTypes.NotificationDestinationConfig.write(value:to:))
        try writer["Status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.NotificationConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.NotificationConfiguration()
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.destinationConfig = try reader["DestinationConfig"].readIfPresent(with: KinesisVideoClientTypes.NotificationDestinationConfig.read(from:))
        return value
    }
}

extension KinesisVideoClientTypes.NotificationDestinationConfig {

    static func write(value: KinesisVideoClientTypes.NotificationDestinationConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Uri"].write(value.uri)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.NotificationDestinationConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.NotificationDestinationConfig()
        value.uri = try reader["Uri"].readIfPresent() ?? ""
        return value
    }
}

extension KinesisVideoClientTypes.ChannelInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.ChannelInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.ChannelInfo()
        value.channelName = try reader["ChannelName"].readIfPresent()
        value.channelARN = try reader["ChannelARN"].readIfPresent()
        value.channelType = try reader["ChannelType"].readIfPresent()
        value.channelStatus = try reader["ChannelStatus"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.singleMasterConfiguration = try reader["SingleMasterConfiguration"].readIfPresent(with: KinesisVideoClientTypes.SingleMasterConfiguration.read(from:))
        value.version = try reader["Version"].readIfPresent()
        return value
    }
}

extension KinesisVideoClientTypes.SingleMasterConfiguration {

    static func write(value: KinesisVideoClientTypes.SingleMasterConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MessageTtlSeconds"].write(value.messageTtlSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.SingleMasterConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.SingleMasterConfiguration()
        value.messageTtlSeconds = try reader["MessageTtlSeconds"].readIfPresent()
        return value
    }
}

extension KinesisVideoClientTypes.StreamInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.StreamInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.StreamInfo()
        value.deviceName = try reader["DeviceName"].readIfPresent()
        value.streamName = try reader["StreamName"].readIfPresent()
        value.streamARN = try reader["StreamARN"].readIfPresent()
        value.mediaType = try reader["MediaType"].readIfPresent()
        value.kmsKeyId = try reader["KmsKeyId"].readIfPresent()
        value.version = try reader["Version"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.dataRetentionInHours = try reader["DataRetentionInHours"].readIfPresent()
        return value
    }
}

extension KinesisVideoClientTypes.ResourceEndpointListItem {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.ResourceEndpointListItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.ResourceEndpointListItem()
        value.`protocol` = try reader["Protocol"].readIfPresent()
        value.resourceEndpoint = try reader["ResourceEndpoint"].readIfPresent()
        return value
    }
}

extension KinesisVideoClientTypes.ListEdgeAgentConfigurationsEdgeConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> KinesisVideoClientTypes.ListEdgeAgentConfigurationsEdgeConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = KinesisVideoClientTypes.ListEdgeAgentConfigurationsEdgeConfig()
        value.streamName = try reader["StreamName"].readIfPresent()
        value.streamARN = try reader["StreamARN"].readIfPresent()
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.syncStatus = try reader["SyncStatus"].readIfPresent()
        value.failedStatusDetails = try reader["FailedStatusDetails"].readIfPresent()
        value.edgeConfig = try reader["EdgeConfig"].readIfPresent(with: KinesisVideoClientTypes.EdgeConfig.read(from:))
        return value
    }
}

extension KinesisVideoClientTypes.Tag {

    static func write(value: KinesisVideoClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }
}

extension KinesisVideoClientTypes.SingleMasterChannelEndpointConfiguration {

    static func write(value: KinesisVideoClientTypes.SingleMasterChannelEndpointConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Protocols"].writeList(value.protocols, memberWritingClosure: SmithyReadWrite.WritingClosureBox<KinesisVideoClientTypes.ChannelProtocol>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Role"].write(value.role)
    }
}

extension KinesisVideoClientTypes.ChannelNameCondition {

    static func write(value: KinesisVideoClientTypes.ChannelNameCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComparisonOperator"].write(value.comparisonOperator)
        try writer["ComparisonValue"].write(value.comparisonValue)
    }
}

extension KinesisVideoClientTypes.StreamNameCondition {

    static func write(value: KinesisVideoClientTypes.StreamNameCondition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComparisonOperator"].write(value.comparisonOperator)
        try writer["ComparisonValue"].write(value.comparisonValue)
    }
}

public enum KinesisVideoClientTypes {}
