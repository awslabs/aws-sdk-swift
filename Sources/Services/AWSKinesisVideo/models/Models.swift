// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension KinesisVideoClientTypes {
    public enum APIName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case getClip
        case getDashStreamingSessionUrl
        case getHlsStreamingSessionUrl
        case getImages
        case getMedia
        case getMediaForFragmentList
        case listFragments
        case putMedia
        case sdkUnknown(Swift.String)

        public static var allCases: [APIName] {
            return [
                .getClip,
                .getDashStreamingSessionUrl,
                .getHlsStreamingSessionUrl,
                .getImages,
                .getMedia,
                .getMediaForFragmentList,
                .listFragments,
                .putMedia,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .getClip: return "GET_CLIP"
            case .getDashStreamingSessionUrl: return "GET_DASH_STREAMING_SESSION_URL"
            case .getHlsStreamingSessionUrl: return "GET_HLS_STREAMING_SESSION_URL"
            case .getImages: return "GET_IMAGES"
            case .getMedia: return "GET_MEDIA"
            case .getMediaForFragmentList: return "GET_MEDIA_FOR_FRAGMENT_LIST"
            case .listFragments: return "LIST_FRAGMENTS"
            case .putMedia: return "PUT_MEDIA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = APIName(rawValue: rawValue) ?? APIName.sdkUnknown(rawValue)
        }
    }
}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have required permissions to perform this operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountChannelLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccountChannelLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have reached the maximum limit of active signaling channels for this Amazon Web Services account in this region.
public struct AccountChannelLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccountChannelLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccountChannelLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccountChannelLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountStreamLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccountStreamLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of streams created for the account is too high.
public struct AccountStreamLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccountStreamLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccountStreamLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccountStreamLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisVideoClientTypes.ChannelInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case channelName = "ChannelName"
        case channelStatus = "ChannelStatus"
        case channelType = "ChannelType"
        case creationTime = "CreationTime"
        case singleMasterConfiguration = "SingleMasterConfiguration"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = self.channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelStatus = self.channelStatus {
            try encodeContainer.encode(channelStatus.rawValue, forKey: .channelStatus)
        }
        if let channelType = self.channelType {
            try encodeContainer.encode(channelType.rawValue, forKey: .channelType)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let singleMasterConfiguration = self.singleMasterConfiguration {
            try encodeContainer.encode(singleMasterConfiguration, forKey: .singleMasterConfiguration)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
        let channelTypeDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ChannelType.self, forKey: .channelType)
        channelType = channelTypeDecoded
        let channelStatusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.Status.self, forKey: .channelStatus)
        channelStatus = channelStatusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let singleMasterConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.SingleMasterConfiguration.self, forKey: .singleMasterConfiguration)
        singleMasterConfiguration = singleMasterConfigurationDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension KinesisVideoClientTypes {
    /// A structure that encapsulates a signaling channel's metadata and properties.
    public struct ChannelInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the signaling channel.
        public var channelARN: Swift.String?
        /// The name of the signaling channel.
        public var channelName: Swift.String?
        /// Current status of the signaling channel.
        public var channelStatus: KinesisVideoClientTypes.Status?
        /// The type of the signaling channel.
        public var channelType: KinesisVideoClientTypes.ChannelType?
        /// The time at which the signaling channel was created.
        public var creationTime: ClientRuntime.Date?
        /// A structure that contains the configuration for the SINGLE_MASTER channel type.
        public var singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration?
        /// The current version of the signaling channel.
        public var version: Swift.String?

        public init(
            channelARN: Swift.String? = nil,
            channelName: Swift.String? = nil,
            channelStatus: KinesisVideoClientTypes.Status? = nil,
            channelType: KinesisVideoClientTypes.ChannelType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration? = nil,
            version: Swift.String? = nil
        )
        {
            self.channelARN = channelARN
            self.channelName = channelName
            self.channelStatus = channelStatus
            self.channelType = channelType
            self.creationTime = creationTime
            self.singleMasterConfiguration = singleMasterConfiguration
            self.version = version
        }
    }

}

extension KinesisVideoClientTypes.ChannelNameCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonOperator = "ComparisonOperator"
        case comparisonValue = "ComparisonValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = self.comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let comparisonValue = self.comparisonValue {
            try encodeContainer.encode(comparisonValue, forKey: .comparisonValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let comparisonValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comparisonValue)
        comparisonValue = comparisonValueDecoded
    }
}

extension KinesisVideoClientTypes {
    /// An optional input parameter for the ListSignalingChannels API. When this parameter is specified while invoking ListSignalingChannels, the API returns only the channels that satisfy a condition specified in ChannelNameCondition.
    public struct ChannelNameCondition: Swift.Equatable {
        /// A comparison operator. Currently, you can only specify the BEGINS_WITH operator, which finds signaling channels whose names begin with a given prefix.
        public var comparisonOperator: KinesisVideoClientTypes.ComparisonOperator?
        /// A value to compare.
        public var comparisonValue: Swift.String?

        public init(
            comparisonOperator: KinesisVideoClientTypes.ComparisonOperator? = nil,
            comparisonValue: Swift.String? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.comparisonValue = comparisonValue
        }
    }

}

extension KinesisVideoClientTypes {
    public enum ChannelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case https
        case webrtc
        case wss
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelProtocol] {
            return [
                .https,
                .webrtc,
                .wss,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .https: return "HTTPS"
            case .webrtc: return "WEBRTC"
            case .wss: return "WSS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelProtocol(rawValue: rawValue) ?? ChannelProtocol.sdkUnknown(rawValue)
        }
    }
}

extension KinesisVideoClientTypes {
    public enum ChannelRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case master
        case viewer
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelRole] {
            return [
                .master,
                .viewer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .master: return "MASTER"
            case .viewer: return "VIEWER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelRole(rawValue: rawValue) ?? ChannelRole.sdkUnknown(rawValue)
        }
    }
}

extension KinesisVideoClientTypes {
    public enum ChannelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullMesh
        case singleMaster
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelType] {
            return [
                .fullMesh,
                .singleMaster,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullMesh: return "FULL_MESH"
            case .singleMaster: return "SINGLE_MASTER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelType(rawValue: rawValue) ?? ChannelType.sdkUnknown(rawValue)
        }
    }
}

extension ClientLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ClientLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Kinesis Video Streams has throttled the request because you have exceeded the limit of allowed client calls. Try making the call later.
public struct ClientLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ClientLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ClientLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ClientLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisVideoClientTypes {
    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case beginsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .beginsWith,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .beginsWith: return "BEGINS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
        }
    }
}

extension KinesisVideoClientTypes {
    public enum ConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationStatus(rawValue: rawValue) ?? ConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension CreateSignalingChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelName = "ChannelName"
        case channelType = "ChannelType"
        case singleMasterConfiguration = "SingleMasterConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelType = self.channelType {
            try encodeContainer.encode(channelType.rawValue, forKey: .channelType)
        }
        if let singleMasterConfiguration = self.singleMasterConfiguration {
            try encodeContainer.encode(singleMasterConfiguration, forKey: .singleMasterConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateSignalingChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createSignalingChannel"
    }
}

public struct CreateSignalingChannelInput: Swift.Equatable {
    /// A name for the signaling channel that you are creating. It must be unique for each Amazon Web Services account and Amazon Web Services Region.
    /// This member is required.
    public var channelName: Swift.String?
    /// A type of the signaling channel that you are creating. Currently, SINGLE_MASTER is the only supported channel type.
    public var channelType: KinesisVideoClientTypes.ChannelType?
    /// A structure containing the configuration for the SINGLE_MASTER channel type.
    public var singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration?
    /// A set of tags (key-value pairs) that you want to associate with this channel.
    public var tags: [KinesisVideoClientTypes.Tag]?

    public init(
        channelName: Swift.String? = nil,
        channelType: KinesisVideoClientTypes.ChannelType? = nil,
        singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration? = nil,
        tags: [KinesisVideoClientTypes.Tag]? = nil
    )
    {
        self.channelName = channelName
        self.channelType = channelType
        self.singleMasterConfiguration = singleMasterConfiguration
        self.tags = tags
    }
}

struct CreateSignalingChannelInputBody: Swift.Equatable {
    let channelName: Swift.String?
    let channelType: KinesisVideoClientTypes.ChannelType?
    let singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration?
    let tags: [KinesisVideoClientTypes.Tag]?
}

extension CreateSignalingChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelName = "ChannelName"
        case channelType = "ChannelType"
        case singleMasterConfiguration = "SingleMasterConfiguration"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelTypeDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ChannelType.self, forKey: .channelType)
        channelType = channelTypeDecoded
        let singleMasterConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.SingleMasterConfiguration.self, forKey: .singleMasterConfiguration)
        singleMasterConfiguration = singleMasterConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KinesisVideoClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KinesisVideoClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSignalingChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSignalingChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelARN = output.channelARN
        } else {
            self.channelARN = nil
        }
    }
}

public struct CreateSignalingChannelOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created channel.
    public var channelARN: Swift.String?

    public init(
        channelARN: Swift.String? = nil
    )
    {
        self.channelARN = channelARN
    }
}

struct CreateSignalingChannelOutputBody: Swift.Equatable {
    let channelARN: Swift.String?
}

extension CreateSignalingChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
    }
}

enum CreateSignalingChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AccountChannelLimitExceededException": return try await AccountChannelLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagsPerResourceExceededLimitException": return try await TagsPerResourceExceededLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRetentionInHours = "DataRetentionInHours"
        case deviceName = "DeviceName"
        case kmsKeyId = "KmsKeyId"
        case mediaType = "MediaType"
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataRetentionInHours = self.dataRetentionInHours {
            try encodeContainer.encode(dataRetentionInHours, forKey: .dataRetentionInHours)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let mediaType = self.mediaType {
            try encodeContainer.encode(mediaType, forKey: .mediaType)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, resourceTags0) in tags {
                try tagsContainer.encode(resourceTags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createStream"
    }
}

public struct CreateStreamInput: Swift.Equatable {
    /// The number of hours that you want to retain the data in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream. The default value is 0, indicating that the stream does not persist data. When the DataRetentionInHours value is 0, consumers can still consume the fragments that remain in the service host buffer, which has a retention time limit of 5 minutes and a retention memory limit of 200 MB. Fragments are removed from the buffer when either limit is reached.
    public var dataRetentionInHours: Swift.Int?
    /// The name of the device that is writing to the stream. In the current implementation, Kinesis Video Streams does not use this name.
    public var deviceName: Swift.String?
    /// The ID of the Key Management Service (KMS) key that you want Kinesis Video Streams to use to encrypt stream data. If no key ID is specified, the default, Kinesis Video-managed key (Amazon Web Services/kinesisvideo) is used. For more information, see [DescribeKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters).
    public var kmsKeyId: Swift.String?
    /// The media type of the stream. Consumers of the stream can use this information when processing the stream. For more information about media types, see [Media Types](http://www.iana.org/assignments/media-types/media-types.xhtml). If you choose to specify the MediaType, see [Naming Requirements](https://tools.ietf.org/html/rfc6838#section-4.2) for guidelines. Example valid values include "video/h264" and "video/h264,audio/aac". This parameter is optional; the default value is null (or empty in JSON).
    public var mediaType: Swift.String?
    /// A name for the stream that you are creating. The stream name is an identifier for the stream, and must be unique for each account and region.
    /// This member is required.
    public var streamName: Swift.String?
    /// A list of tags to associate with the specified stream. Each tag is a key-value pair (the value is optional).
    public var tags: [Swift.String:Swift.String]?

    public init(
        dataRetentionInHours: Swift.Int? = nil,
        deviceName: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        mediaType: Swift.String? = nil,
        streamName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.dataRetentionInHours = dataRetentionInHours
        self.deviceName = deviceName
        self.kmsKeyId = kmsKeyId
        self.mediaType = mediaType
        self.streamName = streamName
        self.tags = tags
    }
}

struct CreateStreamInputBody: Swift.Equatable {
    let deviceName: Swift.String?
    let streamName: Swift.String?
    let mediaType: Swift.String?
    let kmsKeyId: Swift.String?
    let dataRetentionInHours: Swift.Int?
    let tags: [Swift.String:Swift.String]?
}

extension CreateStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRetentionInHours = "DataRetentionInHours"
        case deviceName = "DeviceName"
        case kmsKeyId = "KmsKeyId"
        case mediaType = "MediaType"
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let mediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaType)
        mediaType = mediaTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dataRetentionInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRetentionInHours)
        dataRetentionInHours = dataRetentionInHoursDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateStreamOutputBody = try responseDecoder.decode(responseBody: data)
            self.streamARN = output.streamARN
        } else {
            self.streamARN = nil
        }
    }
}

public struct CreateStreamOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the stream.
    public var streamARN: Swift.String?

    public init(
        streamARN: Swift.String? = nil
    )
    {
        self.streamARN = streamARN
    }
}

struct CreateStreamOutputBody: Swift.Equatable {
    let streamARN: Swift.String?
}

extension CreateStreamOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

enum CreateStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccountStreamLimitExceededException": return try await AccountStreamLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DeviceStreamLimitExceededException": return try await DeviceStreamLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidDeviceException": return try await InvalidDeviceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagsPerResourceExceededLimitException": return try await TagsPerResourceExceededLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEdgeConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension DeleteEdgeConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteEdgeConfiguration"
    }
}

public struct DeleteEdgeConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the stream. Specify either the StreamName or the StreamARN.
    public var streamARN: Swift.String?
    /// The name of the stream from which to delete the edge configuration. Specify either the StreamName or the StreamARN.
    public var streamName: Swift.String?

    public init(
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct DeleteEdgeConfigurationInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
}

extension DeleteEdgeConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

extension DeleteEdgeConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEdgeConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEdgeConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StreamEdgeConfigurationNotFoundException": return try await StreamEdgeConfigurationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSignalingChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case currentVersion = "CurrentVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = self.channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
    }
}

extension DeleteSignalingChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteSignalingChannel"
    }
}

public struct DeleteSignalingChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the signaling channel that you want to delete.
    /// This member is required.
    public var channelARN: Swift.String?
    /// The current version of the signaling channel that you want to delete. You can obtain the current version by invoking the DescribeSignalingChannel or ListSignalingChannels API operations.
    public var currentVersion: Swift.String?

    public init(
        channelARN: Swift.String? = nil,
        currentVersion: Swift.String? = nil
    )
    {
        self.channelARN = channelARN
        self.currentVersion = currentVersion
    }
}

struct DeleteSignalingChannelInputBody: Swift.Equatable {
    let channelARN: Swift.String?
    let currentVersion: Swift.String?
}

extension DeleteSignalingChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case currentVersion = "CurrentVersion"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
    }
}

extension DeleteSignalingChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSignalingChannelOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSignalingChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionMismatchException": return try await VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case streamARN = "StreamARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
    }
}

extension DeleteStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteStream"
    }
}

public struct DeleteStreamInput: Swift.Equatable {
    /// Optional: The version of the stream that you want to delete. Specify the version as a safeguard to ensure that your are deleting the correct stream. To get the stream version, use the DescribeStream API. If not specified, only the CreationTime is checked before deleting the stream.
    public var currentVersion: Swift.String?
    /// The Amazon Resource Name (ARN) of the stream that you want to delete.
    /// This member is required.
    public var streamARN: Swift.String?

    public init(
        currentVersion: Swift.String? = nil,
        streamARN: Swift.String? = nil
    )
    {
        self.currentVersion = currentVersion
        self.streamARN = streamARN
    }
}

struct DeleteStreamInputBody: Swift.Equatable {
    let streamARN: Swift.String?
    let currentVersion: Swift.String?
}

extension DeleteStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case streamARN = "StreamARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
    }
}

extension DeleteStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteStreamOutput: Swift.Equatable {

    public init() { }
}

enum DeleteStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionMismatchException": return try await VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension KinesisVideoClientTypes.DeletionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteAfterUpload = "DeleteAfterUpload"
        case edgeRetentionInHours = "EdgeRetentionInHours"
        case localSizeConfig = "LocalSizeConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteAfterUpload = self.deleteAfterUpload {
            try encodeContainer.encode(deleteAfterUpload, forKey: .deleteAfterUpload)
        }
        if let edgeRetentionInHours = self.edgeRetentionInHours {
            try encodeContainer.encode(edgeRetentionInHours, forKey: .edgeRetentionInHours)
        }
        if let localSizeConfig = self.localSizeConfig {
            try encodeContainer.encode(localSizeConfig, forKey: .localSizeConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let edgeRetentionInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .edgeRetentionInHours)
        edgeRetentionInHours = edgeRetentionInHoursDecoded
        let localSizeConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.LocalSizeConfig.self, forKey: .localSizeConfig)
        localSizeConfig = localSizeConfigDecoded
        let deleteAfterUploadDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteAfterUpload)
        deleteAfterUpload = deleteAfterUploadDecoded
    }
}

extension KinesisVideoClientTypes {
    /// The configuration details required to delete the connection of the stream from the Edge Agent.
    public struct DeletionConfig: Swift.Equatable {
        /// The boolean value used to indicate whether or not you want to mark the media for deletion, once it has been uploaded to the Kinesis Video Stream cloud. The media files can be deleted if any of the deletion configuration values are set to true, such as when the limit for the EdgeRetentionInHours, or the MaxLocalMediaSizeInMB, has been reached. Since the default value is set to true, configure the uploader schedule such that the media files are not being deleted before they are initially uploaded to the Amazon Web Services cloud.
        public var deleteAfterUpload: Swift.Bool?
        /// The number of hours that you want to retain the data in the stream on the Edge Agent. The default value of the retention time is 720 hours, which translates to 30 days.
        public var edgeRetentionInHours: Swift.Int?
        /// The value of the local size required in order to delete the edge configuration.
        public var localSizeConfig: KinesisVideoClientTypes.LocalSizeConfig?

        public init(
            deleteAfterUpload: Swift.Bool? = nil,
            edgeRetentionInHours: Swift.Int? = nil,
            localSizeConfig: KinesisVideoClientTypes.LocalSizeConfig? = nil
        )
        {
            self.deleteAfterUpload = deleteAfterUpload
            self.edgeRetentionInHours = edgeRetentionInHours
            self.localSizeConfig = localSizeConfig
        }
    }

}

extension DescribeEdgeConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension DescribeEdgeConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeEdgeConfiguration"
    }
}

public struct DescribeEdgeConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the stream. Specify either the StreamNameor the StreamARN.
    public var streamARN: Swift.String?
    /// The name of the stream whose edge configuration you want to update. Specify either the StreamName or the StreamARN.
    public var streamName: Swift.String?

    public init(
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct DescribeEdgeConfigurationInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
}

extension DescribeEdgeConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

extension DescribeEdgeConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEdgeConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.edgeAgentStatus = output.edgeAgentStatus
            self.edgeConfig = output.edgeConfig
            self.failedStatusDetails = output.failedStatusDetails
            self.lastUpdatedTime = output.lastUpdatedTime
            self.streamARN = output.streamARN
            self.streamName = output.streamName
            self.syncStatus = output.syncStatus
        } else {
            self.creationTime = nil
            self.edgeAgentStatus = nil
            self.edgeConfig = nil
            self.failedStatusDetails = nil
            self.lastUpdatedTime = nil
            self.streamARN = nil
            self.streamName = nil
            self.syncStatus = nil
        }
    }
}

public struct DescribeEdgeConfigurationOutput: Swift.Equatable {
    /// The timestamp at which a stream’s edge configuration was first created.
    public var creationTime: ClientRuntime.Date?
    /// An object that contains the latest status details for an edge agent's recorder and uploader jobs. Use this information to determine the current health of an edge agent.
    public var edgeAgentStatus: KinesisVideoClientTypes.EdgeAgentStatus?
    /// A description of the stream's edge configuration that will be used to sync with the Edge Agent IoT Greengrass component. The Edge Agent component will run on an IoT Hub Device setup at your premise.
    public var edgeConfig: KinesisVideoClientTypes.EdgeConfig?
    /// A description of the generated failure status.
    public var failedStatusDetails: Swift.String?
    /// The timestamp at which a stream’s edge configuration was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the stream.
    public var streamARN: Swift.String?
    /// The name of the stream from which the edge configuration was updated.
    public var streamName: Swift.String?
    /// The latest status of the edge configuration update.
    public var syncStatus: KinesisVideoClientTypes.SyncStatus?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        edgeAgentStatus: KinesisVideoClientTypes.EdgeAgentStatus? = nil,
        edgeConfig: KinesisVideoClientTypes.EdgeConfig? = nil,
        failedStatusDetails: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil,
        syncStatus: KinesisVideoClientTypes.SyncStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.edgeAgentStatus = edgeAgentStatus
        self.edgeConfig = edgeConfig
        self.failedStatusDetails = failedStatusDetails
        self.lastUpdatedTime = lastUpdatedTime
        self.streamARN = streamARN
        self.streamName = streamName
        self.syncStatus = syncStatus
    }
}

struct DescribeEdgeConfigurationOutputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastUpdatedTime: ClientRuntime.Date?
    let syncStatus: KinesisVideoClientTypes.SyncStatus?
    let failedStatusDetails: Swift.String?
    let edgeConfig: KinesisVideoClientTypes.EdgeConfig?
    let edgeAgentStatus: KinesisVideoClientTypes.EdgeAgentStatus?
}

extension DescribeEdgeConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case edgeAgentStatus = "EdgeAgentStatus"
        case edgeConfig = "EdgeConfig"
        case failedStatusDetails = "FailedStatusDetails"
        case lastUpdatedTime = "LastUpdatedTime"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case syncStatus = "SyncStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let syncStatusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.SyncStatus.self, forKey: .syncStatus)
        syncStatus = syncStatusDecoded
        let failedStatusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failedStatusDetails)
        failedStatusDetails = failedStatusDetailsDecoded
        let edgeConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.EdgeConfig.self, forKey: .edgeConfig)
        edgeConfig = edgeConfigDecoded
        let edgeAgentStatusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.EdgeAgentStatus.self, forKey: .edgeAgentStatus)
        edgeAgentStatus = edgeAgentStatusDecoded
    }
}

enum DescribeEdgeConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "StreamEdgeConfigurationNotFoundException": return try await StreamEdgeConfigurationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeImageGenerationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension DescribeImageGenerationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeImageGenerationConfiguration"
    }
}

public struct DescribeImageGenerationConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Kinesis video stream from which to retrieve the image generation configuration. You must specify either the StreamName or the StreamARN.
    public var streamARN: Swift.String?
    /// The name of the stream from which to retrieve the image generation configuration. You must specify either the StreamName or the StreamARN.
    public var streamName: Swift.String?

    public init(
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct DescribeImageGenerationConfigurationInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
}

extension DescribeImageGenerationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

extension DescribeImageGenerationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeImageGenerationConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageGenerationConfiguration = output.imageGenerationConfiguration
        } else {
            self.imageGenerationConfiguration = nil
        }
    }
}

public struct DescribeImageGenerationConfigurationOutput: Swift.Equatable {
    /// The structure that contains the information required for the Kinesis video stream (KVS) images delivery. If this structure is null, the configuration will be deleted from the stream.
    public var imageGenerationConfiguration: KinesisVideoClientTypes.ImageGenerationConfiguration?

    public init(
        imageGenerationConfiguration: KinesisVideoClientTypes.ImageGenerationConfiguration? = nil
    )
    {
        self.imageGenerationConfiguration = imageGenerationConfiguration
    }
}

struct DescribeImageGenerationConfigurationOutputBody: Swift.Equatable {
    let imageGenerationConfiguration: KinesisVideoClientTypes.ImageGenerationConfiguration?
}

extension DescribeImageGenerationConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageGenerationConfiguration = "ImageGenerationConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageGenerationConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ImageGenerationConfiguration.self, forKey: .imageGenerationConfiguration)
        imageGenerationConfiguration = imageGenerationConfigurationDecoded
    }
}

enum DescribeImageGenerationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeMappedResourceConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension DescribeMappedResourceConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeMappedResourceConfiguration"
    }
}

public struct DescribeMappedResourceConfigurationInput: Swift.Equatable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The token to provide in your next request, to get another batch of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the stream.
    public var streamARN: Swift.String?
    /// The name of the stream.
    public var streamName: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct DescribeMappedResourceConfigurationInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeMappedResourceConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMappedResourceConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMappedResourceConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.mappedResourceConfigurationList = output.mappedResourceConfigurationList
            self.nextToken = output.nextToken
        } else {
            self.mappedResourceConfigurationList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeMappedResourceConfigurationOutput: Swift.Equatable {
    /// A structure that encapsulates, or contains, the media storage configuration properties.
    public var mappedResourceConfigurationList: [KinesisVideoClientTypes.MappedResourceConfigurationListItem]?
    /// The token that was used in the NextTokenrequest to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        mappedResourceConfigurationList: [KinesisVideoClientTypes.MappedResourceConfigurationListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mappedResourceConfigurationList = mappedResourceConfigurationList
        self.nextToken = nextToken
    }
}

struct DescribeMappedResourceConfigurationOutputBody: Swift.Equatable {
    let mappedResourceConfigurationList: [KinesisVideoClientTypes.MappedResourceConfigurationListItem]?
    let nextToken: Swift.String?
}

extension DescribeMappedResourceConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mappedResourceConfigurationList = "MappedResourceConfigurationList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mappedResourceConfigurationListContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.MappedResourceConfigurationListItem?].self, forKey: .mappedResourceConfigurationList)
        var mappedResourceConfigurationListDecoded0:[KinesisVideoClientTypes.MappedResourceConfigurationListItem]? = nil
        if let mappedResourceConfigurationListContainer = mappedResourceConfigurationListContainer {
            mappedResourceConfigurationListDecoded0 = [KinesisVideoClientTypes.MappedResourceConfigurationListItem]()
            for structure0 in mappedResourceConfigurationListContainer {
                if let structure0 = structure0 {
                    mappedResourceConfigurationListDecoded0?.append(structure0)
                }
            }
        }
        mappedResourceConfigurationList = mappedResourceConfigurationListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeMappedResourceConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeMediaStorageConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case channelName = "ChannelName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = self.channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
    }
}

extension DescribeMediaStorageConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeMediaStorageConfiguration"
    }
}

public struct DescribeMediaStorageConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the channel.
    public var channelARN: Swift.String?
    /// The name of the channel.
    public var channelName: Swift.String?

    public init(
        channelARN: Swift.String? = nil,
        channelName: Swift.String? = nil
    )
    {
        self.channelARN = channelARN
        self.channelName = channelName
    }
}

struct DescribeMediaStorageConfigurationInputBody: Swift.Equatable {
    let channelName: Swift.String?
    let channelARN: Swift.String?
}

extension DescribeMediaStorageConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case channelName = "ChannelName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
    }
}

extension DescribeMediaStorageConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMediaStorageConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.mediaStorageConfiguration = output.mediaStorageConfiguration
        } else {
            self.mediaStorageConfiguration = nil
        }
    }
}

public struct DescribeMediaStorageConfigurationOutput: Swift.Equatable {
    /// A structure that encapsulates, or contains, the media storage configuration properties.
    public var mediaStorageConfiguration: KinesisVideoClientTypes.MediaStorageConfiguration?

    public init(
        mediaStorageConfiguration: KinesisVideoClientTypes.MediaStorageConfiguration? = nil
    )
    {
        self.mediaStorageConfiguration = mediaStorageConfiguration
    }
}

struct DescribeMediaStorageConfigurationOutputBody: Swift.Equatable {
    let mediaStorageConfiguration: KinesisVideoClientTypes.MediaStorageConfiguration?
}

extension DescribeMediaStorageConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaStorageConfiguration = "MediaStorageConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaStorageConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.MediaStorageConfiguration.self, forKey: .mediaStorageConfiguration)
        mediaStorageConfiguration = mediaStorageConfigurationDecoded
    }
}

enum DescribeMediaStorageConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeNotificationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension DescribeNotificationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeNotificationConfiguration"
    }
}

public struct DescribeNotificationConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Kinesis video stream from where you want to retrieve the notification configuration. You must specify either the StreamName or the StreamARN.
    public var streamARN: Swift.String?
    /// The name of the stream from which to retrieve the notification configuration. You must specify either the StreamName or the StreamARN.
    public var streamName: Swift.String?

    public init(
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct DescribeNotificationConfigurationInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
}

extension DescribeNotificationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

extension DescribeNotificationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeNotificationConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.notificationConfiguration = output.notificationConfiguration
        } else {
            self.notificationConfiguration = nil
        }
    }
}

public struct DescribeNotificationConfigurationOutput: Swift.Equatable {
    /// The structure that contains the information required for notifications. If the structure is null, the configuration will be deleted from the stream.
    public var notificationConfiguration: KinesisVideoClientTypes.NotificationConfiguration?

    public init(
        notificationConfiguration: KinesisVideoClientTypes.NotificationConfiguration? = nil
    )
    {
        self.notificationConfiguration = notificationConfiguration
    }
}

struct DescribeNotificationConfigurationOutputBody: Swift.Equatable {
    let notificationConfiguration: KinesisVideoClientTypes.NotificationConfiguration?
}

extension DescribeNotificationConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationConfiguration = "NotificationConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
    }
}

enum DescribeNotificationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSignalingChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case channelName = "ChannelName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = self.channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
    }
}

extension DescribeSignalingChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeSignalingChannel"
    }
}

public struct DescribeSignalingChannelInput: Swift.Equatable {
    /// The ARN of the signaling channel that you want to describe.
    public var channelARN: Swift.String?
    /// The name of the signaling channel that you want to describe.
    public var channelName: Swift.String?

    public init(
        channelARN: Swift.String? = nil,
        channelName: Swift.String? = nil
    )
    {
        self.channelARN = channelARN
        self.channelName = channelName
    }
}

struct DescribeSignalingChannelInputBody: Swift.Equatable {
    let channelName: Swift.String?
    let channelARN: Swift.String?
}

extension DescribeSignalingChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case channelName = "ChannelName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
    }
}

extension DescribeSignalingChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSignalingChannelOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelInfo = output.channelInfo
        } else {
            self.channelInfo = nil
        }
    }
}

public struct DescribeSignalingChannelOutput: Swift.Equatable {
    /// A structure that encapsulates the specified signaling channel's metadata and properties.
    public var channelInfo: KinesisVideoClientTypes.ChannelInfo?

    public init(
        channelInfo: KinesisVideoClientTypes.ChannelInfo? = nil
    )
    {
        self.channelInfo = channelInfo
    }
}

struct DescribeSignalingChannelOutputBody: Swift.Equatable {
    let channelInfo: KinesisVideoClientTypes.ChannelInfo?
}

extension DescribeSignalingChannelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelInfo = "ChannelInfo"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelInfoDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ChannelInfo.self, forKey: .channelInfo)
        channelInfo = channelInfoDecoded
    }
}

enum DescribeSignalingChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension DescribeStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeStream"
    }
}

public struct DescribeStreamInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the stream.
    public var streamARN: Swift.String?
    /// The name of the stream.
    public var streamName: Swift.String?

    public init(
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct DescribeStreamInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
}

extension DescribeStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

extension DescribeStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeStreamOutputBody = try responseDecoder.decode(responseBody: data)
            self.streamInfo = output.streamInfo
        } else {
            self.streamInfo = nil
        }
    }
}

public struct DescribeStreamOutput: Swift.Equatable {
    /// An object that describes the stream.
    public var streamInfo: KinesisVideoClientTypes.StreamInfo?

    public init(
        streamInfo: KinesisVideoClientTypes.StreamInfo? = nil
    )
    {
        self.streamInfo = streamInfo
    }
}

struct DescribeStreamOutputBody: Swift.Equatable {
    let streamInfo: KinesisVideoClientTypes.StreamInfo?
}

extension DescribeStreamOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamInfo = "StreamInfo"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamInfoDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.StreamInfo.self, forKey: .streamInfo)
        streamInfo = streamInfoDecoded
    }
}

enum DescribeStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeviceStreamLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeviceStreamLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Not implemented.
public struct DeviceStreamLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DeviceStreamLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DeviceStreamLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeviceStreamLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisVideoClientTypes.EdgeAgentStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastRecorderStatus = "LastRecorderStatus"
        case lastUploaderStatus = "LastUploaderStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lastRecorderStatus = self.lastRecorderStatus {
            try encodeContainer.encode(lastRecorderStatus, forKey: .lastRecorderStatus)
        }
        if let lastUploaderStatus = self.lastUploaderStatus {
            try encodeContainer.encode(lastUploaderStatus, forKey: .lastUploaderStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastRecorderStatusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.LastRecorderStatus.self, forKey: .lastRecorderStatus)
        lastRecorderStatus = lastRecorderStatusDecoded
        let lastUploaderStatusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.LastUploaderStatus.self, forKey: .lastUploaderStatus)
        lastUploaderStatus = lastUploaderStatusDecoded
    }
}

extension KinesisVideoClientTypes {
    /// An object that contains the latest status details for an edge agent's recorder and uploader jobs. Use this information to determine the current health of an edge agent.
    public struct EdgeAgentStatus: Swift.Equatable {
        /// The latest status of a stream’s edge recording job.
        public var lastRecorderStatus: KinesisVideoClientTypes.LastRecorderStatus?
        /// The latest status of a stream’s edge to cloud uploader job.
        public var lastUploaderStatus: KinesisVideoClientTypes.LastUploaderStatus?

        public init(
            lastRecorderStatus: KinesisVideoClientTypes.LastRecorderStatus? = nil,
            lastUploaderStatus: KinesisVideoClientTypes.LastUploaderStatus? = nil
        )
        {
            self.lastRecorderStatus = lastRecorderStatus
            self.lastUploaderStatus = lastUploaderStatus
        }
    }

}

extension KinesisVideoClientTypes.EdgeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionConfig = "DeletionConfig"
        case hubDeviceArn = "HubDeviceArn"
        case recorderConfig = "RecorderConfig"
        case uploaderConfig = "UploaderConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionConfig = self.deletionConfig {
            try encodeContainer.encode(deletionConfig, forKey: .deletionConfig)
        }
        if let hubDeviceArn = self.hubDeviceArn {
            try encodeContainer.encode(hubDeviceArn, forKey: .hubDeviceArn)
        }
        if let recorderConfig = self.recorderConfig {
            try encodeContainer.encode(recorderConfig, forKey: .recorderConfig)
        }
        if let uploaderConfig = self.uploaderConfig {
            try encodeContainer.encode(uploaderConfig, forKey: .uploaderConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hubDeviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hubDeviceArn)
        hubDeviceArn = hubDeviceArnDecoded
        let recorderConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.RecorderConfig.self, forKey: .recorderConfig)
        recorderConfig = recorderConfigDecoded
        let uploaderConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.UploaderConfig.self, forKey: .uploaderConfig)
        uploaderConfig = uploaderConfigDecoded
        let deletionConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.DeletionConfig.self, forKey: .deletionConfig)
        deletionConfig = deletionConfigDecoded
    }
}

extension KinesisVideoClientTypes {
    /// A description of the stream's edge configuration that will be used to sync with the Edge Agent IoT Greengrass component. The Edge Agent component will run on an IoT Hub Device setup at your premise.
    public struct EdgeConfig: Swift.Equatable {
        /// The deletion configuration is made up of the retention time (EdgeRetentionInHours) and local size configuration (LocalSizeConfig) details that are used to make the deletion.
        public var deletionConfig: KinesisVideoClientTypes.DeletionConfig?
        /// The "Internet of Things (IoT) Thing" Arn of the stream.
        /// This member is required.
        public var hubDeviceArn: Swift.String?
        /// The recorder configuration consists of the local MediaSourceConfig details, that are used as credentials to access the local media files streamed on the camera.
        /// This member is required.
        public var recorderConfig: KinesisVideoClientTypes.RecorderConfig?
        /// The uploader configuration contains the ScheduleExpression details that are used to schedule upload jobs for the recorded media files from the Edge Agent to a Kinesis Video Stream.
        public var uploaderConfig: KinesisVideoClientTypes.UploaderConfig?

        public init(
            deletionConfig: KinesisVideoClientTypes.DeletionConfig? = nil,
            hubDeviceArn: Swift.String? = nil,
            recorderConfig: KinesisVideoClientTypes.RecorderConfig? = nil,
            uploaderConfig: KinesisVideoClientTypes.UploaderConfig? = nil
        )
        {
            self.deletionConfig = deletionConfig
            self.hubDeviceArn = hubDeviceArn
            self.recorderConfig = recorderConfig
            self.uploaderConfig = uploaderConfig
        }
    }

}

extension KinesisVideoClientTypes {
    public enum Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jpeg
        case png
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .jpeg,
                .png,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jpeg: return "JPEG"
            case .png: return "PNG"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
        }
    }
}

extension KinesisVideoClientTypes {
    public enum FormatConfigKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jpegquality
        case sdkUnknown(Swift.String)

        public static var allCases: [FormatConfigKey] {
            return [
                .jpegquality,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jpegquality: return "JPEGQuality"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FormatConfigKey(rawValue: rawValue) ?? FormatConfigKey.sdkUnknown(rawValue)
        }
    }
}

extension GetDataEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiName = "APIName"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiName = self.apiName {
            try encodeContainer.encode(apiName.rawValue, forKey: .apiName)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension GetDataEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getDataEndpoint"
    }
}

public struct GetDataEndpointInput: Swift.Equatable {
    /// The name of the API action for which to get an endpoint.
    /// This member is required.
    public var apiName: KinesisVideoClientTypes.APIName?
    /// The Amazon Resource Name (ARN) of the stream that you want to get the endpoint for. You must specify either this parameter or a StreamName in the request.
    public var streamARN: Swift.String?
    /// The name of the stream that you want to get the endpoint for. You must specify either this parameter or a StreamARN in the request.
    public var streamName: Swift.String?

    public init(
        apiName: KinesisVideoClientTypes.APIName? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.apiName = apiName
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct GetDataEndpointInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let apiName: KinesisVideoClientTypes.APIName?
}

extension GetDataEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiName = "APIName"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let apiNameDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.APIName.self, forKey: .apiName)
        apiName = apiNameDecoded
    }
}

extension GetDataEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDataEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataEndpoint = output.dataEndpoint
        } else {
            self.dataEndpoint = nil
        }
    }
}

public struct GetDataEndpointOutput: Swift.Equatable {
    /// The endpoint value. To read data from the stream or to write data to it, specify this endpoint in your application.
    public var dataEndpoint: Swift.String?

    public init(
        dataEndpoint: Swift.String? = nil
    )
    {
        self.dataEndpoint = dataEndpoint
    }
}

struct GetDataEndpointOutputBody: Swift.Equatable {
    let dataEndpoint: Swift.String?
}

extension GetDataEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataEndpoint = "DataEndpoint"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataEndpoint)
        dataEndpoint = dataEndpointDecoded
    }
}

enum GetDataEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSignalingChannelEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case singleMasterChannelEndpointConfiguration = "SingleMasterChannelEndpointConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = self.channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let singleMasterChannelEndpointConfiguration = self.singleMasterChannelEndpointConfiguration {
            try encodeContainer.encode(singleMasterChannelEndpointConfiguration, forKey: .singleMasterChannelEndpointConfiguration)
        }
    }
}

extension GetSignalingChannelEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getSignalingChannelEndpoint"
    }
}

public struct GetSignalingChannelEndpointInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the signalling channel for which you want to get an endpoint.
    /// This member is required.
    public var channelARN: Swift.String?
    /// A structure containing the endpoint configuration for the SINGLE_MASTER channel type.
    public var singleMasterChannelEndpointConfiguration: KinesisVideoClientTypes.SingleMasterChannelEndpointConfiguration?

    public init(
        channelARN: Swift.String? = nil,
        singleMasterChannelEndpointConfiguration: KinesisVideoClientTypes.SingleMasterChannelEndpointConfiguration? = nil
    )
    {
        self.channelARN = channelARN
        self.singleMasterChannelEndpointConfiguration = singleMasterChannelEndpointConfiguration
    }
}

struct GetSignalingChannelEndpointInputBody: Swift.Equatable {
    let channelARN: Swift.String?
    let singleMasterChannelEndpointConfiguration: KinesisVideoClientTypes.SingleMasterChannelEndpointConfiguration?
}

extension GetSignalingChannelEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case singleMasterChannelEndpointConfiguration = "SingleMasterChannelEndpointConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
        let singleMasterChannelEndpointConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.SingleMasterChannelEndpointConfiguration.self, forKey: .singleMasterChannelEndpointConfiguration)
        singleMasterChannelEndpointConfiguration = singleMasterChannelEndpointConfigurationDecoded
    }
}

extension GetSignalingChannelEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSignalingChannelEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.resourceEndpointList = output.resourceEndpointList
        } else {
            self.resourceEndpointList = nil
        }
    }
}

public struct GetSignalingChannelEndpointOutput: Swift.Equatable {
    /// A list of endpoints for the specified signaling channel.
    public var resourceEndpointList: [KinesisVideoClientTypes.ResourceEndpointListItem]?

    public init(
        resourceEndpointList: [KinesisVideoClientTypes.ResourceEndpointListItem]? = nil
    )
    {
        self.resourceEndpointList = resourceEndpointList
    }
}

struct GetSignalingChannelEndpointOutputBody: Swift.Equatable {
    let resourceEndpointList: [KinesisVideoClientTypes.ResourceEndpointListItem]?
}

extension GetSignalingChannelEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceEndpointList = "ResourceEndpointList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceEndpointListContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.ResourceEndpointListItem?].self, forKey: .resourceEndpointList)
        var resourceEndpointListDecoded0:[KinesisVideoClientTypes.ResourceEndpointListItem]? = nil
        if let resourceEndpointListContainer = resourceEndpointListContainer {
            resourceEndpointListDecoded0 = [KinesisVideoClientTypes.ResourceEndpointListItem]()
            for structure0 in resourceEndpointListContainer {
                if let structure0 = structure0 {
                    resourceEndpointListDecoded0?.append(structure0)
                }
            }
        }
        resourceEndpointList = resourceEndpointListDecoded0
    }
}

enum GetSignalingChannelEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension KinesisVideoClientTypes.ImageGenerationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case format = "Format"
        case formatConfig = "FormatConfig"
        case heightPixels = "HeightPixels"
        case imageSelectorType = "ImageSelectorType"
        case samplingInterval = "SamplingInterval"
        case status = "Status"
        case widthPixels = "WidthPixels"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfig = self.destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let formatConfig = formatConfig {
            var formatConfigContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .formatConfig)
            for (dictKey0, formatConfig0) in formatConfig {
                try formatConfigContainer.encode(formatConfig0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let heightPixels = self.heightPixels {
            try encodeContainer.encode(heightPixels, forKey: .heightPixels)
        }
        if let imageSelectorType = self.imageSelectorType {
            try encodeContainer.encode(imageSelectorType.rawValue, forKey: .imageSelectorType)
        }
        if let samplingInterval = self.samplingInterval {
            try encodeContainer.encode(samplingInterval, forKey: .samplingInterval)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let widthPixels = self.widthPixels {
            try encodeContainer.encode(widthPixels, forKey: .widthPixels)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let imageSelectorTypeDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ImageSelectorType.self, forKey: .imageSelectorType)
        imageSelectorType = imageSelectorTypeDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ImageGenerationDestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let samplingIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samplingInterval)
        samplingInterval = samplingIntervalDecoded
        let formatDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let formatConfigContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .formatConfig)
        var formatConfigDecoded0: [Swift.String:Swift.String]? = nil
        if let formatConfigContainer = formatConfigContainer {
            formatConfigDecoded0 = [Swift.String:Swift.String]()
            for (key0, formatconfigvalue0) in formatConfigContainer {
                if let formatconfigvalue0 = formatconfigvalue0 {
                    formatConfigDecoded0?[key0] = formatconfigvalue0
                }
            }
        }
        formatConfig = formatConfigDecoded0
        let widthPixelsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .widthPixels)
        widthPixels = widthPixelsDecoded
        let heightPixelsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .heightPixels)
        heightPixels = heightPixelsDecoded
    }
}

extension KinesisVideoClientTypes {
    /// The structure that contains the information required for the KVS images delivery. If null, the configuration will be deleted from the stream.
    public struct ImageGenerationConfiguration: Swift.Equatable {
        /// The structure that contains the information required to deliver images to a customer.
        /// This member is required.
        public var destinationConfig: KinesisVideoClientTypes.ImageGenerationDestinationConfig?
        /// The accepted image format.
        /// This member is required.
        public var format: KinesisVideoClientTypes.Format?
        /// The list of a key-value pair structure that contains extra parameters that can be applied when the image is generated. The FormatConfig key is the JPEGQuality, which indicates the JPEG quality key to be used to generate the image. The FormatConfig value accepts ints from 1 to 100. If the value is 1, the image will be generated with less quality and the best compression. If the value is 100, the image will be generated with the best quality and less compression. If no value is provided, the default value of the JPEGQuality key will be set to 80.
        public var formatConfig: [Swift.String:Swift.String]?
        /// The height of the output image that is used in conjunction with the WidthPixels parameter. When both HeightPixels and WidthPixels parameters are provided, the image will be stretched to fit the specified aspect ratio. If only the HeightPixels parameter is provided, its original aspect ratio will be used to calculate the WidthPixels ratio. If neither parameter is provided, the original image size will be returned.
        public var heightPixels: Swift.Int?
        /// The origin of the Server or Producer timestamps to use to generate the images.
        /// This member is required.
        public var imageSelectorType: KinesisVideoClientTypes.ImageSelectorType?
        /// The time interval in milliseconds (ms) at which the images need to be generated from the stream. The minimum value that can be provided is 200 ms. If the timestamp range is less than the sampling interval, the Image from the StartTimestamp will be returned if available.
        /// This member is required.
        public var samplingInterval: Swift.Int?
        /// Indicates whether the ContinuousImageGenerationConfigurations API is enabled or disabled.
        /// This member is required.
        public var status: KinesisVideoClientTypes.ConfigurationStatus?
        /// The width of the output image that is used in conjunction with the HeightPixels parameter. When both WidthPixels and HeightPixels parameters are provided, the image will be stretched to fit the specified aspect ratio. If only the WidthPixels parameter is provided, its original aspect ratio will be used to calculate the HeightPixels ratio. If neither parameter is provided, the original image size will be returned.
        public var widthPixels: Swift.Int?

        public init(
            destinationConfig: KinesisVideoClientTypes.ImageGenerationDestinationConfig? = nil,
            format: KinesisVideoClientTypes.Format? = nil,
            formatConfig: [Swift.String:Swift.String]? = nil,
            heightPixels: Swift.Int? = nil,
            imageSelectorType: KinesisVideoClientTypes.ImageSelectorType? = nil,
            samplingInterval: Swift.Int? = nil,
            status: KinesisVideoClientTypes.ConfigurationStatus? = nil,
            widthPixels: Swift.Int? = nil
        )
        {
            self.destinationConfig = destinationConfig
            self.format = format
            self.formatConfig = formatConfig
            self.heightPixels = heightPixels
            self.imageSelectorType = imageSelectorType
            self.samplingInterval = samplingInterval
            self.status = status
            self.widthPixels = widthPixels
        }
    }

}

extension KinesisVideoClientTypes.ImageGenerationDestinationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationRegion = "DestinationRegion"
        case uri = "Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationRegion = self.destinationRegion {
            try encodeContainer.encode(destinationRegion, forKey: .destinationRegion)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let destinationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationRegion)
        destinationRegion = destinationRegionDecoded
    }
}

extension KinesisVideoClientTypes {
    /// The structure that contains the information required to deliver images to a customer.
    public struct ImageGenerationDestinationConfig: Swift.Equatable {
        /// The Amazon Web Services Region of the S3 bucket where images will be delivered. This DestinationRegion must match the Region where the stream is located.
        /// This member is required.
        public var destinationRegion: Swift.String?
        /// The Uniform Resource Identifier (URI) that identifies where the images will be delivered.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            destinationRegion: Swift.String? = nil,
            uri: Swift.String? = nil
        )
        {
            self.destinationRegion = destinationRegion
            self.uri = uri
        }
    }

}

extension KinesisVideoClientTypes {
    public enum ImageSelectorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case producerTimestamp
        case serverTimestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageSelectorType] {
            return [
                .producerTimestamp,
                .serverTimestamp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .producerTimestamp: return "PRODUCER_TIMESTAMP"
            case .serverTimestamp: return "SERVER_TIMESTAMP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageSelectorType(rawValue: rawValue) ?? ImageSelectorType.sdkUnknown(rawValue)
        }
    }
}

extension InvalidArgumentException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The value for this input parameter is invalid.
public struct InvalidArgumentException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidArgumentException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidArgumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDeviceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidDeviceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Not implemented.
public struct InvalidDeviceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidDeviceException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidDeviceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDeviceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceFormatException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidResourceFormatExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The format of the StreamARN is invalid.
public struct InvalidResourceFormatException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidResourceFormatException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidResourceFormatExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResourceFormatExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisVideoClientTypes.LastRecorderStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobStatusDetails = "JobStatusDetails"
        case lastCollectedTime = "LastCollectedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case recorderStatus = "RecorderStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobStatusDetails = self.jobStatusDetails {
            try encodeContainer.encode(jobStatusDetails, forKey: .jobStatusDetails)
        }
        if let lastCollectedTime = self.lastCollectedTime {
            try encodeContainer.encodeTimestamp(lastCollectedTime, format: .epochSeconds, forKey: .lastCollectedTime)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let recorderStatus = self.recorderStatus {
            try encodeContainer.encode(recorderStatus.rawValue, forKey: .recorderStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobStatusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobStatusDetails)
        jobStatusDetails = jobStatusDetailsDecoded
        let lastCollectedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastCollectedTime)
        lastCollectedTime = lastCollectedTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let recorderStatusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.RecorderStatus.self, forKey: .recorderStatus)
        recorderStatus = recorderStatusDecoded
    }
}

extension KinesisVideoClientTypes {
    /// The latest status of a stream's edge recording job.
    public struct LastRecorderStatus: Swift.Equatable {
        /// A description of a recorder job’s latest status.
        public var jobStatusDetails: Swift.String?
        /// The timestamp at which the recorder job was last executed and media stored to local disk.
        public var lastCollectedTime: ClientRuntime.Date?
        /// The timestamp at which the recorder status was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The status of the latest recorder job.
        public var recorderStatus: KinesisVideoClientTypes.RecorderStatus?

        public init(
            jobStatusDetails: Swift.String? = nil,
            lastCollectedTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            recorderStatus: KinesisVideoClientTypes.RecorderStatus? = nil
        )
        {
            self.jobStatusDetails = jobStatusDetails
            self.lastCollectedTime = lastCollectedTime
            self.lastUpdatedTime = lastUpdatedTime
            self.recorderStatus = recorderStatus
        }
    }

}

extension KinesisVideoClientTypes.LastUploaderStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobStatusDetails = "JobStatusDetails"
        case lastCollectedTime = "LastCollectedTime"
        case lastUpdatedTime = "LastUpdatedTime"
        case uploaderStatus = "UploaderStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobStatusDetails = self.jobStatusDetails {
            try encodeContainer.encode(jobStatusDetails, forKey: .jobStatusDetails)
        }
        if let lastCollectedTime = self.lastCollectedTime {
            try encodeContainer.encodeTimestamp(lastCollectedTime, format: .epochSeconds, forKey: .lastCollectedTime)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let uploaderStatus = self.uploaderStatus {
            try encodeContainer.encode(uploaderStatus.rawValue, forKey: .uploaderStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobStatusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobStatusDetails)
        jobStatusDetails = jobStatusDetailsDecoded
        let lastCollectedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastCollectedTime)
        lastCollectedTime = lastCollectedTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let uploaderStatusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.UploaderStatus.self, forKey: .uploaderStatus)
        uploaderStatus = uploaderStatusDecoded
    }
}

extension KinesisVideoClientTypes {
    /// The latest status of a stream’s edge to cloud uploader job.
    public struct LastUploaderStatus: Swift.Equatable {
        /// A description of an uploader job’s latest status.
        public var jobStatusDetails: Swift.String?
        /// The timestamp at which the uploader job was last executed and media collected to the cloud.
        public var lastCollectedTime: ClientRuntime.Date?
        /// The timestamp at which the uploader status was last updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The status of the latest uploader job.
        public var uploaderStatus: KinesisVideoClientTypes.UploaderStatus?

        public init(
            jobStatusDetails: Swift.String? = nil,
            lastCollectedTime: ClientRuntime.Date? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            uploaderStatus: KinesisVideoClientTypes.UploaderStatus? = nil
        )
        {
            self.jobStatusDetails = jobStatusDetails
            self.lastCollectedTime = lastCollectedTime
            self.lastUpdatedTime = lastUpdatedTime
            self.uploaderStatus = uploaderStatus
        }
    }

}

extension KinesisVideoClientTypes.ListEdgeAgentConfigurationsEdgeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case edgeConfig = "EdgeConfig"
        case failedStatusDetails = "FailedStatusDetails"
        case lastUpdatedTime = "LastUpdatedTime"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case syncStatus = "SyncStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let edgeConfig = self.edgeConfig {
            try encodeContainer.encode(edgeConfig, forKey: .edgeConfig)
        }
        if let failedStatusDetails = self.failedStatusDetails {
            try encodeContainer.encode(failedStatusDetails, forKey: .failedStatusDetails)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let syncStatus = self.syncStatus {
            try encodeContainer.encode(syncStatus.rawValue, forKey: .syncStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let syncStatusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.SyncStatus.self, forKey: .syncStatus)
        syncStatus = syncStatusDecoded
        let failedStatusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failedStatusDetails)
        failedStatusDetails = failedStatusDetailsDecoded
        let edgeConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.EdgeConfig.self, forKey: .edgeConfig)
        edgeConfig = edgeConfigDecoded
    }
}

extension KinesisVideoClientTypes {
    /// A description of a single stream's edge configuration.
    public struct ListEdgeAgentConfigurationsEdgeConfig: Swift.Equatable {
        /// The timestamp when the stream first created the edge config.
        public var creationTime: ClientRuntime.Date?
        /// A description of the stream's edge configuration that will be used to sync with the Edge Agent IoT Greengrass component. The Edge Agent component will run on an IoT Hub Device setup at your premise.
        public var edgeConfig: KinesisVideoClientTypes.EdgeConfig?
        /// A description of the generated failure status.
        public var failedStatusDetails: Swift.String?
        /// The timestamp when the stream last updated the edge config.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the stream.
        public var streamARN: Swift.String?
        /// The name of the stream.
        public var streamName: Swift.String?
        /// The current sync status of the stream's edge configuration.
        public var syncStatus: KinesisVideoClientTypes.SyncStatus?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            edgeConfig: KinesisVideoClientTypes.EdgeConfig? = nil,
            failedStatusDetails: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            streamARN: Swift.String? = nil,
            streamName: Swift.String? = nil,
            syncStatus: KinesisVideoClientTypes.SyncStatus? = nil
        )
        {
            self.creationTime = creationTime
            self.edgeConfig = edgeConfig
            self.failedStatusDetails = failedStatusDetails
            self.lastUpdatedTime = lastUpdatedTime
            self.streamARN = streamARN
            self.streamName = streamName
            self.syncStatus = syncStatus
        }
    }

}

extension ListEdgeAgentConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hubDeviceArn = "HubDeviceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hubDeviceArn = self.hubDeviceArn {
            try encodeContainer.encode(hubDeviceArn, forKey: .hubDeviceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListEdgeAgentConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listEdgeAgentConfigurations"
    }
}

public struct ListEdgeAgentConfigurationsInput: Swift.Equatable {
    /// The "Internet of Things (IoT) Thing" Arn of the edge agent.
    /// This member is required.
    public var hubDeviceArn: Swift.String?
    /// The maximum number of edge configurations to return in the response. The default is 5.
    public var maxResults: Swift.Int?
    /// If you specify this parameter, when the result of a ListEdgeAgentConfigurations operation is truncated, the call returns the NextToken in the response. To get another batch of edge configurations, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        hubDeviceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.hubDeviceArn = hubDeviceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEdgeAgentConfigurationsInputBody: Swift.Equatable {
    let hubDeviceArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListEdgeAgentConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hubDeviceArn = "HubDeviceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hubDeviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hubDeviceArn)
        hubDeviceArn = hubDeviceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListEdgeAgentConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEdgeAgentConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.edgeConfigs = output.edgeConfigs
            self.nextToken = output.nextToken
        } else {
            self.edgeConfigs = nil
            self.nextToken = nil
        }
    }
}

public struct ListEdgeAgentConfigurationsOutput: Swift.Equatable {
    /// A description of a single stream's edge configuration.
    public var edgeConfigs: [KinesisVideoClientTypes.ListEdgeAgentConfigurationsEdgeConfig]?
    /// If the response is truncated, the call returns this element with a given token. To get the next batch of edge configurations, use this token in your next request.
    public var nextToken: Swift.String?

    public init(
        edgeConfigs: [KinesisVideoClientTypes.ListEdgeAgentConfigurationsEdgeConfig]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.edgeConfigs = edgeConfigs
        self.nextToken = nextToken
    }
}

struct ListEdgeAgentConfigurationsOutputBody: Swift.Equatable {
    let edgeConfigs: [KinesisVideoClientTypes.ListEdgeAgentConfigurationsEdgeConfig]?
    let nextToken: Swift.String?
}

extension ListEdgeAgentConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case edgeConfigs = "EdgeConfigs"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let edgeConfigsContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.ListEdgeAgentConfigurationsEdgeConfig?].self, forKey: .edgeConfigs)
        var edgeConfigsDecoded0:[KinesisVideoClientTypes.ListEdgeAgentConfigurationsEdgeConfig]? = nil
        if let edgeConfigsContainer = edgeConfigsContainer {
            edgeConfigsDecoded0 = [KinesisVideoClientTypes.ListEdgeAgentConfigurationsEdgeConfig]()
            for structure0 in edgeConfigsContainer {
                if let structure0 = structure0 {
                    edgeConfigsDecoded0?.append(structure0)
                }
            }
        }
        edgeConfigs = edgeConfigsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEdgeAgentConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSignalingChannelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelNameCondition = "ChannelNameCondition"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelNameCondition = self.channelNameCondition {
            try encodeContainer.encode(channelNameCondition, forKey: .channelNameCondition)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSignalingChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listSignalingChannels"
    }
}

public struct ListSignalingChannelsInput: Swift.Equatable {
    /// Optional: Returns only the channels that satisfy a specific condition.
    public var channelNameCondition: KinesisVideoClientTypes.ChannelNameCondition?
    /// The maximum number of channels to return in the response. The default is 500.
    public var maxResults: Swift.Int?
    /// If you specify this parameter, when the result of a ListSignalingChannels operation is truncated, the call returns the NextToken in the response. To get another batch of channels, provide this token in your next request.
    public var nextToken: Swift.String?

    public init(
        channelNameCondition: KinesisVideoClientTypes.ChannelNameCondition? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelNameCondition = channelNameCondition
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSignalingChannelsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let channelNameCondition: KinesisVideoClientTypes.ChannelNameCondition?
}

extension ListSignalingChannelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelNameCondition = "ChannelNameCondition"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let channelNameConditionDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ChannelNameCondition.self, forKey: .channelNameCondition)
        channelNameCondition = channelNameConditionDecoded
    }
}

extension ListSignalingChannelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSignalingChannelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelInfoList = output.channelInfoList
            self.nextToken = output.nextToken
        } else {
            self.channelInfoList = nil
            self.nextToken = nil
        }
    }
}

public struct ListSignalingChannelsOutput: Swift.Equatable {
    /// An array of ChannelInfo objects.
    public var channelInfoList: [KinesisVideoClientTypes.ChannelInfo]?
    /// If the response is truncated, the call returns this element with a token. To get the next batch of streams, use this token in your next request.
    public var nextToken: Swift.String?

    public init(
        channelInfoList: [KinesisVideoClientTypes.ChannelInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelInfoList = channelInfoList
        self.nextToken = nextToken
    }
}

struct ListSignalingChannelsOutputBody: Swift.Equatable {
    let channelInfoList: [KinesisVideoClientTypes.ChannelInfo]?
    let nextToken: Swift.String?
}

extension ListSignalingChannelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelInfoList = "ChannelInfoList"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelInfoListContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.ChannelInfo?].self, forKey: .channelInfoList)
        var channelInfoListDecoded0:[KinesisVideoClientTypes.ChannelInfo]? = nil
        if let channelInfoListContainer = channelInfoListContainer {
            channelInfoListDecoded0 = [KinesisVideoClientTypes.ChannelInfo]()
            for structure0 in channelInfoListContainer {
                if let structure0 = structure0 {
                    channelInfoListDecoded0?.append(structure0)
                }
            }
        }
        channelInfoList = channelInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSignalingChannelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStreamsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case streamNameCondition = "StreamNameCondition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let streamNameCondition = self.streamNameCondition {
            try encodeContainer.encode(streamNameCondition, forKey: .streamNameCondition)
        }
    }
}

extension ListStreamsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listStreams"
    }
}

public struct ListStreamsInput: Swift.Equatable {
    /// The maximum number of streams to return in the response. The default is 10,000.
    public var maxResults: Swift.Int?
    /// If you specify this parameter, when the result of a ListStreams operation is truncated, the call returns the NextToken in the response. To get another batch of streams, provide this token in your next request.
    public var nextToken: Swift.String?
    /// Optional: Returns only streams that satisfy a specific condition. Currently, you can specify only the prefix of a stream name as a condition.
    public var streamNameCondition: KinesisVideoClientTypes.StreamNameCondition?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        streamNameCondition: KinesisVideoClientTypes.StreamNameCondition? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.streamNameCondition = streamNameCondition
    }
}

struct ListStreamsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let streamNameCondition: KinesisVideoClientTypes.StreamNameCondition?
}

extension ListStreamsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case streamNameCondition = "StreamNameCondition"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let streamNameConditionDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.StreamNameCondition.self, forKey: .streamNameCondition)
        streamNameCondition = streamNameConditionDecoded
    }
}

extension ListStreamsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStreamsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.streamInfoList = output.streamInfoList
        } else {
            self.nextToken = nil
            self.streamInfoList = nil
        }
    }
}

public struct ListStreamsOutput: Swift.Equatable {
    /// If the response is truncated, the call returns this element with a token. To get the next batch of streams, use this token in your next request.
    public var nextToken: Swift.String?
    /// An array of StreamInfo objects.
    public var streamInfoList: [KinesisVideoClientTypes.StreamInfo]?

    public init(
        nextToken: Swift.String? = nil,
        streamInfoList: [KinesisVideoClientTypes.StreamInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.streamInfoList = streamInfoList
    }
}

struct ListStreamsOutputBody: Swift.Equatable {
    let streamInfoList: [KinesisVideoClientTypes.StreamInfo]?
    let nextToken: Swift.String?
}

extension ListStreamsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case streamInfoList = "StreamInfoList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamInfoListContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.StreamInfo?].self, forKey: .streamInfoList)
        var streamInfoListDecoded0:[KinesisVideoClientTypes.StreamInfo]? = nil
        if let streamInfoListContainer = streamInfoListContainer {
            streamInfoListDecoded0 = [KinesisVideoClientTypes.StreamInfo]()
            for structure0 in streamInfoListContainer {
                if let structure0 = structure0 {
                    streamInfoListDecoded0?.append(structure0)
                }
            }
        }
        streamInfoList = streamInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListStreamsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListTagsForResource"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// If you specify this parameter and the result of a ListTagsForResource call is truncated, the response includes a token that you can use in the next request to fetch the next batch of tags.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the signaling channel for which you want to list tags.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// If you specify this parameter and the result of a ListTagsForResource call is truncated, the response includes a token that you can use in the next request to fetch the next set of tags.
    public var nextToken: Swift.String?
    /// A map of tag keys and values associated with the specified signaling channel.
    public var tags: [Swift.String:Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension ListTagsForStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listTagsForStream"
    }
}

public struct ListTagsForStreamInput: Swift.Equatable {
    /// If you specify this parameter and the result of a ListTagsForStream call is truncated, the response includes a token that you can use in the next request to fetch the next batch of tags.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the stream that you want to list tags for.
    public var streamARN: Swift.String?
    /// The name of the stream that you want to list tags for.
    public var streamName: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct ListTagsForStreamInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let streamARN: Swift.String?
    let streamName: Swift.String?
}

extension ListTagsForStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
    }
}

extension ListTagsForStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForStreamOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForStreamOutput: Swift.Equatable {
    /// If you specify this parameter and the result of a ListTags call is truncated, the response includes a token that you can use in the next request to fetch the next set of tags.
    public var nextToken: Swift.String?
    /// A map of tag keys and values associated with the specified stream.
    public var tags: [Swift.String:Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForStreamOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForStreamOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceFormatException": return try await InvalidResourceFormatException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension KinesisVideoClientTypes.LocalSizeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxLocalMediaSizeInMB = "MaxLocalMediaSizeInMB"
        case strategyOnFullSize = "StrategyOnFullSize"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxLocalMediaSizeInMB = self.maxLocalMediaSizeInMB {
            try encodeContainer.encode(maxLocalMediaSizeInMB, forKey: .maxLocalMediaSizeInMB)
        }
        if let strategyOnFullSize = self.strategyOnFullSize {
            try encodeContainer.encode(strategyOnFullSize.rawValue, forKey: .strategyOnFullSize)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxLocalMediaSizeInMBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxLocalMediaSizeInMB)
        maxLocalMediaSizeInMB = maxLocalMediaSizeInMBDecoded
        let strategyOnFullSizeDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.StrategyOnFullSize.self, forKey: .strategyOnFullSize)
        strategyOnFullSize = strategyOnFullSizeDecoded
    }
}

extension KinesisVideoClientTypes {
    /// The configuration details that include the maximum size of the media (MaxLocalMediaSizeInMB) that you want to store for a stream on the Edge Agent, as well as the strategy that should be used (StrategyOnFullSize) when a stream's maximum size has been reached.
    public struct LocalSizeConfig: Swift.Equatable {
        /// The overall maximum size of the media that you want to store for a stream on the Edge Agent.
        public var maxLocalMediaSizeInMB: Swift.Int?
        /// The strategy to perform when a stream’s MaxLocalMediaSizeInMB limit is reached.
        public var strategyOnFullSize: KinesisVideoClientTypes.StrategyOnFullSize?

        public init(
            maxLocalMediaSizeInMB: Swift.Int? = nil,
            strategyOnFullSize: KinesisVideoClientTypes.StrategyOnFullSize? = nil
        )
        {
            self.maxLocalMediaSizeInMB = maxLocalMediaSizeInMB
            self.strategyOnFullSize = strategyOnFullSize
        }
    }

}

extension KinesisVideoClientTypes.MappedResourceConfigurationListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension KinesisVideoClientTypes {
    /// A structure that encapsulates, or contains, the media storage configuration properties.
    public struct MappedResourceConfigurationListItem: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Kinesis Video Stream resource, associated with the stream.
        public var arn: Swift.String?
        /// The type of the associated resource for the kinesis video stream.
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.type = type
        }
    }

}

extension KinesisVideoClientTypes.MediaSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaUriSecretArn = "MediaUriSecretArn"
        case mediaUriType = "MediaUriType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaUriSecretArn = self.mediaUriSecretArn {
            try encodeContainer.encode(mediaUriSecretArn, forKey: .mediaUriSecretArn)
        }
        if let mediaUriType = self.mediaUriType {
            try encodeContainer.encode(mediaUriType.rawValue, forKey: .mediaUriType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaUriSecretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaUriSecretArn)
        mediaUriSecretArn = mediaUriSecretArnDecoded
        let mediaUriTypeDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.MediaUriType.self, forKey: .mediaUriType)
        mediaUriType = mediaUriTypeDecoded
    }
}

extension KinesisVideoClientTypes.MediaSourceConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaSourceConfig(mediaUriType: \(Swift.String(describing: mediaUriType)), mediaUriSecretArn: \"CONTENT_REDACTED\")"}
}

extension KinesisVideoClientTypes {
    /// The configuration details that consist of the credentials required (MediaUriSecretArn and MediaUriType) to access the media files that are streamed to the camera.
    public struct MediaSourceConfig: Swift.Equatable {
        /// The Amazon Web Services Secrets Manager ARN for the username and password of the camera, or a local media file location.
        /// This member is required.
        public var mediaUriSecretArn: Swift.String?
        /// The Uniform Resource Identifier (URI) type. The FILE_URI value can be used to stream local media files. Preview only supports the RTSP_URI media source URI format .
        /// This member is required.
        public var mediaUriType: KinesisVideoClientTypes.MediaUriType?

        public init(
            mediaUriSecretArn: Swift.String? = nil,
            mediaUriType: KinesisVideoClientTypes.MediaUriType? = nil
        )
        {
            self.mediaUriSecretArn = mediaUriSecretArn
            self.mediaUriType = mediaUriType
        }
    }

}

extension KinesisVideoClientTypes.MediaStorageConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case streamARN = "StreamARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.MediaStorageConfigurationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension KinesisVideoClientTypes {
    /// A structure that encapsulates, or contains, the media storage configuration properties.
    public struct MediaStorageConfiguration: Swift.Equatable {
        /// The status of the media storage configuration.
        /// This member is required.
        public var status: KinesisVideoClientTypes.MediaStorageConfigurationStatus?
        /// The Amazon Resource Name (ARN) of the stream
        public var streamARN: Swift.String?

        public init(
            status: KinesisVideoClientTypes.MediaStorageConfigurationStatus? = nil,
            streamARN: Swift.String? = nil
        )
        {
            self.status = status
            self.streamARN = streamARN
        }
    }

}

extension KinesisVideoClientTypes {
    public enum MediaStorageConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaStorageConfigurationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaStorageConfigurationStatus(rawValue: rawValue) ?? MediaStorageConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension KinesisVideoClientTypes {
    public enum MediaUriType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fileUri
        case rtspUri
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaUriType] {
            return [
                .fileUri,
                .rtspUri,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fileUri: return "FILE_URI"
            case .rtspUri: return "RTSP_URI"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaUriType(rawValue: rawValue) ?? MediaUriType.sdkUnknown(rawValue)
        }
    }
}

extension NoDataRetentionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NoDataRetentionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Stream data retention in hours is equal to zero.
public struct NoDataRetentionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NoDataRetentionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NoDataRetentionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoDataRetentionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotAuthorizedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The caller is not authorized to perform this operation.
public struct NotAuthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotAuthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotAuthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotAuthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisVideoClientTypes.NotificationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfig = self.destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.NotificationDestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension KinesisVideoClientTypes {
    /// The structure that contains the notification information for the KVS images delivery. If this parameter is null, the configuration will be deleted from the stream.
    public struct NotificationConfiguration: Swift.Equatable {
        /// The destination information required to deliver a notification to a customer.
        /// This member is required.
        public var destinationConfig: KinesisVideoClientTypes.NotificationDestinationConfig?
        /// Indicates if a notification configuration is enabled or disabled.
        /// This member is required.
        public var status: KinesisVideoClientTypes.ConfigurationStatus?

        public init(
            destinationConfig: KinesisVideoClientTypes.NotificationDestinationConfig? = nil,
            status: KinesisVideoClientTypes.ConfigurationStatus? = nil
        )
        {
            self.destinationConfig = destinationConfig
            self.status = status
        }
    }

}

extension KinesisVideoClientTypes.NotificationDestinationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uri = "Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
    }
}

extension KinesisVideoClientTypes {
    /// The structure that contains the information required to deliver a notification to a customer.
    public struct NotificationDestinationConfig: Swift.Equatable {
        /// The Uniform Resource Identifier (URI) that identifies where the images will be delivered.
        /// This member is required.
        public var uri: Swift.String?

        public init(
            uri: Swift.String? = nil
        )
        {
            self.uri = uri
        }
    }

}

extension KinesisVideoClientTypes.RecorderConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaSourceConfig = "MediaSourceConfig"
        case scheduleConfig = "ScheduleConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaSourceConfig = self.mediaSourceConfig {
            try encodeContainer.encode(mediaSourceConfig, forKey: .mediaSourceConfig)
        }
        if let scheduleConfig = self.scheduleConfig {
            try encodeContainer.encode(scheduleConfig, forKey: .scheduleConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaSourceConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.MediaSourceConfig.self, forKey: .mediaSourceConfig)
        mediaSourceConfig = mediaSourceConfigDecoded
        let scheduleConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ScheduleConfig.self, forKey: .scheduleConfig)
        scheduleConfig = scheduleConfigDecoded
    }
}

extension KinesisVideoClientTypes {
    /// The recorder configuration consists of the local MediaSourceConfig details that are used as credentials to accesss the local media files streamed on the camera.
    public struct RecorderConfig: Swift.Equatable {
        /// The configuration details that consist of the credentials required (MediaUriSecretArn and MediaUriType) to access the media files streamed to the camera.
        /// This member is required.
        public var mediaSourceConfig: KinesisVideoClientTypes.MediaSourceConfig?
        /// The configuration that consists of the ScheduleExpression and the DurationInMinutes details that specify the scheduling to record from a camera, or local media file, onto the Edge Agent. If the ScheduleExpression attribute is not provided, then the Edge Agent will always be set to recording mode.
        public var scheduleConfig: KinesisVideoClientTypes.ScheduleConfig?

        public init(
            mediaSourceConfig: KinesisVideoClientTypes.MediaSourceConfig? = nil,
            scheduleConfig: KinesisVideoClientTypes.ScheduleConfig? = nil
        )
        {
            self.mediaSourceConfig = mediaSourceConfig
            self.scheduleConfig = scheduleConfig
        }
    }

}

extension KinesisVideoClientTypes {
    public enum RecorderStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case success
        case systemError
        case userError
        case sdkUnknown(Swift.String)

        public static var allCases: [RecorderStatus] {
            return [
                .success,
                .systemError,
                .userError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .success: return "SUCCESS"
            case .systemError: return "SYSTEM_ERROR"
            case .userError: return "USER_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecorderStatus(rawValue: rawValue) ?? RecorderStatus.sdkUnknown(rawValue)
        }
    }
}

extension KinesisVideoClientTypes.ResourceEndpointListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `protocol` = "Protocol"
        case resourceEndpoint = "ResourceEndpoint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let resourceEndpoint = self.resourceEndpoint {
            try encodeContainer.encode(resourceEndpoint, forKey: .resourceEndpoint)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ChannelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let resourceEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceEndpoint)
        resourceEndpoint = resourceEndpointDecoded
    }
}

extension KinesisVideoClientTypes {
    /// An object that describes the endpoint of the signaling channel returned by the GetSignalingChannelEndpoint API. The media server endpoint will correspond to the WEBRTC Protocol.
    public struct ResourceEndpointListItem: Swift.Equatable {
        /// The protocol of the signaling channel returned by the GetSignalingChannelEndpoint API.
        public var `protocol`: KinesisVideoClientTypes.ChannelProtocol?
        /// The endpoint of the signaling channel returned by the GetSignalingChannelEndpoint API.
        public var resourceEndpoint: Swift.String?

        public init(
            `protocol`: KinesisVideoClientTypes.ChannelProtocol? = nil,
            resourceEndpoint: Swift.String? = nil
        )
        {
            self.`protocol` = `protocol`
            self.resourceEndpoint = resourceEndpoint
        }
    }

}

extension ResourceInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// When the input StreamARN or ChannelARN in CLOUD_STORAGE_MODE is already mapped to a different Kinesis Video Stream resource, or if the provided input StreamARN or ChannelARN is not in Active status, try one of the following :
///
/// * The DescribeMediaStorageConfiguration API to determine what the stream given channel is mapped to.
///
/// * The DescribeMappedResourceConfiguration API to determine the channel that the given stream is mapped to.
///
/// * The DescribeStream or DescribeSignalingChannel API to determine the status of the resource.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Amazon Kinesis Video Streams can't find the stream that you specified.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisVideoClientTypes.ScheduleConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationInSeconds = "DurationInSeconds"
        case scheduleExpression = "ScheduleExpression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInSeconds = self.durationInSeconds {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let scheduleExpression = self.scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
    }
}

extension KinesisVideoClientTypes {
    /// This API enables you to specify the duration that the camera, or local media file, should record onto the Edge Agent. The ScheduleConfig consists of the ScheduleExpression and the DurationInMinutes attributes. If the ScheduleConfig is not provided in the RecorderConfig, then the Edge Agent will always be set to recording mode. If the ScheduleConfig is not provided in the UploaderConfig, then the Edge Agent will upload at regular intervals (every 1 hour).
    public struct ScheduleConfig: Swift.Equatable {
        /// The total duration to record the media. If the ScheduleExpression attribute is provided, then the DurationInSeconds attribute should also be specified.
        /// This member is required.
        public var durationInSeconds: Swift.Int?
        /// The Quartz cron expression that takes care of scheduling jobs to record from the camera, or local media file, onto the Edge Agent. If the ScheduleExpression is not provided for the RecorderConfig, then the Edge Agent will always be set to recording mode. For more information about Quartz, refer to the [ Cron Trigger Tutorial ](http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) page to understand the valid expressions and its use.
        /// This member is required.
        public var scheduleExpression: Swift.String?

        public init(
            durationInSeconds: Swift.Int? = nil,
            scheduleExpression: Swift.String? = nil
        )
        {
            self.durationInSeconds = durationInSeconds
            self.scheduleExpression = scheduleExpression
        }
    }

}

extension KinesisVideoClientTypes.SingleMasterChannelEndpointConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protocols = "Protocols"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for channelprotocol0 in protocols {
                try protocolsContainer.encode(channelprotocol0.rawValue)
            }
        }
        if let role = self.role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolsContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.ChannelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[KinesisVideoClientTypes.ChannelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [KinesisVideoClientTypes.ChannelProtocol]()
            for enum0 in protocolsContainer {
                if let enum0 = enum0 {
                    protocolsDecoded0?.append(enum0)
                }
            }
        }
        protocols = protocolsDecoded0
        let roleDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ChannelRole.self, forKey: .role)
        role = roleDecoded
    }
}

extension KinesisVideoClientTypes {
    /// An object that contains the endpoint configuration for the SINGLE_MASTER channel type.
    public struct SingleMasterChannelEndpointConfiguration: Swift.Equatable {
        /// This property is used to determine the nature of communication over this SINGLE_MASTER signaling channel. If WSS is specified, this API returns a websocket endpoint. If HTTPS is specified, this API returns an HTTPS endpoint.
        public var protocols: [KinesisVideoClientTypes.ChannelProtocol]?
        /// This property is used to determine messaging permissions in this SINGLE_MASTER signaling channel. If MASTER is specified, this API returns an endpoint that a client can use to receive offers from and send answers to any of the viewers on this signaling channel. If VIEWER is specified, this API returns an endpoint that a client can use only to send offers to another MASTER client on this signaling channel.
        public var role: KinesisVideoClientTypes.ChannelRole?

        public init(
            protocols: [KinesisVideoClientTypes.ChannelProtocol]? = nil,
            role: KinesisVideoClientTypes.ChannelRole? = nil
        )
        {
            self.protocols = protocols
            self.role = role
        }
    }

}

extension KinesisVideoClientTypes.SingleMasterConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageTtlSeconds = "MessageTtlSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageTtlSeconds = self.messageTtlSeconds {
            try encodeContainer.encode(messageTtlSeconds, forKey: .messageTtlSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageTtlSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .messageTtlSeconds)
        messageTtlSeconds = messageTtlSecondsDecoded
    }
}

extension KinesisVideoClientTypes {
    /// A structure that contains the configuration for the SINGLE_MASTER channel type.
    public struct SingleMasterConfiguration: Swift.Equatable {
        /// The period of time a signaling channel retains undelivered messages before they are discarded.
        public var messageTtlSeconds: Swift.Int?

        public init(
            messageTtlSeconds: Swift.Int? = nil
        )
        {
            self.messageTtlSeconds = messageTtlSeconds
        }
    }

}

extension StartEdgeConfigurationUpdateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case edgeConfig = "EdgeConfig"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let edgeConfig = self.edgeConfig {
            try encodeContainer.encode(edgeConfig, forKey: .edgeConfig)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension StartEdgeConfigurationUpdateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/startEdgeConfigurationUpdate"
    }
}

public struct StartEdgeConfigurationUpdateInput: Swift.Equatable {
    /// The edge configuration details required to invoke the update process.
    /// This member is required.
    public var edgeConfig: KinesisVideoClientTypes.EdgeConfig?
    /// The Amazon Resource Name (ARN) of the stream. Specify either the StreamName or the StreamARN.
    public var streamARN: Swift.String?
    /// The name of the stream whose edge configuration you want to update. Specify either the StreamName or the StreamARN.
    public var streamName: Swift.String?

    public init(
        edgeConfig: KinesisVideoClientTypes.EdgeConfig? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.edgeConfig = edgeConfig
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct StartEdgeConfigurationUpdateInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let edgeConfig: KinesisVideoClientTypes.EdgeConfig?
}

extension StartEdgeConfigurationUpdateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case edgeConfig = "EdgeConfig"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let edgeConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.EdgeConfig.self, forKey: .edgeConfig)
        edgeConfig = edgeConfigDecoded
    }
}

extension StartEdgeConfigurationUpdateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartEdgeConfigurationUpdateOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.edgeConfig = output.edgeConfig
            self.failedStatusDetails = output.failedStatusDetails
            self.lastUpdatedTime = output.lastUpdatedTime
            self.streamARN = output.streamARN
            self.streamName = output.streamName
            self.syncStatus = output.syncStatus
        } else {
            self.creationTime = nil
            self.edgeConfig = nil
            self.failedStatusDetails = nil
            self.lastUpdatedTime = nil
            self.streamARN = nil
            self.streamName = nil
            self.syncStatus = nil
        }
    }
}

public struct StartEdgeConfigurationUpdateOutput: Swift.Equatable {
    /// The timestamp at which a stream’s edge configuration was first created.
    public var creationTime: ClientRuntime.Date?
    /// A description of the stream's edge configuration that will be used to sync with the Edge Agent IoT Greengrass component. The Edge Agent component will run on an IoT Hub Device setup at your premise.
    public var edgeConfig: KinesisVideoClientTypes.EdgeConfig?
    /// A description of the generated failure status.
    public var failedStatusDetails: Swift.String?
    /// The timestamp at which a stream’s edge configuration was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the stream.
    public var streamARN: Swift.String?
    /// The name of the stream from which the edge configuration was updated.
    public var streamName: Swift.String?
    /// The current sync status of the stream's edge configuration. When you invoke this API, the sync status will be set to the SYNCING state. Use the DescribeEdgeConfiguration API to get the latest status of the edge configuration.
    public var syncStatus: KinesisVideoClientTypes.SyncStatus?

    public init(
        creationTime: ClientRuntime.Date? = nil,
        edgeConfig: KinesisVideoClientTypes.EdgeConfig? = nil,
        failedStatusDetails: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil,
        syncStatus: KinesisVideoClientTypes.SyncStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.edgeConfig = edgeConfig
        self.failedStatusDetails = failedStatusDetails
        self.lastUpdatedTime = lastUpdatedTime
        self.streamARN = streamARN
        self.streamName = streamName
        self.syncStatus = syncStatus
    }
}

struct StartEdgeConfigurationUpdateOutputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastUpdatedTime: ClientRuntime.Date?
    let syncStatus: KinesisVideoClientTypes.SyncStatus?
    let failedStatusDetails: Swift.String?
    let edgeConfig: KinesisVideoClientTypes.EdgeConfig?
}

extension StartEdgeConfigurationUpdateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case edgeConfig = "EdgeConfig"
        case failedStatusDetails = "FailedStatusDetails"
        case lastUpdatedTime = "LastUpdatedTime"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case syncStatus = "SyncStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let syncStatusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.SyncStatus.self, forKey: .syncStatus)
        syncStatus = syncStatusDecoded
        let failedStatusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failedStatusDetails)
        failedStatusDetails = failedStatusDetailsDecoded
        let edgeConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.EdgeConfig.self, forKey: .edgeConfig)
        edgeConfig = edgeConfigDecoded
    }
}

enum StartEdgeConfigurationUpdateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoDataRetentionException": return try await NoDataRetentionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension KinesisVideoClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .active,
                .creating,
                .deleting,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension KinesisVideoClientTypes {
    public enum StrategyOnFullSize: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleteOldestMedia
        case denyNewMedia
        case sdkUnknown(Swift.String)

        public static var allCases: [StrategyOnFullSize] {
            return [
                .deleteOldestMedia,
                .denyNewMedia,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleteOldestMedia: return "DELETE_OLDEST_MEDIA"
            case .denyNewMedia: return "DENY_NEW_MEDIA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StrategyOnFullSize(rawValue: rawValue) ?? StrategyOnFullSize.sdkUnknown(rawValue)
        }
    }
}

extension StreamEdgeConfigurationNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StreamEdgeConfigurationNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Exception rendered when the Amazon Kinesis Video Stream can't find a stream's edge configuration that you specified.
public struct StreamEdgeConfigurationNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "StreamEdgeConfigurationNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct StreamEdgeConfigurationNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension StreamEdgeConfigurationNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisVideoClientTypes.StreamInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataRetentionInHours = "DataRetentionInHours"
        case deviceName = "DeviceName"
        case kmsKeyId = "KmsKeyId"
        case mediaType = "MediaType"
        case status = "Status"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let dataRetentionInHours = self.dataRetentionInHours {
            try encodeContainer.encode(dataRetentionInHours, forKey: .dataRetentionInHours)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let mediaType = self.mediaType {
            try encodeContainer.encode(mediaType, forKey: .mediaType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let mediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaType)
        mediaType = mediaTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let dataRetentionInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRetentionInHours)
        dataRetentionInHours = dataRetentionInHoursDecoded
    }
}

extension KinesisVideoClientTypes {
    /// An object describing a Kinesis video stream.
    public struct StreamInfo: Swift.Equatable {
        /// A time stamp that indicates when the stream was created.
        public var creationTime: ClientRuntime.Date?
        /// How long the stream retains data, in hours.
        public var dataRetentionInHours: Swift.Int?
        /// The name of the device that is associated with the stream.
        public var deviceName: Swift.String?
        /// The ID of the Key Management Service (KMS) key that Kinesis Video Streams uses to encrypt data on the stream.
        public var kmsKeyId: Swift.String?
        /// The MediaType of the stream.
        public var mediaType: Swift.String?
        /// The status of the stream.
        public var status: KinesisVideoClientTypes.Status?
        /// The Amazon Resource Name (ARN) of the stream.
        public var streamARN: Swift.String?
        /// The name of the stream.
        public var streamName: Swift.String?
        /// The version of the stream.
        public var version: Swift.String?

        public init(
            creationTime: ClientRuntime.Date? = nil,
            dataRetentionInHours: Swift.Int? = nil,
            deviceName: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            mediaType: Swift.String? = nil,
            status: KinesisVideoClientTypes.Status? = nil,
            streamARN: Swift.String? = nil,
            streamName: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.dataRetentionInHours = dataRetentionInHours
            self.deviceName = deviceName
            self.kmsKeyId = kmsKeyId
            self.mediaType = mediaType
            self.status = status
            self.streamARN = streamARN
            self.streamName = streamName
            self.version = version
        }
    }

}

extension KinesisVideoClientTypes.StreamNameCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonOperator = "ComparisonOperator"
        case comparisonValue = "ComparisonValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = self.comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let comparisonValue = self.comparisonValue {
            try encodeContainer.encode(comparisonValue, forKey: .comparisonValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let comparisonValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comparisonValue)
        comparisonValue = comparisonValueDecoded
    }
}

extension KinesisVideoClientTypes {
    /// Specifies the condition that streams must satisfy to be returned when you list streams (see the ListStreams API). A condition has a comparison operation and a value. Currently, you can specify only the BEGINS_WITH operator, which finds streams whose names start with a given prefix.
    public struct StreamNameCondition: Swift.Equatable {
        /// A comparison operator. Currently, you can specify only the BEGINS_WITH operator, which finds streams whose names start with a given prefix.
        public var comparisonOperator: KinesisVideoClientTypes.ComparisonOperator?
        /// A value to compare.
        public var comparisonValue: Swift.String?

        public init(
            comparisonOperator: KinesisVideoClientTypes.ComparisonOperator? = nil,
            comparisonValue: Swift.String? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.comparisonValue = comparisonValue
        }
    }

}

extension KinesisVideoClientTypes {
    public enum SyncStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acknowledged
        case deleteFailed
        case deleting
        case deletingAcknowledged
        case inSync
        case syncing
        case syncFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncStatus] {
            return [
                .acknowledged,
                .deleteFailed,
                .deleting,
                .deletingAcknowledged,
                .inSync,
                .syncing,
                .syncFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acknowledged: return "ACKNOWLEDGED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .deletingAcknowledged: return "DELETING_ACKNOWLEDGED"
            case .inSync: return "IN_SYNC"
            case .syncing: return "SYNCING"
            case .syncFailed: return "SYNC_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SyncStatus(rawValue: rawValue) ?? SyncStatus.sdkUnknown(rawValue)
        }
    }
}

extension KinesisVideoClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension KinesisVideoClientTypes {
    /// A key and value pair that is associated with the specified signaling channel.
    public struct Tag: Swift.Equatable {
        /// The key of the tag that is associated with the specified signaling channel.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag that is associated with the specified signaling channel.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/TagResource"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the signaling channel to which you want to add tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tags to associate with the specified signaling channel. Each tag is a key-value pair.
    /// This member is required.
    public var tags: [KinesisVideoClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [KinesisVideoClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [KinesisVideoClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KinesisVideoClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KinesisVideoClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagsPerResourceExceededLimitException": return try await TagsPerResourceExceededLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, resourceTags0) in tags {
                try tagsContainer.encode(resourceTags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tagStream"
    }
}

public struct TagStreamInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to add the tag or tags to.
    public var streamARN: Swift.String?
    /// The name of the stream that you want to add the tag or tags to.
    public var streamName: Swift.String?
    /// A list of tags to associate with the specified stream. Each tag is a key-value pair (the value is optional).
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
        self.tags = tags
    }
}

struct TagStreamInputBody: Swift.Equatable {
    let streamARN: Swift.String?
    let streamName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension TagStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagStreamOutput: Swift.Equatable {

    public init() { }
}

enum TagStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceFormatException": return try await InvalidResourceFormatException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TagsPerResourceExceededLimitException": return try await TagsPerResourceExceededLimitException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagsPerResourceExceededLimitException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TagsPerResourceExceededLimitExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have exceeded the limit of tags that you can associate with the resource. A Kinesis video stream can support up to 50 tags.
public struct TagsPerResourceExceededLimitException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagsPerResourceExceededLimitException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TagsPerResourceExceededLimitExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagsPerResourceExceededLimitExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeyList = "TagKeyList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeyList = tagKeyList {
            var tagKeyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeyList)
            for tagkey0 in tagKeyList {
                try tagKeyListContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UntagResource"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the signaling channel from which you want to remove tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of the keys of the tags that you want to remove.
    /// This member is required.
    public var tagKeyList: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeyList: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeyList = tagKeyList
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeyList: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeyList = "TagKeyList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeyListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeyList)
        var tagKeyListDecoded0:[Swift.String]? = nil
        if let tagKeyListContainer = tagKeyListContainer {
            tagKeyListDecoded0 = [Swift.String]()
            for string0 in tagKeyListContainer {
                if let string0 = string0 {
                    tagKeyListDecoded0?.append(string0)
                }
            }
        }
        tagKeyList = tagKeyListDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case tagKeyList = "TagKeyList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let tagKeyList = tagKeyList {
            var tagKeyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeyList)
            for tagkey0 in tagKeyList {
                try tagKeyListContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/untagStream"
    }
}

public struct UntagStreamInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the stream that you want to remove tags from.
    public var streamARN: Swift.String?
    /// The name of the stream that you want to remove tags from.
    public var streamName: Swift.String?
    /// A list of the keys of the tags that you want to remove.
    /// This member is required.
    public var tagKeyList: [Swift.String]?

    public init(
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil,
        tagKeyList: [Swift.String]? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
        self.tagKeyList = tagKeyList
    }
}

struct UntagStreamInputBody: Swift.Equatable {
    let streamARN: Swift.String?
    let streamName: Swift.String?
    let tagKeyList: [Swift.String]?
}

extension UntagStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case tagKeyList = "TagKeyList"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let tagKeyListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeyList)
        var tagKeyListDecoded0:[Swift.String]? = nil
        if let tagKeyListContainer = tagKeyListContainer {
            tagKeyListDecoded0 = [Swift.String]()
            for string0 in tagKeyListContainer {
                if let string0 = string0 {
                    tagKeyListDecoded0?.append(string0)
                }
            }
        }
        tagKeyList = tagKeyListDecoded0
    }
}

extension UntagStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagStreamOutput: Swift.Equatable {

    public init() { }
}

enum UntagStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidResourceFormatException": return try await InvalidResourceFormatException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDataRetentionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case dataRetentionChangeInHours = "DataRetentionChangeInHours"
        case operation = "Operation"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let dataRetentionChangeInHours = self.dataRetentionChangeInHours {
            try encodeContainer.encode(dataRetentionChangeInHours, forKey: .dataRetentionChangeInHours)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension UpdateDataRetentionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateDataRetention"
    }
}

public struct UpdateDataRetentionInput: Swift.Equatable {
    /// The version of the stream whose retention period you want to change. To get the version, call either the DescribeStream or the ListStreams API.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// The retention period, in hours. The value you specify replaces the current value. The maximum value for this parameter is 87600 (ten years).
    /// This member is required.
    public var dataRetentionChangeInHours: Swift.Int?
    /// Indicates whether you want to increase or decrease the retention period.
    /// This member is required.
    public var operation: KinesisVideoClientTypes.UpdateDataRetentionOperation?
    /// The Amazon Resource Name (ARN) of the stream whose retention period you want to change.
    public var streamARN: Swift.String?
    /// The name of the stream whose retention period you want to change.
    public var streamName: Swift.String?

    public init(
        currentVersion: Swift.String? = nil,
        dataRetentionChangeInHours: Swift.Int? = nil,
        operation: KinesisVideoClientTypes.UpdateDataRetentionOperation? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.currentVersion = currentVersion
        self.dataRetentionChangeInHours = dataRetentionChangeInHours
        self.operation = operation
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct UpdateDataRetentionInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let currentVersion: Swift.String?
    let operation: KinesisVideoClientTypes.UpdateDataRetentionOperation?
    let dataRetentionChangeInHours: Swift.Int?
}

extension UpdateDataRetentionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case dataRetentionChangeInHours = "DataRetentionChangeInHours"
        case operation = "Operation"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let operationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.UpdateDataRetentionOperation.self, forKey: .operation)
        operation = operationDecoded
        let dataRetentionChangeInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRetentionChangeInHours)
        dataRetentionChangeInHours = dataRetentionChangeInHoursDecoded
    }
}

extension KinesisVideoClientTypes {
    public enum UpdateDataRetentionOperation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case decreaseDataRetention
        case increaseDataRetention
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateDataRetentionOperation] {
            return [
                .decreaseDataRetention,
                .increaseDataRetention,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .decreaseDataRetention: return "DECREASE_DATA_RETENTION"
            case .increaseDataRetention: return "INCREASE_DATA_RETENTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateDataRetentionOperation(rawValue: rawValue) ?? UpdateDataRetentionOperation.sdkUnknown(rawValue)
        }
    }
}

extension UpdateDataRetentionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDataRetentionOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDataRetentionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionMismatchException": return try await VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateImageGenerationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageGenerationConfiguration = "ImageGenerationConfiguration"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageGenerationConfiguration = self.imageGenerationConfiguration {
            try encodeContainer.encode(imageGenerationConfiguration, forKey: .imageGenerationConfiguration)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension UpdateImageGenerationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateImageGenerationConfiguration"
    }
}

public struct UpdateImageGenerationConfigurationInput: Swift.Equatable {
    /// The structure that contains the information required for the KVS images delivery. If the structure is null, the configuration will be deleted from the stream.
    public var imageGenerationConfiguration: KinesisVideoClientTypes.ImageGenerationConfiguration?
    /// The Amazon Resource Name (ARN) of the Kinesis video stream from where you want to update the image generation configuration. You must specify either the StreamName or the StreamARN.
    public var streamARN: Swift.String?
    /// The name of the stream from which to update the image generation configuration. You must specify either the StreamName or the StreamARN.
    public var streamName: Swift.String?

    public init(
        imageGenerationConfiguration: KinesisVideoClientTypes.ImageGenerationConfiguration? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.imageGenerationConfiguration = imageGenerationConfiguration
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct UpdateImageGenerationConfigurationInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let imageGenerationConfiguration: KinesisVideoClientTypes.ImageGenerationConfiguration?
}

extension UpdateImageGenerationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageGenerationConfiguration = "ImageGenerationConfiguration"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let imageGenerationConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ImageGenerationConfiguration.self, forKey: .imageGenerationConfiguration)
        imageGenerationConfiguration = imageGenerationConfigurationDecoded
    }
}

extension UpdateImageGenerationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateImageGenerationConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateImageGenerationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoDataRetentionException": return try await NoDataRetentionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMediaStorageConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case mediaStorageConfiguration = "MediaStorageConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = self.channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let mediaStorageConfiguration = self.mediaStorageConfiguration {
            try encodeContainer.encode(mediaStorageConfiguration, forKey: .mediaStorageConfiguration)
        }
    }
}

extension UpdateMediaStorageConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateMediaStorageConfiguration"
    }
}

public struct UpdateMediaStorageConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the channel.
    /// This member is required.
    public var channelARN: Swift.String?
    /// A structure that encapsulates, or contains, the media storage configuration properties.
    /// This member is required.
    public var mediaStorageConfiguration: KinesisVideoClientTypes.MediaStorageConfiguration?

    public init(
        channelARN: Swift.String? = nil,
        mediaStorageConfiguration: KinesisVideoClientTypes.MediaStorageConfiguration? = nil
    )
    {
        self.channelARN = channelARN
        self.mediaStorageConfiguration = mediaStorageConfiguration
    }
}

struct UpdateMediaStorageConfigurationInputBody: Swift.Equatable {
    let channelARN: Swift.String?
    let mediaStorageConfiguration: KinesisVideoClientTypes.MediaStorageConfiguration?
}

extension UpdateMediaStorageConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case mediaStorageConfiguration = "MediaStorageConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
        let mediaStorageConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.MediaStorageConfiguration.self, forKey: .mediaStorageConfiguration)
        mediaStorageConfiguration = mediaStorageConfigurationDecoded
    }
}

extension UpdateMediaStorageConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateMediaStorageConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateMediaStorageConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoDataRetentionException": return try await NoDataRetentionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateNotificationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationConfiguration = "NotificationConfiguration"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationConfiguration = self.notificationConfiguration {
            try encodeContainer.encode(notificationConfiguration, forKey: .notificationConfiguration)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension UpdateNotificationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateNotificationConfiguration"
    }
}

public struct UpdateNotificationConfigurationInput: Swift.Equatable {
    /// The structure containing the information required for notifications. If the structure is null, the configuration will be deleted from the stream.
    public var notificationConfiguration: KinesisVideoClientTypes.NotificationConfiguration?
    /// The Amazon Resource Name (ARN) of the Kinesis video stream from where you want to update the notification configuration. You must specify either the StreamName or the StreamARN.
    public var streamARN: Swift.String?
    /// The name of the stream from which to update the notification configuration. You must specify either the StreamName or the StreamARN.
    public var streamName: Swift.String?

    public init(
        notificationConfiguration: KinesisVideoClientTypes.NotificationConfiguration? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.notificationConfiguration = notificationConfiguration
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct UpdateNotificationConfigurationInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let notificationConfiguration: KinesisVideoClientTypes.NotificationConfiguration?
}

extension UpdateNotificationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationConfiguration = "NotificationConfiguration"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
    }
}

extension UpdateNotificationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateNotificationConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateNotificationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NoDataRetentionException": return try await NoDataRetentionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSignalingChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case currentVersion = "CurrentVersion"
        case singleMasterConfiguration = "SingleMasterConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = self.channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let singleMasterConfiguration = self.singleMasterConfiguration {
            try encodeContainer.encode(singleMasterConfiguration, forKey: .singleMasterConfiguration)
        }
    }
}

extension UpdateSignalingChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateSignalingChannel"
    }
}

public struct UpdateSignalingChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the signaling channel that you want to update.
    /// This member is required.
    public var channelARN: Swift.String?
    /// The current version of the signaling channel that you want to update.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// The structure containing the configuration for the SINGLE_MASTER type of the signaling channel that you want to update.
    public var singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration?

    public init(
        channelARN: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration? = nil
    )
    {
        self.channelARN = channelARN
        self.currentVersion = currentVersion
        self.singleMasterConfiguration = singleMasterConfiguration
    }
}

struct UpdateSignalingChannelInputBody: Swift.Equatable {
    let channelARN: Swift.String?
    let currentVersion: Swift.String?
    let singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration?
}

extension UpdateSignalingChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case currentVersion = "CurrentVersion"
        case singleMasterConfiguration = "SingleMasterConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let singleMasterConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.SingleMasterConfiguration.self, forKey: .singleMasterConfiguration)
        singleMasterConfiguration = singleMasterConfigurationDecoded
    }
}

extension UpdateSignalingChannelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateSignalingChannelOutput: Swift.Equatable {

    public init() { }
}

enum UpdateSignalingChannelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionMismatchException": return try await VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case deviceName = "DeviceName"
        case mediaType = "MediaType"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let mediaType = self.mediaType {
            try encodeContainer.encode(mediaType, forKey: .mediaType)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension UpdateStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateStream"
    }
}

public struct UpdateStreamInput: Swift.Equatable {
    /// The version of the stream whose metadata you want to update.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// The name of the device that is writing to the stream. In the current implementation, Kinesis Video Streams does not use this name.
    public var deviceName: Swift.String?
    /// The stream's media type. Use MediaType to specify the type of content that the stream contains to the consumers of the stream. For more information about media types, see [Media Types](http://www.iana.org/assignments/media-types/media-types.xhtml). If you choose to specify the MediaType, see [Naming Requirements](https://tools.ietf.org/html/rfc6838#section-4.2). To play video on the console, you must specify the correct video type. For example, if the video in the stream is H.264, specify video/h264 as the MediaType.
    public var mediaType: Swift.String?
    /// The ARN of the stream whose metadata you want to update.
    public var streamARN: Swift.String?
    /// The name of the stream whose metadata you want to update. The stream name is an identifier for the stream, and must be unique for each account and region.
    public var streamName: Swift.String?

    public init(
        currentVersion: Swift.String? = nil,
        deviceName: Swift.String? = nil,
        mediaType: Swift.String? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.currentVersion = currentVersion
        self.deviceName = deviceName
        self.mediaType = mediaType
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct UpdateStreamInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let currentVersion: Swift.String?
    let deviceName: Swift.String?
    let mediaType: Swift.String?
}

extension UpdateStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case deviceName = "DeviceName"
        case mediaType = "MediaType"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let mediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaType)
        mediaType = mediaTypeDecoded
    }
}

extension UpdateStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateStreamOutput: Swift.Equatable {

    public init() { }
}

enum UpdateStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ClientLimitExceededException": return try await ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidArgumentException": return try await InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotAuthorizedException": return try await NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "VersionMismatchException": return try await VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension KinesisVideoClientTypes.UploaderConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduleConfig = "ScheduleConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scheduleConfig = self.scheduleConfig {
            try encodeContainer.encode(scheduleConfig, forKey: .scheduleConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ScheduleConfig.self, forKey: .scheduleConfig)
        scheduleConfig = scheduleConfigDecoded
    }
}

extension KinesisVideoClientTypes {
    /// The configuration that consists of the ScheduleExpression and the DurationInMinutes details that specify the scheduling to record from a camera, or local media file, onto the Edge Agent. If the ScheduleConfig is not provided in the UploaderConfig, then the Edge Agent will upload at regular intervals (every 1 hour).
    public struct UploaderConfig: Swift.Equatable {
        /// The configuration that consists of the ScheduleExpression and the DurationInMinutes details that specify the scheduling to record from a camera, or local media file, onto the Edge Agent. If the ScheduleConfig is not provided in this UploaderConfig, then the Edge Agent will upload at regular intervals (every 1 hour).
        /// This member is required.
        public var scheduleConfig: KinesisVideoClientTypes.ScheduleConfig?

        public init(
            scheduleConfig: KinesisVideoClientTypes.ScheduleConfig? = nil
        )
        {
            self.scheduleConfig = scheduleConfig
        }
    }

}

extension KinesisVideoClientTypes {
    public enum UploaderStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case success
        case systemError
        case userError
        case sdkUnknown(Swift.String)

        public static var allCases: [UploaderStatus] {
            return [
                .success,
                .systemError,
                .userError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .success: return "SUCCESS"
            case .systemError: return "SYSTEM_ERROR"
            case .userError: return "USER_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UploaderStatus(rawValue: rawValue) ?? UploaderStatus.sdkUnknown(rawValue)
        }
    }
}

extension VersionMismatchException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: VersionMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The stream version that you specified is not the latest version. To get the latest version, use the [DescribeStream](https://docs.aws.amazon.com/kinesisvideostreams/latest/dg/API_DescribeStream.html) API.
public struct VersionMismatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "VersionMismatchException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct VersionMismatchExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension VersionMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
