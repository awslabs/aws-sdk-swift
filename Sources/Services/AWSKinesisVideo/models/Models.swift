// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension KinesisVideoClientTypes {
    public enum APIName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case getClip
        case getDashStreamingSessionUrl
        case getHlsStreamingSessionUrl
        case getImages
        case getMedia
        case getMediaForFragmentList
        case listFragments
        case putMedia
        case sdkUnknown(Swift.String)

        public static var allCases: [APIName] {
            return [
                .getClip,
                .getDashStreamingSessionUrl,
                .getHlsStreamingSessionUrl,
                .getImages,
                .getMedia,
                .getMediaForFragmentList,
                .listFragments,
                .putMedia,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .getClip: return "GET_CLIP"
            case .getDashStreamingSessionUrl: return "GET_DASH_STREAMING_SESSION_URL"
            case .getHlsStreamingSessionUrl: return "GET_HLS_STREAMING_SESSION_URL"
            case .getImages: return "GET_IMAGES"
            case .getMedia: return "GET_MEDIA"
            case .getMediaForFragmentList: return "GET_MEDIA_FOR_FRAGMENT_LIST"
            case .listFragments: return "LIST_FRAGMENTS"
            case .putMedia: return "PUT_MEDIA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = APIName(rawValue: rawValue) ?? APIName.sdkUnknown(rawValue)
        }
    }
}

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have required permissions to perform this operation.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountChannelLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccountChannelLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have reached the maximum limit of active signaling channels for this Amazon Web Services account in this region.
public struct AccountChannelLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccountChannelLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccountChannelLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AccountStreamLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccountStreamLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of streams created for the account is too high.
public struct AccountStreamLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccountStreamLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccountStreamLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisVideoClientTypes.ChannelInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case channelName = "ChannelName"
        case channelStatus = "ChannelStatus"
        case channelType = "ChannelType"
        case creationTime = "CreationTime"
        case singleMasterConfiguration = "SingleMasterConfiguration"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = self.channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelStatus = self.channelStatus {
            try encodeContainer.encode(channelStatus.rawValue, forKey: .channelStatus)
        }
        if let channelType = self.channelType {
            try encodeContainer.encode(channelType.rawValue, forKey: .channelType)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let singleMasterConfiguration = self.singleMasterConfiguration {
            try encodeContainer.encode(singleMasterConfiguration, forKey: .singleMasterConfiguration)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
        let channelTypeDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ChannelType.self, forKey: .channelType)
        channelType = channelTypeDecoded
        let channelStatusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.Status.self, forKey: .channelStatus)
        channelStatus = channelStatusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let singleMasterConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.SingleMasterConfiguration.self, forKey: .singleMasterConfiguration)
        singleMasterConfiguration = singleMasterConfigurationDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension KinesisVideoClientTypes {
    /// A structure that encapsulates a signaling channel's metadata and properties.
    public struct ChannelInfo: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the signaling channel.
        public var channelARN: Swift.String?
        /// The name of the signaling channel.
        public var channelName: Swift.String?
        /// Current status of the signaling channel.
        public var channelStatus: KinesisVideoClientTypes.Status?
        /// The type of the signaling channel.
        public var channelType: KinesisVideoClientTypes.ChannelType?
        /// The time at which the signaling channel was created.
        public var creationTime: ClientRuntime.Date?
        /// A structure that contains the configuration for the SINGLE_MASTER channel type.
        public var singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration?
        /// The current version of the signaling channel.
        public var version: Swift.String?

        public init (
            channelARN: Swift.String? = nil,
            channelName: Swift.String? = nil,
            channelStatus: KinesisVideoClientTypes.Status? = nil,
            channelType: KinesisVideoClientTypes.ChannelType? = nil,
            creationTime: ClientRuntime.Date? = nil,
            singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration? = nil,
            version: Swift.String? = nil
        )
        {
            self.channelARN = channelARN
            self.channelName = channelName
            self.channelStatus = channelStatus
            self.channelType = channelType
            self.creationTime = creationTime
            self.singleMasterConfiguration = singleMasterConfiguration
            self.version = version
        }
    }

}

extension KinesisVideoClientTypes.ChannelNameCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonOperator = "ComparisonOperator"
        case comparisonValue = "ComparisonValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = self.comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let comparisonValue = self.comparisonValue {
            try encodeContainer.encode(comparisonValue, forKey: .comparisonValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let comparisonValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comparisonValue)
        comparisonValue = comparisonValueDecoded
    }
}

extension KinesisVideoClientTypes {
    /// An optional input parameter for the ListSignalingChannels API. When this parameter is specified while invoking ListSignalingChannels, the API returns only the channels that satisfy a condition specified in ChannelNameCondition.
    public struct ChannelNameCondition: Swift.Equatable {
        /// A comparison operator. Currently, you can only specify the BEGINS_WITH operator, which finds signaling channels whose names begin with a given prefix.
        public var comparisonOperator: KinesisVideoClientTypes.ComparisonOperator?
        /// A value to compare.
        public var comparisonValue: Swift.String?

        public init (
            comparisonOperator: KinesisVideoClientTypes.ComparisonOperator? = nil,
            comparisonValue: Swift.String? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.comparisonValue = comparisonValue
        }
    }

}

extension KinesisVideoClientTypes {
    public enum ChannelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case https
        case webrtc
        case wss
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelProtocol] {
            return [
                .https,
                .webrtc,
                .wss,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .https: return "HTTPS"
            case .webrtc: return "WEBRTC"
            case .wss: return "WSS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelProtocol(rawValue: rawValue) ?? ChannelProtocol.sdkUnknown(rawValue)
        }
    }
}

extension KinesisVideoClientTypes {
    public enum ChannelRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case master
        case viewer
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelRole] {
            return [
                .master,
                .viewer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .master: return "MASTER"
            case .viewer: return "VIEWER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelRole(rawValue: rawValue) ?? ChannelRole.sdkUnknown(rawValue)
        }
    }
}

extension KinesisVideoClientTypes {
    public enum ChannelType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fullMesh
        case singleMaster
        case sdkUnknown(Swift.String)

        public static var allCases: [ChannelType] {
            return [
                .fullMesh,
                .singleMaster,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fullMesh: return "FULL_MESH"
            case .singleMaster: return "SINGLE_MASTER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChannelType(rawValue: rawValue) ?? ChannelType.sdkUnknown(rawValue)
        }
    }
}

extension ClientLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ClientLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Kinesis Video Streams has throttled the request because you have exceeded the limit of allowed client calls. Try making the call later.
public struct ClientLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ClientLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ClientLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisVideoClientTypes {
    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case beginsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .beginsWith,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .beginsWith: return "BEGINS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
        }
    }
}

extension KinesisVideoClientTypes {
    public enum ConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationStatus(rawValue: rawValue) ?? ConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension CreateSignalingChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelName = "ChannelName"
        case channelType = "ChannelType"
        case singleMasterConfiguration = "SingleMasterConfiguration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelType = self.channelType {
            try encodeContainer.encode(channelType.rawValue, forKey: .channelType)
        }
        if let singleMasterConfiguration = self.singleMasterConfiguration {
            try encodeContainer.encode(singleMasterConfiguration, forKey: .singleMasterConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateSignalingChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createSignalingChannel"
    }
}

public struct CreateSignalingChannelInput: Swift.Equatable {
    /// A name for the signaling channel that you are creating. It must be unique for each Amazon Web Services account and Amazon Web Services Region.
    /// This member is required.
    public var channelName: Swift.String?
    /// A type of the signaling channel that you are creating. Currently, SINGLE_MASTER is the only supported channel type.
    public var channelType: KinesisVideoClientTypes.ChannelType?
    /// A structure containing the configuration for the SINGLE_MASTER channel type.
    public var singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration?
    /// A set of tags (key-value pairs) that you want to associate with this channel.
    public var tags: [KinesisVideoClientTypes.Tag]?

    public init (
        channelName: Swift.String? = nil,
        channelType: KinesisVideoClientTypes.ChannelType? = nil,
        singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration? = nil,
        tags: [KinesisVideoClientTypes.Tag]? = nil
    )
    {
        self.channelName = channelName
        self.channelType = channelType
        self.singleMasterConfiguration = singleMasterConfiguration
        self.tags = tags
    }
}

struct CreateSignalingChannelInputBody: Swift.Equatable {
    let channelName: Swift.String?
    let channelType: KinesisVideoClientTypes.ChannelType?
    let singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration?
    let tags: [KinesisVideoClientTypes.Tag]?
}

extension CreateSignalingChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelName = "ChannelName"
        case channelType = "ChannelType"
        case singleMasterConfiguration = "SingleMasterConfiguration"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelTypeDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ChannelType.self, forKey: .channelType)
        channelType = channelTypeDecoded
        let singleMasterConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.SingleMasterConfiguration.self, forKey: .singleMasterConfiguration)
        singleMasterConfiguration = singleMasterConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KinesisVideoClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KinesisVideoClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSignalingChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSignalingChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "AccountChannelLimitExceededException" : self = .accountChannelLimitExceededException(try AccountChannelLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagsPerResourceExceededLimitException" : self = .tagsPerResourceExceededLimitException(try TagsPerResourceExceededLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSignalingChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case accountChannelLimitExceededException(AccountChannelLimitExceededException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case tagsPerResourceExceededLimitException(TagsPerResourceExceededLimitException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSignalingChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSignalingChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelARN = output.channelARN
        } else {
            self.channelARN = nil
        }
    }
}

public struct CreateSignalingChannelOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the created channel.
    public var channelARN: Swift.String?

    public init (
        channelARN: Swift.String? = nil
    )
    {
        self.channelARN = channelARN
    }
}

struct CreateSignalingChannelOutputResponseBody: Swift.Equatable {
    let channelARN: Swift.String?
}

extension CreateSignalingChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
    }
}

extension CreateStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRetentionInHours = "DataRetentionInHours"
        case deviceName = "DeviceName"
        case kmsKeyId = "KmsKeyId"
        case mediaType = "MediaType"
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataRetentionInHours = self.dataRetentionInHours {
            try encodeContainer.encode(dataRetentionInHours, forKey: .dataRetentionInHours)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let mediaType = self.mediaType {
            try encodeContainer.encode(mediaType, forKey: .mediaType)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, resourceTags0) in tags {
                try tagsContainer.encode(resourceTags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/createStream"
    }
}

public struct CreateStreamInput: Swift.Equatable {
    /// The number of hours that you want to retain the data in the stream. Kinesis Video Streams retains the data in a data store that is associated with the stream. The default value is 0, indicating that the stream does not persist data. When the DataRetentionInHours value is 0, consumers can still consume the fragments that remain in the service host buffer, which has a retention time limit of 5 minutes and a retention memory limit of 200 MB. Fragments are removed from the buffer when either limit is reached.
    public var dataRetentionInHours: Swift.Int?
    /// The name of the device that is writing to the stream. In the current implementation, Kinesis Video Streams does not use this name.
    public var deviceName: Swift.String?
    /// The ID of the Key Management Service (KMS) key that you want Kinesis Video Streams to use to encrypt stream data. If no key ID is specified, the default, Kinesis Video-managed key (aws/kinesisvideo) is used. For more information, see [DescribeKey](https://docs.aws.amazon.com/kms/latest/APIReference/API_DescribeKey.html#API_DescribeKey_RequestParameters).
    public var kmsKeyId: Swift.String?
    /// The media type of the stream. Consumers of the stream can use this information when processing the stream. For more information about media types, see [Media Types](http://www.iana.org/assignments/media-types/media-types.xhtml). If you choose to specify the MediaType, see [Naming Requirements](https://tools.ietf.org/html/rfc6838#section-4.2) for guidelines. Example valid values include "video/h264" and "video/h264,audio/aac". This parameter is optional; the default value is null (or empty in JSON).
    public var mediaType: Swift.String?
    /// A name for the stream that you are creating. The stream name is an identifier for the stream, and must be unique for each account and region.
    /// This member is required.
    public var streamName: Swift.String?
    /// A list of tags to associate with the specified stream. Each tag is a key-value pair (the value is optional).
    public var tags: [Swift.String:Swift.String]?

    public init (
        dataRetentionInHours: Swift.Int? = nil,
        deviceName: Swift.String? = nil,
        kmsKeyId: Swift.String? = nil,
        mediaType: Swift.String? = nil,
        streamName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.dataRetentionInHours = dataRetentionInHours
        self.deviceName = deviceName
        self.kmsKeyId = kmsKeyId
        self.mediaType = mediaType
        self.streamName = streamName
        self.tags = tags
    }
}

struct CreateStreamInputBody: Swift.Equatable {
    let deviceName: Swift.String?
    let streamName: Swift.String?
    let mediaType: Swift.String?
    let kmsKeyId: Swift.String?
    let dataRetentionInHours: Swift.Int?
    let tags: [Swift.String:Swift.String]?
}

extension CreateStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataRetentionInHours = "DataRetentionInHours"
        case deviceName = "DeviceName"
        case kmsKeyId = "KmsKeyId"
        case mediaType = "MediaType"
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let mediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaType)
        mediaType = mediaTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let dataRetentionInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRetentionInHours)
        dataRetentionInHours = dataRetentionInHoursDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccountStreamLimitExceededException" : self = .accountStreamLimitExceededException(try AccountStreamLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DeviceStreamLimitExceededException" : self = .deviceStreamLimitExceededException(try DeviceStreamLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidDeviceException" : self = .invalidDeviceException(try InvalidDeviceException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagsPerResourceExceededLimitException" : self = .tagsPerResourceExceededLimitException(try TagsPerResourceExceededLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateStreamOutputError: Swift.Error, Swift.Equatable {
    case accountStreamLimitExceededException(AccountStreamLimitExceededException)
    case clientLimitExceededException(ClientLimitExceededException)
    case deviceStreamLimitExceededException(DeviceStreamLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidDeviceException(InvalidDeviceException)
    case resourceInUseException(ResourceInUseException)
    case tagsPerResourceExceededLimitException(TagsPerResourceExceededLimitException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamARN = output.streamARN
        } else {
            self.streamARN = nil
        }
    }
}

public struct CreateStreamOutputResponse: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the stream.
    public var streamARN: Swift.String?

    public init (
        streamARN: Swift.String? = nil
    )
    {
        self.streamARN = streamARN
    }
}

struct CreateStreamOutputResponseBody: Swift.Equatable {
    let streamARN: Swift.String?
}

extension CreateStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

extension DeleteSignalingChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case currentVersion = "CurrentVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = self.channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
    }
}

extension DeleteSignalingChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteSignalingChannel"
    }
}

public struct DeleteSignalingChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the signaling channel that you want to delete.
    /// This member is required.
    public var channelARN: Swift.String?
    /// The current version of the signaling channel that you want to delete. You can obtain the current version by invoking the DescribeSignalingChannel or ListSignalingChannels API operations.
    public var currentVersion: Swift.String?

    public init (
        channelARN: Swift.String? = nil,
        currentVersion: Swift.String? = nil
    )
    {
        self.channelARN = channelARN
        self.currentVersion = currentVersion
    }
}

struct DeleteSignalingChannelInputBody: Swift.Equatable {
    let channelARN: Swift.String?
    let currentVersion: Swift.String?
}

extension DeleteSignalingChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case currentVersion = "CurrentVersion"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
    }
}

extension DeleteSignalingChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSignalingChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionMismatchException" : self = .versionMismatchException(try VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSignalingChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case versionMismatchException(VersionMismatchException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSignalingChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSignalingChannelOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case streamARN = "StreamARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
    }
}

extension DeleteStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/deleteStream"
    }
}

public struct DeleteStreamInput: Swift.Equatable {
    /// Optional: The version of the stream that you want to delete. Specify the version as a safeguard to ensure that your are deleting the correct stream. To get the stream version, use the DescribeStream API. If not specified, only the CreationTime is checked before deleting the stream.
    public var currentVersion: Swift.String?
    /// The Amazon Resource Name (ARN) of the stream that you want to delete.
    /// This member is required.
    public var streamARN: Swift.String?

    public init (
        currentVersion: Swift.String? = nil,
        streamARN: Swift.String? = nil
    )
    {
        self.currentVersion = currentVersion
        self.streamARN = streamARN
    }
}

struct DeleteStreamInputBody: Swift.Equatable {
    let streamARN: Swift.String?
    let currentVersion: Swift.String?
}

extension DeleteStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case streamARN = "StreamARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
    }
}

extension DeleteStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionMismatchException" : self = .versionMismatchException(try VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteStreamOutputError: Swift.Error, Swift.Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case versionMismatchException(VersionMismatchException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteStreamOutputResponse: Swift.Equatable {

    public init () { }
}

extension KinesisVideoClientTypes.DeletionConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deleteAfterUpload = "DeleteAfterUpload"
        case edgeRetentionInHours = "EdgeRetentionInHours"
        case localSizeConfig = "LocalSizeConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deleteAfterUpload = self.deleteAfterUpload {
            try encodeContainer.encode(deleteAfterUpload, forKey: .deleteAfterUpload)
        }
        if let edgeRetentionInHours = self.edgeRetentionInHours {
            try encodeContainer.encode(edgeRetentionInHours, forKey: .edgeRetentionInHours)
        }
        if let localSizeConfig = self.localSizeConfig {
            try encodeContainer.encode(localSizeConfig, forKey: .localSizeConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let edgeRetentionInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .edgeRetentionInHours)
        edgeRetentionInHours = edgeRetentionInHoursDecoded
        let localSizeConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.LocalSizeConfig.self, forKey: .localSizeConfig)
        localSizeConfig = localSizeConfigDecoded
        let deleteAfterUploadDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deleteAfterUpload)
        deleteAfterUpload = deleteAfterUploadDecoded
    }
}

extension KinesisVideoClientTypes {
    /// The configuration details required to delete the connection of the stream from the Edge Agent.
    public struct DeletionConfig: Swift.Equatable {
        /// The boolean value used to indicate whether or not you want to mark the media for deletion, once it has been uploaded to the Kinesis Video Stream cloud. The media files can be deleted if any of the deletion configuration values are set to true, such as when the limit for the EdgeRetentionInHours, or the MaxLocalMediaSizeInMB, has been reached. Since the default value is set to true, configure the uploader schedule such that the media files are not being deleted before they are initially uploaded to AWS cloud.
        public var deleteAfterUpload: Swift.Bool?
        /// The number of hours that you want to retain the data in the stream on the Edge Agent. The default value of the retention time is 720 hours, which translates to 30 days.
        public var edgeRetentionInHours: Swift.Int?
        /// The value of the local size required in order to delete the edge configuration.
        public var localSizeConfig: KinesisVideoClientTypes.LocalSizeConfig?

        public init (
            deleteAfterUpload: Swift.Bool? = nil,
            edgeRetentionInHours: Swift.Int? = nil,
            localSizeConfig: KinesisVideoClientTypes.LocalSizeConfig? = nil
        )
        {
            self.deleteAfterUpload = deleteAfterUpload
            self.edgeRetentionInHours = edgeRetentionInHours
            self.localSizeConfig = localSizeConfig
        }
    }

}

extension DescribeEdgeConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension DescribeEdgeConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeEdgeConfiguration"
    }
}

public struct DescribeEdgeConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the stream. Specify either the StreamNameor the StreamARN.
    public var streamARN: Swift.String?
    /// The name of the stream whose edge configuration you want to update. Specify either the StreamName or the StreamARN.
    public var streamName: Swift.String?

    public init (
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct DescribeEdgeConfigurationInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
}

extension DescribeEdgeConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

extension DescribeEdgeConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEdgeConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "StreamEdgeConfigurationNotFoundException" : self = .streamEdgeConfigurationNotFoundException(try StreamEdgeConfigurationNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEdgeConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case streamEdgeConfigurationNotFoundException(StreamEdgeConfigurationNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEdgeConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEdgeConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.edgeConfig = output.edgeConfig
            self.failedStatusDetails = output.failedStatusDetails
            self.lastUpdatedTime = output.lastUpdatedTime
            self.streamARN = output.streamARN
            self.streamName = output.streamName
            self.syncStatus = output.syncStatus
        } else {
            self.creationTime = nil
            self.edgeConfig = nil
            self.failedStatusDetails = nil
            self.lastUpdatedTime = nil
            self.streamARN = nil
            self.streamName = nil
            self.syncStatus = nil
        }
    }
}

public struct DescribeEdgeConfigurationOutputResponse: Swift.Equatable {
    /// The timestamp at which a streams edge configuration was first created.
    public var creationTime: ClientRuntime.Date?
    /// A description of the stream's edge configuration that will be used to sync with the Edge Agent IoT Greengrass component. The Edge Agent component will run on an IoT Hub Device setup at your premise.
    public var edgeConfig: KinesisVideoClientTypes.EdgeConfig?
    /// A description of the generated failure status.
    public var failedStatusDetails: Swift.String?
    /// The timestamp at which a streams edge configuration was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the stream.
    public var streamARN: Swift.String?
    /// The name of the stream from which the edge configuration was updated.
    public var streamName: Swift.String?
    /// The latest status of the edge configuration update.
    public var syncStatus: KinesisVideoClientTypes.SyncStatus?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        edgeConfig: KinesisVideoClientTypes.EdgeConfig? = nil,
        failedStatusDetails: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil,
        syncStatus: KinesisVideoClientTypes.SyncStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.edgeConfig = edgeConfig
        self.failedStatusDetails = failedStatusDetails
        self.lastUpdatedTime = lastUpdatedTime
        self.streamARN = streamARN
        self.streamName = streamName
        self.syncStatus = syncStatus
    }
}

struct DescribeEdgeConfigurationOutputResponseBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastUpdatedTime: ClientRuntime.Date?
    let syncStatus: KinesisVideoClientTypes.SyncStatus?
    let failedStatusDetails: Swift.String?
    let edgeConfig: KinesisVideoClientTypes.EdgeConfig?
}

extension DescribeEdgeConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case edgeConfig = "EdgeConfig"
        case failedStatusDetails = "FailedStatusDetails"
        case lastUpdatedTime = "LastUpdatedTime"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case syncStatus = "SyncStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let syncStatusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.SyncStatus.self, forKey: .syncStatus)
        syncStatus = syncStatusDecoded
        let failedStatusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failedStatusDetails)
        failedStatusDetails = failedStatusDetailsDecoded
        let edgeConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.EdgeConfig.self, forKey: .edgeConfig)
        edgeConfig = edgeConfigDecoded
    }
}

extension DescribeImageGenerationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension DescribeImageGenerationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeImageGenerationConfiguration"
    }
}

public struct DescribeImageGenerationConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Kinesis video stream from which to retrieve the image generation configuration. You must specify either the StreamName or the StreamARN.
    public var streamARN: Swift.String?
    /// The name of the stream from which to retrieve the image generation configuration. You must specify either the StreamName or the StreamARN.
    public var streamName: Swift.String?

    public init (
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct DescribeImageGenerationConfigurationInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
}

extension DescribeImageGenerationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

extension DescribeImageGenerationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeImageGenerationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeImageGenerationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeImageGenerationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeImageGenerationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.imageGenerationConfiguration = output.imageGenerationConfiguration
        } else {
            self.imageGenerationConfiguration = nil
        }
    }
}

public struct DescribeImageGenerationConfigurationOutputResponse: Swift.Equatable {
    /// The structure that contains the information required for the Kinesis video stream (KVS) images delivery. If this structure is null, the configuration will be deleted from the stream.
    public var imageGenerationConfiguration: KinesisVideoClientTypes.ImageGenerationConfiguration?

    public init (
        imageGenerationConfiguration: KinesisVideoClientTypes.ImageGenerationConfiguration? = nil
    )
    {
        self.imageGenerationConfiguration = imageGenerationConfiguration
    }
}

struct DescribeImageGenerationConfigurationOutputResponseBody: Swift.Equatable {
    let imageGenerationConfiguration: KinesisVideoClientTypes.ImageGenerationConfiguration?
}

extension DescribeImageGenerationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageGenerationConfiguration = "ImageGenerationConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageGenerationConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ImageGenerationConfiguration.self, forKey: .imageGenerationConfiguration)
        imageGenerationConfiguration = imageGenerationConfigurationDecoded
    }
}

extension DescribeMappedResourceConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension DescribeMappedResourceConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeMappedResourceConfiguration"
    }
}

public struct DescribeMappedResourceConfigurationInput: Swift.Equatable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// The token to provide in your next request, to get another batch of results.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the stream.
    public var streamARN: Swift.String?
    /// The name of the stream.
    public var streamName: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct DescribeMappedResourceConfigurationInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeMappedResourceConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMappedResourceConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMappedResourceConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeMappedResourceConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMappedResourceConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeMappedResourceConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mappedResourceConfigurationList = output.mappedResourceConfigurationList
            self.nextToken = output.nextToken
        } else {
            self.mappedResourceConfigurationList = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeMappedResourceConfigurationOutputResponse: Swift.Equatable {
    /// A structure that encapsulates, or contains, the media storage configuration properties.
    public var mappedResourceConfigurationList: [KinesisVideoClientTypes.MappedResourceConfigurationListItem]?
    /// The token that was used in the NextTokenrequest to fetch the next set of results.
    public var nextToken: Swift.String?

    public init (
        mappedResourceConfigurationList: [KinesisVideoClientTypes.MappedResourceConfigurationListItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.mappedResourceConfigurationList = mappedResourceConfigurationList
        self.nextToken = nextToken
    }
}

struct DescribeMappedResourceConfigurationOutputResponseBody: Swift.Equatable {
    let mappedResourceConfigurationList: [KinesisVideoClientTypes.MappedResourceConfigurationListItem]?
    let nextToken: Swift.String?
}

extension DescribeMappedResourceConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mappedResourceConfigurationList = "MappedResourceConfigurationList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mappedResourceConfigurationListContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.MappedResourceConfigurationListItem?].self, forKey: .mappedResourceConfigurationList)
        var mappedResourceConfigurationListDecoded0:[KinesisVideoClientTypes.MappedResourceConfigurationListItem]? = nil
        if let mappedResourceConfigurationListContainer = mappedResourceConfigurationListContainer {
            mappedResourceConfigurationListDecoded0 = [KinesisVideoClientTypes.MappedResourceConfigurationListItem]()
            for structure0 in mappedResourceConfigurationListContainer {
                if let structure0 = structure0 {
                    mappedResourceConfigurationListDecoded0?.append(structure0)
                }
            }
        }
        mappedResourceConfigurationList = mappedResourceConfigurationListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeMediaStorageConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case channelName = "ChannelName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = self.channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
    }
}

extension DescribeMediaStorageConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeMediaStorageConfiguration"
    }
}

public struct DescribeMediaStorageConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the channel.
    public var channelARN: Swift.String?
    /// The name of the channel.
    public var channelName: Swift.String?

    public init (
        channelARN: Swift.String? = nil,
        channelName: Swift.String? = nil
    )
    {
        self.channelARN = channelARN
        self.channelName = channelName
    }
}

struct DescribeMediaStorageConfigurationInputBody: Swift.Equatable {
    let channelName: Swift.String?
    let channelARN: Swift.String?
}

extension DescribeMediaStorageConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case channelName = "ChannelName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
    }
}

extension DescribeMediaStorageConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMediaStorageConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeMediaStorageConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMediaStorageConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeMediaStorageConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.mediaStorageConfiguration = output.mediaStorageConfiguration
        } else {
            self.mediaStorageConfiguration = nil
        }
    }
}

public struct DescribeMediaStorageConfigurationOutputResponse: Swift.Equatable {
    /// A structure that encapsulates, or contains, the media storage configuration properties.
    public var mediaStorageConfiguration: KinesisVideoClientTypes.MediaStorageConfiguration?

    public init (
        mediaStorageConfiguration: KinesisVideoClientTypes.MediaStorageConfiguration? = nil
    )
    {
        self.mediaStorageConfiguration = mediaStorageConfiguration
    }
}

struct DescribeMediaStorageConfigurationOutputResponseBody: Swift.Equatable {
    let mediaStorageConfiguration: KinesisVideoClientTypes.MediaStorageConfiguration?
}

extension DescribeMediaStorageConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaStorageConfiguration = "MediaStorageConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaStorageConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.MediaStorageConfiguration.self, forKey: .mediaStorageConfiguration)
        mediaStorageConfiguration = mediaStorageConfigurationDecoded
    }
}

extension DescribeNotificationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension DescribeNotificationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeNotificationConfiguration"
    }
}

public struct DescribeNotificationConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the Kinesis video stream from where you want to retrieve the notification configuration. You must specify either the StreamName or the StreamARN.
    public var streamARN: Swift.String?
    /// The name of the stream from which to retrieve the notification configuration. You must specify either the StreamName or the StreamARN.
    public var streamName: Swift.String?

    public init (
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct DescribeNotificationConfigurationInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
}

extension DescribeNotificationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

extension DescribeNotificationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeNotificationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeNotificationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNotificationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeNotificationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.notificationConfiguration = output.notificationConfiguration
        } else {
            self.notificationConfiguration = nil
        }
    }
}

public struct DescribeNotificationConfigurationOutputResponse: Swift.Equatable {
    /// The structure that contains the information required for notifications. If the structure is null, the configuration will be deleted from the stream.
    public var notificationConfiguration: KinesisVideoClientTypes.NotificationConfiguration?

    public init (
        notificationConfiguration: KinesisVideoClientTypes.NotificationConfiguration? = nil
    )
    {
        self.notificationConfiguration = notificationConfiguration
    }
}

struct DescribeNotificationConfigurationOutputResponseBody: Swift.Equatable {
    let notificationConfiguration: KinesisVideoClientTypes.NotificationConfiguration?
}

extension DescribeNotificationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationConfiguration = "NotificationConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
    }
}

extension DescribeSignalingChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case channelName = "ChannelName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = self.channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
    }
}

extension DescribeSignalingChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeSignalingChannel"
    }
}

public struct DescribeSignalingChannelInput: Swift.Equatable {
    /// The ARN of the signaling channel that you want to describe.
    public var channelARN: Swift.String?
    /// The name of the signaling channel that you want to describe.
    public var channelName: Swift.String?

    public init (
        channelARN: Swift.String? = nil,
        channelName: Swift.String? = nil
    )
    {
        self.channelARN = channelARN
        self.channelName = channelName
    }
}

struct DescribeSignalingChannelInputBody: Swift.Equatable {
    let channelName: Swift.String?
    let channelARN: Swift.String?
}

extension DescribeSignalingChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case channelName = "ChannelName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
    }
}

extension DescribeSignalingChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSignalingChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSignalingChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSignalingChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSignalingChannelOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelInfo = output.channelInfo
        } else {
            self.channelInfo = nil
        }
    }
}

public struct DescribeSignalingChannelOutputResponse: Swift.Equatable {
    /// A structure that encapsulates the specified signaling channel's metadata and properties.
    public var channelInfo: KinesisVideoClientTypes.ChannelInfo?

    public init (
        channelInfo: KinesisVideoClientTypes.ChannelInfo? = nil
    )
    {
        self.channelInfo = channelInfo
    }
}

struct DescribeSignalingChannelOutputResponseBody: Swift.Equatable {
    let channelInfo: KinesisVideoClientTypes.ChannelInfo?
}

extension DescribeSignalingChannelOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelInfo = "ChannelInfo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelInfoDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ChannelInfo.self, forKey: .channelInfo)
        channelInfo = channelInfoDecoded
    }
}

extension DescribeStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension DescribeStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/describeStream"
    }
}

public struct DescribeStreamInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the stream.
    public var streamARN: Swift.String?
    /// The name of the stream.
    public var streamName: Swift.String?

    public init (
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct DescribeStreamInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
}

extension DescribeStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
    }
}

extension DescribeStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeStreamOutputError: Swift.Error, Swift.Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.streamInfo = output.streamInfo
        } else {
            self.streamInfo = nil
        }
    }
}

public struct DescribeStreamOutputResponse: Swift.Equatable {
    /// An object that describes the stream.
    public var streamInfo: KinesisVideoClientTypes.StreamInfo?

    public init (
        streamInfo: KinesisVideoClientTypes.StreamInfo? = nil
    )
    {
        self.streamInfo = streamInfo
    }
}

struct DescribeStreamOutputResponseBody: Swift.Equatable {
    let streamInfo: KinesisVideoClientTypes.StreamInfo?
}

extension DescribeStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamInfo = "StreamInfo"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamInfoDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.StreamInfo.self, forKey: .streamInfo)
        streamInfo = streamInfoDecoded
    }
}

extension DeviceStreamLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeviceStreamLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Not implemented.
public struct DeviceStreamLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DeviceStreamLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DeviceStreamLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisVideoClientTypes.EdgeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionConfig = "DeletionConfig"
        case hubDeviceArn = "HubDeviceArn"
        case recorderConfig = "RecorderConfig"
        case uploaderConfig = "UploaderConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionConfig = self.deletionConfig {
            try encodeContainer.encode(deletionConfig, forKey: .deletionConfig)
        }
        if let hubDeviceArn = self.hubDeviceArn {
            try encodeContainer.encode(hubDeviceArn, forKey: .hubDeviceArn)
        }
        if let recorderConfig = self.recorderConfig {
            try encodeContainer.encode(recorderConfig, forKey: .recorderConfig)
        }
        if let uploaderConfig = self.uploaderConfig {
            try encodeContainer.encode(uploaderConfig, forKey: .uploaderConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hubDeviceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hubDeviceArn)
        hubDeviceArn = hubDeviceArnDecoded
        let recorderConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.RecorderConfig.self, forKey: .recorderConfig)
        recorderConfig = recorderConfigDecoded
        let uploaderConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.UploaderConfig.self, forKey: .uploaderConfig)
        uploaderConfig = uploaderConfigDecoded
        let deletionConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.DeletionConfig.self, forKey: .deletionConfig)
        deletionConfig = deletionConfigDecoded
    }
}

extension KinesisVideoClientTypes {
    /// A description of the stream's edge configuration that will be used to sync with the Edge Agent IoT Greengrass component. The Edge Agent component will run on an IoT Hub Device setup at your premise.
    public struct EdgeConfig: Swift.Equatable {
        /// The deletion configuration is made up of the retention time (EdgeRetentionInHours) and local size configuration (LocalSizeConfig) details that are used to make the deletion.
        public var deletionConfig: KinesisVideoClientTypes.DeletionConfig?
        /// The "Internet of Things (IoT) Thing" Arn of the stream.
        /// This member is required.
        public var hubDeviceArn: Swift.String?
        /// The recorder configuration consists of the local MediaSourceConfig details, that are used as credentials to access the local media files streamed on the camera.
        /// This member is required.
        public var recorderConfig: KinesisVideoClientTypes.RecorderConfig?
        /// The uploader configuration contains the ScheduleExpression details that are used to schedule upload jobs for the recorded media files from the Edge Agent to a Kinesis Video Stream.
        public var uploaderConfig: KinesisVideoClientTypes.UploaderConfig?

        public init (
            deletionConfig: KinesisVideoClientTypes.DeletionConfig? = nil,
            hubDeviceArn: Swift.String? = nil,
            recorderConfig: KinesisVideoClientTypes.RecorderConfig? = nil,
            uploaderConfig: KinesisVideoClientTypes.UploaderConfig? = nil
        )
        {
            self.deletionConfig = deletionConfig
            self.hubDeviceArn = hubDeviceArn
            self.recorderConfig = recorderConfig
            self.uploaderConfig = uploaderConfig
        }
    }

}

extension KinesisVideoClientTypes {
    public enum Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jpeg
        case png
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .jpeg,
                .png,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jpeg: return "JPEG"
            case .png: return "PNG"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
        }
    }
}

extension KinesisVideoClientTypes {
    public enum FormatConfigKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case jpegquality
        case sdkUnknown(Swift.String)

        public static var allCases: [FormatConfigKey] {
            return [
                .jpegquality,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .jpegquality: return "JPEGQuality"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FormatConfigKey(rawValue: rawValue) ?? FormatConfigKey.sdkUnknown(rawValue)
        }
    }
}

extension GetDataEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiName = "APIName"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiName = self.apiName {
            try encodeContainer.encode(apiName.rawValue, forKey: .apiName)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension GetDataEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getDataEndpoint"
    }
}

public struct GetDataEndpointInput: Swift.Equatable {
    /// The name of the API action for which to get an endpoint.
    /// This member is required.
    public var apiName: KinesisVideoClientTypes.APIName?
    /// The Amazon Resource Name (ARN) of the stream that you want to get the endpoint for. You must specify either this parameter or a StreamName in the request.
    public var streamARN: Swift.String?
    /// The name of the stream that you want to get the endpoint for. You must specify either this parameter or a StreamARN in the request.
    public var streamName: Swift.String?

    public init (
        apiName: KinesisVideoClientTypes.APIName? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.apiName = apiName
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct GetDataEndpointInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let apiName: KinesisVideoClientTypes.APIName?
}

extension GetDataEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiName = "APIName"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let apiNameDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.APIName.self, forKey: .apiName)
        apiName = apiNameDecoded
    }
}

extension GetDataEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDataEndpointOutputError: Swift.Error, Swift.Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDataEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataEndpoint = output.dataEndpoint
        } else {
            self.dataEndpoint = nil
        }
    }
}

public struct GetDataEndpointOutputResponse: Swift.Equatable {
    /// The endpoint value. To read data from the stream or to write data to it, specify this endpoint in your application.
    public var dataEndpoint: Swift.String?

    public init (
        dataEndpoint: Swift.String? = nil
    )
    {
        self.dataEndpoint = dataEndpoint
    }
}

struct GetDataEndpointOutputResponseBody: Swift.Equatable {
    let dataEndpoint: Swift.String?
}

extension GetDataEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataEndpoint = "DataEndpoint"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataEndpoint)
        dataEndpoint = dataEndpointDecoded
    }
}

extension GetSignalingChannelEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case singleMasterChannelEndpointConfiguration = "SingleMasterChannelEndpointConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = self.channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let singleMasterChannelEndpointConfiguration = self.singleMasterChannelEndpointConfiguration {
            try encodeContainer.encode(singleMasterChannelEndpointConfiguration, forKey: .singleMasterChannelEndpointConfiguration)
        }
    }
}

extension GetSignalingChannelEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/getSignalingChannelEndpoint"
    }
}

public struct GetSignalingChannelEndpointInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the signalling channel for which you want to get an endpoint.
    /// This member is required.
    public var channelARN: Swift.String?
    /// A structure containing the endpoint configuration for the SINGLE_MASTER channel type.
    public var singleMasterChannelEndpointConfiguration: KinesisVideoClientTypes.SingleMasterChannelEndpointConfiguration?

    public init (
        channelARN: Swift.String? = nil,
        singleMasterChannelEndpointConfiguration: KinesisVideoClientTypes.SingleMasterChannelEndpointConfiguration? = nil
    )
    {
        self.channelARN = channelARN
        self.singleMasterChannelEndpointConfiguration = singleMasterChannelEndpointConfiguration
    }
}

struct GetSignalingChannelEndpointInputBody: Swift.Equatable {
    let channelARN: Swift.String?
    let singleMasterChannelEndpointConfiguration: KinesisVideoClientTypes.SingleMasterChannelEndpointConfiguration?
}

extension GetSignalingChannelEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case singleMasterChannelEndpointConfiguration = "SingleMasterChannelEndpointConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
        let singleMasterChannelEndpointConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.SingleMasterChannelEndpointConfiguration.self, forKey: .singleMasterChannelEndpointConfiguration)
        singleMasterChannelEndpointConfiguration = singleMasterChannelEndpointConfigurationDecoded
    }
}

extension GetSignalingChannelEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSignalingChannelEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSignalingChannelEndpointOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSignalingChannelEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSignalingChannelEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.resourceEndpointList = output.resourceEndpointList
        } else {
            self.resourceEndpointList = nil
        }
    }
}

public struct GetSignalingChannelEndpointOutputResponse: Swift.Equatable {
    /// A list of endpoints for the specified signaling channel.
    public var resourceEndpointList: [KinesisVideoClientTypes.ResourceEndpointListItem]?

    public init (
        resourceEndpointList: [KinesisVideoClientTypes.ResourceEndpointListItem]? = nil
    )
    {
        self.resourceEndpointList = resourceEndpointList
    }
}

struct GetSignalingChannelEndpointOutputResponseBody: Swift.Equatable {
    let resourceEndpointList: [KinesisVideoClientTypes.ResourceEndpointListItem]?
}

extension GetSignalingChannelEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceEndpointList = "ResourceEndpointList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceEndpointListContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.ResourceEndpointListItem?].self, forKey: .resourceEndpointList)
        var resourceEndpointListDecoded0:[KinesisVideoClientTypes.ResourceEndpointListItem]? = nil
        if let resourceEndpointListContainer = resourceEndpointListContainer {
            resourceEndpointListDecoded0 = [KinesisVideoClientTypes.ResourceEndpointListItem]()
            for structure0 in resourceEndpointListContainer {
                if let structure0 = structure0 {
                    resourceEndpointListDecoded0?.append(structure0)
                }
            }
        }
        resourceEndpointList = resourceEndpointListDecoded0
    }
}

extension KinesisVideoClientTypes.ImageGenerationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case format = "Format"
        case formatConfig = "FormatConfig"
        case heightPixels = "HeightPixels"
        case imageSelectorType = "ImageSelectorType"
        case samplingInterval = "SamplingInterval"
        case status = "Status"
        case widthPixels = "WidthPixels"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfig = self.destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let formatConfig = formatConfig {
            var formatConfigContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .formatConfig)
            for (dictKey0, formatConfig0) in formatConfig {
                try formatConfigContainer.encode(formatConfig0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let heightPixels = self.heightPixels {
            try encodeContainer.encode(heightPixels, forKey: .heightPixels)
        }
        if let imageSelectorType = self.imageSelectorType {
            try encodeContainer.encode(imageSelectorType.rawValue, forKey: .imageSelectorType)
        }
        if let samplingInterval = self.samplingInterval {
            try encodeContainer.encode(samplingInterval, forKey: .samplingInterval)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let widthPixels = self.widthPixels {
            try encodeContainer.encode(widthPixels, forKey: .widthPixels)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let imageSelectorTypeDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ImageSelectorType.self, forKey: .imageSelectorType)
        imageSelectorType = imageSelectorTypeDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ImageGenerationDestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
        let samplingIntervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .samplingInterval)
        samplingInterval = samplingIntervalDecoded
        let formatDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let formatConfigContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .formatConfig)
        var formatConfigDecoded0: [Swift.String:Swift.String]? = nil
        if let formatConfigContainer = formatConfigContainer {
            formatConfigDecoded0 = [Swift.String:Swift.String]()
            for (key0, formatconfigvalue0) in formatConfigContainer {
                if let formatconfigvalue0 = formatconfigvalue0 {
                    formatConfigDecoded0?[key0] = formatconfigvalue0
                }
            }
        }
        formatConfig = formatConfigDecoded0
        let widthPixelsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .widthPixels)
        widthPixels = widthPixelsDecoded
        let heightPixelsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .heightPixels)
        heightPixels = heightPixelsDecoded
    }
}

extension KinesisVideoClientTypes {
    /// The structure that contains the information required for the KVS images delivery. If null, the configuration will be deleted from the stream.
    public struct ImageGenerationConfiguration: Swift.Equatable {
        /// The structure that contains the information required to deliver images to a customer.
        /// This member is required.
        public var destinationConfig: KinesisVideoClientTypes.ImageGenerationDestinationConfig?
        /// The accepted image format.
        /// This member is required.
        public var format: KinesisVideoClientTypes.Format?
        /// The list of a key-value pair structure that contains extra parameters that can be applied when the image is generated. The FormatConfig key is the JPEGQuality, which indicates the JPEG quality key to be used to generate the image. The FormatConfig value accepts ints from 1 to 100. If the value is 1, the image will be generated with less quality and the best compression. If the value is 100, the image will be generated with the best quality and less compression. If no value is provided, the default value of the JPEGQuality key will be set to 80.
        public var formatConfig: [Swift.String:Swift.String]?
        /// The height of the output image that is used in conjunction with the WidthPixels parameter. When both HeightPixels and WidthPixels parameters are provided, the image will be stretched to fit the specified aspect ratio. If only the HeightPixels parameter is provided, its original aspect ratio will be used to calculate the WidthPixels ratio. If neither parameter is provided, the original image size will be returned.
        public var heightPixels: Swift.Int?
        /// The origin of the Server or Producer timestamps to use to generate the images.
        /// This member is required.
        public var imageSelectorType: KinesisVideoClientTypes.ImageSelectorType?
        /// The time interval in milliseconds (ms) at which the images need to be generated from the stream. The minimum value that can be provided is 33 ms, because a camera that generates content at 30 FPS would create a frame every 33.3 ms. If the timestamp range is less than the sampling interval, the Image from the StartTimestamp will be returned if available.
        /// This member is required.
        public var samplingInterval: Swift.Int?
        /// Indicates whether the ContinuousImageGenerationConfigurations API is enabled or disabled.
        /// This member is required.
        public var status: KinesisVideoClientTypes.ConfigurationStatus?
        /// The width of the output image that is used in conjunction with the HeightPixels parameter. When both WidthPixels and HeightPixels parameters are provided, the image will be stretched to fit the specified aspect ratio. If only the WidthPixels parameter is provided, its original aspect ratio will be used to calculate the HeightPixels ratio. If neither parameter is provided, the original image size will be returned.
        public var widthPixels: Swift.Int?

        public init (
            destinationConfig: KinesisVideoClientTypes.ImageGenerationDestinationConfig? = nil,
            format: KinesisVideoClientTypes.Format? = nil,
            formatConfig: [Swift.String:Swift.String]? = nil,
            heightPixels: Swift.Int? = nil,
            imageSelectorType: KinesisVideoClientTypes.ImageSelectorType? = nil,
            samplingInterval: Swift.Int? = nil,
            status: KinesisVideoClientTypes.ConfigurationStatus? = nil,
            widthPixels: Swift.Int? = nil
        )
        {
            self.destinationConfig = destinationConfig
            self.format = format
            self.formatConfig = formatConfig
            self.heightPixels = heightPixels
            self.imageSelectorType = imageSelectorType
            self.samplingInterval = samplingInterval
            self.status = status
            self.widthPixels = widthPixels
        }
    }

}

extension KinesisVideoClientTypes.ImageGenerationDestinationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationRegion = "DestinationRegion"
        case uri = "Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationRegion = self.destinationRegion {
            try encodeContainer.encode(destinationRegion, forKey: .destinationRegion)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let destinationRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationRegion)
        destinationRegion = destinationRegionDecoded
    }
}

extension KinesisVideoClientTypes {
    /// The structure that contains the information required to deliver images to a customer.
    public struct ImageGenerationDestinationConfig: Swift.Equatable {
        /// The AWS Region of the S3 bucket where images will be delivered. This DestinationRegion must match the Region where the stream is located.
        /// This member is required.
        public var destinationRegion: Swift.String?
        /// The Uniform Resource Identifier (URI) that identifies where the images will be delivered.
        /// This member is required.
        public var uri: Swift.String?

        public init (
            destinationRegion: Swift.String? = nil,
            uri: Swift.String? = nil
        )
        {
            self.destinationRegion = destinationRegion
            self.uri = uri
        }
    }

}

extension KinesisVideoClientTypes {
    public enum ImageSelectorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case producerTimestamp
        case serverTimestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageSelectorType] {
            return [
                .producerTimestamp,
                .serverTimestamp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .producerTimestamp: return "PRODUCER_TIMESTAMP"
            case .serverTimestamp: return "SERVER_TIMESTAMP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageSelectorType(rawValue: rawValue) ?? ImageSelectorType.sdkUnknown(rawValue)
        }
    }
}

extension InvalidArgumentException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidArgumentExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The value for this input parameter is invalid.
public struct InvalidArgumentException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidArgumentExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidArgumentExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidDeviceException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidDeviceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Not implemented.
public struct InvalidDeviceException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidDeviceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidDeviceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidResourceFormatException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidResourceFormatExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The format of the StreamARN is invalid.
public struct InvalidResourceFormatException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidResourceFormatExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidResourceFormatExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListSignalingChannelsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelNameCondition = "ChannelNameCondition"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelNameCondition = self.channelNameCondition {
            try encodeContainer.encode(channelNameCondition, forKey: .channelNameCondition)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSignalingChannelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listSignalingChannels"
    }
}

public struct ListSignalingChannelsInput: Swift.Equatable {
    /// Optional: Returns only the channels that satisfy a specific condition.
    public var channelNameCondition: KinesisVideoClientTypes.ChannelNameCondition?
    /// The maximum number of channels to return in the response. The default is 500.
    public var maxResults: Swift.Int?
    /// If you specify this parameter, when the result of a ListSignalingChannels operation is truncated, the call returns the NextToken in the response. To get another batch of channels, provide this token in your next request.
    public var nextToken: Swift.String?

    public init (
        channelNameCondition: KinesisVideoClientTypes.ChannelNameCondition? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelNameCondition = channelNameCondition
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSignalingChannelsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let channelNameCondition: KinesisVideoClientTypes.ChannelNameCondition?
}

extension ListSignalingChannelsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelNameCondition = "ChannelNameCondition"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let channelNameConditionDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ChannelNameCondition.self, forKey: .channelNameCondition)
        channelNameCondition = channelNameConditionDecoded
    }
}

extension ListSignalingChannelsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSignalingChannelsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSignalingChannelsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSignalingChannelsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSignalingChannelsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelInfoList = output.channelInfoList
            self.nextToken = output.nextToken
        } else {
            self.channelInfoList = nil
            self.nextToken = nil
        }
    }
}

public struct ListSignalingChannelsOutputResponse: Swift.Equatable {
    /// An array of ChannelInfo objects.
    public var channelInfoList: [KinesisVideoClientTypes.ChannelInfo]?
    /// If the response is truncated, the call returns this element with a token. To get the next batch of streams, use this token in your next request.
    public var nextToken: Swift.String?

    public init (
        channelInfoList: [KinesisVideoClientTypes.ChannelInfo]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.channelInfoList = channelInfoList
        self.nextToken = nextToken
    }
}

struct ListSignalingChannelsOutputResponseBody: Swift.Equatable {
    let channelInfoList: [KinesisVideoClientTypes.ChannelInfo]?
    let nextToken: Swift.String?
}

extension ListSignalingChannelsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelInfoList = "ChannelInfoList"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelInfoListContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.ChannelInfo?].self, forKey: .channelInfoList)
        var channelInfoListDecoded0:[KinesisVideoClientTypes.ChannelInfo]? = nil
        if let channelInfoListContainer = channelInfoListContainer {
            channelInfoListDecoded0 = [KinesisVideoClientTypes.ChannelInfo]()
            for structure0 in channelInfoListContainer {
                if let structure0 = structure0 {
                    channelInfoListDecoded0?.append(structure0)
                }
            }
        }
        channelInfoList = channelInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListStreamsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case streamNameCondition = "StreamNameCondition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let streamNameCondition = self.streamNameCondition {
            try encodeContainer.encode(streamNameCondition, forKey: .streamNameCondition)
        }
    }
}

extension ListStreamsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listStreams"
    }
}

public struct ListStreamsInput: Swift.Equatable {
    /// The maximum number of streams to return in the response. The default is 10,000.
    public var maxResults: Swift.Int?
    /// If you specify this parameter, when the result of a ListStreams operation is truncated, the call returns the NextToken in the response. To get another batch of streams, provide this token in your next request.
    public var nextToken: Swift.String?
    /// Optional: Returns only streams that satisfy a specific condition. Currently, you can specify only the prefix of a stream name as a condition.
    public var streamNameCondition: KinesisVideoClientTypes.StreamNameCondition?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        streamNameCondition: KinesisVideoClientTypes.StreamNameCondition? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.streamNameCondition = streamNameCondition
    }
}

struct ListStreamsInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let streamNameCondition: KinesisVideoClientTypes.StreamNameCondition?
}

extension ListStreamsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case streamNameCondition = "StreamNameCondition"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let streamNameConditionDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.StreamNameCondition.self, forKey: .streamNameCondition)
        streamNameCondition = streamNameConditionDecoded
    }
}

extension ListStreamsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListStreamsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListStreamsOutputError: Swift.Error, Swift.Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListStreamsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListStreamsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.streamInfoList = output.streamInfoList
        } else {
            self.nextToken = nil
            self.streamInfoList = nil
        }
    }
}

public struct ListStreamsOutputResponse: Swift.Equatable {
    /// If the response is truncated, the call returns this element with a token. To get the next batch of streams, use this token in your next request.
    public var nextToken: Swift.String?
    /// An array of StreamInfo objects.
    public var streamInfoList: [KinesisVideoClientTypes.StreamInfo]?

    public init (
        nextToken: Swift.String? = nil,
        streamInfoList: [KinesisVideoClientTypes.StreamInfo]? = nil
    )
    {
        self.nextToken = nextToken
        self.streamInfoList = streamInfoList
    }
}

struct ListStreamsOutputResponseBody: Swift.Equatable {
    let streamInfoList: [KinesisVideoClientTypes.StreamInfo]?
    let nextToken: Swift.String?
}

extension ListStreamsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case streamInfoList = "StreamInfoList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamInfoListContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.StreamInfo?].self, forKey: .streamInfoList)
        var streamInfoListDecoded0:[KinesisVideoClientTypes.StreamInfo]? = nil
        if let streamInfoListContainer = streamInfoListContainer {
            streamInfoListDecoded0 = [KinesisVideoClientTypes.StreamInfo]()
            for structure0 in streamInfoListContainer {
                if let structure0 = structure0 {
                    streamInfoListDecoded0?.append(structure0)
                }
            }
        }
        streamInfoList = streamInfoListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListTagsForResource"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// If you specify this parameter and the result of a ListTagsForResource call is truncated, the response includes a token that you can use in the next request to fetch the next batch of tags.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the signaling channel for which you want to list tags.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        resourceARN: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let resourceARN: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case resourceARN = "ResourceARN"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// If you specify this parameter and the result of a ListTagsForResource call is truncated, the response includes a token that you can use in the next request to fetch the next set of tags.
    public var nextToken: Swift.String?
    /// A map of tag keys and values associated with the specified signaling channel.
    public var tags: [Swift.String:Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListTagsForStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension ListTagsForStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/listTagsForStream"
    }
}

public struct ListTagsForStreamInput: Swift.Equatable {
    /// If you specify this parameter and the result of a ListTagsForStream call is truncated, the response includes a token that you can use in the next request to fetch the next batch of tags.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the stream that you want to list tags for.
    public var streamARN: Swift.String?
    /// The name of the stream that you want to list tags for.
    public var streamName: Swift.String?

    public init (
        nextToken: Swift.String? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct ListTagsForStreamInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let streamARN: Swift.String?
    let streamName: Swift.String?
}

extension ListTagsForStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
    }
}

extension ListTagsForStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceFormatException" : self = .invalidResourceFormatException(try InvalidResourceFormatException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForStreamOutputError: Swift.Error, Swift.Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidResourceFormatException(InvalidResourceFormatException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForStreamOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForStreamOutputResponse: Swift.Equatable {
    /// If you specify this parameter and the result of a ListTags call is truncated, the response includes a token that you can use in the next request to fetch the next set of tags.
    public var nextToken: Swift.String?
    /// A map of tag keys and values associated with the specified stream.
    public var tags: [Swift.String:Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForStreamOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForStreamOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension KinesisVideoClientTypes.LocalSizeConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxLocalMediaSizeInMB = "MaxLocalMediaSizeInMB"
        case strategyOnFullSize = "StrategyOnFullSize"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxLocalMediaSizeInMB = self.maxLocalMediaSizeInMB {
            try encodeContainer.encode(maxLocalMediaSizeInMB, forKey: .maxLocalMediaSizeInMB)
        }
        if let strategyOnFullSize = self.strategyOnFullSize {
            try encodeContainer.encode(strategyOnFullSize.rawValue, forKey: .strategyOnFullSize)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxLocalMediaSizeInMBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxLocalMediaSizeInMB)
        maxLocalMediaSizeInMB = maxLocalMediaSizeInMBDecoded
        let strategyOnFullSizeDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.StrategyOnFullSize.self, forKey: .strategyOnFullSize)
        strategyOnFullSize = strategyOnFullSizeDecoded
    }
}

extension KinesisVideoClientTypes {
    /// The configuration details that include the maximum size of the media (MaxLocalMediaSizeInMB) that you want to store for a stream on the Edge Agent, as well as the strategy that should be used (StrategyOnFullSize) when a stream's maximum size has been reached.
    public struct LocalSizeConfig: Swift.Equatable {
        /// The overall maximum size of the media that you want to store for a stream on the Edge Agent.
        public var maxLocalMediaSizeInMB: Swift.Int?
        /// The strategy to perform when a streams MaxLocalMediaSizeInMB limit is reached.
        public var strategyOnFullSize: KinesisVideoClientTypes.StrategyOnFullSize?

        public init (
            maxLocalMediaSizeInMB: Swift.Int? = nil,
            strategyOnFullSize: KinesisVideoClientTypes.StrategyOnFullSize? = nil
        )
        {
            self.maxLocalMediaSizeInMB = maxLocalMediaSizeInMB
            self.strategyOnFullSize = strategyOnFullSize
        }
    }

}

extension KinesisVideoClientTypes.MappedResourceConfigurationListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "ARN"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension KinesisVideoClientTypes {
    /// A structure that encapsulates, or contains, the media storage configuration properties.
    public struct MappedResourceConfigurationListItem: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the Kinesis Video Stream resource, associated with the stream.
        public var arn: Swift.String?
        /// The type of the associated resource for the kinesis video stream.
        public var type: Swift.String?

        public init (
            arn: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.type = type
        }
    }

}

extension KinesisVideoClientTypes.MediaSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaUriSecretArn = "MediaUriSecretArn"
        case mediaUriType = "MediaUriType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaUriSecretArn = self.mediaUriSecretArn {
            try encodeContainer.encode(mediaUriSecretArn, forKey: .mediaUriSecretArn)
        }
        if let mediaUriType = self.mediaUriType {
            try encodeContainer.encode(mediaUriType.rawValue, forKey: .mediaUriType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaUriSecretArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaUriSecretArn)
        mediaUriSecretArn = mediaUriSecretArnDecoded
        let mediaUriTypeDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.MediaUriType.self, forKey: .mediaUriType)
        mediaUriType = mediaUriTypeDecoded
    }
}

extension KinesisVideoClientTypes.MediaSourceConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "MediaSourceConfig(mediaUriType: \(Swift.String(describing: mediaUriType)), mediaUriSecretArn: \"CONTENT_REDACTED\")"}
}

extension KinesisVideoClientTypes {
    /// The configuration details that consist of the credentials required (MediaUriSecretArn and MediaUriType) to access the media files that are streamed to the camera.
    public struct MediaSourceConfig: Swift.Equatable {
        /// The AWS Secrets Manager ARN for the username and password of the camera, or a local media file location.
        /// This member is required.
        public var mediaUriSecretArn: Swift.String?
        /// The Uniform Resource Identifier (URI) type. The FILE_URI value can be used to stream local media files. Preview only supports the RTSP_URI media source URI format .
        /// This member is required.
        public var mediaUriType: KinesisVideoClientTypes.MediaUriType?

        public init (
            mediaUriSecretArn: Swift.String? = nil,
            mediaUriType: KinesisVideoClientTypes.MediaUriType? = nil
        )
        {
            self.mediaUriSecretArn = mediaUriSecretArn
            self.mediaUriType = mediaUriType
        }
    }

}

extension KinesisVideoClientTypes.MediaStorageConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case streamARN = "StreamARN"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.MediaStorageConfigurationStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension KinesisVideoClientTypes {
    /// A structure that encapsulates, or contains, the media storage configuration properties.
    public struct MediaStorageConfiguration: Swift.Equatable {
        /// The status of the media storage configuration.
        /// This member is required.
        public var status: KinesisVideoClientTypes.MediaStorageConfigurationStatus?
        /// The Amazon Resource Name (ARN) of the stream
        public var streamARN: Swift.String?

        public init (
            status: KinesisVideoClientTypes.MediaStorageConfigurationStatus? = nil,
            streamARN: Swift.String? = nil
        )
        {
            self.status = status
            self.streamARN = streamARN
        }
    }

}

extension KinesisVideoClientTypes {
    public enum MediaStorageConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaStorageConfigurationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaStorageConfigurationStatus(rawValue: rawValue) ?? MediaStorageConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension KinesisVideoClientTypes {
    public enum MediaUriType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fileUri
        case rtspUri
        case sdkUnknown(Swift.String)

        public static var allCases: [MediaUriType] {
            return [
                .fileUri,
                .rtspUri,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fileUri: return "FILE_URI"
            case .rtspUri: return "RTSP_URI"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MediaUriType(rawValue: rawValue) ?? MediaUriType.sdkUnknown(rawValue)
        }
    }
}

extension NoDataRetentionException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NoDataRetentionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Stream data retention in hours is equal to zero.
public struct NoDataRetentionException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NoDataRetentionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NoDataRetentionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotAuthorizedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotAuthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The caller is not authorized to perform this operation.
public struct NotAuthorizedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotAuthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotAuthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisVideoClientTypes.NotificationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationConfig = "DestinationConfig"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationConfig = self.destinationConfig {
            try encodeContainer.encode(destinationConfig, forKey: .destinationConfig)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let destinationConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.NotificationDestinationConfig.self, forKey: .destinationConfig)
        destinationConfig = destinationConfigDecoded
    }
}

extension KinesisVideoClientTypes {
    /// The structure that contains the notification information for the KVS images delivery. If this parameter is null, the configuration will be deleted from the stream.
    public struct NotificationConfiguration: Swift.Equatable {
        /// The destination information required to deliver a notification to a customer.
        /// This member is required.
        public var destinationConfig: KinesisVideoClientTypes.NotificationDestinationConfig?
        /// Indicates if a notification configuration is enabled or disabled.
        /// This member is required.
        public var status: KinesisVideoClientTypes.ConfigurationStatus?

        public init (
            destinationConfig: KinesisVideoClientTypes.NotificationDestinationConfig? = nil,
            status: KinesisVideoClientTypes.ConfigurationStatus? = nil
        )
        {
            self.destinationConfig = destinationConfig
            self.status = status
        }
    }

}

extension KinesisVideoClientTypes.NotificationDestinationConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case uri = "Uri"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
    }
}

extension KinesisVideoClientTypes {
    /// The structure that contains the information required to deliver a notification to a customer.
    public struct NotificationDestinationConfig: Swift.Equatable {
        /// The Uniform Resource Identifier (URI) that identifies where the images will be delivered.
        /// This member is required.
        public var uri: Swift.String?

        public init (
            uri: Swift.String? = nil
        )
        {
            self.uri = uri
        }
    }

}

extension KinesisVideoClientTypes.RecorderConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mediaSourceConfig = "MediaSourceConfig"
        case scheduleConfig = "ScheduleConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mediaSourceConfig = self.mediaSourceConfig {
            try encodeContainer.encode(mediaSourceConfig, forKey: .mediaSourceConfig)
        }
        if let scheduleConfig = self.scheduleConfig {
            try encodeContainer.encode(scheduleConfig, forKey: .scheduleConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mediaSourceConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.MediaSourceConfig.self, forKey: .mediaSourceConfig)
        mediaSourceConfig = mediaSourceConfigDecoded
        let scheduleConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ScheduleConfig.self, forKey: .scheduleConfig)
        scheduleConfig = scheduleConfigDecoded
    }
}

extension KinesisVideoClientTypes {
    /// The recorder configuration consists of the local MediaSourceConfig details that are used as credentials to accesss the local media files streamed on the camera.
    public struct RecorderConfig: Swift.Equatable {
        /// The configuration details that consist of the credentials required (MediaUriSecretArn and MediaUriType) to access the media files streamed to the camera.
        /// This member is required.
        public var mediaSourceConfig: KinesisVideoClientTypes.MediaSourceConfig?
        /// The configuration that consists of the ScheduleExpression and the DurationInMinutes details that specify the scheduling to record from a camera, or local media file, onto the Edge Agent. If the ScheduleExpression attribute is not provided, then the Edge Agent will always be set to recording mode.
        public var scheduleConfig: KinesisVideoClientTypes.ScheduleConfig?

        public init (
            mediaSourceConfig: KinesisVideoClientTypes.MediaSourceConfig? = nil,
            scheduleConfig: KinesisVideoClientTypes.ScheduleConfig? = nil
        )
        {
            self.mediaSourceConfig = mediaSourceConfig
            self.scheduleConfig = scheduleConfig
        }
    }

}

extension KinesisVideoClientTypes.ResourceEndpointListItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case `protocol` = "Protocol"
        case resourceEndpoint = "ResourceEndpoint"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let resourceEndpoint = self.resourceEndpoint {
            try encodeContainer.encode(resourceEndpoint, forKey: .resourceEndpoint)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ChannelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let resourceEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceEndpoint)
        resourceEndpoint = resourceEndpointDecoded
    }
}

extension KinesisVideoClientTypes {
    /// An object that describes the endpoint of the signaling channel returned by the GetSignalingChannelEndpoint API.
    public struct ResourceEndpointListItem: Swift.Equatable {
        /// The protocol of the signaling channel returned by the GetSignalingChannelEndpoint API.
        public var `protocol`: KinesisVideoClientTypes.ChannelProtocol?
        /// The endpoint of the signaling channel returned by the GetSignalingChannelEndpoint API.
        public var resourceEndpoint: Swift.String?

        public init (
            `protocol`: KinesisVideoClientTypes.ChannelProtocol? = nil,
            resourceEndpoint: Swift.String? = nil
        )
        {
            self.`protocol` = `protocol`
            self.resourceEndpoint = resourceEndpoint
        }
    }

}

extension ResourceInUseException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// When the input StreamARN or ChannelARN in CLOUD_STORAGE_MODE is already mapped to a different Kinesis Video Stream resource, or if the provided input StreamARN or ChannelARN is not in Active status, try one of the following :
///
/// * The DescribeMediaStorageConfiguration API to determine what the stream given channel is mapped to.
///
/// * The DescribeMappedResourceConfiguration API to determine the channel that the given stream is mapped to.
///
/// * The DescribeStream or DescribeSignalingChannel API to determine the status of the resource.
public struct ResourceInUseException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Amazon Kinesis Video Streams can't find the stream that you specified.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisVideoClientTypes.ScheduleConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case durationInSeconds = "DurationInSeconds"
        case scheduleExpression = "ScheduleExpression"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let durationInSeconds = self.durationInSeconds {
            try encodeContainer.encode(durationInSeconds, forKey: .durationInSeconds)
        }
        if let scheduleExpression = self.scheduleExpression {
            try encodeContainer.encode(scheduleExpression, forKey: .scheduleExpression)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scheduleExpression)
        scheduleExpression = scheduleExpressionDecoded
        let durationInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInSeconds)
        durationInSeconds = durationInSecondsDecoded
    }
}

extension KinesisVideoClientTypes {
    /// This API enables you to specify the duration that the camera, or local media file, should record onto the Edge Agent. The ScheduleConfig consists of the ScheduleExpression and the DurationInMinutes attributes. If the ScheduleExpression is not provided, then the Edge Agent will always be set to recording mode.
    public struct ScheduleConfig: Swift.Equatable {
        /// The total duration to record the media. If the ScheduleExpression attribute is provided, then the DurationInSeconds attribute should also be specified.
        /// This member is required.
        public var durationInSeconds: Swift.Int?
        /// The Quartz cron expression that takes care of scheduling jobs to record from the camera, or local media file, onto the Edge Agent. If the ScheduleExpression is not provided for the RecorderConfig, then the Edge Agent will always be set to recording mode. For more information about Quartz, refer to the [ Cron Trigger Tutorial ](http://www.quartz-scheduler.org/documentation/quartz-2.3.0/tutorials/crontrigger.html) page to understand the valid expressions and its use.
        /// This member is required.
        public var scheduleExpression: Swift.String?

        public init (
            durationInSeconds: Swift.Int? = nil,
            scheduleExpression: Swift.String? = nil
        )
        {
            self.durationInSeconds = durationInSeconds
            self.scheduleExpression = scheduleExpression
        }
    }

}

extension KinesisVideoClientTypes.SingleMasterChannelEndpointConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protocols = "Protocols"
        case role = "Role"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let protocols = protocols {
            var protocolsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .protocols)
            for channelprotocol0 in protocols {
                try protocolsContainer.encode(channelprotocol0.rawValue)
            }
        }
        if let role = self.role {
            try encodeContainer.encode(role.rawValue, forKey: .role)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protocolsContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.ChannelProtocol?].self, forKey: .protocols)
        var protocolsDecoded0:[KinesisVideoClientTypes.ChannelProtocol]? = nil
        if let protocolsContainer = protocolsContainer {
            protocolsDecoded0 = [KinesisVideoClientTypes.ChannelProtocol]()
            for enum0 in protocolsContainer {
                if let enum0 = enum0 {
                    protocolsDecoded0?.append(enum0)
                }
            }
        }
        protocols = protocolsDecoded0
        let roleDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ChannelRole.self, forKey: .role)
        role = roleDecoded
    }
}

extension KinesisVideoClientTypes {
    /// An object that contains the endpoint configuration for the SINGLE_MASTER channel type.
    public struct SingleMasterChannelEndpointConfiguration: Swift.Equatable {
        /// This property is used to determine the nature of communication over this SINGLE_MASTER signaling channel. If WSS is specified, this API returns a websocket endpoint. If HTTPS is specified, this API returns an HTTPS endpoint.
        public var protocols: [KinesisVideoClientTypes.ChannelProtocol]?
        /// This property is used to determine messaging permissions in this SINGLE_MASTER signaling channel. If MASTER is specified, this API returns an endpoint that a client can use to receive offers from and send answers to any of the viewers on this signaling channel. If VIEWER is specified, this API returns an endpoint that a client can use only to send offers to another MASTER client on this signaling channel.
        public var role: KinesisVideoClientTypes.ChannelRole?

        public init (
            protocols: [KinesisVideoClientTypes.ChannelProtocol]? = nil,
            role: KinesisVideoClientTypes.ChannelRole? = nil
        )
        {
            self.protocols = protocols
            self.role = role
        }
    }

}

extension KinesisVideoClientTypes.SingleMasterConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageTtlSeconds = "MessageTtlSeconds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageTtlSeconds = self.messageTtlSeconds {
            try encodeContainer.encode(messageTtlSeconds, forKey: .messageTtlSeconds)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageTtlSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .messageTtlSeconds)
        messageTtlSeconds = messageTtlSecondsDecoded
    }
}

extension KinesisVideoClientTypes {
    /// A structure that contains the configuration for the SINGLE_MASTER channel type.
    public struct SingleMasterConfiguration: Swift.Equatable {
        /// The period of time a signaling channel retains undelivered messages before they are discarded.
        public var messageTtlSeconds: Swift.Int?

        public init (
            messageTtlSeconds: Swift.Int? = nil
        )
        {
            self.messageTtlSeconds = messageTtlSeconds
        }
    }

}

extension StartEdgeConfigurationUpdateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case edgeConfig = "EdgeConfig"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let edgeConfig = self.edgeConfig {
            try encodeContainer.encode(edgeConfig, forKey: .edgeConfig)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension StartEdgeConfigurationUpdateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/startEdgeConfigurationUpdate"
    }
}

public struct StartEdgeConfigurationUpdateInput: Swift.Equatable {
    /// The edge configuration details required to invoke the update process.
    /// This member is required.
    public var edgeConfig: KinesisVideoClientTypes.EdgeConfig?
    /// The Amazon Resource Name (ARN) of the stream. Specify either the StreamName or the StreamARN.
    public var streamARN: Swift.String?
    /// The name of the stream whose edge configuration you want to update. Specify either the StreamName or the StreamARN.
    public var streamName: Swift.String?

    public init (
        edgeConfig: KinesisVideoClientTypes.EdgeConfig? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.edgeConfig = edgeConfig
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct StartEdgeConfigurationUpdateInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let edgeConfig: KinesisVideoClientTypes.EdgeConfig?
}

extension StartEdgeConfigurationUpdateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case edgeConfig = "EdgeConfig"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let edgeConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.EdgeConfig.self, forKey: .edgeConfig)
        edgeConfig = edgeConfigDecoded
    }
}

extension StartEdgeConfigurationUpdateOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartEdgeConfigurationUpdateOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoDataRetentionException" : self = .noDataRetentionException(try NoDataRetentionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartEdgeConfigurationUpdateOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case noDataRetentionException(NoDataRetentionException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartEdgeConfigurationUpdateOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartEdgeConfigurationUpdateOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.creationTime = output.creationTime
            self.edgeConfig = output.edgeConfig
            self.failedStatusDetails = output.failedStatusDetails
            self.lastUpdatedTime = output.lastUpdatedTime
            self.streamARN = output.streamARN
            self.streamName = output.streamName
            self.syncStatus = output.syncStatus
        } else {
            self.creationTime = nil
            self.edgeConfig = nil
            self.failedStatusDetails = nil
            self.lastUpdatedTime = nil
            self.streamARN = nil
            self.streamName = nil
            self.syncStatus = nil
        }
    }
}

public struct StartEdgeConfigurationUpdateOutputResponse: Swift.Equatable {
    /// The timestamp at which a streams edge configuration was first created.
    public var creationTime: ClientRuntime.Date?
    /// A description of the stream's edge configuration that will be used to sync with the Edge Agent IoT Greengrass component. The Edge Agent component will run on an IoT Hub Device setup at your premise.
    public var edgeConfig: KinesisVideoClientTypes.EdgeConfig?
    /// A description of the generated failure status.
    public var failedStatusDetails: Swift.String?
    /// The timestamp at which a streams edge configuration was last updated.
    public var lastUpdatedTime: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the stream.
    public var streamARN: Swift.String?
    /// The name of the stream from which the edge configuration was updated.
    public var streamName: Swift.String?
    /// The current sync status of the stream's edge configuration. When you invoke this API, the sync status will be set to the SYNCING state. Use the DescribeEdgeConfiguration API to get the latest status of the edge configuration.
    public var syncStatus: KinesisVideoClientTypes.SyncStatus?

    public init (
        creationTime: ClientRuntime.Date? = nil,
        edgeConfig: KinesisVideoClientTypes.EdgeConfig? = nil,
        failedStatusDetails: Swift.String? = nil,
        lastUpdatedTime: ClientRuntime.Date? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil,
        syncStatus: KinesisVideoClientTypes.SyncStatus? = nil
    )
    {
        self.creationTime = creationTime
        self.edgeConfig = edgeConfig
        self.failedStatusDetails = failedStatusDetails
        self.lastUpdatedTime = lastUpdatedTime
        self.streamARN = streamARN
        self.streamName = streamName
        self.syncStatus = syncStatus
    }
}

struct StartEdgeConfigurationUpdateOutputResponseBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let creationTime: ClientRuntime.Date?
    let lastUpdatedTime: ClientRuntime.Date?
    let syncStatus: KinesisVideoClientTypes.SyncStatus?
    let failedStatusDetails: Swift.String?
    let edgeConfig: KinesisVideoClientTypes.EdgeConfig?
}

extension StartEdgeConfigurationUpdateOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case edgeConfig = "EdgeConfig"
        case failedStatusDetails = "FailedStatusDetails"
        case lastUpdatedTime = "LastUpdatedTime"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case syncStatus = "SyncStatus"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let syncStatusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.SyncStatus.self, forKey: .syncStatus)
        syncStatus = syncStatusDecoded
        let failedStatusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failedStatusDetails)
        failedStatusDetails = failedStatusDetailsDecoded
        let edgeConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.EdgeConfig.self, forKey: .edgeConfig)
        edgeConfig = edgeConfigDecoded
    }
}

extension KinesisVideoClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .active,
                .creating,
                .deleting,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension KinesisVideoClientTypes {
    public enum StrategyOnFullSize: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleteOldestMedia
        case denyNewMedia
        case sdkUnknown(Swift.String)

        public static var allCases: [StrategyOnFullSize] {
            return [
                .deleteOldestMedia,
                .denyNewMedia,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleteOldestMedia: return "DELETE_OLDEST_MEDIA"
            case .denyNewMedia: return "DENY_NEW_MEDIA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StrategyOnFullSize(rawValue: rawValue) ?? StrategyOnFullSize.sdkUnknown(rawValue)
        }
    }
}

extension StreamEdgeConfigurationNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StreamEdgeConfigurationNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The Exception rendered when the Amazon Kinesis Video Stream can't find a stream's edge configuration that you specified.
public struct StreamEdgeConfigurationNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct StreamEdgeConfigurationNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension StreamEdgeConfigurationNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KinesisVideoClientTypes.StreamInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationTime = "CreationTime"
        case dataRetentionInHours = "DataRetentionInHours"
        case deviceName = "DeviceName"
        case kmsKeyId = "KmsKeyId"
        case mediaType = "MediaType"
        case status = "Status"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let dataRetentionInHours = self.dataRetentionInHours {
            try encodeContainer.encode(dataRetentionInHours, forKey: .dataRetentionInHours)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
        if let mediaType = self.mediaType {
            try encodeContainer.encode(mediaType, forKey: .mediaType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let mediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaType)
        mediaType = mediaTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let dataRetentionInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRetentionInHours)
        dataRetentionInHours = dataRetentionInHoursDecoded
    }
}

extension KinesisVideoClientTypes {
    /// An object describing a Kinesis video stream.
    public struct StreamInfo: Swift.Equatable {
        /// A time stamp that indicates when the stream was created.
        public var creationTime: ClientRuntime.Date?
        /// How long the stream retains data, in hours.
        public var dataRetentionInHours: Swift.Int?
        /// The name of the device that is associated with the stream.
        public var deviceName: Swift.String?
        /// The ID of the Key Management Service (KMS) key that Kinesis Video Streams uses to encrypt data on the stream.
        public var kmsKeyId: Swift.String?
        /// The MediaType of the stream.
        public var mediaType: Swift.String?
        /// The status of the stream.
        public var status: KinesisVideoClientTypes.Status?
        /// The Amazon Resource Name (ARN) of the stream.
        public var streamARN: Swift.String?
        /// The name of the stream.
        public var streamName: Swift.String?
        /// The version of the stream.
        public var version: Swift.String?

        public init (
            creationTime: ClientRuntime.Date? = nil,
            dataRetentionInHours: Swift.Int? = nil,
            deviceName: Swift.String? = nil,
            kmsKeyId: Swift.String? = nil,
            mediaType: Swift.String? = nil,
            status: KinesisVideoClientTypes.Status? = nil,
            streamARN: Swift.String? = nil,
            streamName: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.creationTime = creationTime
            self.dataRetentionInHours = dataRetentionInHours
            self.deviceName = deviceName
            self.kmsKeyId = kmsKeyId
            self.mediaType = mediaType
            self.status = status
            self.streamARN = streamARN
            self.streamName = streamName
            self.version = version
        }
    }

}

extension KinesisVideoClientTypes.StreamNameCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonOperator = "ComparisonOperator"
        case comparisonValue = "ComparisonValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = self.comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let comparisonValue = self.comparisonValue {
            try encodeContainer.encode(comparisonValue, forKey: .comparisonValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let comparisonValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comparisonValue)
        comparisonValue = comparisonValueDecoded
    }
}

extension KinesisVideoClientTypes {
    /// Specifies the condition that streams must satisfy to be returned when you list streams (see the ListStreams API). A condition has a comparison operation and a value. Currently, you can specify only the BEGINS_WITH operator, which finds streams whose names start with a given prefix.
    public struct StreamNameCondition: Swift.Equatable {
        /// A comparison operator. Currently, you can specify only the BEGINS_WITH operator, which finds streams whose names start with a given prefix.
        public var comparisonOperator: KinesisVideoClientTypes.ComparisonOperator?
        /// A value to compare.
        public var comparisonValue: Swift.String?

        public init (
            comparisonOperator: KinesisVideoClientTypes.ComparisonOperator? = nil,
            comparisonValue: Swift.String? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.comparisonValue = comparisonValue
        }
    }

}

extension KinesisVideoClientTypes {
    public enum SyncStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case acknowledged
        case deleteFailed
        case deleting
        case inSync
        case syncing
        case syncFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [SyncStatus] {
            return [
                .acknowledged,
                .deleteFailed,
                .deleting,
                .inSync,
                .syncing,
                .syncFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .acknowledged: return "ACKNOWLEDGED"
            case .deleteFailed: return "DELETE_FAILED"
            case .deleting: return "DELETING"
            case .inSync: return "IN_SYNC"
            case .syncing: return "SYNCING"
            case .syncFailed: return "SYNC_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SyncStatus(rawValue: rawValue) ?? SyncStatus.sdkUnknown(rawValue)
        }
    }
}

extension KinesisVideoClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension KinesisVideoClientTypes {
    /// A key and value pair that is associated with the specified signaling channel.
    public struct Tag: Swift.Equatable {
        /// The key of the tag that is associated with the specified signaling channel.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag that is associated with the specified signaling channel.
        /// This member is required.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/TagResource"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the signaling channel to which you want to add tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of tags to associate with the specified signaling channel. Each tag is a key-value pair.
    /// This member is required.
    public var tags: [KinesisVideoClientTypes.Tag]?

    public init (
        resourceARN: Swift.String? = nil,
        tags: [KinesisVideoClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [KinesisVideoClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([KinesisVideoClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[KinesisVideoClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [KinesisVideoClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagsPerResourceExceededLimitException" : self = .tagsPerResourceExceededLimitException(try TagsPerResourceExceededLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagsPerResourceExceededLimitException(TagsPerResourceExceededLimitException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension TagStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, resourceTags0) in tags {
                try tagsContainer.encode(resourceTags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tagStream"
    }
}

public struct TagStreamInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to add the tag or tags to.
    public var streamARN: Swift.String?
    /// The name of the stream that you want to add the tag or tags to.
    public var streamName: Swift.String?
    /// A list of tags to associate with the specified stream. Each tag is a key-value pair (the value is optional).
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
        self.tags = tags
    }
}

struct TagStreamInputBody: Swift.Equatable {
    let streamARN: Swift.String?
    let streamName: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension TagStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceFormatException" : self = .invalidResourceFormatException(try InvalidResourceFormatException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "TagsPerResourceExceededLimitException" : self = .tagsPerResourceExceededLimitException(try TagsPerResourceExceededLimitException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagStreamOutputError: Swift.Error, Swift.Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidResourceFormatException(InvalidResourceFormatException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case tagsPerResourceExceededLimitException(TagsPerResourceExceededLimitException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagStreamOutputResponse: Swift.Equatable {

    public init () { }
}

extension TagsPerResourceExceededLimitException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: TagsPerResourceExceededLimitExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You have exceeded the limit of tags that you can associate with the resource. A Kinesis video stream can support up to 50 tags.
public struct TagsPerResourceExceededLimitException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct TagsPerResourceExceededLimitExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TagsPerResourceExceededLimitExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeyList = "TagKeyList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeyList = tagKeyList {
            var tagKeyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeyList)
            for tagkey0 in tagKeyList {
                try tagKeyListContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UntagResource"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the signaling channel from which you want to remove tags.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// A list of the keys of the tags that you want to remove.
    /// This member is required.
    public var tagKeyList: [Swift.String]?

    public init (
        resourceARN: Swift.String? = nil,
        tagKeyList: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeyList = tagKeyList
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeyList: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeyList = "TagKeyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeyListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeyList)
        var tagKeyListDecoded0:[Swift.String]? = nil
        if let tagKeyListContainer = tagKeyListContainer {
            tagKeyListDecoded0 = [Swift.String]()
            for string0 in tagKeyListContainer {
                if let string0 = string0 {
                    tagKeyListDecoded0?.append(string0)
                }
            }
        }
        tagKeyList = tagKeyListDecoded0
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UntagStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case tagKeyList = "TagKeyList"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let tagKeyList = tagKeyList {
            var tagKeyListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeyList)
            for tagkey0 in tagKeyList {
                try tagKeyListContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/untagStream"
    }
}

public struct UntagStreamInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the stream that you want to remove tags from.
    public var streamARN: Swift.String?
    /// The name of the stream that you want to remove tags from.
    public var streamName: Swift.String?
    /// A list of the keys of the tags that you want to remove.
    /// This member is required.
    public var tagKeyList: [Swift.String]?

    public init (
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil,
        tagKeyList: [Swift.String]? = nil
    )
    {
        self.streamARN = streamARN
        self.streamName = streamName
        self.tagKeyList = tagKeyList
    }
}

struct UntagStreamInputBody: Swift.Equatable {
    let streamARN: Swift.String?
    let streamName: Swift.String?
    let tagKeyList: [Swift.String]?
}

extension UntagStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamARN = "StreamARN"
        case streamName = "StreamName"
        case tagKeyList = "TagKeyList"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let tagKeyListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeyList)
        var tagKeyListDecoded0:[Swift.String]? = nil
        if let tagKeyListContainer = tagKeyListContainer {
            tagKeyListDecoded0 = [Swift.String]()
            for string0 in tagKeyListContainer {
                if let string0 = string0 {
                    tagKeyListDecoded0?.append(string0)
                }
            }
        }
        tagKeyList = tagKeyListDecoded0
    }
}

extension UntagStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidResourceFormatException" : self = .invalidResourceFormatException(try InvalidResourceFormatException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagStreamOutputError: Swift.Error, Swift.Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case invalidResourceFormatException(InvalidResourceFormatException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagStreamOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateDataRetentionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case dataRetentionChangeInHours = "DataRetentionChangeInHours"
        case operation = "Operation"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let dataRetentionChangeInHours = self.dataRetentionChangeInHours {
            try encodeContainer.encode(dataRetentionChangeInHours, forKey: .dataRetentionChangeInHours)
        }
        if let operation = self.operation {
            try encodeContainer.encode(operation.rawValue, forKey: .operation)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension UpdateDataRetentionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateDataRetention"
    }
}

public struct UpdateDataRetentionInput: Swift.Equatable {
    /// The version of the stream whose retention period you want to change. To get the version, call either the DescribeStream or the ListStreams API.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// The retention period, in hours. The value you specify replaces the current value. The maximum value for this parameter is 87600 (ten years).
    /// This member is required.
    public var dataRetentionChangeInHours: Swift.Int?
    /// Indicates whether you want to increase or decrease the retention period.
    /// This member is required.
    public var operation: KinesisVideoClientTypes.UpdateDataRetentionOperation?
    /// The Amazon Resource Name (ARN) of the stream whose retention period you want to change.
    public var streamARN: Swift.String?
    /// The name of the stream whose retention period you want to change.
    public var streamName: Swift.String?

    public init (
        currentVersion: Swift.String? = nil,
        dataRetentionChangeInHours: Swift.Int? = nil,
        operation: KinesisVideoClientTypes.UpdateDataRetentionOperation? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.currentVersion = currentVersion
        self.dataRetentionChangeInHours = dataRetentionChangeInHours
        self.operation = operation
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct UpdateDataRetentionInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let currentVersion: Swift.String?
    let operation: KinesisVideoClientTypes.UpdateDataRetentionOperation?
    let dataRetentionChangeInHours: Swift.Int?
}

extension UpdateDataRetentionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case dataRetentionChangeInHours = "DataRetentionChangeInHours"
        case operation = "Operation"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let operationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.UpdateDataRetentionOperation.self, forKey: .operation)
        operation = operationDecoded
        let dataRetentionChangeInHoursDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .dataRetentionChangeInHours)
        dataRetentionChangeInHours = dataRetentionChangeInHoursDecoded
    }
}

extension KinesisVideoClientTypes {
    public enum UpdateDataRetentionOperation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case decreaseDataRetention
        case increaseDataRetention
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateDataRetentionOperation] {
            return [
                .decreaseDataRetention,
                .increaseDataRetention,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .decreaseDataRetention: return "DECREASE_DATA_RETENTION"
            case .increaseDataRetention: return "INCREASE_DATA_RETENTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateDataRetentionOperation(rawValue: rawValue) ?? UpdateDataRetentionOperation.sdkUnknown(rawValue)
        }
    }
}

extension UpdateDataRetentionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDataRetentionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionMismatchException" : self = .versionMismatchException(try VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDataRetentionOutputError: Swift.Error, Swift.Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case versionMismatchException(VersionMismatchException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDataRetentionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDataRetentionOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateImageGenerationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageGenerationConfiguration = "ImageGenerationConfiguration"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageGenerationConfiguration = self.imageGenerationConfiguration {
            try encodeContainer.encode(imageGenerationConfiguration, forKey: .imageGenerationConfiguration)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension UpdateImageGenerationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateImageGenerationConfiguration"
    }
}

public struct UpdateImageGenerationConfigurationInput: Swift.Equatable {
    /// The structure that contains the information required for the KVS images delivery. If the structure is null, the configuration will be deleted from the stream.
    public var imageGenerationConfiguration: KinesisVideoClientTypes.ImageGenerationConfiguration?
    /// The Amazon Resource Name (ARN) of the Kinesis video stream from where you want to update the image generation configuration. You must specify either the StreamName or the StreamARN.
    public var streamARN: Swift.String?
    /// The name of the stream from which to update the image generation configuration. You must specify either the StreamName or the StreamARN.
    public var streamName: Swift.String?

    public init (
        imageGenerationConfiguration: KinesisVideoClientTypes.ImageGenerationConfiguration? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.imageGenerationConfiguration = imageGenerationConfiguration
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct UpdateImageGenerationConfigurationInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let imageGenerationConfiguration: KinesisVideoClientTypes.ImageGenerationConfiguration?
}

extension UpdateImageGenerationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageGenerationConfiguration = "ImageGenerationConfiguration"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let imageGenerationConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ImageGenerationConfiguration.self, forKey: .imageGenerationConfiguration)
        imageGenerationConfiguration = imageGenerationConfigurationDecoded
    }
}

extension UpdateImageGenerationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateImageGenerationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoDataRetentionException" : self = .noDataRetentionException(try NoDataRetentionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateImageGenerationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case noDataRetentionException(NoDataRetentionException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateImageGenerationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateImageGenerationConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateMediaStorageConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case mediaStorageConfiguration = "MediaStorageConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = self.channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let mediaStorageConfiguration = self.mediaStorageConfiguration {
            try encodeContainer.encode(mediaStorageConfiguration, forKey: .mediaStorageConfiguration)
        }
    }
}

extension UpdateMediaStorageConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateMediaStorageConfiguration"
    }
}

public struct UpdateMediaStorageConfigurationInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the channel.
    /// This member is required.
    public var channelARN: Swift.String?
    /// A structure that encapsulates, or contains, the media storage configuration properties.
    /// This member is required.
    public var mediaStorageConfiguration: KinesisVideoClientTypes.MediaStorageConfiguration?

    public init (
        channelARN: Swift.String? = nil,
        mediaStorageConfiguration: KinesisVideoClientTypes.MediaStorageConfiguration? = nil
    )
    {
        self.channelARN = channelARN
        self.mediaStorageConfiguration = mediaStorageConfiguration
    }
}

struct UpdateMediaStorageConfigurationInputBody: Swift.Equatable {
    let channelARN: Swift.String?
    let mediaStorageConfiguration: KinesisVideoClientTypes.MediaStorageConfiguration?
}

extension UpdateMediaStorageConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case mediaStorageConfiguration = "MediaStorageConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
        let mediaStorageConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.MediaStorageConfiguration.self, forKey: .mediaStorageConfiguration)
        mediaStorageConfiguration = mediaStorageConfigurationDecoded
    }
}

extension UpdateMediaStorageConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMediaStorageConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoDataRetentionException" : self = .noDataRetentionException(try NoDataRetentionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateMediaStorageConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case noDataRetentionException(NoDataRetentionException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMediaStorageConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateMediaStorageConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateNotificationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationConfiguration = "NotificationConfiguration"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notificationConfiguration = self.notificationConfiguration {
            try encodeContainer.encode(notificationConfiguration, forKey: .notificationConfiguration)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension UpdateNotificationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateNotificationConfiguration"
    }
}

public struct UpdateNotificationConfigurationInput: Swift.Equatable {
    /// The structure containing the information required for notifications. If the structure is null, the configuration will be deleted from the stream.
    public var notificationConfiguration: KinesisVideoClientTypes.NotificationConfiguration?
    /// The Amazon Resource Name (ARN) of the Kinesis video stream from where you want to update the notification configuration. You must specify either the StreamName or the StreamARN.
    public var streamARN: Swift.String?
    /// The name of the stream from which to update the notification configuration. You must specify either the StreamName or the StreamARN.
    public var streamName: Swift.String?

    public init (
        notificationConfiguration: KinesisVideoClientTypes.NotificationConfiguration? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.notificationConfiguration = notificationConfiguration
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct UpdateNotificationConfigurationInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let notificationConfiguration: KinesisVideoClientTypes.NotificationConfiguration?
}

extension UpdateNotificationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notificationConfiguration = "NotificationConfiguration"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let notificationConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.NotificationConfiguration.self, forKey: .notificationConfiguration)
        notificationConfiguration = notificationConfigurationDecoded
    }
}

extension UpdateNotificationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNotificationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NoDataRetentionException" : self = .noDataRetentionException(try NoDataRetentionException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateNotificationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case noDataRetentionException(NoDataRetentionException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNotificationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateNotificationConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateSignalingChannelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case currentVersion = "CurrentVersion"
        case singleMasterConfiguration = "SingleMasterConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelARN = self.channelARN {
            try encodeContainer.encode(channelARN, forKey: .channelARN)
        }
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let singleMasterConfiguration = self.singleMasterConfiguration {
            try encodeContainer.encode(singleMasterConfiguration, forKey: .singleMasterConfiguration)
        }
    }
}

extension UpdateSignalingChannelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateSignalingChannel"
    }
}

public struct UpdateSignalingChannelInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the signaling channel that you want to update.
    /// This member is required.
    public var channelARN: Swift.String?
    /// The current version of the signaling channel that you want to update.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// The structure containing the configuration for the SINGLE_MASTER type of the signaling channel that you want to update.
    public var singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration?

    public init (
        channelARN: Swift.String? = nil,
        currentVersion: Swift.String? = nil,
        singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration? = nil
    )
    {
        self.channelARN = channelARN
        self.currentVersion = currentVersion
        self.singleMasterConfiguration = singleMasterConfiguration
    }
}

struct UpdateSignalingChannelInputBody: Swift.Equatable {
    let channelARN: Swift.String?
    let currentVersion: Swift.String?
    let singleMasterConfiguration: KinesisVideoClientTypes.SingleMasterConfiguration?
}

extension UpdateSignalingChannelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelARN = "ChannelARN"
        case currentVersion = "CurrentVersion"
        case singleMasterConfiguration = "SingleMasterConfiguration"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelARN)
        channelARN = channelARNDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let singleMasterConfigurationDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.SingleMasterConfiguration.self, forKey: .singleMasterConfiguration)
        singleMasterConfiguration = singleMasterConfigurationDecoded
    }
}

extension UpdateSignalingChannelOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSignalingChannelOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionMismatchException" : self = .versionMismatchException(try VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSignalingChannelOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case versionMismatchException(VersionMismatchException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSignalingChannelOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateSignalingChannelOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateStreamInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case deviceName = "DeviceName"
        case mediaType = "MediaType"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let currentVersion = self.currentVersion {
            try encodeContainer.encode(currentVersion, forKey: .currentVersion)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let mediaType = self.mediaType {
            try encodeContainer.encode(mediaType, forKey: .mediaType)
        }
        if let streamARN = self.streamARN {
            try encodeContainer.encode(streamARN, forKey: .streamARN)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }
}

extension UpdateStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/updateStream"
    }
}

public struct UpdateStreamInput: Swift.Equatable {
    /// The version of the stream whose metadata you want to update.
    /// This member is required.
    public var currentVersion: Swift.String?
    /// The name of the device that is writing to the stream. In the current implementation, Kinesis Video Streams does not use this name.
    public var deviceName: Swift.String?
    /// The stream's media type. Use MediaType to specify the type of content that the stream contains to the consumers of the stream. For more information about media types, see [Media Types](http://www.iana.org/assignments/media-types/media-types.xhtml). If you choose to specify the MediaType, see [Naming Requirements](https://tools.ietf.org/html/rfc6838#section-4.2). To play video on the console, you must specify the correct video type. For example, if the video in the stream is H.264, specify video/h264 as the MediaType.
    public var mediaType: Swift.String?
    /// The ARN of the stream whose metadata you want to update.
    public var streamARN: Swift.String?
    /// The name of the stream whose metadata you want to update. The stream name is an identifier for the stream, and must be unique for each account and region.
    public var streamName: Swift.String?

    public init (
        currentVersion: Swift.String? = nil,
        deviceName: Swift.String? = nil,
        mediaType: Swift.String? = nil,
        streamARN: Swift.String? = nil,
        streamName: Swift.String? = nil
    )
    {
        self.currentVersion = currentVersion
        self.deviceName = deviceName
        self.mediaType = mediaType
        self.streamARN = streamARN
        self.streamName = streamName
    }
}

struct UpdateStreamInputBody: Swift.Equatable {
    let streamName: Swift.String?
    let streamARN: Swift.String?
    let currentVersion: Swift.String?
    let deviceName: Swift.String?
    let mediaType: Swift.String?
}

extension UpdateStreamInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case currentVersion = "CurrentVersion"
        case deviceName = "DeviceName"
        case mediaType = "MediaType"
        case streamARN = "StreamARN"
        case streamName = "StreamName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
        let streamARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamARN)
        streamARN = streamARNDecoded
        let currentVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentVersion)
        currentVersion = currentVersionDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let mediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaType)
        mediaType = mediaTypeDecoded
    }
}

extension UpdateStreamOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateStreamOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ClientLimitExceededException" : self = .clientLimitExceededException(try ClientLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidArgumentException" : self = .invalidArgumentException(try InvalidArgumentException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotAuthorizedException" : self = .notAuthorizedException(try NotAuthorizedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceInUseException" : self = .resourceInUseException(try ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "VersionMismatchException" : self = .versionMismatchException(try VersionMismatchException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateStreamOutputError: Swift.Error, Swift.Equatable {
    case clientLimitExceededException(ClientLimitExceededException)
    case invalidArgumentException(InvalidArgumentException)
    case notAuthorizedException(NotAuthorizedException)
    case resourceInUseException(ResourceInUseException)
    case resourceNotFoundException(ResourceNotFoundException)
    case versionMismatchException(VersionMismatchException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateStreamOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateStreamOutputResponse: Swift.Equatable {

    public init () { }
}

extension KinesisVideoClientTypes.UploaderConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scheduleConfig = "ScheduleConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scheduleConfig = self.scheduleConfig {
            try encodeContainer.encode(scheduleConfig, forKey: .scheduleConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scheduleConfigDecoded = try containerValues.decodeIfPresent(KinesisVideoClientTypes.ScheduleConfig.self, forKey: .scheduleConfig)
        scheduleConfig = scheduleConfigDecoded
    }
}

extension KinesisVideoClientTypes {
    /// The configuration that consists of the ScheduleExpression and the DurationInMinutesdetails, that specify the scheduling to record from a camera, or local media file, onto the Edge Agent. If the ScheduleExpression is not provided, then the Edge Agent will always be in upload mode.
    public struct UploaderConfig: Swift.Equatable {
        /// The configuration that consists of the ScheduleExpression and the DurationInMinutesdetails that specify the scheduling to record from a camera, or local media file, onto the Edge Agent. If the ScheduleExpression is not provided, then the Edge Agent will always be in recording mode.
        /// This member is required.
        public var scheduleConfig: KinesisVideoClientTypes.ScheduleConfig?

        public init (
            scheduleConfig: KinesisVideoClientTypes.ScheduleConfig? = nil
        )
        {
            self.scheduleConfig = scheduleConfig
        }
    }

}

extension VersionMismatchException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: VersionMismatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The stream version that you specified is not the latest version. To get the latest version, use the [DescribeStream](https://docs.aws.amazon.com/kinesisvideostreams/latest/dg/API_DescribeStream.html) API.
public struct VersionMismatchException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct VersionMismatchExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension VersionMismatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
