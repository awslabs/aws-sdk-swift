//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct DeleteNamespaceOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTableBucketEncryptionOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTableBucketOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTableBucketPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTableOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTablePolicyOutput: Swift.Sendable {

    public init() { }
}

public struct PutTableBucketEncryptionOutput: Swift.Sendable {

    public init() { }
}

public struct PutTableBucketMaintenanceConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct PutTableBucketPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct PutTableMaintenanceConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct PutTablePolicyOutput: Swift.Sendable {

    public init() { }
}

public struct RenameTableOutput: Swift.Sendable {

    public init() { }
}

/// The action cannot be performed because you do not have the required permission.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request is invalid or malformed.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request failed because there is a conflict with a previous write. You can retry the request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The caller isn't authorized to make the request.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request failed due to an internal server error.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request was rejected because the specified resource could not be found.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The limit on the number of requests per second was exceeded.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct CreateNamespaceInput: Swift.Sendable {
    /// A name for the namespace.
    /// This member is required.
    public var namespace: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the table bucket to create the namespace in.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        namespace: [Swift.String]? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

public struct CreateNamespaceOutput: Swift.Sendable {
    /// The name of the namespace.
    /// This member is required.
    public var namespace: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the table bucket the namespace was created in.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        namespace: [Swift.String]? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

extension S3TablesClientTypes {

    public enum SSEAlgorithm: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aes256
        case awsKms
        case sdkUnknown(Swift.String)

        public static var allCases: [SSEAlgorithm] {
            return [
                .aes256,
                .awsKms
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aes256: return "AES256"
            case .awsKms: return "aws:kms"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension S3TablesClientTypes {

    /// Configuration specifying how data should be encrypted. This structure defines the encryption algorithm and optional KMS key to be used for server-side encryption.
    public struct EncryptionConfiguration: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the KMS key to use for encryption. This field is required only when sseAlgorithm is set to aws:kms.
        public var kmsKeyArn: Swift.String?
        /// The server-side encryption algorithm to use. Valid values are AES256 for S3-managed encryption keys, or aws:kms for Amazon Web Services KMS-managed encryption keys. If you choose SSE-KMS encryption you must grant the S3 Tables maintenance principal access to your KMS key. For more information, see [Permissions requirements for S3 Tables SSE-KMS encryption](https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-tables-kms-permissions.html).
        /// This member is required.
        public var sseAlgorithm: S3TablesClientTypes.SSEAlgorithm?

        public init(
            kmsKeyArn: Swift.String? = nil,
            sseAlgorithm: S3TablesClientTypes.SSEAlgorithm? = nil
        ) {
            self.kmsKeyArn = kmsKeyArn
            self.sseAlgorithm = sseAlgorithm
        }
    }
}

extension S3TablesClientTypes {

    public enum OpenTableFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iceberg
        case sdkUnknown(Swift.String)

        public static var allCases: [OpenTableFormat] {
            return [
                .iceberg
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iceberg: return "ICEBERG"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension S3TablesClientTypes {

    /// Contains details about a schema field.
    public struct SchemaField: Swift.Sendable {
        /// The name of the field.
        /// This member is required.
        public var name: Swift.String?
        /// A Boolean value that specifies whether values are required for each row in this field. By default, this is false and null values are allowed in the field. If this is true the field does not allow null values.
        public var `required`: Swift.Bool
        /// The field type. S3 Tables supports all Apache Iceberg primitive types. For more information, see the [Apache Iceberg documentation](https://iceberg.apache.org/spec/#primitive-types).
        /// This member is required.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            `required`: Swift.Bool = false,
            type: Swift.String? = nil
        ) {
            self.name = name
            self.`required` = `required`
            self.type = type
        }
    }
}

extension S3TablesClientTypes {

    /// Contains details about the schema for an Iceberg table.
    public struct IcebergSchema: Swift.Sendable {
        /// The schema fields for the table
        /// This member is required.
        public var fields: [S3TablesClientTypes.SchemaField]?

        public init(
            fields: [S3TablesClientTypes.SchemaField]? = nil
        ) {
            self.fields = fields
        }
    }
}

extension S3TablesClientTypes {

    /// Contains details about the metadata for an Iceberg table.
    public struct IcebergMetadata: Swift.Sendable {
        /// The schema for an Iceberg table.
        /// This member is required.
        public var schema: S3TablesClientTypes.IcebergSchema?

        public init(
            schema: S3TablesClientTypes.IcebergSchema? = nil
        ) {
            self.schema = schema
        }
    }
}

extension S3TablesClientTypes {

    /// Contains details about the table metadata.
    public enum TableMetadata: Swift.Sendable {
        /// Contains details about the metadata of an Iceberg table.
        case iceberg(S3TablesClientTypes.IcebergMetadata)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateTableInput: Swift.Sendable {
    /// The encryption configuration to use for the table. This configuration specifies the encryption algorithm and, if using SSE-KMS, the KMS key to use for encrypting the table. If you choose SSE-KMS encryption you must grant the S3 Tables maintenance principal access to your KMS key. For more information, see [Permissions requirements for S3 Tables SSE-KMS encryption](https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-tables-kms-permissions.html).
    public var encryptionConfiguration: S3TablesClientTypes.EncryptionConfiguration?
    /// The format for the table.
    /// This member is required.
    public var format: S3TablesClientTypes.OpenTableFormat?
    /// The metadata for the table.
    public var metadata: S3TablesClientTypes.TableMetadata?
    /// The name for the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace to associated with the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket to create the table in.
    /// This member is required.
    public var tableBucketARN: Swift.String?
    /// A map of user-defined tags that you would like to apply to the table that you are creating. A tag is a key-value pair that you apply to your resources. Tags can help you organize, track costs for, and control access to resources. For more information, see [Tagging for cost allocation or attribute-based access control (ABAC)](https://docs.aws.amazon.com/AmazonS3/latest/userguide/tagging.html). You must have the s3tables:TagResource permission in addition to s3tables:CreateTable permission to create a table with tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        encryptionConfiguration: S3TablesClientTypes.EncryptionConfiguration? = nil,
        format: S3TablesClientTypes.OpenTableFormat? = nil,
        metadata: S3TablesClientTypes.TableMetadata? = nil,
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.encryptionConfiguration = encryptionConfiguration
        self.format = format
        self.metadata = metadata
        self.name = name
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
        self.tags = tags
    }
}

public struct CreateTableOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the table.
    /// This member is required.
    public var tableARN: Swift.String?
    /// The version token of the table.
    /// This member is required.
    public var versionToken: Swift.String?

    public init(
        tableARN: Swift.String? = nil,
        versionToken: Swift.String? = nil
    ) {
        self.tableARN = tableARN
        self.versionToken = versionToken
    }
}

public struct CreateTableBucketInput: Swift.Sendable {
    /// The encryption configuration to use for the table bucket. This configuration specifies the default encryption settings that will be applied to all tables created in this bucket unless overridden at the table level. The configuration includes the encryption algorithm and, if using SSE-KMS, the KMS key to use.
    public var encryptionConfiguration: S3TablesClientTypes.EncryptionConfiguration?
    /// The name for the table bucket.
    /// This member is required.
    public var name: Swift.String?
    /// A map of user-defined tags that you would like to apply to the table bucket that you are creating. A tag is a key-value pair that you apply to your resources. Tags can help you organize and control access to resources. For more information, see [Tagging for cost allocation or attribute-based access control (ABAC)](https://docs.aws.amazon.com/AmazonS3/latest/userguide/tagging.html). You must have the s3tables:TagResource permission in addition to s3tables:CreateTableBucket permisson to create a table bucket with tags.
    public var tags: [Swift.String: Swift.String]?

    public init(
        encryptionConfiguration: S3TablesClientTypes.EncryptionConfiguration? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.encryptionConfiguration = encryptionConfiguration
        self.name = name
        self.tags = tags
    }
}

public struct CreateTableBucketOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct DeleteNamespaceInput: Swift.Sendable {
    /// The name of the namespace.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket associated with the namespace.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

public struct DeleteTableInput: Swift.Sendable {
    /// The name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace associated with the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket that contains the table.
    /// This member is required.
    public var tableBucketARN: Swift.String?
    /// The version token of the table.
    public var versionToken: Swift.String?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil,
        versionToken: Swift.String? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
        self.versionToken = versionToken
    }
}

public struct DeleteTableBucketInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        tableBucketARN: Swift.String? = nil
    ) {
        self.tableBucketARN = tableBucketARN
    }
}

public struct DeleteTableBucketEncryptionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        tableBucketARN: Swift.String? = nil
    ) {
        self.tableBucketARN = tableBucketARN
    }
}

public struct DeleteTableBucketPolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        tableBucketARN: Swift.String? = nil
    ) {
        self.tableBucketARN = tableBucketARN
    }
}

public struct DeleteTablePolicyInput: Swift.Sendable {
    /// The table name.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace associated with the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket that contains the table.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

public struct GetNamespaceInput: Swift.Sendable {
    /// The name of the namespace.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

public struct GetNamespaceOutput: Swift.Sendable {
    /// The date and time the namespace was created at.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The ID of the account that created the namespace.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The name of the namespace.
    /// This member is required.
    public var namespace: [Swift.String]?
    /// The unique identifier of the namespace.
    public var namespaceId: Swift.String?
    /// The ID of the account that owns the namespcace.
    /// This member is required.
    public var ownerAccountId: Swift.String?
    /// The unique identifier of the table bucket containing this namespace.
    public var tableBucketId: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        namespace: [Swift.String]? = nil,
        namespaceId: Swift.String? = nil,
        ownerAccountId: Swift.String? = nil,
        tableBucketId: Swift.String? = nil
    ) {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.namespace = namespace
        self.namespaceId = namespaceId
        self.ownerAccountId = ownerAccountId
        self.tableBucketId = tableBucketId
    }
}

public struct GetTableInput: Swift.Sendable {
    /// The name of the table.
    public var name: Swift.String?
    /// The name of the namespace the table is associated with.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table.
    public var tableArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket associated with the table.
    public var tableBucketARN: Swift.String?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableArn: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.tableArn = tableArn
        self.tableBucketARN = tableBucketARN
    }
}

extension S3TablesClientTypes {

    public enum TableType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aws
        case customer
        case sdkUnknown(Swift.String)

        public static var allCases: [TableType] {
            return [
                .aws,
                .customer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aws: return "aws"
            case .customer: return "customer"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetTableOutput: Swift.Sendable {
    /// The date and time the table bucket was created at.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The ID of the account that created the table.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The format of the table.
    /// This member is required.
    public var format: S3TablesClientTypes.OpenTableFormat?
    /// The service that manages the table.
    public var managedByService: Swift.String?
    /// The metadata location of the table.
    public var metadataLocation: Swift.String?
    /// The date and time the table was last modified on.
    /// This member is required.
    public var modifiedAt: Foundation.Date?
    /// The ID of the account that last modified the table.
    /// This member is required.
    public var modifiedBy: Swift.String?
    /// The name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace associated with the table.
    /// This member is required.
    public var namespace: [Swift.String]?
    /// The unique identifier of the namespace containing this table.
    public var namespaceId: Swift.String?
    /// The ID of the account that owns the table.
    /// This member is required.
    public var ownerAccountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the table.
    /// This member is required.
    public var tableARN: Swift.String?
    /// The unique identifier of the table bucket containing this table.
    public var tableBucketId: Swift.String?
    /// The type of the table.
    /// This member is required.
    public var type: S3TablesClientTypes.TableType?
    /// The version token of the table.
    /// This member is required.
    public var versionToken: Swift.String?
    /// The warehouse location of the table.
    /// This member is required.
    public var warehouseLocation: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        format: S3TablesClientTypes.OpenTableFormat? = nil,
        managedByService: Swift.String? = nil,
        metadataLocation: Swift.String? = nil,
        modifiedAt: Foundation.Date? = nil,
        modifiedBy: Swift.String? = nil,
        name: Swift.String? = nil,
        namespace: [Swift.String]? = nil,
        namespaceId: Swift.String? = nil,
        ownerAccountId: Swift.String? = nil,
        tableARN: Swift.String? = nil,
        tableBucketId: Swift.String? = nil,
        type: S3TablesClientTypes.TableType? = nil,
        versionToken: Swift.String? = nil,
        warehouseLocation: Swift.String? = nil
    ) {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.format = format
        self.managedByService = managedByService
        self.metadataLocation = metadataLocation
        self.modifiedAt = modifiedAt
        self.modifiedBy = modifiedBy
        self.name = name
        self.namespace = namespace
        self.namespaceId = namespaceId
        self.ownerAccountId = ownerAccountId
        self.tableARN = tableARN
        self.tableBucketId = tableBucketId
        self.type = type
        self.versionToken = versionToken
        self.warehouseLocation = warehouseLocation
    }
}

public struct GetTableBucketInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        tableBucketARN: Swift.String? = nil
    ) {
        self.tableBucketARN = tableBucketARN
    }
}

extension S3TablesClientTypes {

    public enum TableBucketType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aws
        case customer
        case sdkUnknown(Swift.String)

        public static var allCases: [TableBucketType] {
            return [
                .aws,
                .customer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aws: return "aws"
            case .customer: return "customer"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetTableBucketOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time the table bucket was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The name of the table bucket
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the account that owns the table bucket.
    /// This member is required.
    public var ownerAccountId: Swift.String?
    /// The unique identifier of the table bucket.
    public var tableBucketId: Swift.String?
    /// The type of the table bucket.
    public var type: S3TablesClientTypes.TableBucketType?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        ownerAccountId: Swift.String? = nil,
        tableBucketId: Swift.String? = nil,
        type: S3TablesClientTypes.TableBucketType? = nil
    ) {
        self.arn = arn
        self.createdAt = createdAt
        self.name = name
        self.ownerAccountId = ownerAccountId
        self.tableBucketId = tableBucketId
        self.type = type
    }
}

public struct GetTableBucketEncryptionInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        tableBucketARN: Swift.String? = nil
    ) {
        self.tableBucketARN = tableBucketARN
    }
}

public struct GetTableBucketEncryptionOutput: Swift.Sendable {
    /// The encryption configuration for the table bucket.
    /// This member is required.
    public var encryptionConfiguration: S3TablesClientTypes.EncryptionConfiguration?

    public init(
        encryptionConfiguration: S3TablesClientTypes.EncryptionConfiguration? = nil
    ) {
        self.encryptionConfiguration = encryptionConfiguration
    }
}

public struct GetTableBucketMaintenanceConfigurationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the table bucket associated with the maintenance configuration.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        tableBucketARN: Swift.String? = nil
    ) {
        self.tableBucketARN = tableBucketARN
    }
}

extension S3TablesClientTypes {

    public enum TableBucketMaintenanceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case icebergUnreferencedFileRemoval
        case sdkUnknown(Swift.String)

        public static var allCases: [TableBucketMaintenanceType] {
            return [
                .icebergUnreferencedFileRemoval
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .icebergUnreferencedFileRemoval: return "icebergUnreferencedFileRemoval"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension S3TablesClientTypes {

    /// Contains details about the unreferenced file removal settings for an Iceberg table bucket.
    public struct IcebergUnreferencedFileRemovalSettings: Swift.Sendable {
        /// The number of days an object has to be non-current before it is deleted.
        public var nonCurrentDays: Swift.Int?
        /// The number of days an object has to be unreferenced before it is marked as non-current.
        public var unreferencedDays: Swift.Int?

        public init(
            nonCurrentDays: Swift.Int? = nil,
            unreferencedDays: Swift.Int? = nil
        ) {
            self.nonCurrentDays = nonCurrentDays
            self.unreferencedDays = unreferencedDays
        }
    }
}

extension S3TablesClientTypes {

    /// Contains details about the maintenance settings for the table bucket.
    public enum TableBucketMaintenanceSettings: Swift.Sendable {
        /// The unreferenced file removal settings for the table bucket.
        case icebergunreferencedfileremoval(S3TablesClientTypes.IcebergUnreferencedFileRemovalSettings)
        case sdkUnknown(Swift.String)
    }
}

extension S3TablesClientTypes {

    public enum MaintenanceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "disabled"
            case .enabled: return "enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension S3TablesClientTypes {

    /// Details about the values that define the maintenance configuration for a table bucket.
    public struct TableBucketMaintenanceConfigurationValue: Swift.Sendable {
        /// Contains details about the settings of the maintenance configuration.
        public var settings: S3TablesClientTypes.TableBucketMaintenanceSettings?
        /// The status of the maintenance configuration.
        public var status: S3TablesClientTypes.MaintenanceStatus?

        public init(
            settings: S3TablesClientTypes.TableBucketMaintenanceSettings? = nil,
            status: S3TablesClientTypes.MaintenanceStatus? = nil
        ) {
            self.settings = settings
            self.status = status
        }
    }
}

public struct GetTableBucketMaintenanceConfigurationOutput: Swift.Sendable {
    /// Details about the maintenance configuration for the table bucket.
    /// This member is required.
    public var configuration: [Swift.String: S3TablesClientTypes.TableBucketMaintenanceConfigurationValue]?
    /// The Amazon Resource Name (ARN) of the table bucket associated with the maintenance configuration.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        configuration: [Swift.String: S3TablesClientTypes.TableBucketMaintenanceConfigurationValue]? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.configuration = configuration
        self.tableBucketARN = tableBucketARN
    }
}

public struct GetTableBucketPolicyInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        tableBucketARN: Swift.String? = nil
    ) {
        self.tableBucketARN = tableBucketARN
    }
}

public struct GetTableBucketPolicyOutput: Swift.Sendable {
    /// The JSON that defines the policy.
    /// This member is required.
    public var resourcePolicy: Swift.String?

    public init(
        resourcePolicy: Swift.String? = nil
    ) {
        self.resourcePolicy = resourcePolicy
    }
}

public struct GetTableEncryptionInput: Swift.Sendable {
    /// The name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace associated with the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket containing the table.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

public struct GetTableEncryptionOutput: Swift.Sendable {
    /// The encryption configuration for the table.
    /// This member is required.
    public var encryptionConfiguration: S3TablesClientTypes.EncryptionConfiguration?

    public init(
        encryptionConfiguration: S3TablesClientTypes.EncryptionConfiguration? = nil
    ) {
        self.encryptionConfiguration = encryptionConfiguration
    }
}

public struct GetTableMaintenanceConfigurationInput: Swift.Sendable {
    /// The name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace associated with the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

extension S3TablesClientTypes {

    public enum TableMaintenanceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case icebergCompaction
        case icebergSnapshotManagement
        case sdkUnknown(Swift.String)

        public static var allCases: [TableMaintenanceType] {
            return [
                .icebergCompaction,
                .icebergSnapshotManagement
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .icebergCompaction: return "icebergCompaction"
            case .icebergSnapshotManagement: return "icebergSnapshotManagement"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension S3TablesClientTypes {

    public enum IcebergCompactionStrategy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case binpack
        case sort
        case zorder
        case sdkUnknown(Swift.String)

        public static var allCases: [IcebergCompactionStrategy] {
            return [
                .auto,
                .binpack,
                .sort,
                .zorder
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "auto"
            case .binpack: return "binpack"
            case .sort: return "sort"
            case .zorder: return "z-order"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension S3TablesClientTypes {

    /// Contains details about the compaction settings for an Iceberg table.
    public struct IcebergCompactionSettings: Swift.Sendable {
        /// The compaction strategy to use for the table. This determines how files are selected and combined during compaction operations.
        public var strategy: S3TablesClientTypes.IcebergCompactionStrategy?
        /// The target file size for the table in MB.
        public var targetFileSizeMB: Swift.Int?

        public init(
            strategy: S3TablesClientTypes.IcebergCompactionStrategy? = nil,
            targetFileSizeMB: Swift.Int? = nil
        ) {
            self.strategy = strategy
            self.targetFileSizeMB = targetFileSizeMB
        }
    }
}

extension S3TablesClientTypes {

    /// Contains details about the snapshot management settings for an Iceberg table. The oldest snapshot expires when its age exceeds the maxSnapshotAgeHours and the total number of snapshots exceeds the value for the minimum number of snapshots to keep minSnapshotsToKeep.
    public struct IcebergSnapshotManagementSettings: Swift.Sendable {
        /// The maximum age of a snapshot before it can be expired.
        public var maxSnapshotAgeHours: Swift.Int?
        /// The minimum number of snapshots to keep.
        public var minSnapshotsToKeep: Swift.Int?

        public init(
            maxSnapshotAgeHours: Swift.Int? = nil,
            minSnapshotsToKeep: Swift.Int? = nil
        ) {
            self.maxSnapshotAgeHours = maxSnapshotAgeHours
            self.minSnapshotsToKeep = minSnapshotsToKeep
        }
    }
}

extension S3TablesClientTypes {

    /// Contains details about maintenance settings for the table.
    public enum TableMaintenanceSettings: Swift.Sendable {
        /// Contains details about the Iceberg compaction settings for the table.
        case icebergcompaction(S3TablesClientTypes.IcebergCompactionSettings)
        /// Contains details about the Iceberg snapshot management settings for the table.
        case icebergsnapshotmanagement(S3TablesClientTypes.IcebergSnapshotManagementSettings)
        case sdkUnknown(Swift.String)
    }
}

extension S3TablesClientTypes {

    /// Contains the values that define a maintenance configuration for a table.
    public struct TableMaintenanceConfigurationValue: Swift.Sendable {
        /// Contains details about the settings for the maintenance configuration.
        public var settings: S3TablesClientTypes.TableMaintenanceSettings?
        /// The status of the maintenance configuration.
        public var status: S3TablesClientTypes.MaintenanceStatus?

        public init(
            settings: S3TablesClientTypes.TableMaintenanceSettings? = nil,
            status: S3TablesClientTypes.MaintenanceStatus? = nil
        ) {
            self.settings = settings
            self.status = status
        }
    }
}

public struct GetTableMaintenanceConfigurationOutput: Swift.Sendable {
    /// Details about the maintenance configuration for the table bucket.
    /// This member is required.
    public var configuration: [Swift.String: S3TablesClientTypes.TableMaintenanceConfigurationValue]?
    /// The Amazon Resource Name (ARN) of the table.
    /// This member is required.
    public var tableARN: Swift.String?

    public init(
        configuration: [Swift.String: S3TablesClientTypes.TableMaintenanceConfigurationValue]? = nil,
        tableARN: Swift.String? = nil
    ) {
        self.configuration = configuration
        self.tableARN = tableARN
    }
}

public struct GetTableMaintenanceJobStatusInput: Swift.Sendable {
    /// The name of the table containing the maintenance job status you want to check.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the namespace the table is associated with.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

extension S3TablesClientTypes {

    public enum TableMaintenanceJobType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case icebergCompaction
        case icebergSnapshotManagement
        case icebergUnreferencedFileRemoval
        case sdkUnknown(Swift.String)

        public static var allCases: [TableMaintenanceJobType] {
            return [
                .icebergCompaction,
                .icebergSnapshotManagement,
                .icebergUnreferencedFileRemoval
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .icebergCompaction: return "icebergCompaction"
            case .icebergSnapshotManagement: return "icebergSnapshotManagement"
            case .icebergUnreferencedFileRemoval: return "icebergUnreferencedFileRemoval"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension S3TablesClientTypes {

    public enum JobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case failed
        case notYetRun
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .disabled,
                .failed,
                .notYetRun,
                .successful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .failed: return "Failed"
            case .notYetRun: return "Not_Yet_Run"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension S3TablesClientTypes {

    /// Details about the status of a maintenance job.
    public struct TableMaintenanceJobStatusValue: Swift.Sendable {
        /// The failure message of a failed job.
        public var failureMessage: Swift.String?
        /// The date and time that the maintenance job was last run.
        public var lastRunTimestamp: Foundation.Date?
        /// The status of the job.
        /// This member is required.
        public var status: S3TablesClientTypes.JobStatus?

        public init(
            failureMessage: Swift.String? = nil,
            lastRunTimestamp: Foundation.Date? = nil,
            status: S3TablesClientTypes.JobStatus? = nil
        ) {
            self.failureMessage = failureMessage
            self.lastRunTimestamp = lastRunTimestamp
            self.status = status
        }
    }
}

public struct GetTableMaintenanceJobStatusOutput: Swift.Sendable {
    /// The status of the maintenance job.
    /// This member is required.
    public var status: [Swift.String: S3TablesClientTypes.TableMaintenanceJobStatusValue]?
    /// The Amazon Resource Name (ARN) of the table.
    /// This member is required.
    public var tableARN: Swift.String?

    public init(
        status: [Swift.String: S3TablesClientTypes.TableMaintenanceJobStatusValue]? = nil,
        tableARN: Swift.String? = nil
    ) {
        self.status = status
        self.tableARN = tableARN
    }
}

public struct GetTableMetadataLocationInput: Swift.Sendable {
    /// The name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace of the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

public struct GetTableMetadataLocationOutput: Swift.Sendable {
    /// The metadata location.
    public var metadataLocation: Swift.String?
    /// The version token.
    /// This member is required.
    public var versionToken: Swift.String?
    /// The warehouse location.
    /// This member is required.
    public var warehouseLocation: Swift.String?

    public init(
        metadataLocation: Swift.String? = nil,
        versionToken: Swift.String? = nil,
        warehouseLocation: Swift.String? = nil
    ) {
        self.metadataLocation = metadataLocation
        self.versionToken = versionToken
        self.warehouseLocation = warehouseLocation
    }
}

public struct GetTablePolicyInput: Swift.Sendable {
    /// The name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace associated with the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket that contains the table.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

public struct GetTablePolicyOutput: Swift.Sendable {
    /// The JSON that defines the policy.
    /// This member is required.
    public var resourcePolicy: Swift.String?

    public init(
        resourcePolicy: Swift.String? = nil
    ) {
        self.resourcePolicy = resourcePolicy
    }
}

public struct ListNamespacesInput: Swift.Sendable {
    /// ContinuationToken indicates to Amazon S3 that the list is being continued on this bucket with a token. ContinuationToken is obfuscated and is not a real key. You can use this ContinuationToken for pagination of the list results.
    public var continuationToken: Swift.String?
    /// The maximum number of namespaces to return in the list.
    public var maxNamespaces: Swift.Int?
    /// The prefix of the namespaces.
    public var `prefix`: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        continuationToken: Swift.String? = nil,
        maxNamespaces: Swift.Int? = nil,
        `prefix`: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.continuationToken = continuationToken
        self.maxNamespaces = maxNamespaces
        self.`prefix` = `prefix`
        self.tableBucketARN = tableBucketARN
    }
}

extension S3TablesClientTypes {

    /// Contains details about a namespace.
    public struct NamespaceSummary: Swift.Sendable {
        /// The date and time the namespace was created at.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The ID of the account that created the namespace.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The name of the namespace.
        /// This member is required.
        public var namespace: [Swift.String]?
        /// The system-assigned unique identifier for the namespace.
        public var namespaceId: Swift.String?
        /// The ID of the account that owns the namespace.
        /// This member is required.
        public var ownerAccountId: Swift.String?
        /// The system-assigned unique identifier for the table bucket that contains this namespace.
        public var tableBucketId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            namespace: [Swift.String]? = nil,
            namespaceId: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            tableBucketId: Swift.String? = nil
        ) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.namespace = namespace
            self.namespaceId = namespaceId
            self.ownerAccountId = ownerAccountId
            self.tableBucketId = tableBucketId
        }
    }
}

public struct ListNamespacesOutput: Swift.Sendable {
    /// The ContinuationToken for pagination of the list results.
    public var continuationToken: Swift.String?
    /// A list of namespaces.
    /// This member is required.
    public var namespaces: [S3TablesClientTypes.NamespaceSummary]?

    public init(
        continuationToken: Swift.String? = nil,
        namespaces: [S3TablesClientTypes.NamespaceSummary]? = nil
    ) {
        self.continuationToken = continuationToken
        self.namespaces = namespaces
    }
}

public struct ListTableBucketsInput: Swift.Sendable {
    /// ContinuationToken indicates to Amazon S3 that the list is being continued on this bucket with a token. ContinuationToken is obfuscated and is not a real key. You can use this ContinuationToken for pagination of the list results.
    public var continuationToken: Swift.String?
    /// The maximum number of table buckets to return in the list.
    public var maxBuckets: Swift.Int?
    /// The prefix of the table buckets.
    public var `prefix`: Swift.String?
    /// The type of table buckets to filter by in the list.
    public var type: S3TablesClientTypes.TableBucketType?

    public init(
        continuationToken: Swift.String? = nil,
        maxBuckets: Swift.Int? = nil,
        `prefix`: Swift.String? = nil,
        type: S3TablesClientTypes.TableBucketType? = nil
    ) {
        self.continuationToken = continuationToken
        self.maxBuckets = maxBuckets
        self.`prefix` = `prefix`
        self.type = type
    }
}

extension S3TablesClientTypes {

    /// Contains details about a table bucket.
    public struct TableBucketSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the table bucket.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time the table bucket was created at.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The name of the table bucket.
        /// This member is required.
        public var name: Swift.String?
        /// The ID of the account that owns the table bucket.
        /// This member is required.
        public var ownerAccountId: Swift.String?
        /// The system-assigned unique identifier for the table bucket.
        public var tableBucketId: Swift.String?
        /// The type of the table bucket.
        public var type: S3TablesClientTypes.TableBucketType?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            tableBucketId: Swift.String? = nil,
            type: S3TablesClientTypes.TableBucketType? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.name = name
            self.ownerAccountId = ownerAccountId
            self.tableBucketId = tableBucketId
            self.type = type
        }
    }
}

public struct ListTableBucketsOutput: Swift.Sendable {
    /// You can use this ContinuationToken for pagination of the list results.
    public var continuationToken: Swift.String?
    /// A list of table buckets.
    /// This member is required.
    public var tableBuckets: [S3TablesClientTypes.TableBucketSummary]?

    public init(
        continuationToken: Swift.String? = nil,
        tableBuckets: [S3TablesClientTypes.TableBucketSummary]? = nil
    ) {
        self.continuationToken = continuationToken
        self.tableBuckets = tableBuckets
    }
}

public struct ListTablesInput: Swift.Sendable {
    /// ContinuationToken indicates to Amazon S3 that the list is being continued on this bucket with a token. ContinuationToken is obfuscated and is not a real key. You can use this ContinuationToken for pagination of the list results.
    public var continuationToken: Swift.String?
    /// The maximum number of tables to return.
    public var maxTables: Swift.Int?
    /// The namespace of the tables.
    public var namespace: Swift.String?
    /// The prefix of the tables.
    public var `prefix`: Swift.String?
    /// The Amazon resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        continuationToken: Swift.String? = nil,
        maxTables: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        `prefix`: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.continuationToken = continuationToken
        self.maxTables = maxTables
        self.namespace = namespace
        self.`prefix` = `prefix`
        self.tableBucketARN = tableBucketARN
    }
}

extension S3TablesClientTypes {

    /// Contains details about a table.
    public struct TableSummary: Swift.Sendable {
        /// The date and time the table was created at.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The date and time the table was last modified at.
        /// This member is required.
        public var modifiedAt: Foundation.Date?
        /// The name of the table.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the namespace.
        /// This member is required.
        public var namespace: [Swift.String]?
        /// The unique identifier for the namespace that contains this table.
        public var namespaceId: Swift.String?
        /// The Amazon Resource Name (ARN) of the table.
        /// This member is required.
        public var tableARN: Swift.String?
        /// The unique identifier for the table bucket that contains this table.
        public var tableBucketId: Swift.String?
        /// The type of the table.
        /// This member is required.
        public var type: S3TablesClientTypes.TableType?

        public init(
            createdAt: Foundation.Date? = nil,
            modifiedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            namespace: [Swift.String]? = nil,
            namespaceId: Swift.String? = nil,
            tableARN: Swift.String? = nil,
            tableBucketId: Swift.String? = nil,
            type: S3TablesClientTypes.TableType? = nil
        ) {
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.name = name
            self.namespace = namespace
            self.namespaceId = namespaceId
            self.tableARN = tableARN
            self.tableBucketId = tableBucketId
            self.type = type
        }
    }
}

public struct ListTablesOutput: Swift.Sendable {
    /// You can use this ContinuationToken for pagination of the list results.
    public var continuationToken: Swift.String?
    /// A list of tables.
    /// This member is required.
    public var tables: [S3TablesClientTypes.TableSummary]?

    public init(
        continuationToken: Swift.String? = nil,
        tables: [S3TablesClientTypes.TableSummary]? = nil
    ) {
        self.continuationToken = continuationToken
        self.tables = tables
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Amazon S3 Tables resource that you want to list tags for. The tagged resource can be a table bucket or a table. For a list of all S3 resources that support tagging, see [Managing tags for Amazon S3 resources](https://docs.aws.amazon.com/AmazonS3/latest/userguide/tagging.html#manage-tags).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The user-defined tags that are applied to the resource. For more information, see [Tagging for cost allocation or attribute-based access control (ABAC)](https://docs.aws.amazon.com/AmazonS3/latest/userguide/tagging.html).
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

public struct PutTableBucketEncryptionInput: Swift.Sendable {
    /// The encryption configuration to apply to the table bucket.
    /// This member is required.
    public var encryptionConfiguration: S3TablesClientTypes.EncryptionConfiguration?
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        encryptionConfiguration: S3TablesClientTypes.EncryptionConfiguration? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.encryptionConfiguration = encryptionConfiguration
        self.tableBucketARN = tableBucketARN
    }
}

public struct PutTableBucketMaintenanceConfigurationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the table bucket associated with the maintenance configuration.
    /// This member is required.
    public var tableBucketARN: Swift.String?
    /// The type of the maintenance configuration.
    /// This member is required.
    public var type: S3TablesClientTypes.TableBucketMaintenanceType?
    /// Defines the values of the maintenance configuration for the table bucket.
    /// This member is required.
    public var value: S3TablesClientTypes.TableBucketMaintenanceConfigurationValue?

    public init(
        tableBucketARN: Swift.String? = nil,
        type: S3TablesClientTypes.TableBucketMaintenanceType? = nil,
        value: S3TablesClientTypes.TableBucketMaintenanceConfigurationValue? = nil
    ) {
        self.tableBucketARN = tableBucketARN
        self.type = type
        self.value = value
    }
}

public struct PutTableBucketPolicyInput: Swift.Sendable {
    /// The JSON that defines the policy.
    /// This member is required.
    public var resourcePolicy: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        resourcePolicy: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.resourcePolicy = resourcePolicy
        self.tableBucketARN = tableBucketARN
    }
}

public struct PutTableMaintenanceConfigurationInput: Swift.Sendable {
    /// The name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace of the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table associated with the maintenance configuration.
    /// This member is required.
    public var tableBucketARN: Swift.String?
    /// The type of the maintenance configuration.
    /// This member is required.
    public var type: S3TablesClientTypes.TableMaintenanceType?
    /// Defines the values of the maintenance configuration for the table.
    /// This member is required.
    public var value: S3TablesClientTypes.TableMaintenanceConfigurationValue?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil,
        type: S3TablesClientTypes.TableMaintenanceType? = nil,
        value: S3TablesClientTypes.TableMaintenanceConfigurationValue? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
        self.type = type
        self.value = value
    }
}

public struct PutTablePolicyInput: Swift.Sendable {
    /// The name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace associated with the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The JSON that defines the policy.
    /// This member is required.
    public var resourcePolicy: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket that contains the table.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        resourcePolicy: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.resourcePolicy = resourcePolicy
        self.tableBucketARN = tableBucketARN
    }
}

public struct RenameTableInput: Swift.Sendable {
    /// The current name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace associated with the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The new name for the table.
    public var newName: Swift.String?
    /// The new name for the namespace.
    public var newNamespaceName: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?
    /// The version token of the table.
    public var versionToken: Swift.String?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        newName: Swift.String? = nil,
        newNamespaceName: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil,
        versionToken: Swift.String? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.newName = newName
        self.newNamespaceName = newNamespaceName
        self.tableBucketARN = tableBucketARN
        self.versionToken = versionToken
    }
}

public struct UpdateTableMetadataLocationInput: Swift.Sendable {
    /// The new metadata location for the table.
    /// This member is required.
    public var metadataLocation: Swift.String?
    /// The name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace of the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?
    /// The version token of the table.
    /// This member is required.
    public var versionToken: Swift.String?

    public init(
        metadataLocation: Swift.String? = nil,
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil,
        versionToken: Swift.String? = nil
    ) {
        self.metadataLocation = metadataLocation
        self.name = name
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
        self.versionToken = versionToken
    }
}

public struct UpdateTableMetadataLocationOutput: Swift.Sendable {
    /// The metadata location of the table.
    /// This member is required.
    public var metadataLocation: Swift.String?
    /// The name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace the table is associated with.
    /// This member is required.
    public var namespace: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the table.
    /// This member is required.
    public var tableARN: Swift.String?
    /// The version token of the table.
    /// This member is required.
    public var versionToken: Swift.String?

    public init(
        metadataLocation: Swift.String? = nil,
        name: Swift.String? = nil,
        namespace: [Swift.String]? = nil,
        tableARN: Swift.String? = nil,
        versionToken: Swift.String? = nil
    ) {
        self.metadataLocation = metadataLocation
        self.name = name
        self.namespace = namespace
        self.tableARN = tableARN
        self.versionToken = versionToken
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Amazon S3 Tables resource that you're applying tags to. The tagged resource can be a table bucket or a table. For a list of all S3 resources that support tagging, see [Managing tags for Amazon S3 resources](https://docs.aws.amazon.com/AmazonS3/latest/userguide/tagging.html#manage-tags).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The user-defined tag that you want to add to the specified S3 Tables resource. For more information, see [Tagging for cost allocation or attribute-based access control (ABAC)](https://docs.aws.amazon.com/AmazonS3/latest/userguide/tagging.html).
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the Amazon S3 Tables resource that you're removing tags from. The tagged resource can be a table bucket or a table. For a list of all S3 resources that support tagging, see [Managing tags for Amazon S3 resources](https://docs.aws.amazon.com/AmazonS3/latest/userguide/tagging.html#manage-tags).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The array of tag keys that you're removing from the S3 Tables resource. For more information, see [Tagging for cost allocation or attribute-based access control (ABAC)](https://docs.aws.amazon.com/AmazonS3/latest/userguide/tagging.html).
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension CreateNamespaceInput {

    static func urlPathProvider(_ value: CreateNamespaceInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/namespaces/\(tableBucketARN.urlPercentEncoding())"
    }
}

extension CreateTableInput {

    static func urlPathProvider(_ value: CreateTableInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())"
    }
}

extension CreateTableBucketInput {

    static func urlPathProvider(_ value: CreateTableBucketInput) -> Swift.String? {
        return "/buckets"
    }
}

extension DeleteNamespaceInput {

    static func urlPathProvider(_ value: DeleteNamespaceInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        return "/namespaces/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())"
    }
}

extension DeleteTableInput {

    static func urlPathProvider(_ value: DeleteTableInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())"
    }
}

extension DeleteTableInput {

    static func queryItemProvider(_ value: DeleteTableInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let versionToken = value.versionToken {
            let versionTokenQueryItem = Smithy.URIQueryItem(name: "versionToken".urlPercentEncoding(), value: Swift.String(versionToken).urlPercentEncoding())
            items.append(versionTokenQueryItem)
        }
        return items
    }
}

extension DeleteTableBucketInput {

    static func urlPathProvider(_ value: DeleteTableBucketInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/buckets/\(tableBucketARN.urlPercentEncoding())"
    }
}

extension DeleteTableBucketEncryptionInput {

    static func urlPathProvider(_ value: DeleteTableBucketEncryptionInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/buckets/\(tableBucketARN.urlPercentEncoding())/encryption"
    }
}

extension DeleteTableBucketPolicyInput {

    static func urlPathProvider(_ value: DeleteTableBucketPolicyInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/buckets/\(tableBucketARN.urlPercentEncoding())/policy"
    }
}

extension DeleteTablePolicyInput {

    static func urlPathProvider(_ value: DeleteTablePolicyInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/policy"
    }
}

extension GetNamespaceInput {

    static func urlPathProvider(_ value: GetNamespaceInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        return "/namespaces/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())"
    }
}

extension GetTableInput {

    static func urlPathProvider(_ value: GetTableInput) -> Swift.String? {
        return "/get-table"
    }
}

extension GetTableInput {

    static func queryItemProvider(_ value: GetTableInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let tableBucketARN = value.tableBucketARN {
            let tableBucketARNQueryItem = Smithy.URIQueryItem(name: "tableBucketARN".urlPercentEncoding(), value: Swift.String(tableBucketARN).urlPercentEncoding())
            items.append(tableBucketARNQueryItem)
        }
        if let namespace = value.namespace {
            let namespaceQueryItem = Smithy.URIQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        if let name = value.name {
            let nameQueryItem = Smithy.URIQueryItem(name: "name".urlPercentEncoding(), value: Swift.String(name).urlPercentEncoding())
            items.append(nameQueryItem)
        }
        if let tableArn = value.tableArn {
            let tableArnQueryItem = Smithy.URIQueryItem(name: "tableArn".urlPercentEncoding(), value: Swift.String(tableArn).urlPercentEncoding())
            items.append(tableArnQueryItem)
        }
        return items
    }
}

extension GetTableBucketInput {

    static func urlPathProvider(_ value: GetTableBucketInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/buckets/\(tableBucketARN.urlPercentEncoding())"
    }
}

extension GetTableBucketEncryptionInput {

    static func urlPathProvider(_ value: GetTableBucketEncryptionInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/buckets/\(tableBucketARN.urlPercentEncoding())/encryption"
    }
}

extension GetTableBucketMaintenanceConfigurationInput {

    static func urlPathProvider(_ value: GetTableBucketMaintenanceConfigurationInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/buckets/\(tableBucketARN.urlPercentEncoding())/maintenance"
    }
}

extension GetTableBucketPolicyInput {

    static func urlPathProvider(_ value: GetTableBucketPolicyInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/buckets/\(tableBucketARN.urlPercentEncoding())/policy"
    }
}

extension GetTableEncryptionInput {

    static func urlPathProvider(_ value: GetTableEncryptionInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/encryption"
    }
}

extension GetTableMaintenanceConfigurationInput {

    static func urlPathProvider(_ value: GetTableMaintenanceConfigurationInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/maintenance"
    }
}

extension GetTableMaintenanceJobStatusInput {

    static func urlPathProvider(_ value: GetTableMaintenanceJobStatusInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/maintenance-job-status"
    }
}

extension GetTableMetadataLocationInput {

    static func urlPathProvider(_ value: GetTableMetadataLocationInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/metadata-location"
    }
}

extension GetTablePolicyInput {

    static func urlPathProvider(_ value: GetTablePolicyInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/policy"
    }
}

extension ListNamespacesInput {

    static func urlPathProvider(_ value: ListNamespacesInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/namespaces/\(tableBucketARN.urlPercentEncoding())"
    }
}

extension ListNamespacesInput {

    static func queryItemProvider(_ value: ListNamespacesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let `prefix` = value.`prefix` {
            let prefixQueryItem = Smithy.URIQueryItem(name: "prefix".urlPercentEncoding(), value: Swift.String(`prefix`).urlPercentEncoding())
            items.append(prefixQueryItem)
        }
        if let maxNamespaces = value.maxNamespaces {
            let maxNamespacesQueryItem = Smithy.URIQueryItem(name: "maxNamespaces".urlPercentEncoding(), value: Swift.String(maxNamespaces).urlPercentEncoding())
            items.append(maxNamespacesQueryItem)
        }
        if let continuationToken = value.continuationToken {
            let continuationTokenQueryItem = Smithy.URIQueryItem(name: "continuationToken".urlPercentEncoding(), value: Swift.String(continuationToken).urlPercentEncoding())
            items.append(continuationTokenQueryItem)
        }
        return items
    }
}

extension ListTableBucketsInput {

    static func urlPathProvider(_ value: ListTableBucketsInput) -> Swift.String? {
        return "/buckets"
    }
}

extension ListTableBucketsInput {

    static func queryItemProvider(_ value: ListTableBucketsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxBuckets = value.maxBuckets {
            let maxBucketsQueryItem = Smithy.URIQueryItem(name: "maxBuckets".urlPercentEncoding(), value: Swift.String(maxBuckets).urlPercentEncoding())
            items.append(maxBucketsQueryItem)
        }
        if let `prefix` = value.`prefix` {
            let prefixQueryItem = Smithy.URIQueryItem(name: "prefix".urlPercentEncoding(), value: Swift.String(`prefix`).urlPercentEncoding())
            items.append(prefixQueryItem)
        }
        if let type = value.type {
            let typeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let continuationToken = value.continuationToken {
            let continuationTokenQueryItem = Smithy.URIQueryItem(name: "continuationToken".urlPercentEncoding(), value: Swift.String(continuationToken).urlPercentEncoding())
            items.append(continuationTokenQueryItem)
        }
        return items
    }
}

extension ListTablesInput {

    static func urlPathProvider(_ value: ListTablesInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())"
    }
}

extension ListTablesInput {

    static func queryItemProvider(_ value: ListTablesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxTables = value.maxTables {
            let maxTablesQueryItem = Smithy.URIQueryItem(name: "maxTables".urlPercentEncoding(), value: Swift.String(maxTables).urlPercentEncoding())
            items.append(maxTablesQueryItem)
        }
        if let `prefix` = value.`prefix` {
            let prefixQueryItem = Smithy.URIQueryItem(name: "prefix".urlPercentEncoding(), value: Swift.String(`prefix`).urlPercentEncoding())
            items.append(prefixQueryItem)
        }
        if let namespace = value.namespace {
            let namespaceQueryItem = Smithy.URIQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        if let continuationToken = value.continuationToken {
            let continuationTokenQueryItem = Smithy.URIQueryItem(name: "continuationToken".urlPercentEncoding(), value: Swift.String(continuationToken).urlPercentEncoding())
            items.append(continuationTokenQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tag/\(resourceArn.urlPercentEncoding())"
    }
}

extension PutTableBucketEncryptionInput {

    static func urlPathProvider(_ value: PutTableBucketEncryptionInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/buckets/\(tableBucketARN.urlPercentEncoding())/encryption"
    }
}

extension PutTableBucketMaintenanceConfigurationInput {

    static func urlPathProvider(_ value: PutTableBucketMaintenanceConfigurationInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let type = value.type else {
            return nil
        }
        return "/buckets/\(tableBucketARN.urlPercentEncoding())/maintenance/\(type.rawValue.urlPercentEncoding())"
    }
}

extension PutTableBucketPolicyInput {

    static func urlPathProvider(_ value: PutTableBucketPolicyInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/buckets/\(tableBucketARN.urlPercentEncoding())/policy"
    }
}

extension PutTableMaintenanceConfigurationInput {

    static func urlPathProvider(_ value: PutTableMaintenanceConfigurationInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        guard let type = value.type else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/maintenance/\(type.rawValue.urlPercentEncoding())"
    }
}

extension PutTablePolicyInput {

    static func urlPathProvider(_ value: PutTablePolicyInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/policy"
    }
}

extension RenameTableInput {

    static func urlPathProvider(_ value: RenameTableInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/rename"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tag/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tag/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateTableMetadataLocationInput {

    static func urlPathProvider(_ value: UpdateTableMetadataLocationInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/metadata-location"
    }
}

extension CreateNamespaceInput {

    static func write(value: CreateNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["namespace"].writeList(value.namespace, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateTableInput {

    static func write(value: CreateTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: S3TablesClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["format"].write(value.format)
        try writer["metadata"].write(value.metadata, with: S3TablesClientTypes.TableMetadata.write(value:to:))
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateTableBucketInput {

    static func write(value: CreateTableBucketInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: S3TablesClientTypes.EncryptionConfiguration.write(value:to:))
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PutTableBucketEncryptionInput {

    static func write(value: PutTableBucketEncryptionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionConfiguration"].write(value.encryptionConfiguration, with: S3TablesClientTypes.EncryptionConfiguration.write(value:to:))
    }
}

extension PutTableBucketMaintenanceConfigurationInput {

    static func write(value: PutTableBucketMaintenanceConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["value"].write(value.value, with: S3TablesClientTypes.TableBucketMaintenanceConfigurationValue.write(value:to:))
    }
}

extension PutTableBucketPolicyInput {

    static func write(value: PutTableBucketPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourcePolicy"].write(value.resourcePolicy)
    }
}

extension PutTableMaintenanceConfigurationInput {

    static func write(value: PutTableMaintenanceConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["value"].write(value.value, with: S3TablesClientTypes.TableMaintenanceConfigurationValue.write(value:to:))
    }
}

extension PutTablePolicyInput {

    static func write(value: PutTablePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourcePolicy"].write(value.resourcePolicy)
    }
}

extension RenameTableInput {

    static func write(value: RenameTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["newName"].write(value.newName)
        try writer["newNamespaceName"].write(value.newNamespaceName)
        try writer["versionToken"].write(value.versionToken)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateTableMetadataLocationInput {

    static func write(value: UpdateTableMetadataLocationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metadataLocation"].write(value.metadataLocation)
        try writer["versionToken"].write(value.versionToken)
    }
}

extension CreateNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateNamespaceOutput()
        value.namespace = try reader["namespace"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tableBucketARN = try reader["tableBucketARN"].readIfPresent() ?? ""
        return value
    }
}

extension CreateTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTableOutput()
        value.tableARN = try reader["tableARN"].readIfPresent() ?? ""
        value.versionToken = try reader["versionToken"].readIfPresent() ?? ""
        return value
    }
}

extension CreateTableBucketOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTableBucketOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTableBucketOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteNamespaceOutput {
        return DeleteNamespaceOutput()
    }
}

extension DeleteTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTableOutput {
        return DeleteTableOutput()
    }
}

extension DeleteTableBucketOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTableBucketOutput {
        return DeleteTableBucketOutput()
    }
}

extension DeleteTableBucketEncryptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTableBucketEncryptionOutput {
        return DeleteTableBucketEncryptionOutput()
    }
}

extension DeleteTableBucketPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTableBucketPolicyOutput {
        return DeleteTableBucketPolicyOutput()
    }
}

extension DeleteTablePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTablePolicyOutput {
        return DeleteTablePolicyOutput()
    }
}

extension GetNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNamespaceOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.namespace = try reader["namespace"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.namespaceId = try reader["namespaceId"].readIfPresent()
        value.ownerAccountId = try reader["ownerAccountId"].readIfPresent() ?? ""
        value.tableBucketId = try reader["tableBucketId"].readIfPresent()
        return value
    }
}

extension GetTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.format = try reader["format"].readIfPresent() ?? .sdkUnknown("")
        value.managedByService = try reader["managedByService"].readIfPresent()
        value.metadataLocation = try reader["metadataLocation"].readIfPresent()
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modifiedBy = try reader["modifiedBy"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.namespace = try reader["namespace"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.namespaceId = try reader["namespaceId"].readIfPresent()
        value.ownerAccountId = try reader["ownerAccountId"].readIfPresent() ?? ""
        value.tableARN = try reader["tableARN"].readIfPresent() ?? ""
        value.tableBucketId = try reader["tableBucketId"].readIfPresent()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.versionToken = try reader["versionToken"].readIfPresent() ?? ""
        value.warehouseLocation = try reader["warehouseLocation"].readIfPresent() ?? ""
        return value
    }
}

extension GetTableBucketOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableBucketOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableBucketOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.ownerAccountId = try reader["ownerAccountId"].readIfPresent() ?? ""
        value.tableBucketId = try reader["tableBucketId"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension GetTableBucketEncryptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableBucketEncryptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableBucketEncryptionOutput()
        value.encryptionConfiguration = try reader["encryptionConfiguration"].readIfPresent(with: S3TablesClientTypes.EncryptionConfiguration.read(from:))
        return value
    }
}

extension GetTableBucketMaintenanceConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableBucketMaintenanceConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableBucketMaintenanceConfigurationOutput()
        value.configuration = try reader["configuration"].readMapIfPresent(valueReadingClosure: S3TablesClientTypes.TableBucketMaintenanceConfigurationValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.tableBucketARN = try reader["tableBucketARN"].readIfPresent() ?? ""
        return value
    }
}

extension GetTableBucketPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableBucketPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableBucketPolicyOutput()
        value.resourcePolicy = try reader["resourcePolicy"].readIfPresent() ?? ""
        return value
    }
}

extension GetTableEncryptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableEncryptionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableEncryptionOutput()
        value.encryptionConfiguration = try reader["encryptionConfiguration"].readIfPresent(with: S3TablesClientTypes.EncryptionConfiguration.read(from:))
        return value
    }
}

extension GetTableMaintenanceConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableMaintenanceConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableMaintenanceConfigurationOutput()
        value.configuration = try reader["configuration"].readMapIfPresent(valueReadingClosure: S3TablesClientTypes.TableMaintenanceConfigurationValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.tableARN = try reader["tableARN"].readIfPresent() ?? ""
        return value
    }
}

extension GetTableMaintenanceJobStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableMaintenanceJobStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableMaintenanceJobStatusOutput()
        value.status = try reader["status"].readMapIfPresent(valueReadingClosure: S3TablesClientTypes.TableMaintenanceJobStatusValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.tableARN = try reader["tableARN"].readIfPresent() ?? ""
        return value
    }
}

extension GetTableMetadataLocationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableMetadataLocationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableMetadataLocationOutput()
        value.metadataLocation = try reader["metadataLocation"].readIfPresent()
        value.versionToken = try reader["versionToken"].readIfPresent() ?? ""
        value.warehouseLocation = try reader["warehouseLocation"].readIfPresent() ?? ""
        return value
    }
}

extension GetTablePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTablePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTablePolicyOutput()
        value.resourcePolicy = try reader["resourcePolicy"].readIfPresent() ?? ""
        return value
    }
}

extension ListNamespacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNamespacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNamespacesOutput()
        value.continuationToken = try reader["continuationToken"].readIfPresent()
        value.namespaces = try reader["namespaces"].readListIfPresent(memberReadingClosure: S3TablesClientTypes.NamespaceSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTableBucketsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTableBucketsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTableBucketsOutput()
        value.continuationToken = try reader["continuationToken"].readIfPresent()
        value.tableBuckets = try reader["tableBuckets"].readListIfPresent(memberReadingClosure: S3TablesClientTypes.TableBucketSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTablesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTablesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTablesOutput()
        value.continuationToken = try reader["continuationToken"].readIfPresent()
        value.tables = try reader["tables"].readListIfPresent(memberReadingClosure: S3TablesClientTypes.TableSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension PutTableBucketEncryptionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutTableBucketEncryptionOutput {
        return PutTableBucketEncryptionOutput()
    }
}

extension PutTableBucketMaintenanceConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutTableBucketMaintenanceConfigurationOutput {
        return PutTableBucketMaintenanceConfigurationOutput()
    }
}

extension PutTableBucketPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutTableBucketPolicyOutput {
        return PutTableBucketPolicyOutput()
    }
}

extension PutTableMaintenanceConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutTableMaintenanceConfigurationOutput {
        return PutTableMaintenanceConfigurationOutput()
    }
}

extension PutTablePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutTablePolicyOutput {
        return PutTablePolicyOutput()
    }
}

extension RenameTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RenameTableOutput {
        return RenameTableOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateTableMetadataLocationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTableMetadataLocationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTableMetadataLocationOutput()
        value.metadataLocation = try reader["metadataLocation"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.namespace = try reader["namespace"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tableARN = try reader["tableARN"].readIfPresent() ?? ""
        value.versionToken = try reader["versionToken"].readIfPresent() ?? ""
        return value
    }
}

enum CreateNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTableBucketOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTableBucketOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTableBucketEncryptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTableBucketPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTablePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableBucketOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableBucketEncryptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableBucketMaintenanceConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableBucketPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableEncryptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableMaintenanceConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableMaintenanceJobStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableMetadataLocationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTablePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNamespacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTableBucketsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTablesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutTableBucketEncryptionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutTableBucketMaintenanceConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutTableBucketPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutTableMaintenanceConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutTablePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RenameTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTableMetadataLocationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServerErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension S3TablesClientTypes.EncryptionConfiguration {

    static func write(value: S3TablesClientTypes.EncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
        try writer["sseAlgorithm"].write(value.sseAlgorithm)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.EncryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3TablesClientTypes.EncryptionConfiguration()
        value.sseAlgorithm = try reader["sseAlgorithm"].readIfPresent() ?? .sdkUnknown("")
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        return value
    }
}

extension S3TablesClientTypes.TableBucketMaintenanceConfigurationValue {

    static func write(value: S3TablesClientTypes.TableBucketMaintenanceConfigurationValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["settings"].write(value.settings, with: S3TablesClientTypes.TableBucketMaintenanceSettings.write(value:to:))
        try writer["status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.TableBucketMaintenanceConfigurationValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3TablesClientTypes.TableBucketMaintenanceConfigurationValue()
        value.status = try reader["status"].readIfPresent()
        value.settings = try reader["settings"].readIfPresent(with: S3TablesClientTypes.TableBucketMaintenanceSettings.read(from:))
        return value
    }
}

extension S3TablesClientTypes.TableBucketMaintenanceSettings {

    static func write(value: S3TablesClientTypes.TableBucketMaintenanceSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .icebergunreferencedfileremoval(icebergunreferencedfileremoval):
                try writer["icebergUnreferencedFileRemoval"].write(icebergunreferencedfileremoval, with: S3TablesClientTypes.IcebergUnreferencedFileRemovalSettings.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.TableBucketMaintenanceSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "icebergUnreferencedFileRemoval":
                return .icebergunreferencedfileremoval(try reader["icebergUnreferencedFileRemoval"].read(with: S3TablesClientTypes.IcebergUnreferencedFileRemovalSettings.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension S3TablesClientTypes.IcebergUnreferencedFileRemovalSettings {

    static func write(value: S3TablesClientTypes.IcebergUnreferencedFileRemovalSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["nonCurrentDays"].write(value.nonCurrentDays)
        try writer["unreferencedDays"].write(value.unreferencedDays)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.IcebergUnreferencedFileRemovalSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3TablesClientTypes.IcebergUnreferencedFileRemovalSettings()
        value.unreferencedDays = try reader["unreferencedDays"].readIfPresent()
        value.nonCurrentDays = try reader["nonCurrentDays"].readIfPresent()
        return value
    }
}

extension S3TablesClientTypes.TableMaintenanceConfigurationValue {

    static func write(value: S3TablesClientTypes.TableMaintenanceConfigurationValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["settings"].write(value.settings, with: S3TablesClientTypes.TableMaintenanceSettings.write(value:to:))
        try writer["status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.TableMaintenanceConfigurationValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3TablesClientTypes.TableMaintenanceConfigurationValue()
        value.status = try reader["status"].readIfPresent()
        value.settings = try reader["settings"].readIfPresent(with: S3TablesClientTypes.TableMaintenanceSettings.read(from:))
        return value
    }
}

extension S3TablesClientTypes.TableMaintenanceSettings {

    static func write(value: S3TablesClientTypes.TableMaintenanceSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .icebergcompaction(icebergcompaction):
                try writer["icebergCompaction"].write(icebergcompaction, with: S3TablesClientTypes.IcebergCompactionSettings.write(value:to:))
            case let .icebergsnapshotmanagement(icebergsnapshotmanagement):
                try writer["icebergSnapshotManagement"].write(icebergsnapshotmanagement, with: S3TablesClientTypes.IcebergSnapshotManagementSettings.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.TableMaintenanceSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "icebergCompaction":
                return .icebergcompaction(try reader["icebergCompaction"].read(with: S3TablesClientTypes.IcebergCompactionSettings.read(from:)))
            case "icebergSnapshotManagement":
                return .icebergsnapshotmanagement(try reader["icebergSnapshotManagement"].read(with: S3TablesClientTypes.IcebergSnapshotManagementSettings.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension S3TablesClientTypes.IcebergSnapshotManagementSettings {

    static func write(value: S3TablesClientTypes.IcebergSnapshotManagementSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxSnapshotAgeHours"].write(value.maxSnapshotAgeHours)
        try writer["minSnapshotsToKeep"].write(value.minSnapshotsToKeep)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.IcebergSnapshotManagementSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3TablesClientTypes.IcebergSnapshotManagementSettings()
        value.minSnapshotsToKeep = try reader["minSnapshotsToKeep"].readIfPresent()
        value.maxSnapshotAgeHours = try reader["maxSnapshotAgeHours"].readIfPresent()
        return value
    }
}

extension S3TablesClientTypes.IcebergCompactionSettings {

    static func write(value: S3TablesClientTypes.IcebergCompactionSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["strategy"].write(value.strategy)
        try writer["targetFileSizeMB"].write(value.targetFileSizeMB)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.IcebergCompactionSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3TablesClientTypes.IcebergCompactionSettings()
        value.targetFileSizeMB = try reader["targetFileSizeMB"].readIfPresent()
        value.strategy = try reader["strategy"].readIfPresent()
        return value
    }
}

extension S3TablesClientTypes.TableMaintenanceJobStatusValue {

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.TableMaintenanceJobStatusValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3TablesClientTypes.TableMaintenanceJobStatusValue()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.lastRunTimestamp = try reader["lastRunTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        return value
    }
}

extension S3TablesClientTypes.NamespaceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.NamespaceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3TablesClientTypes.NamespaceSummary()
        value.namespace = try reader["namespace"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.ownerAccountId = try reader["ownerAccountId"].readIfPresent() ?? ""
        value.namespaceId = try reader["namespaceId"].readIfPresent()
        value.tableBucketId = try reader["tableBucketId"].readIfPresent()
        return value
    }
}

extension S3TablesClientTypes.TableBucketSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.TableBucketSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3TablesClientTypes.TableBucketSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.ownerAccountId = try reader["ownerAccountId"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.tableBucketId = try reader["tableBucketId"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension S3TablesClientTypes.TableSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.TableSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3TablesClientTypes.TableSummary()
        value.namespace = try reader["namespace"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.tableARN = try reader["tableARN"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.namespaceId = try reader["namespaceId"].readIfPresent()
        value.tableBucketId = try reader["tableBucketId"].readIfPresent()
        return value
    }
}

extension S3TablesClientTypes.TableMetadata {

    static func write(value: S3TablesClientTypes.TableMetadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .iceberg(iceberg):
                try writer["iceberg"].write(iceberg, with: S3TablesClientTypes.IcebergMetadata.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension S3TablesClientTypes.IcebergMetadata {

    static func write(value: S3TablesClientTypes.IcebergMetadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["schema"].write(value.schema, with: S3TablesClientTypes.IcebergSchema.write(value:to:))
    }
}

extension S3TablesClientTypes.IcebergSchema {

    static func write(value: S3TablesClientTypes.IcebergSchema?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fields"].writeList(value.fields, memberWritingClosure: S3TablesClientTypes.SchemaField.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension S3TablesClientTypes.SchemaField {

    static func write(value: S3TablesClientTypes.SchemaField?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["required"].write(value.`required`)
        try writer["type"].write(value.type)
    }
}

public enum S3TablesClientTypes {}
