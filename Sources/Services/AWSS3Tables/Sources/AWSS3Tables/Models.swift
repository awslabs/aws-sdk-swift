//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct DeleteNamespaceOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTableBucketOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTableBucketPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTableOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTablePolicyOutput: Swift.Sendable {

    public init() { }
}

public struct PutTableBucketMaintenanceConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct PutTableBucketPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct PutTableMaintenanceConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct PutTablePolicyOutput: Swift.Sendable {

    public init() { }
}

public struct RenameTableOutput: Swift.Sendable {

    public init() { }
}

/// The action cannot be performed because you do not have the required permission.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request is invalid or malformed.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request failed because there is a conflict with a previous write. You can retry the request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The caller isn't authorized to make the request.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request failed due to an internal server error.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request was rejected because the specified resource could not be found.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The limit on the number of requests per second was exceeded.
public struct TooManyRequestsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyRequestsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct CreateNamespaceInput: Swift.Sendable {
    /// A name for the namespace.
    /// This member is required.
    public var namespace: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the table bucket to create the namespace in.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        namespace: [Swift.String]? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

public struct CreateNamespaceOutput: Swift.Sendable {
    /// The name of the namespace.
    /// This member is required.
    public var namespace: [Swift.String]?
    /// The Amazon Resource Name (ARN) of the table bucket the namespace was created in.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        namespace: [Swift.String]? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

extension S3TablesClientTypes {

    public enum OpenTableFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iceberg
        case sdkUnknown(Swift.String)

        public static var allCases: [OpenTableFormat] {
            return [
                .iceberg
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iceberg: return "ICEBERG"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateTableInput: Swift.Sendable {
    /// The format for the table.
    /// This member is required.
    public var format: S3TablesClientTypes.OpenTableFormat?
    /// The name for the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace to associated with the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket to create the table in.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        format: S3TablesClientTypes.OpenTableFormat? = nil,
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.format = format
        self.name = name
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

public struct CreateTableOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the table.
    /// This member is required.
    public var tableARN: Swift.String?
    /// The version token of the table.
    /// This member is required.
    public var versionToken: Swift.String?

    public init(
        tableARN: Swift.String? = nil,
        versionToken: Swift.String? = nil
    ) {
        self.tableARN = tableARN
        self.versionToken = versionToken
    }
}

public struct CreateTableBucketInput: Swift.Sendable {
    /// The name for the table bucket.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    ) {
        self.name = name
    }
}

public struct CreateTableBucketOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct DeleteNamespaceInput: Swift.Sendable {
    /// The name of the namespace.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket associated with the namespace.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

public struct DeleteTableInput: Swift.Sendable {
    /// The name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace associated with the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket that contains the table.
    /// This member is required.
    public var tableBucketARN: Swift.String?
    /// The version token of the table.
    public var versionToken: Swift.String?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil,
        versionToken: Swift.String? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
        self.versionToken = versionToken
    }
}

public struct DeleteTableBucketInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        tableBucketARN: Swift.String? = nil
    ) {
        self.tableBucketARN = tableBucketARN
    }
}

public struct DeleteTableBucketPolicyInput: Swift.Sendable {
    /// The Amazon Resource Number (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        tableBucketARN: Swift.String? = nil
    ) {
        self.tableBucketARN = tableBucketARN
    }
}

public struct DeleteTablePolicyInput: Swift.Sendable {
    /// The table name.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace associated with the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Number (ARN) of the table bucket that contains the table.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

public struct GetNamespaceInput: Swift.Sendable {
    /// The name of the namespace.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

public struct GetNamespaceOutput: Swift.Sendable {
    /// The date and time the namespace was created at.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The ID of the account that created the namespace.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The name of the namespace.
    /// This member is required.
    public var namespace: [Swift.String]?
    /// The ID of the account that owns the namespcace.
    /// This member is required.
    public var ownerAccountId: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        namespace: [Swift.String]? = nil,
        ownerAccountId: Swift.String? = nil
    ) {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.namespace = namespace
        self.ownerAccountId = ownerAccountId
    }
}

public struct GetTableInput: Swift.Sendable {
    /// The name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the namespace the table is associated with.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket associated with the table.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

extension S3TablesClientTypes {

    public enum TableType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aws
        case customer
        case sdkUnknown(Swift.String)

        public static var allCases: [TableType] {
            return [
                .aws,
                .customer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aws: return "aws"
            case .customer: return "customer"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetTableOutput: Swift.Sendable {
    /// The date and time the table bucket was created at.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The ID of the account that created the table.
    /// This member is required.
    public var createdBy: Swift.String?
    /// The format of the table.
    /// This member is required.
    public var format: S3TablesClientTypes.OpenTableFormat?
    /// The service that manages the table.
    public var managedByService: Swift.String?
    /// The metadata location of the table.
    public var metadataLocation: Swift.String?
    /// The date and time the table was last modified on.
    /// This member is required.
    public var modifiedAt: Foundation.Date?
    /// The ID of the account that last modified the table.
    /// This member is required.
    public var modifiedBy: Swift.String?
    /// The name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace associated with the table.
    /// This member is required.
    public var namespace: [Swift.String]?
    /// The ID of the account that owns the table.
    /// This member is required.
    public var ownerAccountId: Swift.String?
    /// The Amazon Resource Name (ARN) of the table.
    /// This member is required.
    public var tableARN: Swift.String?
    /// The type of the table.
    /// This member is required.
    public var type: S3TablesClientTypes.TableType?
    /// The version token of the table.
    /// This member is required.
    public var versionToken: Swift.String?
    /// The warehouse location of the table.
    /// This member is required.
    public var warehouseLocation: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        createdBy: Swift.String? = nil,
        format: S3TablesClientTypes.OpenTableFormat? = nil,
        managedByService: Swift.String? = nil,
        metadataLocation: Swift.String? = nil,
        modifiedAt: Foundation.Date? = nil,
        modifiedBy: Swift.String? = nil,
        name: Swift.String? = nil,
        namespace: [Swift.String]? = nil,
        ownerAccountId: Swift.String? = nil,
        tableARN: Swift.String? = nil,
        type: S3TablesClientTypes.TableType? = nil,
        versionToken: Swift.String? = nil,
        warehouseLocation: Swift.String? = nil
    ) {
        self.createdAt = createdAt
        self.createdBy = createdBy
        self.format = format
        self.managedByService = managedByService
        self.metadataLocation = metadataLocation
        self.modifiedAt = modifiedAt
        self.modifiedBy = modifiedBy
        self.name = name
        self.namespace = namespace
        self.ownerAccountId = ownerAccountId
        self.tableARN = tableARN
        self.type = type
        self.versionToken = versionToken
        self.warehouseLocation = warehouseLocation
    }
}

public struct GetTableBucketInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        tableBucketARN: Swift.String? = nil
    ) {
        self.tableBucketARN = tableBucketARN
    }
}

public struct GetTableBucketOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var arn: Swift.String?
    /// The date and time the table bucket was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The name of the table bucket
    /// This member is required.
    public var name: Swift.String?
    /// The ID of the account that owns the table bucket.
    /// This member is required.
    public var ownerAccountId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        name: Swift.String? = nil,
        ownerAccountId: Swift.String? = nil
    ) {
        self.arn = arn
        self.createdAt = createdAt
        self.name = name
        self.ownerAccountId = ownerAccountId
    }
}

public struct GetTableBucketMaintenanceConfigurationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the table bucket associated with the maintenance configuration.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        tableBucketARN: Swift.String? = nil
    ) {
        self.tableBucketARN = tableBucketARN
    }
}

extension S3TablesClientTypes {

    public enum TableBucketMaintenanceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case icebergUnreferencedFileRemoval
        case sdkUnknown(Swift.String)

        public static var allCases: [TableBucketMaintenanceType] {
            return [
                .icebergUnreferencedFileRemoval
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .icebergUnreferencedFileRemoval: return "icebergUnreferencedFileRemoval"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension S3TablesClientTypes {

    /// Contains details about the unreferenced file removal settings for an Iceberg table bucket.
    public struct IcebergUnreferencedFileRemovalSettings: Swift.Sendable {
        /// The number of days an object has to be non-current before it is deleted.
        public var nonCurrentDays: Swift.Int?
        /// The number of days an object has to be unreferenced before it is marked as non-current.
        public var unreferencedDays: Swift.Int?

        public init(
            nonCurrentDays: Swift.Int? = nil,
            unreferencedDays: Swift.Int? = nil
        ) {
            self.nonCurrentDays = nonCurrentDays
            self.unreferencedDays = unreferencedDays
        }
    }
}

extension S3TablesClientTypes {

    /// Contains details about the maintenance settings for the table bucket.
    public enum TableBucketMaintenanceSettings: Swift.Sendable {
        /// The unreferenced file removal settings for the table bucket.
        case icebergunreferencedfileremoval(S3TablesClientTypes.IcebergUnreferencedFileRemovalSettings)
        case sdkUnknown(Swift.String)
    }
}

extension S3TablesClientTypes {

    public enum MaintenanceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "disabled"
            case .enabled: return "enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension S3TablesClientTypes {

    /// Details about the values that define the maintenance configuration for a table bucket.
    public struct TableBucketMaintenanceConfigurationValue: Swift.Sendable {
        /// Contains details about the settings of the maintenance configuration.
        public var settings: S3TablesClientTypes.TableBucketMaintenanceSettings?
        /// The status of the maintenance configuration.
        public var status: S3TablesClientTypes.MaintenanceStatus?

        public init(
            settings: S3TablesClientTypes.TableBucketMaintenanceSettings? = nil,
            status: S3TablesClientTypes.MaintenanceStatus? = nil
        ) {
            self.settings = settings
            self.status = status
        }
    }
}

public struct GetTableBucketMaintenanceConfigurationOutput: Swift.Sendable {
    /// Details about the maintenance configuration for the table bucket.
    /// This member is required.
    public var configuration: [Swift.String: S3TablesClientTypes.TableBucketMaintenanceConfigurationValue]?
    /// The Amazon Resource Name (ARN) of the table bucket associated with the maintenance configuration.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        configuration: [Swift.String: S3TablesClientTypes.TableBucketMaintenanceConfigurationValue]? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.configuration = configuration
        self.tableBucketARN = tableBucketARN
    }
}

public struct GetTableBucketPolicyInput: Swift.Sendable {
    /// The Amazon Resource Number (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        tableBucketARN: Swift.String? = nil
    ) {
        self.tableBucketARN = tableBucketARN
    }
}

public struct GetTableBucketPolicyOutput: Swift.Sendable {
    /// The name of the resource policy.
    /// This member is required.
    public var resourcePolicy: Swift.String?

    public init(
        resourcePolicy: Swift.String? = nil
    ) {
        self.resourcePolicy = resourcePolicy
    }
}

public struct GetTableMaintenanceConfigurationInput: Swift.Sendable {
    /// The name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace associated with the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

extension S3TablesClientTypes {

    public enum TableMaintenanceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case icebergCompaction
        case icebergSnapshotManagement
        case sdkUnknown(Swift.String)

        public static var allCases: [TableMaintenanceType] {
            return [
                .icebergCompaction,
                .icebergSnapshotManagement
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .icebergCompaction: return "icebergCompaction"
            case .icebergSnapshotManagement: return "icebergSnapshotManagement"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension S3TablesClientTypes {

    /// Contains details about the compaction settings for an Iceberg table.
    public struct IcebergCompactionSettings: Swift.Sendable {
        /// The target file size for the table in MB.
        public var targetFileSizeMB: Swift.Int?

        public init(
            targetFileSizeMB: Swift.Int? = nil
        ) {
            self.targetFileSizeMB = targetFileSizeMB
        }
    }
}

extension S3TablesClientTypes {

    /// Contains details about the snapshot management settings for an Iceberg table. The oldest snapshot expires when its age exceeds the maxSnapshotAgeHours and the total number of snapshots exceeds the value for the minimum number of snapshots to keep minSnapshotsToKeep.
    public struct IcebergSnapshotManagementSettings: Swift.Sendable {
        /// The maximum age of a snapshot before it can be expired.
        public var maxSnapshotAgeHours: Swift.Int?
        /// The minimum number of snapshots to keep.
        public var minSnapshotsToKeep: Swift.Int?

        public init(
            maxSnapshotAgeHours: Swift.Int? = nil,
            minSnapshotsToKeep: Swift.Int? = nil
        ) {
            self.maxSnapshotAgeHours = maxSnapshotAgeHours
            self.minSnapshotsToKeep = minSnapshotsToKeep
        }
    }
}

extension S3TablesClientTypes {

    /// Contains details about maintenance settings for the table.
    public enum TableMaintenanceSettings: Swift.Sendable {
        /// Contains details about the Iceberg compaction settings for the table.
        case icebergcompaction(S3TablesClientTypes.IcebergCompactionSettings)
        /// Contains details about the Iceberg snapshot management settings for the table.
        case icebergsnapshotmanagement(S3TablesClientTypes.IcebergSnapshotManagementSettings)
        case sdkUnknown(Swift.String)
    }
}

extension S3TablesClientTypes {

    /// Contains the values that define a maintenance configuration for a table.
    public struct TableMaintenanceConfigurationValue: Swift.Sendable {
        /// Contains details about the settings for the maintenance configuration.
        public var settings: S3TablesClientTypes.TableMaintenanceSettings?
        /// The status of the maintenance configuration.
        public var status: S3TablesClientTypes.MaintenanceStatus?

        public init(
            settings: S3TablesClientTypes.TableMaintenanceSettings? = nil,
            status: S3TablesClientTypes.MaintenanceStatus? = nil
        ) {
            self.settings = settings
            self.status = status
        }
    }
}

public struct GetTableMaintenanceConfigurationOutput: Swift.Sendable {
    /// Details about the maintenance configuration for the table bucket.
    /// This member is required.
    public var configuration: [Swift.String: S3TablesClientTypes.TableMaintenanceConfigurationValue]?
    /// The Amazon Resource Name (ARN) of the table.
    /// This member is required.
    public var tableARN: Swift.String?

    public init(
        configuration: [Swift.String: S3TablesClientTypes.TableMaintenanceConfigurationValue]? = nil,
        tableARN: Swift.String? = nil
    ) {
        self.configuration = configuration
        self.tableARN = tableARN
    }
}

public struct GetTableMaintenanceJobStatusInput: Swift.Sendable {
    /// The name of the maintenance job.
    /// This member is required.
    public var name: Swift.String?
    /// The name of the namespace the table is associated with.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

extension S3TablesClientTypes {

    public enum TableMaintenanceJobType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case icebergCompaction
        case icebergSnapshotManagement
        case icebergUnreferencedFileRemoval
        case sdkUnknown(Swift.String)

        public static var allCases: [TableMaintenanceJobType] {
            return [
                .icebergCompaction,
                .icebergSnapshotManagement,
                .icebergUnreferencedFileRemoval
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .icebergCompaction: return "icebergCompaction"
            case .icebergSnapshotManagement: return "icebergSnapshotManagement"
            case .icebergUnreferencedFileRemoval: return "icebergUnreferencedFileRemoval"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension S3TablesClientTypes {

    public enum JobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case failed
        case notYetRun
        case successful
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .disabled,
                .failed,
                .notYetRun,
                .successful
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "Disabled"
            case .failed: return "Failed"
            case .notYetRun: return "Not_Yet_Run"
            case .successful: return "Successful"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension S3TablesClientTypes {

    /// Details about the status of a maintenance job.
    public struct TableMaintenanceJobStatusValue: Swift.Sendable {
        /// The failure message of a failed job.
        public var failureMessage: Swift.String?
        /// The date and time that the maintenance job was last run.
        public var lastRunTimestamp: Foundation.Date?
        /// The status of the job.
        /// This member is required.
        public var status: S3TablesClientTypes.JobStatus?

        public init(
            failureMessage: Swift.String? = nil,
            lastRunTimestamp: Foundation.Date? = nil,
            status: S3TablesClientTypes.JobStatus? = nil
        ) {
            self.failureMessage = failureMessage
            self.lastRunTimestamp = lastRunTimestamp
            self.status = status
        }
    }
}

public struct GetTableMaintenanceJobStatusOutput: Swift.Sendable {
    /// The status of the maintenance job.
    /// This member is required.
    public var status: [Swift.String: S3TablesClientTypes.TableMaintenanceJobStatusValue]?
    /// The Amazon Resource Name (ARN) of the table.
    /// This member is required.
    public var tableARN: Swift.String?

    public init(
        status: [Swift.String: S3TablesClientTypes.TableMaintenanceJobStatusValue]? = nil,
        tableARN: Swift.String? = nil
    ) {
        self.status = status
        self.tableARN = tableARN
    }
}

public struct GetTableMetadataLocationInput: Swift.Sendable {
    /// The name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace of the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

public struct GetTableMetadataLocationOutput: Swift.Sendable {
    /// The metadata location.
    public var metadataLocation: Swift.String?
    /// The version token.
    /// This member is required.
    public var versionToken: Swift.String?
    /// The warehouse location.
    /// This member is required.
    public var warehouseLocation: Swift.String?

    public init(
        metadataLocation: Swift.String? = nil,
        versionToken: Swift.String? = nil,
        warehouseLocation: Swift.String? = nil
    ) {
        self.metadataLocation = metadataLocation
        self.versionToken = versionToken
        self.warehouseLocation = warehouseLocation
    }
}

public struct GetTablePolicyInput: Swift.Sendable {
    /// The name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace associated with the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Number (ARN) of the table bucket that contains the table.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
    }
}

public struct GetTablePolicyOutput: Swift.Sendable {
    /// The name of the resource policy.
    /// This member is required.
    public var resourcePolicy: Swift.String?

    public init(
        resourcePolicy: Swift.String? = nil
    ) {
        self.resourcePolicy = resourcePolicy
    }
}

public struct ListNamespacesInput: Swift.Sendable {
    /// ContinuationToken indicates to Amazon S3 that the list is being continued on this bucket with a token. ContinuationToken is obfuscated and is not a real key. You can use this ContinuationToken for pagination of the list results.
    public var continuationToken: Swift.String?
    /// The maximum number of namespaces to return in the list.
    public var maxNamespaces: Swift.Int?
    /// The prefix of the namespaces.
    public var `prefix`: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        continuationToken: Swift.String? = nil,
        maxNamespaces: Swift.Int? = nil,
        `prefix`: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.continuationToken = continuationToken
        self.maxNamespaces = maxNamespaces
        self.`prefix` = `prefix`
        self.tableBucketARN = tableBucketARN
    }
}

extension S3TablesClientTypes {

    /// Contains details about a namespace.
    public struct NamespaceSummary: Swift.Sendable {
        /// The date and time the namespace was created at.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The ID of the account that created the namespace.
        /// This member is required.
        public var createdBy: Swift.String?
        /// The name of the namespace.
        /// This member is required.
        public var namespace: [Swift.String]?
        /// The ID of the account that owns the namespace.
        /// This member is required.
        public var ownerAccountId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            createdBy: Swift.String? = nil,
            namespace: [Swift.String]? = nil,
            ownerAccountId: Swift.String? = nil
        ) {
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.namespace = namespace
            self.ownerAccountId = ownerAccountId
        }
    }
}

public struct ListNamespacesOutput: Swift.Sendable {
    /// The ContinuationToken for pagination of the list results.
    public var continuationToken: Swift.String?
    /// A list of namespaces.
    /// This member is required.
    public var namespaces: [S3TablesClientTypes.NamespaceSummary]?

    public init(
        continuationToken: Swift.String? = nil,
        namespaces: [S3TablesClientTypes.NamespaceSummary]? = nil
    ) {
        self.continuationToken = continuationToken
        self.namespaces = namespaces
    }
}

public struct ListTableBucketsInput: Swift.Sendable {
    /// ContinuationToken indicates to Amazon S3 that the list is being continued on this bucket with a token. ContinuationToken is obfuscated and is not a real key. You can use this ContinuationToken for pagination of the list results.
    public var continuationToken: Swift.String?
    /// The maximum number of table buckets to return in the list.
    public var maxBuckets: Swift.Int?
    /// The prefix of the table buckets.
    public var `prefix`: Swift.String?

    public init(
        continuationToken: Swift.String? = nil,
        maxBuckets: Swift.Int? = nil,
        `prefix`: Swift.String? = nil
    ) {
        self.continuationToken = continuationToken
        self.maxBuckets = maxBuckets
        self.`prefix` = `prefix`
    }
}

extension S3TablesClientTypes {

    /// Contains details about a table bucket.
    public struct TableBucketSummary: Swift.Sendable {
        /// The Amazon Resource Number (ARN) of the table bucket.
        /// This member is required.
        public var arn: Swift.String?
        /// The date and time the table bucket was created at.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The name of the table bucket.
        /// This member is required.
        public var name: Swift.String?
        /// The ID of the account that owns the table bucket.
        /// This member is required.
        public var ownerAccountId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.name = name
            self.ownerAccountId = ownerAccountId
        }
    }
}

public struct ListTableBucketsOutput: Swift.Sendable {
    /// You can use this ContinuationToken for pagination of the list results.
    public var continuationToken: Swift.String?
    /// A list of table buckets.
    /// This member is required.
    public var tableBuckets: [S3TablesClientTypes.TableBucketSummary]?

    public init(
        continuationToken: Swift.String? = nil,
        tableBuckets: [S3TablesClientTypes.TableBucketSummary]? = nil
    ) {
        self.continuationToken = continuationToken
        self.tableBuckets = tableBuckets
    }
}

public struct ListTablesInput: Swift.Sendable {
    /// ContinuationToken indicates to Amazon S3 that the list is being continued on this bucket with a token. ContinuationToken is obfuscated and is not a real key. You can use this ContinuationToken for pagination of the list results.
    public var continuationToken: Swift.String?
    /// The maximum number of tables to return.
    public var maxTables: Swift.Int?
    /// The namespace of the tables.
    public var namespace: Swift.String?
    /// The prefix of the tables.
    public var `prefix`: Swift.String?
    /// The Amazon resource Number (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        continuationToken: Swift.String? = nil,
        maxTables: Swift.Int? = nil,
        namespace: Swift.String? = nil,
        `prefix`: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.continuationToken = continuationToken
        self.maxTables = maxTables
        self.namespace = namespace
        self.`prefix` = `prefix`
        self.tableBucketARN = tableBucketARN
    }
}

extension S3TablesClientTypes {

    /// Contains details about a table.
    public struct TableSummary: Swift.Sendable {
        /// The date and time the table was created at.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The date and time the table was last modified at.
        /// This member is required.
        public var modifiedAt: Foundation.Date?
        /// The name of the table.
        /// This member is required.
        public var name: Swift.String?
        /// The name of the namespace.
        /// This member is required.
        public var namespace: [Swift.String]?
        /// The Amazon Resource Number (ARN) of the table.
        /// This member is required.
        public var tableARN: Swift.String?
        /// The type of the table.
        /// This member is required.
        public var type: S3TablesClientTypes.TableType?

        public init(
            createdAt: Foundation.Date? = nil,
            modifiedAt: Foundation.Date? = nil,
            name: Swift.String? = nil,
            namespace: [Swift.String]? = nil,
            tableARN: Swift.String? = nil,
            type: S3TablesClientTypes.TableType? = nil
        ) {
            self.createdAt = createdAt
            self.modifiedAt = modifiedAt
            self.name = name
            self.namespace = namespace
            self.tableARN = tableARN
            self.type = type
        }
    }
}

public struct ListTablesOutput: Swift.Sendable {
    /// You can use this ContinuationToken for pagination of the list results.
    public var continuationToken: Swift.String?
    /// A list of tables.
    /// This member is required.
    public var tables: [S3TablesClientTypes.TableSummary]?

    public init(
        continuationToken: Swift.String? = nil,
        tables: [S3TablesClientTypes.TableSummary]? = nil
    ) {
        self.continuationToken = continuationToken
        self.tables = tables
    }
}

public struct PutTableBucketMaintenanceConfigurationInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the table bucket associated with the maintenance configuration.
    /// This member is required.
    public var tableBucketARN: Swift.String?
    /// The type of the maintenance configuration.
    /// This member is required.
    public var type: S3TablesClientTypes.TableBucketMaintenanceType?
    /// Defines the values of the maintenance configuration for the table bucket.
    /// This member is required.
    public var value: S3TablesClientTypes.TableBucketMaintenanceConfigurationValue?

    public init(
        tableBucketARN: Swift.String? = nil,
        type: S3TablesClientTypes.TableBucketMaintenanceType? = nil,
        value: S3TablesClientTypes.TableBucketMaintenanceConfigurationValue? = nil
    ) {
        self.tableBucketARN = tableBucketARN
        self.type = type
        self.value = value
    }
}

public struct PutTableBucketPolicyInput: Swift.Sendable {
    /// The name of the resource policy.
    /// This member is required.
    public var resourcePolicy: Swift.String?
    /// The Amazon Resource Number (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        resourcePolicy: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.resourcePolicy = resourcePolicy
        self.tableBucketARN = tableBucketARN
    }
}

public struct PutTableMaintenanceConfigurationInput: Swift.Sendable {
    /// The name of the maintenance configuration.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace of the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table associated with the maintenance configuration.
    /// This member is required.
    public var tableBucketARN: Swift.String?
    /// The type of the maintenance configuration.
    /// This member is required.
    public var type: S3TablesClientTypes.TableMaintenanceType?
    /// Defines the values of the maintenance configuration for the table.
    /// This member is required.
    public var value: S3TablesClientTypes.TableMaintenanceConfigurationValue?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil,
        type: S3TablesClientTypes.TableMaintenanceType? = nil,
        value: S3TablesClientTypes.TableMaintenanceConfigurationValue? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
        self.type = type
        self.value = value
    }
}

public struct PutTablePolicyInput: Swift.Sendable {
    /// The name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace associated with the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The name of the resource policy.
    /// This member is required.
    public var resourcePolicy: Swift.String?
    /// The Amazon Resource Number (ARN) of the table bucket that contains the table.
    /// This member is required.
    public var tableBucketARN: Swift.String?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        resourcePolicy: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.resourcePolicy = resourcePolicy
        self.tableBucketARN = tableBucketARN
    }
}

public struct RenameTableInput: Swift.Sendable {
    /// The current name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace associated with the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The new name for the table.
    public var newName: Swift.String?
    /// The new name for the namespace.
    public var newNamespaceName: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?
    /// The version token of the table.
    public var versionToken: Swift.String?

    public init(
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        newName: Swift.String? = nil,
        newNamespaceName: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil,
        versionToken: Swift.String? = nil
    ) {
        self.name = name
        self.namespace = namespace
        self.newName = newName
        self.newNamespaceName = newNamespaceName
        self.tableBucketARN = tableBucketARN
        self.versionToken = versionToken
    }
}

public struct UpdateTableMetadataLocationInput: Swift.Sendable {
    /// The new metadata location for the table.
    /// This member is required.
    public var metadataLocation: Swift.String?
    /// The name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace of the table.
    /// This member is required.
    public var namespace: Swift.String?
    /// The Amazon Resource Name (ARN) of the table bucket.
    /// This member is required.
    public var tableBucketARN: Swift.String?
    /// The version token of the table.
    /// This member is required.
    public var versionToken: Swift.String?

    public init(
        metadataLocation: Swift.String? = nil,
        name: Swift.String? = nil,
        namespace: Swift.String? = nil,
        tableBucketARN: Swift.String? = nil,
        versionToken: Swift.String? = nil
    ) {
        self.metadataLocation = metadataLocation
        self.name = name
        self.namespace = namespace
        self.tableBucketARN = tableBucketARN
        self.versionToken = versionToken
    }
}

public struct UpdateTableMetadataLocationOutput: Swift.Sendable {
    /// The metadata location of the table.
    /// This member is required.
    public var metadataLocation: Swift.String?
    /// The name of the table.
    /// This member is required.
    public var name: Swift.String?
    /// The namespace the table is associated with.
    /// This member is required.
    public var namespace: [Swift.String]?
    /// The Amazon Resource Number (ARN) of the table.
    /// This member is required.
    public var tableARN: Swift.String?
    /// The version token of the table.
    /// This member is required.
    public var versionToken: Swift.String?

    public init(
        metadataLocation: Swift.String? = nil,
        name: Swift.String? = nil,
        namespace: [Swift.String]? = nil,
        tableARN: Swift.String? = nil,
        versionToken: Swift.String? = nil
    ) {
        self.metadataLocation = metadataLocation
        self.name = name
        self.namespace = namespace
        self.tableARN = tableARN
        self.versionToken = versionToken
    }
}

extension CreateNamespaceInput {

    static func urlPathProvider(_ value: CreateNamespaceInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/namespaces/\(tableBucketARN.urlPercentEncoding())"
    }
}

extension CreateTableInput {

    static func urlPathProvider(_ value: CreateTableInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())"
    }
}

extension CreateTableBucketInput {

    static func urlPathProvider(_ value: CreateTableBucketInput) -> Swift.String? {
        return "/buckets"
    }
}

extension DeleteNamespaceInput {

    static func urlPathProvider(_ value: DeleteNamespaceInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        return "/namespaces/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())"
    }
}

extension DeleteTableInput {

    static func urlPathProvider(_ value: DeleteTableInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())"
    }
}

extension DeleteTableInput {

    static func queryItemProvider(_ value: DeleteTableInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let versionToken = value.versionToken {
            let versionTokenQueryItem = Smithy.URIQueryItem(name: "versionToken".urlPercentEncoding(), value: Swift.String(versionToken).urlPercentEncoding())
            items.append(versionTokenQueryItem)
        }
        return items
    }
}

extension DeleteTableBucketInput {

    static func urlPathProvider(_ value: DeleteTableBucketInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/buckets/\(tableBucketARN.urlPercentEncoding())"
    }
}

extension DeleteTableBucketPolicyInput {

    static func urlPathProvider(_ value: DeleteTableBucketPolicyInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/buckets/\(tableBucketARN.urlPercentEncoding())/policy"
    }
}

extension DeleteTablePolicyInput {

    static func urlPathProvider(_ value: DeleteTablePolicyInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/policy"
    }
}

extension GetNamespaceInput {

    static func urlPathProvider(_ value: GetNamespaceInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        return "/namespaces/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())"
    }
}

extension GetTableInput {

    static func urlPathProvider(_ value: GetTableInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())"
    }
}

extension GetTableBucketInput {

    static func urlPathProvider(_ value: GetTableBucketInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/buckets/\(tableBucketARN.urlPercentEncoding())"
    }
}

extension GetTableBucketMaintenanceConfigurationInput {

    static func urlPathProvider(_ value: GetTableBucketMaintenanceConfigurationInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/buckets/\(tableBucketARN.urlPercentEncoding())/maintenance"
    }
}

extension GetTableBucketPolicyInput {

    static func urlPathProvider(_ value: GetTableBucketPolicyInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/buckets/\(tableBucketARN.urlPercentEncoding())/policy"
    }
}

extension GetTableMaintenanceConfigurationInput {

    static func urlPathProvider(_ value: GetTableMaintenanceConfigurationInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/maintenance"
    }
}

extension GetTableMaintenanceJobStatusInput {

    static func urlPathProvider(_ value: GetTableMaintenanceJobStatusInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/maintenance-job-status"
    }
}

extension GetTableMetadataLocationInput {

    static func urlPathProvider(_ value: GetTableMetadataLocationInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/metadata-location"
    }
}

extension GetTablePolicyInput {

    static func urlPathProvider(_ value: GetTablePolicyInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/policy"
    }
}

extension ListNamespacesInput {

    static func urlPathProvider(_ value: ListNamespacesInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/namespaces/\(tableBucketARN.urlPercentEncoding())"
    }
}

extension ListNamespacesInput {

    static func queryItemProvider(_ value: ListNamespacesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let `prefix` = value.`prefix` {
            let prefixQueryItem = Smithy.URIQueryItem(name: "prefix".urlPercentEncoding(), value: Swift.String(`prefix`).urlPercentEncoding())
            items.append(prefixQueryItem)
        }
        if let maxNamespaces = value.maxNamespaces {
            let maxNamespacesQueryItem = Smithy.URIQueryItem(name: "maxNamespaces".urlPercentEncoding(), value: Swift.String(maxNamespaces).urlPercentEncoding())
            items.append(maxNamespacesQueryItem)
        }
        if let continuationToken = value.continuationToken {
            let continuationTokenQueryItem = Smithy.URIQueryItem(name: "continuationToken".urlPercentEncoding(), value: Swift.String(continuationToken).urlPercentEncoding())
            items.append(continuationTokenQueryItem)
        }
        return items
    }
}

extension ListTableBucketsInput {

    static func urlPathProvider(_ value: ListTableBucketsInput) -> Swift.String? {
        return "/buckets"
    }
}

extension ListTableBucketsInput {

    static func queryItemProvider(_ value: ListTableBucketsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxBuckets = value.maxBuckets {
            let maxBucketsQueryItem = Smithy.URIQueryItem(name: "maxBuckets".urlPercentEncoding(), value: Swift.String(maxBuckets).urlPercentEncoding())
            items.append(maxBucketsQueryItem)
        }
        if let `prefix` = value.`prefix` {
            let prefixQueryItem = Smithy.URIQueryItem(name: "prefix".urlPercentEncoding(), value: Swift.String(`prefix`).urlPercentEncoding())
            items.append(prefixQueryItem)
        }
        if let continuationToken = value.continuationToken {
            let continuationTokenQueryItem = Smithy.URIQueryItem(name: "continuationToken".urlPercentEncoding(), value: Swift.String(continuationToken).urlPercentEncoding())
            items.append(continuationTokenQueryItem)
        }
        return items
    }
}

extension ListTablesInput {

    static func urlPathProvider(_ value: ListTablesInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())"
    }
}

extension ListTablesInput {

    static func queryItemProvider(_ value: ListTablesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxTables = value.maxTables {
            let maxTablesQueryItem = Smithy.URIQueryItem(name: "maxTables".urlPercentEncoding(), value: Swift.String(maxTables).urlPercentEncoding())
            items.append(maxTablesQueryItem)
        }
        if let `prefix` = value.`prefix` {
            let prefixQueryItem = Smithy.URIQueryItem(name: "prefix".urlPercentEncoding(), value: Swift.String(`prefix`).urlPercentEncoding())
            items.append(prefixQueryItem)
        }
        if let namespace = value.namespace {
            let namespaceQueryItem = Smithy.URIQueryItem(name: "namespace".urlPercentEncoding(), value: Swift.String(namespace).urlPercentEncoding())
            items.append(namespaceQueryItem)
        }
        if let continuationToken = value.continuationToken {
            let continuationTokenQueryItem = Smithy.URIQueryItem(name: "continuationToken".urlPercentEncoding(), value: Swift.String(continuationToken).urlPercentEncoding())
            items.append(continuationTokenQueryItem)
        }
        return items
    }
}

extension PutTableBucketMaintenanceConfigurationInput {

    static func urlPathProvider(_ value: PutTableBucketMaintenanceConfigurationInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let type = value.type else {
            return nil
        }
        return "/buckets/\(tableBucketARN.urlPercentEncoding())/maintenance/\(type.rawValue.urlPercentEncoding())"
    }
}

extension PutTableBucketPolicyInput {

    static func urlPathProvider(_ value: PutTableBucketPolicyInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        return "/buckets/\(tableBucketARN.urlPercentEncoding())/policy"
    }
}

extension PutTableMaintenanceConfigurationInput {

    static func urlPathProvider(_ value: PutTableMaintenanceConfigurationInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        guard let type = value.type else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/maintenance/\(type.rawValue.urlPercentEncoding())"
    }
}

extension PutTablePolicyInput {

    static func urlPathProvider(_ value: PutTablePolicyInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/policy"
    }
}

extension RenameTableInput {

    static func urlPathProvider(_ value: RenameTableInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/rename"
    }
}

extension UpdateTableMetadataLocationInput {

    static func urlPathProvider(_ value: UpdateTableMetadataLocationInput) -> Swift.String? {
        guard let tableBucketARN = value.tableBucketARN else {
            return nil
        }
        guard let namespace = value.namespace else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/tables/\(tableBucketARN.urlPercentEncoding())/\(namespace.urlPercentEncoding())/\(name.urlPercentEncoding())/metadata-location"
    }
}

extension CreateNamespaceInput {

    static func write(value: CreateNamespaceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["namespace"].writeList(value.namespace, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateTableInput {

    static func write(value: CreateTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["format"].write(value.format)
        try writer["name"].write(value.name)
    }
}

extension CreateTableBucketInput {

    static func write(value: CreateTableBucketInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }
}

extension PutTableBucketMaintenanceConfigurationInput {

    static func write(value: PutTableBucketMaintenanceConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["value"].write(value.value, with: S3TablesClientTypes.TableBucketMaintenanceConfigurationValue.write(value:to:))
    }
}

extension PutTableBucketPolicyInput {

    static func write(value: PutTableBucketPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourcePolicy"].write(value.resourcePolicy)
    }
}

extension PutTableMaintenanceConfigurationInput {

    static func write(value: PutTableMaintenanceConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["value"].write(value.value, with: S3TablesClientTypes.TableMaintenanceConfigurationValue.write(value:to:))
    }
}

extension PutTablePolicyInput {

    static func write(value: PutTablePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourcePolicy"].write(value.resourcePolicy)
    }
}

extension RenameTableInput {

    static func write(value: RenameTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["newName"].write(value.newName)
        try writer["newNamespaceName"].write(value.newNamespaceName)
        try writer["versionToken"].write(value.versionToken)
    }
}

extension UpdateTableMetadataLocationInput {

    static func write(value: UpdateTableMetadataLocationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["metadataLocation"].write(value.metadataLocation)
        try writer["versionToken"].write(value.versionToken)
    }
}

extension CreateNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateNamespaceOutput()
        value.namespace = try reader["namespace"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tableBucketARN = try reader["tableBucketARN"].readIfPresent() ?? ""
        return value
    }
}

extension CreateTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTableOutput()
        value.tableARN = try reader["tableARN"].readIfPresent() ?? ""
        value.versionToken = try reader["versionToken"].readIfPresent() ?? ""
        return value
    }
}

extension CreateTableBucketOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTableBucketOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTableBucketOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteNamespaceOutput {
        return DeleteNamespaceOutput()
    }
}

extension DeleteTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTableOutput {
        return DeleteTableOutput()
    }
}

extension DeleteTableBucketOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTableBucketOutput {
        return DeleteTableBucketOutput()
    }
}

extension DeleteTableBucketPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTableBucketPolicyOutput {
        return DeleteTableBucketPolicyOutput()
    }
}

extension DeleteTablePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTablePolicyOutput {
        return DeleteTablePolicyOutput()
    }
}

extension GetNamespaceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetNamespaceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetNamespaceOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.namespace = try reader["namespace"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.ownerAccountId = try reader["ownerAccountId"].readIfPresent() ?? ""
        return value
    }
}

extension GetTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.format = try reader["format"].readIfPresent() ?? .sdkUnknown("")
        value.managedByService = try reader["managedByService"].readIfPresent()
        value.metadataLocation = try reader["metadataLocation"].readIfPresent()
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modifiedBy = try reader["modifiedBy"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.namespace = try reader["namespace"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.ownerAccountId = try reader["ownerAccountId"].readIfPresent() ?? ""
        value.tableARN = try reader["tableARN"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.versionToken = try reader["versionToken"].readIfPresent() ?? ""
        value.warehouseLocation = try reader["warehouseLocation"].readIfPresent() ?? ""
        return value
    }
}

extension GetTableBucketOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableBucketOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableBucketOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.ownerAccountId = try reader["ownerAccountId"].readIfPresent() ?? ""
        return value
    }
}

extension GetTableBucketMaintenanceConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableBucketMaintenanceConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableBucketMaintenanceConfigurationOutput()
        value.configuration = try reader["configuration"].readMapIfPresent(valueReadingClosure: S3TablesClientTypes.TableBucketMaintenanceConfigurationValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.tableBucketARN = try reader["tableBucketARN"].readIfPresent() ?? ""
        return value
    }
}

extension GetTableBucketPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableBucketPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableBucketPolicyOutput()
        value.resourcePolicy = try reader["resourcePolicy"].readIfPresent() ?? ""
        return value
    }
}

extension GetTableMaintenanceConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableMaintenanceConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableMaintenanceConfigurationOutput()
        value.configuration = try reader["configuration"].readMapIfPresent(valueReadingClosure: S3TablesClientTypes.TableMaintenanceConfigurationValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.tableARN = try reader["tableARN"].readIfPresent() ?? ""
        return value
    }
}

extension GetTableMaintenanceJobStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableMaintenanceJobStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableMaintenanceJobStatusOutput()
        value.status = try reader["status"].readMapIfPresent(valueReadingClosure: S3TablesClientTypes.TableMaintenanceJobStatusValue.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.tableARN = try reader["tableARN"].readIfPresent() ?? ""
        return value
    }
}

extension GetTableMetadataLocationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTableMetadataLocationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTableMetadataLocationOutput()
        value.metadataLocation = try reader["metadataLocation"].readIfPresent()
        value.versionToken = try reader["versionToken"].readIfPresent() ?? ""
        value.warehouseLocation = try reader["warehouseLocation"].readIfPresent() ?? ""
        return value
    }
}

extension GetTablePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTablePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTablePolicyOutput()
        value.resourcePolicy = try reader["resourcePolicy"].readIfPresent() ?? ""
        return value
    }
}

extension ListNamespacesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListNamespacesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListNamespacesOutput()
        value.continuationToken = try reader["continuationToken"].readIfPresent()
        value.namespaces = try reader["namespaces"].readListIfPresent(memberReadingClosure: S3TablesClientTypes.NamespaceSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTableBucketsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTableBucketsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTableBucketsOutput()
        value.continuationToken = try reader["continuationToken"].readIfPresent()
        value.tableBuckets = try reader["tableBuckets"].readListIfPresent(memberReadingClosure: S3TablesClientTypes.TableBucketSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTablesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTablesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTablesOutput()
        value.continuationToken = try reader["continuationToken"].readIfPresent()
        value.tables = try reader["tables"].readListIfPresent(memberReadingClosure: S3TablesClientTypes.TableSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension PutTableBucketMaintenanceConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutTableBucketMaintenanceConfigurationOutput {
        return PutTableBucketMaintenanceConfigurationOutput()
    }
}

extension PutTableBucketPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutTableBucketPolicyOutput {
        return PutTableBucketPolicyOutput()
    }
}

extension PutTableMaintenanceConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutTableMaintenanceConfigurationOutput {
        return PutTableMaintenanceConfigurationOutput()
    }
}

extension PutTablePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutTablePolicyOutput {
        return PutTablePolicyOutput()
    }
}

extension RenameTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RenameTableOutput {
        return RenameTableOutput()
    }
}

extension UpdateTableMetadataLocationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTableMetadataLocationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateTableMetadataLocationOutput()
        value.metadataLocation = try reader["metadataLocation"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.namespace = try reader["namespace"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tableARN = try reader["tableARN"].readIfPresent() ?? ""
        value.versionToken = try reader["versionToken"].readIfPresent() ?? ""
        return value
    }
}

enum CreateNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTableBucketOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTableBucketOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTableBucketPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTablePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetNamespaceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableBucketOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableBucketMaintenanceConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableBucketPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableMaintenanceConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableMaintenanceJobStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTableMetadataLocationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTablePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListNamespacesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTableBucketsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTablesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutTableBucketMaintenanceConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutTableBucketPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutTableMaintenanceConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutTablePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RenameTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTableMetadataLocationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "BadRequestException": return try BadRequestException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalServerErrorException": return try InternalServerErrorException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "TooManyRequestsException": return try TooManyRequestsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension TooManyRequestsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyRequestsException {
        let reader = baseError.errorBodyReader
        var value = TooManyRequestsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerErrorException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalServerErrorException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BadRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> BadRequestException {
        let reader = baseError.errorBodyReader
        var value = BadRequestException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension S3TablesClientTypes.TableBucketMaintenanceConfigurationValue {

    static func write(value: S3TablesClientTypes.TableBucketMaintenanceConfigurationValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["settings"].write(value.settings, with: S3TablesClientTypes.TableBucketMaintenanceSettings.write(value:to:))
        try writer["status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.TableBucketMaintenanceConfigurationValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3TablesClientTypes.TableBucketMaintenanceConfigurationValue()
        value.status = try reader["status"].readIfPresent()
        value.settings = try reader["settings"].readIfPresent(with: S3TablesClientTypes.TableBucketMaintenanceSettings.read(from:))
        return value
    }
}

extension S3TablesClientTypes.TableBucketMaintenanceSettings {

    static func write(value: S3TablesClientTypes.TableBucketMaintenanceSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .icebergunreferencedfileremoval(icebergunreferencedfileremoval):
                try writer["icebergUnreferencedFileRemoval"].write(icebergunreferencedfileremoval, with: S3TablesClientTypes.IcebergUnreferencedFileRemovalSettings.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.TableBucketMaintenanceSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "icebergUnreferencedFileRemoval":
                return .icebergunreferencedfileremoval(try reader["icebergUnreferencedFileRemoval"].read(with: S3TablesClientTypes.IcebergUnreferencedFileRemovalSettings.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension S3TablesClientTypes.IcebergUnreferencedFileRemovalSettings {

    static func write(value: S3TablesClientTypes.IcebergUnreferencedFileRemovalSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["nonCurrentDays"].write(value.nonCurrentDays)
        try writer["unreferencedDays"].write(value.unreferencedDays)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.IcebergUnreferencedFileRemovalSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3TablesClientTypes.IcebergUnreferencedFileRemovalSettings()
        value.unreferencedDays = try reader["unreferencedDays"].readIfPresent()
        value.nonCurrentDays = try reader["nonCurrentDays"].readIfPresent()
        return value
    }
}

extension S3TablesClientTypes.TableMaintenanceConfigurationValue {

    static func write(value: S3TablesClientTypes.TableMaintenanceConfigurationValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["settings"].write(value.settings, with: S3TablesClientTypes.TableMaintenanceSettings.write(value:to:))
        try writer["status"].write(value.status)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.TableMaintenanceConfigurationValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3TablesClientTypes.TableMaintenanceConfigurationValue()
        value.status = try reader["status"].readIfPresent()
        value.settings = try reader["settings"].readIfPresent(with: S3TablesClientTypes.TableMaintenanceSettings.read(from:))
        return value
    }
}

extension S3TablesClientTypes.TableMaintenanceSettings {

    static func write(value: S3TablesClientTypes.TableMaintenanceSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .icebergcompaction(icebergcompaction):
                try writer["icebergCompaction"].write(icebergcompaction, with: S3TablesClientTypes.IcebergCompactionSettings.write(value:to:))
            case let .icebergsnapshotmanagement(icebergsnapshotmanagement):
                try writer["icebergSnapshotManagement"].write(icebergsnapshotmanagement, with: S3TablesClientTypes.IcebergSnapshotManagementSettings.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.TableMaintenanceSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "icebergCompaction":
                return .icebergcompaction(try reader["icebergCompaction"].read(with: S3TablesClientTypes.IcebergCompactionSettings.read(from:)))
            case "icebergSnapshotManagement":
                return .icebergsnapshotmanagement(try reader["icebergSnapshotManagement"].read(with: S3TablesClientTypes.IcebergSnapshotManagementSettings.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension S3TablesClientTypes.IcebergSnapshotManagementSettings {

    static func write(value: S3TablesClientTypes.IcebergSnapshotManagementSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxSnapshotAgeHours"].write(value.maxSnapshotAgeHours)
        try writer["minSnapshotsToKeep"].write(value.minSnapshotsToKeep)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.IcebergSnapshotManagementSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3TablesClientTypes.IcebergSnapshotManagementSettings()
        value.minSnapshotsToKeep = try reader["minSnapshotsToKeep"].readIfPresent()
        value.maxSnapshotAgeHours = try reader["maxSnapshotAgeHours"].readIfPresent()
        return value
    }
}

extension S3TablesClientTypes.IcebergCompactionSettings {

    static func write(value: S3TablesClientTypes.IcebergCompactionSettings?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetFileSizeMB"].write(value.targetFileSizeMB)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.IcebergCompactionSettings {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3TablesClientTypes.IcebergCompactionSettings()
        value.targetFileSizeMB = try reader["targetFileSizeMB"].readIfPresent()
        return value
    }
}

extension S3TablesClientTypes.TableMaintenanceJobStatusValue {

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.TableMaintenanceJobStatusValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3TablesClientTypes.TableMaintenanceJobStatusValue()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.lastRunTimestamp = try reader["lastRunTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.failureMessage = try reader["failureMessage"].readIfPresent()
        return value
    }
}

extension S3TablesClientTypes.NamespaceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.NamespaceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3TablesClientTypes.NamespaceSummary()
        value.namespace = try reader["namespace"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.createdBy = try reader["createdBy"].readIfPresent() ?? ""
        value.ownerAccountId = try reader["ownerAccountId"].readIfPresent() ?? ""
        return value
    }
}

extension S3TablesClientTypes.TableBucketSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.TableBucketSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3TablesClientTypes.TableBucketSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.ownerAccountId = try reader["ownerAccountId"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension S3TablesClientTypes.TableSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> S3TablesClientTypes.TableSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = S3TablesClientTypes.TableSummary()
        value.namespace = try reader["namespace"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.tableARN = try reader["tableARN"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

public enum S3TablesClientTypes {}
