//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension IoT1ClickDevicesClientTypes {

    public struct DeviceDescription: Swift.Sendable {
        /// The ARN of the device.
        public var arn: Swift.String?
        /// An array of zero or more elements of DeviceAttribute objects providing user specified device attributes.
        public var attributes: [Swift.String: Swift.String]?
        /// The unique identifier of the device.
        public var deviceId: Swift.String?
        /// A Boolean value indicating whether or not the device is enabled.
        public var enabled: Swift.Bool?
        /// A value between 0 and 1 inclusive, representing the fraction of life remaining for the device.
        public var remainingLife: Swift.Double?
        /// The tags currently associated with the AWS IoT 1-Click device.
        public var tags: [Swift.String: Swift.String]?
        /// The type of the device, such as "button".
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            attributes: [Swift.String: Swift.String]? = nil,
            deviceId: Swift.String? = nil,
            enabled: Swift.Bool? = nil,
            remainingLife: Swift.Double? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.attributes = attributes
            self.deviceId = deviceId
            self.enabled = enabled
            self.remainingLife = remainingLife
            self.tags = tags
            self.type = type
        }
    }
}

extension IoT1ClickDevicesClientTypes {

    public struct Attributes: Swift.Sendable {

        public init() { }
    }
}

extension IoT1ClickDevicesClientTypes {

    public struct Device: Swift.Sendable {
        /// The user specified attributes associated with the device for an event.
        public var attributes: IoT1ClickDevicesClientTypes.Attributes?
        /// The unique identifier of the device.
        public var deviceId: Swift.String?
        /// The device type, such as "button".
        public var type: Swift.String?

        public init(
            attributes: IoT1ClickDevicesClientTypes.Attributes? = nil,
            deviceId: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.deviceId = deviceId
            self.type = type
        }
    }
}

extension IoT1ClickDevicesClientTypes {

    public struct DeviceEvent: Swift.Sendable {
        /// An object representing the device associated with the event.
        public var device: IoT1ClickDevicesClientTypes.Device?
        /// A serialized JSON object representing the device-type specific event.
        public var stdEvent: Swift.String?

        public init(
            device: IoT1ClickDevicesClientTypes.Device? = nil,
            stdEvent: Swift.String? = nil
        )
        {
            self.device = device
            self.stdEvent = stdEvent
        }
    }
}

extension IoT1ClickDevicesClientTypes {

    public struct DeviceMethod: Swift.Sendable {
        /// The type of the device, such as "button".
        public var deviceType: Swift.String?
        /// The name of the method applicable to the deviceType.
        public var methodName: Swift.String?

        public init(
            deviceType: Swift.String? = nil,
            methodName: Swift.String? = nil
        )
        {
            self.deviceType = deviceType
            self.methodName = methodName
        }
    }
}

public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// 403
        public internal(set) var code: Swift.String? = nil
        /// The 403 error message returned by the web server.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// 500
        public internal(set) var code: Swift.String? = nil
        /// The 500 error message returned by the web server.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// 400
        public internal(set) var code: Swift.String? = nil
        /// The 400 error message returned by the web server.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct ClaimDevicesByClaimCodeInput: Swift.Sendable {
    /// The claim code, starting with "C-", as provided by the device manufacturer.
    /// This member is required.
    public var claimCode: Swift.String?

    public init(
        claimCode: Swift.String? = nil
    )
    {
        self.claimCode = claimCode
    }
}

public struct ClaimDevicesByClaimCodeOutput: Swift.Sendable {
    /// The claim code provided by the device manufacturer.
    public var claimCode: Swift.String?
    /// The total number of devices associated with the claim code that has been processed in the claim request.
    public var total: Swift.Int?

    public init(
        claimCode: Swift.String? = nil,
        total: Swift.Int? = nil
    )
    {
        self.claimCode = claimCode
        self.total = total
    }
}

public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// 404
        public internal(set) var code: Swift.String? = nil
        /// The requested device could not be found.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct DescribeDeviceInput: Swift.Sendable {
    /// The unique identifier of the device.
    /// This member is required.
    public var deviceId: Swift.String?

    public init(
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

public struct DescribeDeviceOutput: Swift.Sendable {
    /// Device details.
    public var deviceDescription: IoT1ClickDevicesClientTypes.DeviceDescription?

    public init(
        deviceDescription: IoT1ClickDevicesClientTypes.DeviceDescription? = nil
    )
    {
        self.deviceDescription = deviceDescription
    }
}

public struct PreconditionFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// 412
        public internal(set) var code: Swift.String? = nil
        /// An error message explaining the error or its remedy.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PreconditionFailedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct ResourceConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// 409
        public internal(set) var code: Swift.String? = nil
        /// An error message explaining the error or its remedy.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct FinalizeDeviceClaimInput: Swift.Sendable {
    /// The unique identifier of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// A collection of key/value pairs defining the resource tags. For example, { "tags": {"key1": "value1", "key2": "value2"} }. For more information, see [AWS Tagging Strategies](https://aws.amazon.com/answers/account-management/aws-tagging-strategies/).
    public var tags: [Swift.String: Swift.String]?

    public init(
        deviceId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.deviceId = deviceId
        self.tags = tags
    }
}

public struct FinalizeDeviceClaimOutput: Swift.Sendable {
    /// The device's final claim state.
    public var state: Swift.String?

    public init(
        state: Swift.String? = nil
    )
    {
        self.state = state
    }
}

public struct GetDeviceMethodsInput: Swift.Sendable {
    /// The unique identifier of the device.
    /// This member is required.
    public var deviceId: Swift.String?

    public init(
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

public struct GetDeviceMethodsOutput: Swift.Sendable {
    /// List of available device APIs.
    public var deviceMethods: [IoT1ClickDevicesClientTypes.DeviceMethod]?

    public init(
        deviceMethods: [IoT1ClickDevicesClientTypes.DeviceMethod]? = nil
    )
    {
        self.deviceMethods = deviceMethods
    }
}

public struct InitiateDeviceClaimInput: Swift.Sendable {
    /// The unique identifier of the device.
    /// This member is required.
    public var deviceId: Swift.String?

    public init(
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

public struct InitiateDeviceClaimOutput: Swift.Sendable {
    /// The device's final claim state.
    public var state: Swift.String?

    public init(
        state: Swift.String? = nil
    )
    {
        self.state = state
    }
}

public struct RangeNotSatisfiableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// 416
        public internal(set) var code: Swift.String? = nil
        /// The requested number of results specified by nextToken cannot be satisfied.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RangeNotSatisfiableException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

public struct InvokeDeviceMethodInput: Swift.Sendable {
    /// The unique identifier of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The device method to invoke.
    public var deviceMethod: IoT1ClickDevicesClientTypes.DeviceMethod?
    /// A JSON encoded string containing the device method request parameters.
    public var deviceMethodParameters: Swift.String?

    public init(
        deviceId: Swift.String? = nil,
        deviceMethod: IoT1ClickDevicesClientTypes.DeviceMethod? = nil,
        deviceMethodParameters: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
        self.deviceMethod = deviceMethod
        self.deviceMethodParameters = deviceMethodParameters
    }
}

public struct InvokeDeviceMethodOutput: Swift.Sendable {
    /// A JSON encoded string containing the device method response.
    public var deviceMethodResponse: Swift.String?

    public init(
        deviceMethodResponse: Swift.String? = nil
    )
    {
        self.deviceMethodResponse = deviceMethodResponse
    }
}

public struct ListDeviceEventsInput: Swift.Sendable {
    /// The unique identifier of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// The start date for the device event query, in ISO8061 format. For example, 2018-03-28T15:45:12.880Z
    /// This member is required.
    public var fromTimeStamp: Foundation.Date?
    /// The maximum number of results to return per request. If not set, a default value of 100 is used.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The end date for the device event query, in ISO8061 format. For example, 2018-03-28T15:45:12.880Z
    /// This member is required.
    public var toTimeStamp: Foundation.Date?

    public init(
        deviceId: Swift.String? = nil,
        fromTimeStamp: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        toTimeStamp: Foundation.Date? = nil
    )
    {
        self.deviceId = deviceId
        self.fromTimeStamp = fromTimeStamp
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.toTimeStamp = toTimeStamp
    }
}

public struct ListDeviceEventsOutput: Swift.Sendable {
    /// An array of zero or more elements describing the event(s) associated with the device.
    public var events: [IoT1ClickDevicesClientTypes.DeviceEvent]?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        events: [IoT1ClickDevicesClientTypes.DeviceEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

public struct ListDevicesInput: Swift.Sendable {
    /// The type of the device, such as "button".
    public var deviceType: Swift.String?
    /// The maximum number of results to return per request. If not set, a default value of 100 is used.
    public var maxResults: Swift.Int?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        deviceType: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.deviceType = deviceType
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDevicesOutput: Swift.Sendable {
    /// A list of devices.
    public var devices: [IoT1ClickDevicesClientTypes.DeviceDescription]?
    /// The token to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        devices: [IoT1ClickDevicesClientTypes.DeviceDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A collection of key/value pairs defining the resource tags. For example, { "tags": {"key1": "value1", "key2": "value2"} }. For more information, see [AWS Tagging Strategies](https://aws.amazon.com/answers/account-management/aws-tagging-strategies/).
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A collection of key/value pairs defining the resource tags. For example, { "tags": {"key1": "value1", "key2": "value2"} }. For more information, see [AWS Tagging Strategies](https://aws.amazon.com/answers/account-management/aws-tagging-strategies/).
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct UnclaimDeviceInput: Swift.Sendable {
    /// The unique identifier of the device.
    /// This member is required.
    public var deviceId: Swift.String?

    public init(
        deviceId: Swift.String? = nil
    )
    {
        self.deviceId = deviceId
    }
}

public struct UnclaimDeviceOutput: Swift.Sendable {
    /// The device's final claim state.
    public var state: Swift.String?

    public init(
        state: Swift.String? = nil
    )
    {
        self.state = state
    }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A collections of tag keys. For example, {"key1","key2"}
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UpdateDeviceStateInput: Swift.Sendable {
    /// The unique identifier of the device.
    /// This member is required.
    public var deviceId: Swift.String?
    /// If true, the device is enabled. If false, the device is disabled.
    public var enabled: Swift.Bool?

    public init(
        deviceId: Swift.String? = nil,
        enabled: Swift.Bool? = nil
    )
    {
        self.deviceId = deviceId
        self.enabled = enabled
    }
}

public struct UpdateDeviceStateOutput: Swift.Sendable {

    public init() { }
}

extension ClaimDevicesByClaimCodeInput {

    static func urlPathProvider(_ value: ClaimDevicesByClaimCodeInput) -> Swift.String? {
        guard let claimCode = value.claimCode else {
            return nil
        }
        return "/claims/\(claimCode.urlPercentEncoding())"
    }
}

extension DescribeDeviceInput {

    static func urlPathProvider(_ value: DescribeDeviceInput) -> Swift.String? {
        guard let deviceId = value.deviceId else {
            return nil
        }
        return "/devices/\(deviceId.urlPercentEncoding())"
    }
}

extension FinalizeDeviceClaimInput {

    static func urlPathProvider(_ value: FinalizeDeviceClaimInput) -> Swift.String? {
        guard let deviceId = value.deviceId else {
            return nil
        }
        return "/devices/\(deviceId.urlPercentEncoding())/finalize-claim"
    }
}

extension GetDeviceMethodsInput {

    static func urlPathProvider(_ value: GetDeviceMethodsInput) -> Swift.String? {
        guard let deviceId = value.deviceId else {
            return nil
        }
        return "/devices/\(deviceId.urlPercentEncoding())/methods"
    }
}

extension InitiateDeviceClaimInput {

    static func urlPathProvider(_ value: InitiateDeviceClaimInput) -> Swift.String? {
        guard let deviceId = value.deviceId else {
            return nil
        }
        return "/devices/\(deviceId.urlPercentEncoding())/initiate-claim"
    }
}

extension InvokeDeviceMethodInput {

    static func urlPathProvider(_ value: InvokeDeviceMethodInput) -> Swift.String? {
        guard let deviceId = value.deviceId else {
            return nil
        }
        return "/devices/\(deviceId.urlPercentEncoding())/methods"
    }
}

extension ListDeviceEventsInput {

    static func urlPathProvider(_ value: ListDeviceEventsInput) -> Swift.String? {
        guard let deviceId = value.deviceId else {
            return nil
        }
        return "/devices/\(deviceId.urlPercentEncoding())/events"
    }
}

extension ListDeviceEventsInput {

    static func queryItemProvider(_ value: ListDeviceEventsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let toTimeStamp = value.toTimeStamp else {
            let message = "Creating a URL Query Item failed. toTimeStamp is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let toTimeStampQueryItem = Smithy.URIQueryItem(name: "toTimeStamp".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: toTimeStamp)).urlPercentEncoding())
        items.append(toTimeStampQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let fromTimeStamp = value.fromTimeStamp else {
            let message = "Creating a URL Query Item failed. fromTimeStamp is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let fromTimeStampQueryItem = Smithy.URIQueryItem(name: "fromTimeStamp".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: fromTimeStamp)).urlPercentEncoding())
        items.append(fromTimeStampQueryItem)
        return items
    }
}

extension ListDevicesInput {

    static func urlPathProvider(_ value: ListDevicesInput) -> Swift.String? {
        return "/devices"
    }
}

extension ListDevicesInput {

    static func queryItemProvider(_ value: ListDevicesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let deviceType = value.deviceType {
            let deviceTypeQueryItem = Smithy.URIQueryItem(name: "deviceType".urlPercentEncoding(), value: Swift.String(deviceType).urlPercentEncoding())
            items.append(deviceTypeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UnclaimDeviceInput {

    static func urlPathProvider(_ value: UnclaimDeviceInput) -> Swift.String? {
        guard let deviceId = value.deviceId else {
            return nil
        }
        return "/devices/\(deviceId.urlPercentEncoding())/unclaim"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateDeviceStateInput {

    static func urlPathProvider(_ value: UpdateDeviceStateInput) -> Swift.String? {
        guard let deviceId = value.deviceId else {
            return nil
        }
        return "/devices/\(deviceId.urlPercentEncoding())/state"
    }
}

extension FinalizeDeviceClaimInput {

    static func write(value: FinalizeDeviceClaimInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension InvokeDeviceMethodInput {

    static func write(value: InvokeDeviceMethodInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deviceMethod"].write(value.deviceMethod, with: IoT1ClickDevicesClientTypes.DeviceMethod.write(value:to:))
        try writer["deviceMethodParameters"].write(value.deviceMethodParameters)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateDeviceStateInput {

    static func write(value: UpdateDeviceStateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["enabled"].write(value.enabled)
    }
}

extension ClaimDevicesByClaimCodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ClaimDevicesByClaimCodeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ClaimDevicesByClaimCodeOutput()
        value.claimCode = try reader["claimCode"].readIfPresent()
        value.total = try reader["total"].readIfPresent()
        return value
    }
}

extension DescribeDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDeviceOutput()
        value.deviceDescription = try reader["deviceDescription"].readIfPresent(with: IoT1ClickDevicesClientTypes.DeviceDescription.read(from:))
        return value
    }
}

extension FinalizeDeviceClaimOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> FinalizeDeviceClaimOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = FinalizeDeviceClaimOutput()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

extension GetDeviceMethodsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeviceMethodsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeviceMethodsOutput()
        value.deviceMethods = try reader["deviceMethods"].readListIfPresent(memberReadingClosure: IoT1ClickDevicesClientTypes.DeviceMethod.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension InitiateDeviceClaimOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InitiateDeviceClaimOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = InitiateDeviceClaimOutput()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

extension InvokeDeviceMethodOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> InvokeDeviceMethodOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = InvokeDeviceMethodOutput()
        value.deviceMethodResponse = try reader["deviceMethodResponse"].readIfPresent()
        return value
    }
}

extension ListDeviceEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDeviceEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDeviceEventsOutput()
        value.events = try reader["events"].readListIfPresent(memberReadingClosure: IoT1ClickDevicesClientTypes.DeviceEvent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDevicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDevicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDevicesOutput()
        value.devices = try reader["devices"].readListIfPresent(memberReadingClosure: IoT1ClickDevicesClientTypes.DeviceDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UnclaimDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UnclaimDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UnclaimDeviceOutput()
        value.state = try reader["state"].readIfPresent()
        return value
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateDeviceStateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDeviceStateOutput {
        return UpdateDeviceStateOutput()
    }
}

enum ClaimDevicesByClaimCodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ForbiddenException": return try ForbiddenException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum FinalizeDeviceClaimOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeviceMethodsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InitiateDeviceClaimOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum InvokeDeviceMethodOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "RangeNotSatisfiableException": return try RangeNotSatisfiableException.makeError(baseError: baseError)
            case "ResourceConflictException": return try ResourceConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDeviceEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "RangeNotSatisfiableException": return try RangeNotSatisfiableException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDevicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "RangeNotSatisfiableException": return try RangeNotSatisfiableException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UnclaimDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDeviceStateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalFailureException {
        let reader = baseError.errorBodyReader
        var value = InternalFailureException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ForbiddenException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ForbiddenException {
        let reader = baseError.errorBodyReader
        var value = ForbiddenException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceConflictException {
        let reader = baseError.errorBodyReader
        var value = ResourceConflictException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PreconditionFailedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PreconditionFailedException {
        let reader = baseError.errorBodyReader
        var value = PreconditionFailedException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension RangeNotSatisfiableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> RangeNotSatisfiableException {
        let reader = baseError.errorBodyReader
        var value = RangeNotSatisfiableException()
        value.properties.code = try reader["code"].readIfPresent()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IoT1ClickDevicesClientTypes.DeviceDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> IoT1ClickDevicesClientTypes.DeviceDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoT1ClickDevicesClientTypes.DeviceDescription()
        value.arn = try reader["arn"].readIfPresent()
        value.attributes = try reader["attributes"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.deviceId = try reader["deviceId"].readIfPresent()
        value.enabled = try reader["enabled"].readIfPresent()
        value.remainingLife = try reader["remainingLife"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension IoT1ClickDevicesClientTypes.DeviceMethod {

    static func write(value: IoT1ClickDevicesClientTypes.DeviceMethod?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deviceType"].write(value.deviceType)
        try writer["methodName"].write(value.methodName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoT1ClickDevicesClientTypes.DeviceMethod {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoT1ClickDevicesClientTypes.DeviceMethod()
        value.deviceType = try reader["deviceType"].readIfPresent()
        value.methodName = try reader["methodName"].readIfPresent()
        return value
    }
}

extension IoT1ClickDevicesClientTypes.DeviceEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> IoT1ClickDevicesClientTypes.DeviceEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoT1ClickDevicesClientTypes.DeviceEvent()
        value.device = try reader["device"].readIfPresent(with: IoT1ClickDevicesClientTypes.Device.read(from:))
        value.stdEvent = try reader["stdEvent"].readIfPresent()
        return value
    }
}

extension IoT1ClickDevicesClientTypes.Device {

    static func read(from reader: SmithyJSON.Reader) throws -> IoT1ClickDevicesClientTypes.Device {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoT1ClickDevicesClientTypes.Device()
        value.attributes = try reader["attributes"].readIfPresent(with: IoT1ClickDevicesClientTypes.Attributes.read(from:))
        value.deviceId = try reader["deviceId"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        return value
    }
}

extension IoT1ClickDevicesClientTypes.Attributes {

    static func read(from reader: SmithyJSON.Reader) throws -> IoT1ClickDevicesClientTypes.Attributes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return IoT1ClickDevicesClientTypes.Attributes()
    }
}

public enum IoT1ClickDevicesClientTypes {}
