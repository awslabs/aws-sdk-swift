// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension SSOAdminClient {
    /// Paginate over `[ListAccountAssignmentCreationStatusOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAccountAssignmentCreationStatusInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAccountAssignmentCreationStatusOutput`
    public func listAccountAssignmentCreationStatusPaginated(input: ListAccountAssignmentCreationStatusInput) -> ClientRuntime.PaginatorSequence<ListAccountAssignmentCreationStatusInput, ListAccountAssignmentCreationStatusOutput> {
        return ClientRuntime.PaginatorSequence<ListAccountAssignmentCreationStatusInput, ListAccountAssignmentCreationStatusOutput>(input: input, inputKey: \ListAccountAssignmentCreationStatusInput.nextToken, outputKey: \ListAccountAssignmentCreationStatusOutput.nextToken, paginationFunction: self.listAccountAssignmentCreationStatus(input:))
    }
}

extension ListAccountAssignmentCreationStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAccountAssignmentCreationStatusInput {
        return ListAccountAssignmentCreationStatusInput(
            filter: self.filter,
            instanceArn: self.instanceArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListAccountAssignmentCreationStatusInput, Output == ListAccountAssignmentCreationStatusOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAccountAssignmentCreationStatusPaginated`
    /// to access the nested member `[SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]`
    /// - Returns: `[SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]`
    public func accountAssignmentsCreationStatus() async throws -> [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata] {
        return try await self.asyncCompactMap { item in item.accountAssignmentsCreationStatus }
    }
}
extension SSOAdminClient {
    /// Paginate over `[ListAccountAssignmentDeletionStatusOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAccountAssignmentDeletionStatusInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAccountAssignmentDeletionStatusOutput`
    public func listAccountAssignmentDeletionStatusPaginated(input: ListAccountAssignmentDeletionStatusInput) -> ClientRuntime.PaginatorSequence<ListAccountAssignmentDeletionStatusInput, ListAccountAssignmentDeletionStatusOutput> {
        return ClientRuntime.PaginatorSequence<ListAccountAssignmentDeletionStatusInput, ListAccountAssignmentDeletionStatusOutput>(input: input, inputKey: \ListAccountAssignmentDeletionStatusInput.nextToken, outputKey: \ListAccountAssignmentDeletionStatusOutput.nextToken, paginationFunction: self.listAccountAssignmentDeletionStatus(input:))
    }
}

extension ListAccountAssignmentDeletionStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAccountAssignmentDeletionStatusInput {
        return ListAccountAssignmentDeletionStatusInput(
            filter: self.filter,
            instanceArn: self.instanceArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListAccountAssignmentDeletionStatusInput, Output == ListAccountAssignmentDeletionStatusOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAccountAssignmentDeletionStatusPaginated`
    /// to access the nested member `[SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]`
    /// - Returns: `[SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]`
    public func accountAssignmentsDeletionStatus() async throws -> [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata] {
        return try await self.asyncCompactMap { item in item.accountAssignmentsDeletionStatus }
    }
}
extension SSOAdminClient {
    /// Paginate over `[ListAccountAssignmentsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAccountAssignmentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAccountAssignmentsOutput`
    public func listAccountAssignmentsPaginated(input: ListAccountAssignmentsInput) -> ClientRuntime.PaginatorSequence<ListAccountAssignmentsInput, ListAccountAssignmentsOutput> {
        return ClientRuntime.PaginatorSequence<ListAccountAssignmentsInput, ListAccountAssignmentsOutput>(input: input, inputKey: \ListAccountAssignmentsInput.nextToken, outputKey: \ListAccountAssignmentsOutput.nextToken, paginationFunction: self.listAccountAssignments(input:))
    }
}

extension ListAccountAssignmentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAccountAssignmentsInput {
        return ListAccountAssignmentsInput(
            accountId: self.accountId,
            instanceArn: self.instanceArn,
            maxResults: self.maxResults,
            nextToken: token,
            permissionSetArn: self.permissionSetArn
        )}
}

extension PaginatorSequence where Input == ListAccountAssignmentsInput, Output == ListAccountAssignmentsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAccountAssignmentsPaginated`
    /// to access the nested member `[SSOAdminClientTypes.AccountAssignment]`
    /// - Returns: `[SSOAdminClientTypes.AccountAssignment]`
    public func accountAssignments() async throws -> [SSOAdminClientTypes.AccountAssignment] {
        return try await self.asyncCompactMap { item in item.accountAssignments }
    }
}
extension SSOAdminClient {
    /// Paginate over `[ListAccountsForProvisionedPermissionSetOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListAccountsForProvisionedPermissionSetInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListAccountsForProvisionedPermissionSetOutput`
    public func listAccountsForProvisionedPermissionSetPaginated(input: ListAccountsForProvisionedPermissionSetInput) -> ClientRuntime.PaginatorSequence<ListAccountsForProvisionedPermissionSetInput, ListAccountsForProvisionedPermissionSetOutput> {
        return ClientRuntime.PaginatorSequence<ListAccountsForProvisionedPermissionSetInput, ListAccountsForProvisionedPermissionSetOutput>(input: input, inputKey: \ListAccountsForProvisionedPermissionSetInput.nextToken, outputKey: \ListAccountsForProvisionedPermissionSetOutput.nextToken, paginationFunction: self.listAccountsForProvisionedPermissionSet(input:))
    }
}

extension ListAccountsForProvisionedPermissionSetInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListAccountsForProvisionedPermissionSetInput {
        return ListAccountsForProvisionedPermissionSetInput(
            instanceArn: self.instanceArn,
            maxResults: self.maxResults,
            nextToken: token,
            permissionSetArn: self.permissionSetArn,
            provisioningStatus: self.provisioningStatus
        )}
}

extension PaginatorSequence where Input == ListAccountsForProvisionedPermissionSetInput, Output == ListAccountsForProvisionedPermissionSetOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listAccountsForProvisionedPermissionSetPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func accountIds() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.accountIds }
    }
}
extension SSOAdminClient {
    /// Paginate over `[ListCustomerManagedPolicyReferencesInPermissionSetOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListCustomerManagedPolicyReferencesInPermissionSetInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListCustomerManagedPolicyReferencesInPermissionSetOutput`
    public func listCustomerManagedPolicyReferencesInPermissionSetPaginated(input: ListCustomerManagedPolicyReferencesInPermissionSetInput) -> ClientRuntime.PaginatorSequence<ListCustomerManagedPolicyReferencesInPermissionSetInput, ListCustomerManagedPolicyReferencesInPermissionSetOutput> {
        return ClientRuntime.PaginatorSequence<ListCustomerManagedPolicyReferencesInPermissionSetInput, ListCustomerManagedPolicyReferencesInPermissionSetOutput>(input: input, inputKey: \ListCustomerManagedPolicyReferencesInPermissionSetInput.nextToken, outputKey: \ListCustomerManagedPolicyReferencesInPermissionSetOutput.nextToken, paginationFunction: self.listCustomerManagedPolicyReferencesInPermissionSet(input:))
    }
}

extension ListCustomerManagedPolicyReferencesInPermissionSetInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListCustomerManagedPolicyReferencesInPermissionSetInput {
        return ListCustomerManagedPolicyReferencesInPermissionSetInput(
            instanceArn: self.instanceArn,
            maxResults: self.maxResults,
            nextToken: token,
            permissionSetArn: self.permissionSetArn
        )}
}

extension PaginatorSequence where Input == ListCustomerManagedPolicyReferencesInPermissionSetInput, Output == ListCustomerManagedPolicyReferencesInPermissionSetOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listCustomerManagedPolicyReferencesInPermissionSetPaginated`
    /// to access the nested member `[SSOAdminClientTypes.CustomerManagedPolicyReference]`
    /// - Returns: `[SSOAdminClientTypes.CustomerManagedPolicyReference]`
    public func customerManagedPolicyReferences() async throws -> [SSOAdminClientTypes.CustomerManagedPolicyReference] {
        return try await self.asyncCompactMap { item in item.customerManagedPolicyReferences }
    }
}
extension SSOAdminClient {
    /// Paginate over `[ListInstancesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInstancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInstancesOutput`
    public func listInstancesPaginated(input: ListInstancesInput) -> ClientRuntime.PaginatorSequence<ListInstancesInput, ListInstancesOutput> {
        return ClientRuntime.PaginatorSequence<ListInstancesInput, ListInstancesOutput>(input: input, inputKey: \ListInstancesInput.nextToken, outputKey: \ListInstancesOutput.nextToken, paginationFunction: self.listInstances(input:))
    }
}

extension ListInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInstancesInput {
        return ListInstancesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListInstancesInput, Output == ListInstancesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInstancesPaginated`
    /// to access the nested member `[SSOAdminClientTypes.InstanceMetadata]`
    /// - Returns: `[SSOAdminClientTypes.InstanceMetadata]`
    public func instances() async throws -> [SSOAdminClientTypes.InstanceMetadata] {
        return try await self.asyncCompactMap { item in item.instances }
    }
}
extension SSOAdminClient {
    /// Paginate over `[ListManagedPoliciesInPermissionSetOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListManagedPoliciesInPermissionSetInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListManagedPoliciesInPermissionSetOutput`
    public func listManagedPoliciesInPermissionSetPaginated(input: ListManagedPoliciesInPermissionSetInput) -> ClientRuntime.PaginatorSequence<ListManagedPoliciesInPermissionSetInput, ListManagedPoliciesInPermissionSetOutput> {
        return ClientRuntime.PaginatorSequence<ListManagedPoliciesInPermissionSetInput, ListManagedPoliciesInPermissionSetOutput>(input: input, inputKey: \ListManagedPoliciesInPermissionSetInput.nextToken, outputKey: \ListManagedPoliciesInPermissionSetOutput.nextToken, paginationFunction: self.listManagedPoliciesInPermissionSet(input:))
    }
}

extension ListManagedPoliciesInPermissionSetInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListManagedPoliciesInPermissionSetInput {
        return ListManagedPoliciesInPermissionSetInput(
            instanceArn: self.instanceArn,
            maxResults: self.maxResults,
            nextToken: token,
            permissionSetArn: self.permissionSetArn
        )}
}

extension PaginatorSequence where Input == ListManagedPoliciesInPermissionSetInput, Output == ListManagedPoliciesInPermissionSetOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listManagedPoliciesInPermissionSetPaginated`
    /// to access the nested member `[SSOAdminClientTypes.AttachedManagedPolicy]`
    /// - Returns: `[SSOAdminClientTypes.AttachedManagedPolicy]`
    public func attachedManagedPolicies() async throws -> [SSOAdminClientTypes.AttachedManagedPolicy] {
        return try await self.asyncCompactMap { item in item.attachedManagedPolicies }
    }
}
extension SSOAdminClient {
    /// Paginate over `[ListPermissionSetProvisioningStatusOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPermissionSetProvisioningStatusInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPermissionSetProvisioningStatusOutput`
    public func listPermissionSetProvisioningStatusPaginated(input: ListPermissionSetProvisioningStatusInput) -> ClientRuntime.PaginatorSequence<ListPermissionSetProvisioningStatusInput, ListPermissionSetProvisioningStatusOutput> {
        return ClientRuntime.PaginatorSequence<ListPermissionSetProvisioningStatusInput, ListPermissionSetProvisioningStatusOutput>(input: input, inputKey: \ListPermissionSetProvisioningStatusInput.nextToken, outputKey: \ListPermissionSetProvisioningStatusOutput.nextToken, paginationFunction: self.listPermissionSetProvisioningStatus(input:))
    }
}

extension ListPermissionSetProvisioningStatusInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPermissionSetProvisioningStatusInput {
        return ListPermissionSetProvisioningStatusInput(
            filter: self.filter,
            instanceArn: self.instanceArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListPermissionSetProvisioningStatusInput, Output == ListPermissionSetProvisioningStatusOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPermissionSetProvisioningStatusPaginated`
    /// to access the nested member `[SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata]`
    /// - Returns: `[SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata]`
    public func permissionSetsProvisioningStatus() async throws -> [SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata] {
        return try await self.asyncCompactMap { item in item.permissionSetsProvisioningStatus }
    }
}
extension SSOAdminClient {
    /// Paginate over `[ListPermissionSetsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPermissionSetsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPermissionSetsOutput`
    public func listPermissionSetsPaginated(input: ListPermissionSetsInput) -> ClientRuntime.PaginatorSequence<ListPermissionSetsInput, ListPermissionSetsOutput> {
        return ClientRuntime.PaginatorSequence<ListPermissionSetsInput, ListPermissionSetsOutput>(input: input, inputKey: \ListPermissionSetsInput.nextToken, outputKey: \ListPermissionSetsOutput.nextToken, paginationFunction: self.listPermissionSets(input:))
    }
}

extension ListPermissionSetsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPermissionSetsInput {
        return ListPermissionSetsInput(
            instanceArn: self.instanceArn,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListPermissionSetsInput, Output == ListPermissionSetsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPermissionSetsPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func permissionSets() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.permissionSets }
    }
}
extension SSOAdminClient {
    /// Paginate over `[ListPermissionSetsProvisionedToAccountOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListPermissionSetsProvisionedToAccountInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListPermissionSetsProvisionedToAccountOutput`
    public func listPermissionSetsProvisionedToAccountPaginated(input: ListPermissionSetsProvisionedToAccountInput) -> ClientRuntime.PaginatorSequence<ListPermissionSetsProvisionedToAccountInput, ListPermissionSetsProvisionedToAccountOutput> {
        return ClientRuntime.PaginatorSequence<ListPermissionSetsProvisionedToAccountInput, ListPermissionSetsProvisionedToAccountOutput>(input: input, inputKey: \ListPermissionSetsProvisionedToAccountInput.nextToken, outputKey: \ListPermissionSetsProvisionedToAccountOutput.nextToken, paginationFunction: self.listPermissionSetsProvisionedToAccount(input:))
    }
}

extension ListPermissionSetsProvisionedToAccountInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListPermissionSetsProvisionedToAccountInput {
        return ListPermissionSetsProvisionedToAccountInput(
            accountId: self.accountId,
            instanceArn: self.instanceArn,
            maxResults: self.maxResults,
            nextToken: token,
            provisioningStatus: self.provisioningStatus
        )}
}

extension PaginatorSequence where Input == ListPermissionSetsProvisionedToAccountInput, Output == ListPermissionSetsProvisionedToAccountOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listPermissionSetsProvisionedToAccountPaginated`
    /// to access the nested member `[Swift.String]`
    /// - Returns: `[Swift.String]`
    public func permissionSets() async throws -> [Swift.String] {
        return try await self.asyncCompactMap { item in item.permissionSets }
    }
}
extension SSOAdminClient {
    /// Paginate over `[ListTagsForResourceOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTagsForResourceInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTagsForResourceOutput`
    public func listTagsForResourcePaginated(input: ListTagsForResourceInput) -> ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutput> {
        return ClientRuntime.PaginatorSequence<ListTagsForResourceInput, ListTagsForResourceOutput>(input: input, inputKey: \ListTagsForResourceInput.nextToken, outputKey: \ListTagsForResourceOutput.nextToken, paginationFunction: self.listTagsForResource(input:))
    }
}

extension ListTagsForResourceInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTagsForResourceInput {
        return ListTagsForResourceInput(
            instanceArn: self.instanceArn,
            nextToken: token,
            resourceArn: self.resourceArn
        )}
}

extension PaginatorSequence where Input == ListTagsForResourceInput, Output == ListTagsForResourceOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listTagsForResourcePaginated`
    /// to access the nested member `[SSOAdminClientTypes.Tag]`
    /// - Returns: `[SSOAdminClientTypes.Tag]`
    public func tags() async throws -> [SSOAdminClientTypes.Tag] {
        return try await self.asyncCompactMap { item in item.tags }
    }
}
