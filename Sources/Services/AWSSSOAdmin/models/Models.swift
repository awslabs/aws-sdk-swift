// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension SSOAdminClientTypes.AccessControlAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.AccessControlAttributeValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension SSOAdminClientTypes {
    /// These are IAM Identity Center identity store attributes that you can configure for use in attributes-based access control (ABAC). You can create permissions policies that determine who can access your Amazon Web Services resources based upon the configured attribute values. When you enable ABAC and specify AccessControlAttributes, IAM Identity Center passes the attribute values of the authenticated user into IAM for use in policy evaluation.
    public struct AccessControlAttribute: Swift.Equatable {
        /// The name of the attribute associated with your identities in your identity source. This is used to map a specified attribute in your identity source with an attribute in IAM Identity Center.
        /// This member is required.
        public var key: Swift.String?
        /// The value used for mapping a specified attribute to an identity source.
        /// This member is required.
        public var value: SSOAdminClientTypes.AccessControlAttributeValue?

        public init(
            key: Swift.String? = nil,
            value: SSOAdminClientTypes.AccessControlAttributeValue? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SSOAdminClientTypes.AccessControlAttributeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = source {
            var sourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .source)
            for accesscontrolattributevaluesource0 in source {
                try sourceContainer.encode(accesscontrolattributevaluesource0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .source)
        var sourceDecoded0:[Swift.String]? = nil
        if let sourceContainer = sourceContainer {
            sourceDecoded0 = [Swift.String]()
            for string0 in sourceContainer {
                if let string0 = string0 {
                    sourceDecoded0?.append(string0)
                }
            }
        }
        source = sourceDecoded0
    }
}

extension SSOAdminClientTypes {
    /// The value used for mapping a specified attribute to an identity source. For more information, see [Attribute mappings](https://docs.aws.amazon.com/singlesignon/latest/userguide/attributemappingsconcept.html) in the IAM Identity Center User Guide.
    public struct AccessControlAttributeValue: Swift.Equatable {
        /// The identity source to use when mapping a specified attribute to IAM Identity Center.
        /// This member is required.
        public var source: [Swift.String]?

        public init(
            source: [Swift.String]? = nil
        )
        {
            self.source = source
        }
    }

}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SSOAdminClientTypes.AccountAssignment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension SSOAdminClientTypes {
    /// The assignment that indicates a principal's limited access to a specified Amazon Web Services account with a specified permission set. The term principal here refers to a user or group that is defined in IAM Identity Center.
    public struct AccountAssignment: Swift.Equatable {
        /// The identifier of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// The ARN of the permission set. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var permissionSetArn: Swift.String?
        /// An identifier for an object in IAM Identity Center, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in IAM Identity Center, see the [IAM Identity Center Identity Store API Reference].
        public var principalId: Swift.String?
        /// The entity type for which the assignment will be created.
        public var principalType: SSOAdminClientTypes.PrincipalType?

        public init(
            accountId: Swift.String? = nil,
            permissionSetArn: Swift.String? = nil,
            principalId: Swift.String? = nil,
            principalType: SSOAdminClientTypes.PrincipalType? = nil
        )
        {
            self.accountId = accountId
            self.permissionSetArn = permissionSetArn
            self.principalId = principalId
            self.principalType = principalType
        }
    }

}

extension SSOAdminClientTypes.AccountAssignmentForPrincipal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes an assignment of an Amazon Web Services account to a principal and the permissions that principal has in the account.
    public struct AccountAssignmentForPrincipal: Swift.Equatable {
        /// The account ID number of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// The ARN of the IAM Identity Center permission set assigned to this principal for this Amazon Web Services account.
        public var permissionSetArn: Swift.String?
        /// The ID of the principal.
        public var principalId: Swift.String?
        /// The type of the principal.
        public var principalType: SSOAdminClientTypes.PrincipalType?

        public init(
            accountId: Swift.String? = nil,
            permissionSetArn: Swift.String? = nil,
            principalId: Swift.String? = nil,
            principalType: SSOAdminClientTypes.PrincipalType? = nil
        )
        {
            self.accountId = accountId
            self.permissionSetArn = permissionSetArn
            self.principalId = principalId
            self.principalType = principalType
        }
    }

}

extension SSOAdminClientTypes.AccountAssignmentOperationStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case failureReason = "FailureReason"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
        case requestId = "RequestId"
        case status = "Status"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetId = self.targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = self.targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.StatusValues.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension SSOAdminClientTypes {
    /// The status of the creation or deletion operation of an assignment that a principal needs to access an account.
    public struct AccountAssignmentOperationStatus: Swift.Equatable {
        /// The date that the permission set was created.
        public var createdDate: ClientRuntime.Date?
        /// The message that contains an error or exception in case of an operation failure.
        public var failureReason: Swift.String?
        /// The ARN of the permission set. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var permissionSetArn: Swift.String?
        /// An identifier for an object in IAM Identity Center, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in IAM Identity Center, see the [IAM Identity Center Identity Store API Reference].
        public var principalId: Swift.String?
        /// The entity type for which the assignment will be created.
        public var principalType: SSOAdminClientTypes.PrincipalType?
        /// The identifier for tracking the request operation that is generated by the universally unique identifier (UUID) workflow.
        public var requestId: Swift.String?
        /// The status of the permission set provisioning process.
        public var status: SSOAdminClientTypes.StatusValues?
        /// TargetID is an Amazon Web Services account identifier, (For example, 123456789012).
        public var targetId: Swift.String?
        /// The entity type for which the assignment will be created.
        public var targetType: SSOAdminClientTypes.TargetType?

        public init(
            createdDate: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            permissionSetArn: Swift.String? = nil,
            principalId: Swift.String? = nil,
            principalType: SSOAdminClientTypes.PrincipalType? = nil,
            requestId: Swift.String? = nil,
            status: SSOAdminClientTypes.StatusValues? = nil,
            targetId: Swift.String? = nil,
            targetType: SSOAdminClientTypes.TargetType? = nil
        )
        {
            self.createdDate = createdDate
            self.failureReason = failureReason
            self.permissionSetArn = permissionSetArn
            self.principalId = principalId
            self.principalType = principalType
            self.requestId = requestId
            self.status = status
            self.targetId = targetId
            self.targetType = targetType
        }
    }

}

extension SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case requestId = "RequestId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.StatusValues.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension SSOAdminClientTypes {
    /// Provides information about the [AccountAssignment] creation request.
    public struct AccountAssignmentOperationStatusMetadata: Swift.Equatable {
        /// The date that the permission set was created.
        public var createdDate: ClientRuntime.Date?
        /// The identifier for tracking the request operation that is generated by the universally unique identifier (UUID) workflow.
        public var requestId: Swift.String?
        /// The status of the permission set provisioning process.
        public var status: SSOAdminClientTypes.StatusValues?

        public init(
            createdDate: ClientRuntime.Date? = nil,
            requestId: Swift.String? = nil,
            status: SSOAdminClientTypes.StatusValues? = nil
        )
        {
            self.createdDate = createdDate
            self.requestId = requestId
            self.status = status
        }
    }

}

extension SSOAdminClientTypes.Application: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationAccount = "ApplicationAccount"
        case applicationArn = "ApplicationArn"
        case applicationProviderArn = "ApplicationProviderArn"
        case createdDate = "CreatedDate"
        case description = "Description"
        case instanceArn = "InstanceArn"
        case name = "Name"
        case portalOptions = "PortalOptions"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationAccount = self.applicationAccount {
            try encodeContainer.encode(applicationAccount, forKey: .applicationAccount)
        }
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let applicationProviderArn = self.applicationProviderArn {
            try encodeContainer.encode(applicationProviderArn, forKey: .applicationProviderArn)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let portalOptions = self.portalOptions {
            try encodeContainer.encode(portalOptions, forKey: .portalOptions)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let applicationProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationProviderArn)
        applicationProviderArn = applicationProviderArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let applicationAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationAccount)
        applicationAccount = applicationAccountDecoded
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.ApplicationStatus.self, forKey: .status)
        status = statusDecoded
        let portalOptionsDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PortalOptions.self, forKey: .portalOptions)
        portalOptions = portalOptionsDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes an application that uses IAM Identity Center for access management.
    public struct Application: Swift.Equatable {
        /// The Amazon Web Services account ID number of the application.
        public var applicationAccount: Swift.String?
        /// The ARN of the application.
        public var applicationArn: Swift.String?
        /// The ARN of the application provider for this application.
        public var applicationProviderArn: Swift.String?
        /// The date and time when the application was originally created.
        public var createdDate: ClientRuntime.Date?
        /// The description of the application.
        public var description: Swift.String?
        /// The ARN of the instance of IAM Identity Center that is configured with this application.
        public var instanceArn: Swift.String?
        /// The name of the application.
        public var name: Swift.String?
        /// A structure that describes the options for the access portal associated with this application.
        public var portalOptions: SSOAdminClientTypes.PortalOptions?
        /// The current status of the application in this instance of IAM Identity Center.
        public var status: SSOAdminClientTypes.ApplicationStatus?

        public init(
            applicationAccount: Swift.String? = nil,
            applicationArn: Swift.String? = nil,
            applicationProviderArn: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            instanceArn: Swift.String? = nil,
            name: Swift.String? = nil,
            portalOptions: SSOAdminClientTypes.PortalOptions? = nil,
            status: SSOAdminClientTypes.ApplicationStatus? = nil
        )
        {
            self.applicationAccount = applicationAccount
            self.applicationArn = applicationArn
            self.applicationProviderArn = applicationProviderArn
            self.createdDate = createdDate
            self.description = description
            self.instanceArn = instanceArn
            self.name = name
            self.portalOptions = portalOptions
            self.status = status
        }
    }

}

extension SSOAdminClientTypes.ApplicationAssignment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes an assignment of a principal to an application.
    public struct ApplicationAssignment: Swift.Equatable {
        /// The ARN of the application that has principals assigned.
        /// This member is required.
        public var applicationArn: Swift.String?
        /// The unique identifier of the principal assigned to the application.
        /// This member is required.
        public var principalId: Swift.String?
        /// The type of the principal assigned to the application.
        /// This member is required.
        public var principalType: SSOAdminClientTypes.PrincipalType?

        public init(
            applicationArn: Swift.String? = nil,
            principalId: Swift.String? = nil,
            principalType: SSOAdminClientTypes.PrincipalType? = nil
        )
        {
            self.applicationArn = applicationArn
            self.principalId = principalId
            self.principalType = principalType
        }
    }

}

extension SSOAdminClientTypes.ApplicationAssignmentForPrincipal: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes an application to which a principal is assigned.
    public struct ApplicationAssignmentForPrincipal: Swift.Equatable {
        /// The ARN of the application to which the specified principal is assigned.
        public var applicationArn: Swift.String?
        /// The unique identifier of the principal assigned to the application.
        public var principalId: Swift.String?
        /// The type of the principal assigned to the application.
        public var principalType: SSOAdminClientTypes.PrincipalType?

        public init(
            applicationArn: Swift.String? = nil,
            principalId: Swift.String? = nil,
            principalType: SSOAdminClientTypes.PrincipalType? = nil
        )
        {
            self.applicationArn = applicationArn
            self.principalId = principalId
            self.principalType = principalType
        }
    }

}

extension SSOAdminClientTypes.ApplicationProvider: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationProviderArn = "ApplicationProviderArn"
        case displayData = "DisplayData"
        case federationProtocol = "FederationProtocol"
        case resourceServerConfig = "ResourceServerConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationProviderArn = self.applicationProviderArn {
            try encodeContainer.encode(applicationProviderArn, forKey: .applicationProviderArn)
        }
        if let displayData = self.displayData {
            try encodeContainer.encode(displayData, forKey: .displayData)
        }
        if let federationProtocol = self.federationProtocol {
            try encodeContainer.encode(federationProtocol.rawValue, forKey: .federationProtocol)
        }
        if let resourceServerConfig = self.resourceServerConfig {
            try encodeContainer.encode(resourceServerConfig, forKey: .resourceServerConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationProviderArn)
        applicationProviderArn = applicationProviderArnDecoded
        let federationProtocolDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.FederationProtocol.self, forKey: .federationProtocol)
        federationProtocol = federationProtocolDecoded
        let displayDataDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.DisplayData.self, forKey: .displayData)
        displayData = displayDataDecoded
        let resourceServerConfigDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.ResourceServerConfig.self, forKey: .resourceServerConfig)
        resourceServerConfig = resourceServerConfigDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes a provider that can be used to connect an Amazon Web Services managed application or customer managed application to IAM Identity Center.
    public struct ApplicationProvider: Swift.Equatable {
        /// The ARN of the application provider.
        /// This member is required.
        public var applicationProviderArn: Swift.String?
        /// A structure that describes how IAM Identity Center represents the application provider in the portal.
        public var displayData: SSOAdminClientTypes.DisplayData?
        /// The protocol that the application provider uses to perform federation.
        public var federationProtocol: SSOAdminClientTypes.FederationProtocol?
        /// A structure that describes the application provider's resource server.
        public var resourceServerConfig: SSOAdminClientTypes.ResourceServerConfig?

        public init(
            applicationProviderArn: Swift.String? = nil,
            displayData: SSOAdminClientTypes.DisplayData? = nil,
            federationProtocol: SSOAdminClientTypes.FederationProtocol? = nil,
            resourceServerConfig: SSOAdminClientTypes.ResourceServerConfig? = nil
        )
        {
            self.applicationProviderArn = applicationProviderArn
            self.displayData = displayData
            self.federationProtocol = federationProtocol
            self.resourceServerConfig = resourceServerConfig
        }
    }

}

extension SSOAdminClientTypes {
    public enum ApplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationStatus(rawValue: rawValue) ?? ApplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension SSOAdminClientTypes {
    public enum ApplicationVisibility: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationVisibility] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationVisibility(rawValue: rawValue) ?? ApplicationVisibility.sdkUnknown(rawValue)
        }
    }
}

extension AttachCustomerManagedPolicyReferenceToPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerManagedPolicyReference = "CustomerManagedPolicyReference"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerManagedPolicyReference = self.customerManagedPolicyReference {
            try encodeContainer.encode(customerManagedPolicyReference, forKey: .customerManagedPolicyReference)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension AttachCustomerManagedPolicyReferenceToPermissionSetInput {

    static func urlPathProvider(_ value: AttachCustomerManagedPolicyReferenceToPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

public struct AttachCustomerManagedPolicyReferenceToPermissionSetInput: Swift.Equatable {
    /// Specifies the name and path of a customer managed policy. You must have an IAM policy that matches the name and path in each Amazon Web Services account where you want to deploy your permission set.
    /// This member is required.
    public var customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the PermissionSet.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference? = nil,
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.customerManagedPolicyReference = customerManagedPolicyReference
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct AttachCustomerManagedPolicyReferenceToPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference?
}

extension AttachCustomerManagedPolicyReferenceToPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerManagedPolicyReference = "CustomerManagedPolicyReference"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let customerManagedPolicyReferenceDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.CustomerManagedPolicyReference.self, forKey: .customerManagedPolicyReference)
        customerManagedPolicyReference = customerManagedPolicyReferenceDecoded
    }
}

extension AttachCustomerManagedPolicyReferenceToPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AttachCustomerManagedPolicyReferenceToPermissionSetOutput: Swift.Equatable {

    public init() { }
}

enum AttachCustomerManagedPolicyReferenceToPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AttachManagedPolicyToPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case managedPolicyArn = "ManagedPolicyArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let managedPolicyArn = self.managedPolicyArn {
            try encodeContainer.encode(managedPolicyArn, forKey: .managedPolicyArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension AttachManagedPolicyToPermissionSetInput {

    static func urlPathProvider(_ value: AttachManagedPolicyToPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

public struct AttachManagedPolicyToPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The Amazon Web Services managed policy ARN to be attached to a permission set.
    /// This member is required.
    public var managedPolicyArn: Swift.String?
    /// The ARN of the [PermissionSet] that the managed policy should be attached to.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        managedPolicyArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.managedPolicyArn = managedPolicyArn
        self.permissionSetArn = permissionSetArn
    }
}

struct AttachManagedPolicyToPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let managedPolicyArn: Swift.String?
}

extension AttachManagedPolicyToPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case managedPolicyArn = "ManagedPolicyArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let managedPolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedPolicyArn)
        managedPolicyArn = managedPolicyArnDecoded
    }
}

extension AttachManagedPolicyToPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AttachManagedPolicyToPermissionSetOutput: Swift.Equatable {

    public init() { }
}

enum AttachManagedPolicyToPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSOAdminClientTypes.AttachedManagedPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that stores the details of the Amazon Web Services managed policy.
    public struct AttachedManagedPolicy: Swift.Equatable {
        /// The ARN of the Amazon Web Services managed policy. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// The name of the Amazon Web Services managed policy.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension SSOAdminClientTypes.AuthenticationMethod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iam = "Iam"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .iam(iam):
                try container.encode(iam, forKey: .iam)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let iamDecoded = try values.decodeIfPresent(SSOAdminClientTypes.IamAuthenticationMethod.self, forKey: .iam)
        if let iam = iamDecoded {
            self = .iam(iam)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes an authentication method that can be used by an application.
    public enum AuthenticationMethod: Swift.Equatable {
        /// A structure that describes details for IAM authentication.
        case iam(SSOAdminClientTypes.IamAuthenticationMethod)
        case sdkUnknown(Swift.String)
    }

}

extension SSOAdminClientTypes.AuthenticationMethodItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationMethod = "AuthenticationMethod"
        case authenticationMethodType = "AuthenticationMethodType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authenticationMethod = self.authenticationMethod {
            try encodeContainer.encode(authenticationMethod, forKey: .authenticationMethod)
        }
        if let authenticationMethodType = self.authenticationMethodType {
            try encodeContainer.encode(authenticationMethodType.rawValue, forKey: .authenticationMethodType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationMethodTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.AuthenticationMethodType.self, forKey: .authenticationMethodType)
        authenticationMethodType = authenticationMethodTypeDecoded
        let authenticationMethodDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.AuthenticationMethod.self, forKey: .authenticationMethod)
        authenticationMethod = authenticationMethodDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes an authentication method and its type.
    public struct AuthenticationMethodItem: Swift.Equatable {
        /// A structure that describes an authentication method. The contents of this structure is determined by the AuthenticationMethodType.
        public var authenticationMethod: SSOAdminClientTypes.AuthenticationMethod?
        /// The type of authentication that is used by this method.
        public var authenticationMethodType: SSOAdminClientTypes.AuthenticationMethodType?

        public init(
            authenticationMethod: SSOAdminClientTypes.AuthenticationMethod? = nil,
            authenticationMethodType: SSOAdminClientTypes.AuthenticationMethodType? = nil
        )
        {
            self.authenticationMethod = authenticationMethod
            self.authenticationMethodType = authenticationMethodType
        }
    }

}

extension SSOAdminClientTypes {
    public enum AuthenticationMethodType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iam
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationMethodType] {
            return [
                .iam,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iam: return "IAM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationMethodType(rawValue: rawValue) ?? AuthenticationMethodType.sdkUnknown(rawValue)
        }
    }
}

extension SSOAdminClientTypes.AuthorizationCodeGrant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case redirectUris = "RedirectUris"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let redirectUris = redirectUris {
            var redirectUrisContainer = encodeContainer.nestedUnkeyedContainer(forKey: .redirectUris)
            for uri0 in redirectUris {
                try redirectUrisContainer.encode(uri0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let redirectUrisContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .redirectUris)
        var redirectUrisDecoded0:[Swift.String]? = nil
        if let redirectUrisContainer = redirectUrisContainer {
            redirectUrisDecoded0 = [Swift.String]()
            for string0 in redirectUrisContainer {
                if let string0 = string0 {
                    redirectUrisDecoded0?.append(string0)
                }
            }
        }
        redirectUris = redirectUrisDecoded0
    }
}

extension SSOAdminClientTypes {
    /// A structure that defines configuration settings for an application that supports the OAuth 2.0 Authorization Code Grant.
    public struct AuthorizationCodeGrant: Swift.Equatable {
        /// A list of URIs that are valid locations to redirect a user's browser after the user is authorized.
        public var redirectUris: [Swift.String]?

        public init(
            redirectUris: [Swift.String]? = nil
        )
        {
            self.redirectUris = redirectUris
        }
    }

}

extension SSOAdminClientTypes.AuthorizedTokenIssuer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizedAudiences = "AuthorizedAudiences"
        case trustedTokenIssuerArn = "TrustedTokenIssuerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizedAudiences = authorizedAudiences {
            var authorizedAudiencesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizedAudiences)
            for tokenissueraudience0 in authorizedAudiences {
                try authorizedAudiencesContainer.encode(tokenissueraudience0)
            }
        }
        if let trustedTokenIssuerArn = self.trustedTokenIssuerArn {
            try encodeContainer.encode(trustedTokenIssuerArn, forKey: .trustedTokenIssuerArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustedTokenIssuerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustedTokenIssuerArn)
        trustedTokenIssuerArn = trustedTokenIssuerArnDecoded
        let authorizedAudiencesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizedAudiences)
        var authorizedAudiencesDecoded0:[Swift.String]? = nil
        if let authorizedAudiencesContainer = authorizedAudiencesContainer {
            authorizedAudiencesDecoded0 = [Swift.String]()
            for string0 in authorizedAudiencesContainer {
                if let string0 = string0 {
                    authorizedAudiencesDecoded0?.append(string0)
                }
            }
        }
        authorizedAudiences = authorizedAudiencesDecoded0
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes a trusted token issuer and associates it with a set of authorized audiences.
    public struct AuthorizedTokenIssuer: Swift.Equatable {
        /// An array list of authorized audiences, or applications, that can consume the tokens generated by the associated trusted token issuer.
        public var authorizedAudiences: [Swift.String]?
        /// The ARN of the trusted token issuer.
        public var trustedTokenIssuerArn: Swift.String?

        public init(
            authorizedAudiences: [Swift.String]? = nil,
            trustedTokenIssuerArn: Swift.String? = nil
        )
        {
            self.authorizedAudiences = authorizedAudiences
            self.trustedTokenIssuerArn = trustedTokenIssuerArn
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAccountAssignmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
        if let targetId = self.targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = self.targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }
}

extension CreateAccountAssignmentInput {

    static func urlPathProvider(_ value: CreateAccountAssignmentInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateAccountAssignmentInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set that the admin wants to grant the principal access to.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// An identifier for an object in IAM Identity Center, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in IAM Identity Center, see the [IAM Identity Center Identity Store API Reference].
    /// This member is required.
    public var principalId: Swift.String?
    /// The entity type for which the assignment will be created.
    /// This member is required.
    public var principalType: SSOAdminClientTypes.PrincipalType?
    /// TargetID is an Amazon Web Services account identifier, (For example, 123456789012).
    /// This member is required.
    public var targetId: Swift.String?
    /// The entity type for which the assignment will be created.
    /// This member is required.
    public var targetType: SSOAdminClientTypes.TargetType?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: SSOAdminClientTypes.PrincipalType? = nil,
        targetId: Swift.String? = nil,
        targetType: SSOAdminClientTypes.TargetType? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.principalId = principalId
        self.principalType = principalType
        self.targetId = targetId
        self.targetType = targetType
    }
}

struct CreateAccountAssignmentInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let targetId: Swift.String?
    let targetType: SSOAdminClientTypes.TargetType?
    let permissionSetArn: Swift.String?
    let principalType: SSOAdminClientTypes.PrincipalType?
    let principalId: Swift.String?
}

extension CreateAccountAssignmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension CreateAccountAssignmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAccountAssignmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignmentCreationStatus = output.accountAssignmentCreationStatus
        } else {
            self.accountAssignmentCreationStatus = nil
        }
    }
}

public struct CreateAccountAssignmentOutput: Swift.Equatable {
    /// The status object for the account assignment creation operation.
    public var accountAssignmentCreationStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus?

    public init(
        accountAssignmentCreationStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus? = nil
    )
    {
        self.accountAssignmentCreationStatus = accountAssignmentCreationStatus
    }
}

struct CreateAccountAssignmentOutputBody: Swift.Equatable {
    let accountAssignmentCreationStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus?
}

extension CreateAccountAssignmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentCreationStatus = "AccountAssignmentCreationStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentCreationStatusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.AccountAssignmentOperationStatus.self, forKey: .accountAssignmentCreationStatus)
        accountAssignmentCreationStatus = accountAssignmentCreationStatusDecoded
    }
}

enum CreateAccountAssignmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateApplicationAssignmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }
}

extension CreateApplicationAssignmentInput {

    static func urlPathProvider(_ value: CreateApplicationAssignmentInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateApplicationAssignmentInput: Swift.Equatable {
    /// The ARN of the application provider under which the operation will run.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// An identifier for an object in IAM Identity Center, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in IAM Identity Center, see the [IAM Identity Center Identity Store API Reference].
    /// This member is required.
    public var principalId: Swift.String?
    /// The entity type for which the assignment will be created.
    /// This member is required.
    public var principalType: SSOAdminClientTypes.PrincipalType?

    public init(
        applicationArn: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: SSOAdminClientTypes.PrincipalType? = nil
    )
    {
        self.applicationArn = applicationArn
        self.principalId = principalId
        self.principalType = principalType
    }
}

struct CreateApplicationAssignmentInputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let principalId: Swift.String?
    let principalType: SSOAdminClientTypes.PrincipalType?
}

extension CreateApplicationAssignmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
    }
}

extension CreateApplicationAssignmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateApplicationAssignmentOutput: Swift.Equatable {

    public init() { }
}

enum CreateApplicationAssignmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationProviderArn = "ApplicationProviderArn"
        case clientToken = "ClientToken"
        case description = "Description"
        case instanceArn = "InstanceArn"
        case name = "Name"
        case portalOptions = "PortalOptions"
        case status = "Status"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationProviderArn = self.applicationProviderArn {
            try encodeContainer.encode(applicationProviderArn, forKey: .applicationProviderArn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let portalOptions = self.portalOptions {
            try encodeContainer.encode(portalOptions, forKey: .portalOptions)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateApplicationInput {

    static func urlPathProvider(_ value: CreateApplicationInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateApplicationInput: Swift.Equatable {
    /// The ARN of the application provider under which the operation will run.
    /// This member is required.
    public var applicationProviderArn: Swift.String?
    /// Specifies a unique, case-sensitive ID that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// The description of the .
    public var description: Swift.String?
    /// The ARN of the instance of IAM Identity Center under which the operation will run. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The name of the .
    /// This member is required.
    public var name: Swift.String?
    /// A structure that describes the options for the portal associated with an application.
    public var portalOptions: SSOAdminClientTypes.PortalOptions?
    /// Specifies whether the application is enabled or disabled.
    public var status: SSOAdminClientTypes.ApplicationStatus?
    /// Specifies tags to be attached to the application.
    public var tags: [SSOAdminClientTypes.Tag]?

    public init(
        applicationProviderArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        name: Swift.String? = nil,
        portalOptions: SSOAdminClientTypes.PortalOptions? = nil,
        status: SSOAdminClientTypes.ApplicationStatus? = nil,
        tags: [SSOAdminClientTypes.Tag]? = nil
    )
    {
        self.applicationProviderArn = applicationProviderArn
        self.clientToken = clientToken
        self.description = description
        self.instanceArn = instanceArn
        self.name = name
        self.portalOptions = portalOptions
        self.status = status
        self.tags = tags
    }
}

struct CreateApplicationInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let applicationProviderArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let portalOptions: SSOAdminClientTypes.PortalOptions?
    let tags: [SSOAdminClientTypes.Tag]?
    let status: SSOAdminClientTypes.ApplicationStatus?
    let clientToken: Swift.String?
}

extension CreateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationProviderArn = "ApplicationProviderArn"
        case clientToken = "ClientToken"
        case description = "Description"
        case instanceArn = "InstanceArn"
        case name = "Name"
        case portalOptions = "PortalOptions"
        case status = "Status"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let applicationProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationProviderArn)
        applicationProviderArn = applicationProviderArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let portalOptionsDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PortalOptions.self, forKey: .portalOptions)
        portalOptions = portalOptionsDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SSOAdminClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SSOAdminClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.ApplicationStatus.self, forKey: .status)
        status = statusDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationArn = output.applicationArn
        } else {
            self.applicationArn = nil
        }
    }
}

public struct CreateApplicationOutput: Swift.Equatable {
    /// Specifies the ARN of the application.
    public var applicationArn: Swift.String?

    public init(
        applicationArn: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
    }
}

struct CreateApplicationOutputBody: Swift.Equatable {
    let applicationArn: Swift.String?
}

extension CreateApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

enum CreateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateInstanceAccessControlAttributeConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceAccessControlAttributeConfiguration = "InstanceAccessControlAttributeConfiguration"
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceAccessControlAttributeConfiguration = self.instanceAccessControlAttributeConfiguration {
            try encodeContainer.encode(instanceAccessControlAttributeConfiguration, forKey: .instanceAccessControlAttributeConfiguration)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension CreateInstanceAccessControlAttributeConfigurationInput {

    static func urlPathProvider(_ value: CreateInstanceAccessControlAttributeConfigurationInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateInstanceAccessControlAttributeConfigurationInput: Swift.Equatable {
    /// Specifies the IAM Identity Center identity store attributes to add to your ABAC configuration. When using an external identity provider as an identity source, you can pass attributes through the SAML assertion. Doing so provides an alternative to configuring attributes from the IAM Identity Center identity store. If a SAML assertion passes any of these attributes, IAM Identity Center will replace the attribute value with the value from the IAM Identity Center identity store.
    /// This member is required.
    public var instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration? = nil,
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfiguration
        self.instanceArn = instanceArn
    }
}

struct CreateInstanceAccessControlAttributeConfigurationInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration?
}

extension CreateInstanceAccessControlAttributeConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceAccessControlAttributeConfiguration = "InstanceAccessControlAttributeConfiguration"
        case instanceArn = "InstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let instanceAccessControlAttributeConfigurationDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration.self, forKey: .instanceAccessControlAttributeConfiguration)
        instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfigurationDecoded
    }
}

extension CreateInstanceAccessControlAttributeConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateInstanceAccessControlAttributeConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum CreateInstanceAccessControlAttributeConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateInstanceInput {

    static func urlPathProvider(_ value: CreateInstanceInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateInstanceInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive ID that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// The name of the instance of IAM Identity Center.
    public var name: Swift.String?
    /// Specifies tags to be attached to the instance of IAM Identity Center.
    public var tags: [SSOAdminClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [SSOAdminClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.tags = tags
    }
}

struct CreateInstanceInputBody: Swift.Equatable {
    let name: Swift.String?
    let clientToken: Swift.String?
    let tags: [SSOAdminClientTypes.Tag]?
}

extension CreateInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SSOAdminClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SSOAdminClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.instanceArn = output.instanceArn
        } else {
            self.instanceArn = nil
        }
    }
}

public struct CreateInstanceOutput: Swift.Equatable {
    /// The ARN of the instance of IAM Identity Center under which the operation will run. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    public var instanceArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
    }
}

struct CreateInstanceOutputBody: Swift.Equatable {
    let instanceArn: Swift.String?
}

extension CreateInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
    }
}

enum CreateInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case instanceArn = "InstanceArn"
        case name = "Name"
        case relayState = "RelayState"
        case sessionDuration = "SessionDuration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let relayState = self.relayState {
            try encodeContainer.encode(relayState, forKey: .relayState)
        }
        if let sessionDuration = self.sessionDuration {
            try encodeContainer.encode(sessionDuration, forKey: .sessionDuration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreatePermissionSetInput {

    static func urlPathProvider(_ value: CreatePermissionSetInput) -> Swift.String? {
        return "/"
    }
}

public struct CreatePermissionSetInput: Swift.Equatable {
    /// The description of the [PermissionSet].
    public var description: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The name of the [PermissionSet].
    /// This member is required.
    public var name: Swift.String?
    /// Used to redirect users within the application during the federation authentication process.
    public var relayState: Swift.String?
    /// The length of time that the application user sessions are valid in the ISO-8601 standard.
    public var sessionDuration: Swift.String?
    /// The tags to attach to the new [PermissionSet].
    public var tags: [SSOAdminClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        name: Swift.String? = nil,
        relayState: Swift.String? = nil,
        sessionDuration: Swift.String? = nil,
        tags: [SSOAdminClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.instanceArn = instanceArn
        self.name = name
        self.relayState = relayState
        self.sessionDuration = sessionDuration
        self.tags = tags
    }
}

struct CreatePermissionSetInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let instanceArn: Swift.String?
    let sessionDuration: Swift.String?
    let relayState: Swift.String?
    let tags: [SSOAdminClientTypes.Tag]?
}

extension CreatePermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case instanceArn = "InstanceArn"
        case name = "Name"
        case relayState = "RelayState"
        case sessionDuration = "SessionDuration"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let sessionDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionDuration)
        sessionDuration = sessionDurationDecoded
        let relayStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relayState)
        relayState = relayStateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SSOAdminClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SSOAdminClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePermissionSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.permissionSet = output.permissionSet
        } else {
            self.permissionSet = nil
        }
    }
}

public struct CreatePermissionSetOutput: Swift.Equatable {
    /// Defines the level of access on an Amazon Web Services account.
    public var permissionSet: SSOAdminClientTypes.PermissionSet?

    public init(
        permissionSet: SSOAdminClientTypes.PermissionSet? = nil
    )
    {
        self.permissionSet = permissionSet
    }
}

struct CreatePermissionSetOutputBody: Swift.Equatable {
    let permissionSet: SSOAdminClientTypes.PermissionSet?
}

extension CreatePermissionSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionSet = "PermissionSet"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PermissionSet.self, forKey: .permissionSet)
        permissionSet = permissionSetDecoded
    }
}

enum CreatePermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateTrustedTokenIssuerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case instanceArn = "InstanceArn"
        case name = "Name"
        case tags = "Tags"
        case trustedTokenIssuerConfiguration = "TrustedTokenIssuerConfiguration"
        case trustedTokenIssuerType = "TrustedTokenIssuerType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let trustedTokenIssuerConfiguration = self.trustedTokenIssuerConfiguration {
            try encodeContainer.encode(trustedTokenIssuerConfiguration, forKey: .trustedTokenIssuerConfiguration)
        }
        if let trustedTokenIssuerType = self.trustedTokenIssuerType {
            try encodeContainer.encode(trustedTokenIssuerType.rawValue, forKey: .trustedTokenIssuerType)
        }
    }
}

extension CreateTrustedTokenIssuerInput {

    static func urlPathProvider(_ value: CreateTrustedTokenIssuerInput) -> Swift.String? {
        return "/"
    }
}

public struct CreateTrustedTokenIssuerInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive ID that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Specifies the ARN of the instance of IAM Identity Center to contain the new trusted token issuer configuration.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// Specifies the name of the new trusted token issuer configuration.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies tags to be attached to the new trusted token issuer configuration.
    public var tags: [SSOAdminClientTypes.Tag]?
    /// Specifies settings that apply to the new trusted token issuer configuration. The settings that are available depend on what TrustedTokenIssuerType you specify.
    /// This member is required.
    public var trustedTokenIssuerConfiguration: SSOAdminClientTypes.TrustedTokenIssuerConfiguration?
    /// Specifies the type of the new trusted token issuer.
    /// This member is required.
    public var trustedTokenIssuerType: SSOAdminClientTypes.TrustedTokenIssuerType?

    public init(
        clientToken: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [SSOAdminClientTypes.Tag]? = nil,
        trustedTokenIssuerConfiguration: SSOAdminClientTypes.TrustedTokenIssuerConfiguration? = nil,
        trustedTokenIssuerType: SSOAdminClientTypes.TrustedTokenIssuerType? = nil
    )
    {
        self.clientToken = clientToken
        self.instanceArn = instanceArn
        self.name = name
        self.tags = tags
        self.trustedTokenIssuerConfiguration = trustedTokenIssuerConfiguration
        self.trustedTokenIssuerType = trustedTokenIssuerType
    }
}

struct CreateTrustedTokenIssuerInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let name: Swift.String?
    let trustedTokenIssuerType: SSOAdminClientTypes.TrustedTokenIssuerType?
    let trustedTokenIssuerConfiguration: SSOAdminClientTypes.TrustedTokenIssuerConfiguration?
    let clientToken: Swift.String?
    let tags: [SSOAdminClientTypes.Tag]?
}

extension CreateTrustedTokenIssuerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case instanceArn = "InstanceArn"
        case name = "Name"
        case tags = "Tags"
        case trustedTokenIssuerConfiguration = "TrustedTokenIssuerConfiguration"
        case trustedTokenIssuerType = "TrustedTokenIssuerType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let trustedTokenIssuerTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.TrustedTokenIssuerType.self, forKey: .trustedTokenIssuerType)
        trustedTokenIssuerType = trustedTokenIssuerTypeDecoded
        let trustedTokenIssuerConfigurationDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.TrustedTokenIssuerConfiguration.self, forKey: .trustedTokenIssuerConfiguration)
        trustedTokenIssuerConfiguration = trustedTokenIssuerConfigurationDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SSOAdminClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SSOAdminClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateTrustedTokenIssuerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateTrustedTokenIssuerOutputBody = try responseDecoder.decode(responseBody: data)
            self.trustedTokenIssuerArn = output.trustedTokenIssuerArn
        } else {
            self.trustedTokenIssuerArn = nil
        }
    }
}

public struct CreateTrustedTokenIssuerOutput: Swift.Equatable {
    /// The ARN of the new trusted token issuer configuration.
    public var trustedTokenIssuerArn: Swift.String?

    public init(
        trustedTokenIssuerArn: Swift.String? = nil
    )
    {
        self.trustedTokenIssuerArn = trustedTokenIssuerArn
    }
}

struct CreateTrustedTokenIssuerOutputBody: Swift.Equatable {
    let trustedTokenIssuerArn: Swift.String?
}

extension CreateTrustedTokenIssuerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustedTokenIssuerArn = "TrustedTokenIssuerArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustedTokenIssuerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustedTokenIssuerArn)
        trustedTokenIssuerArn = trustedTokenIssuerArnDecoded
    }
}

enum CreateTrustedTokenIssuerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSOAdminClientTypes.CustomerManagedPolicyReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension SSOAdminClientTypes {
    /// Specifies the name and path of a customer managed policy. You must have an IAM policy that matches the name and path in each Amazon Web Services account where you want to deploy your permission set.
    public struct CustomerManagedPolicyReference: Swift.Equatable {
        /// The name of the IAM policy that you have configured in each account where you want to deploy your permission set.
        /// This member is required.
        public var name: Swift.String?
        /// The path to the IAM policy that you have configured in each account where you want to deploy your permission set. The default is /. For more information, see [Friendly names and paths](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-friendly-names) in the IAM User Guide.
        public var path: Swift.String?

        public init(
            name: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.name = name
            self.path = path
        }
    }

}

extension DeleteAccountAssignmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
        if let targetId = self.targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = self.targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }
}

extension DeleteAccountAssignmentInput {

    static func urlPathProvider(_ value: DeleteAccountAssignmentInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteAccountAssignmentInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set that will be used to remove access.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// An identifier for an object in IAM Identity Center, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in IAM Identity Center, see the [IAM Identity Center Identity Store API Reference].
    /// This member is required.
    public var principalId: Swift.String?
    /// The entity type for which the assignment will be deleted.
    /// This member is required.
    public var principalType: SSOAdminClientTypes.PrincipalType?
    /// TargetID is an Amazon Web Services account identifier, (For example, 123456789012).
    /// This member is required.
    public var targetId: Swift.String?
    /// The entity type for which the assignment will be deleted.
    /// This member is required.
    public var targetType: SSOAdminClientTypes.TargetType?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: SSOAdminClientTypes.PrincipalType? = nil,
        targetId: Swift.String? = nil,
        targetType: SSOAdminClientTypes.TargetType? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.principalId = principalId
        self.principalType = principalType
        self.targetId = targetId
        self.targetType = targetType
    }
}

struct DeleteAccountAssignmentInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let targetId: Swift.String?
    let targetType: SSOAdminClientTypes.TargetType?
    let permissionSetArn: Swift.String?
    let principalType: SSOAdminClientTypes.PrincipalType?
    let principalId: Swift.String?
}

extension DeleteAccountAssignmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension DeleteAccountAssignmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteAccountAssignmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignmentDeletionStatus = output.accountAssignmentDeletionStatus
        } else {
            self.accountAssignmentDeletionStatus = nil
        }
    }
}

public struct DeleteAccountAssignmentOutput: Swift.Equatable {
    /// The status object for the account assignment deletion operation.
    public var accountAssignmentDeletionStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus?

    public init(
        accountAssignmentDeletionStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus? = nil
    )
    {
        self.accountAssignmentDeletionStatus = accountAssignmentDeletionStatus
    }
}

struct DeleteAccountAssignmentOutputBody: Swift.Equatable {
    let accountAssignmentDeletionStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus?
}

extension DeleteAccountAssignmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentDeletionStatus = "AccountAssignmentDeletionStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentDeletionStatusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.AccountAssignmentOperationStatus.self, forKey: .accountAssignmentDeletionStatus)
        accountAssignmentDeletionStatus = accountAssignmentDeletionStatusDecoded
    }
}

enum DeleteAccountAssignmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteApplicationAccessScopeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case scope = "Scope"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope, forKey: .scope)
        }
    }
}

extension DeleteApplicationAccessScopeInput {

    static func urlPathProvider(_ value: DeleteApplicationAccessScopeInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationAccessScopeInput: Swift.Equatable {
    /// Specifies the ARN of the application with the access scope to delete.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies the name of the access scope to remove from the application.
    /// This member is required.
    public var scope: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        scope: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.scope = scope
    }
}

struct DeleteApplicationAccessScopeInputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let scope: Swift.String?
}

extension DeleteApplicationAccessScopeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case scope = "Scope"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scope)
        scope = scopeDecoded
    }
}

extension DeleteApplicationAccessScopeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteApplicationAccessScopeOutput: Swift.Equatable {

    public init() { }
}

enum DeleteApplicationAccessScopeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteApplicationAssignmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }
}

extension DeleteApplicationAssignmentInput {

    static func urlPathProvider(_ value: DeleteApplicationAssignmentInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationAssignmentInput: Swift.Equatable {
    /// Specifies the ARN of the application.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// An identifier for an object in IAM Identity Center, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in IAM Identity Center, see the [IAM Identity Center Identity Store API Reference].
    /// This member is required.
    public var principalId: Swift.String?
    /// The entity type for which the assignment will be deleted.
    /// This member is required.
    public var principalType: SSOAdminClientTypes.PrincipalType?

    public init(
        applicationArn: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: SSOAdminClientTypes.PrincipalType? = nil
    )
    {
        self.applicationArn = applicationArn
        self.principalId = principalId
        self.principalType = principalType
    }
}

struct DeleteApplicationAssignmentInputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let principalId: Swift.String?
    let principalType: SSOAdminClientTypes.PrincipalType?
}

extension DeleteApplicationAssignmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
    }
}

extension DeleteApplicationAssignmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteApplicationAssignmentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteApplicationAssignmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteApplicationAuthenticationMethodInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case authenticationMethodType = "AuthenticationMethodType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let authenticationMethodType = self.authenticationMethodType {
            try encodeContainer.encode(authenticationMethodType.rawValue, forKey: .authenticationMethodType)
        }
    }
}

extension DeleteApplicationAuthenticationMethodInput {

    static func urlPathProvider(_ value: DeleteApplicationAuthenticationMethodInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationAuthenticationMethodInput: Swift.Equatable {
    /// Specifies the ARN of the application with the authentication method to delete.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies the authentication method type to delete from the application.
    /// This member is required.
    public var authenticationMethodType: SSOAdminClientTypes.AuthenticationMethodType?

    public init(
        applicationArn: Swift.String? = nil,
        authenticationMethodType: SSOAdminClientTypes.AuthenticationMethodType? = nil
    )
    {
        self.applicationArn = applicationArn
        self.authenticationMethodType = authenticationMethodType
    }
}

struct DeleteApplicationAuthenticationMethodInputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let authenticationMethodType: SSOAdminClientTypes.AuthenticationMethodType?
}

extension DeleteApplicationAuthenticationMethodInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case authenticationMethodType = "AuthenticationMethodType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let authenticationMethodTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.AuthenticationMethodType.self, forKey: .authenticationMethodType)
        authenticationMethodType = authenticationMethodTypeDecoded
    }
}

extension DeleteApplicationAuthenticationMethodOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteApplicationAuthenticationMethodOutput: Swift.Equatable {

    public init() { }
}

enum DeleteApplicationAuthenticationMethodOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteApplicationGrantInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case grantType = "GrantType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let grantType = self.grantType {
            try encodeContainer.encode(grantType.rawValue, forKey: .grantType)
        }
    }
}

extension DeleteApplicationGrantInput {

    static func urlPathProvider(_ value: DeleteApplicationGrantInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationGrantInput: Swift.Equatable {
    /// Specifies the ARN of the application with the grant to delete.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies the type of grant to delete from the application.
    /// This member is required.
    public var grantType: SSOAdminClientTypes.GrantType?

    public init(
        applicationArn: Swift.String? = nil,
        grantType: SSOAdminClientTypes.GrantType? = nil
    )
    {
        self.applicationArn = applicationArn
        self.grantType = grantType
    }
}

struct DeleteApplicationGrantInputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let grantType: SSOAdminClientTypes.GrantType?
}

extension DeleteApplicationGrantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case grantType = "GrantType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let grantTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.GrantType.self, forKey: .grantType)
        grantType = grantTypeDecoded
    }
}

extension DeleteApplicationGrantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteApplicationGrantOutput: Swift.Equatable {

    public init() { }
}

enum DeleteApplicationGrantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
    }
}

extension DeleteApplicationInput {

    static func urlPathProvider(_ value: DeleteApplicationInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteApplicationInput: Swift.Equatable {
    /// Specifies the ARN of the application. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var applicationArn: Swift.String?

    public init(
        applicationArn: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
    }
}

struct DeleteApplicationInputBody: Swift.Equatable {
    let applicationArn: Swift.String?
}

extension DeleteApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

extension DeleteApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteApplicationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteInlinePolicyFromPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension DeleteInlinePolicyFromPermissionSetInput {

    static func urlPathProvider(_ value: DeleteInlinePolicyFromPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteInlinePolicyFromPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set that will be used to remove access.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct DeleteInlinePolicyFromPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
}

extension DeleteInlinePolicyFromPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
    }
}

extension DeleteInlinePolicyFromPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteInlinePolicyFromPermissionSetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteInlinePolicyFromPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteInstanceAccessControlAttributeConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension DeleteInstanceAccessControlAttributeConfigurationInput {

    static func urlPathProvider(_ value: DeleteInstanceAccessControlAttributeConfigurationInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteInstanceAccessControlAttributeConfigurationInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
    }
}

struct DeleteInstanceAccessControlAttributeConfigurationInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
}

extension DeleteInstanceAccessControlAttributeConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
    }
}

extension DeleteInstanceAccessControlAttributeConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteInstanceAccessControlAttributeConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteInstanceAccessControlAttributeConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension DeleteInstanceInput {

    static func urlPathProvider(_ value: DeleteInstanceInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteInstanceInput: Swift.Equatable {
    /// The ARN of the instance of IAM Identity Center under which the operation will run.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
    }
}

struct DeleteInstanceInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
}

extension DeleteInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
    }
}

extension DeleteInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteInstanceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension DeletePermissionSetInput {

    static func urlPathProvider(_ value: DeletePermissionSetInput) -> Swift.String? {
        return "/"
    }
}

public struct DeletePermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set that should be deleted.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct DeletePermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
}

extension DeletePermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
    }
}

extension DeletePermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePermissionSetOutput: Swift.Equatable {

    public init() { }
}

enum DeletePermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePermissionsBoundaryFromPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension DeletePermissionsBoundaryFromPermissionSetInput {

    static func urlPathProvider(_ value: DeletePermissionsBoundaryFromPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

public struct DeletePermissionsBoundaryFromPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the PermissionSet.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct DeletePermissionsBoundaryFromPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
}

extension DeletePermissionsBoundaryFromPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
    }
}

extension DeletePermissionsBoundaryFromPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePermissionsBoundaryFromPermissionSetOutput: Swift.Equatable {

    public init() { }
}

enum DeletePermissionsBoundaryFromPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTrustedTokenIssuerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustedTokenIssuerArn = "TrustedTokenIssuerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trustedTokenIssuerArn = self.trustedTokenIssuerArn {
            try encodeContainer.encode(trustedTokenIssuerArn, forKey: .trustedTokenIssuerArn)
        }
    }
}

extension DeleteTrustedTokenIssuerInput {

    static func urlPathProvider(_ value: DeleteTrustedTokenIssuerInput) -> Swift.String? {
        return "/"
    }
}

public struct DeleteTrustedTokenIssuerInput: Swift.Equatable {
    /// Specifies the ARN of the trusted token issuer configuration to delete.
    /// This member is required.
    public var trustedTokenIssuerArn: Swift.String?

    public init(
        trustedTokenIssuerArn: Swift.String? = nil
    )
    {
        self.trustedTokenIssuerArn = trustedTokenIssuerArn
    }
}

struct DeleteTrustedTokenIssuerInputBody: Swift.Equatable {
    let trustedTokenIssuerArn: Swift.String?
}

extension DeleteTrustedTokenIssuerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustedTokenIssuerArn = "TrustedTokenIssuerArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustedTokenIssuerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustedTokenIssuerArn)
        trustedTokenIssuerArn = trustedTokenIssuerArnDecoded
    }
}

extension DeleteTrustedTokenIssuerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTrustedTokenIssuerOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTrustedTokenIssuerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAccountAssignmentCreationStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentCreationRequestId = "AccountAssignmentCreationRequestId"
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAssignmentCreationRequestId = self.accountAssignmentCreationRequestId {
            try encodeContainer.encode(accountAssignmentCreationRequestId, forKey: .accountAssignmentCreationRequestId)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension DescribeAccountAssignmentCreationStatusInput {

    static func urlPathProvider(_ value: DescribeAccountAssignmentCreationStatusInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeAccountAssignmentCreationStatusInput: Swift.Equatable {
    /// The identifier that is used to track the request operation progress.
    /// This member is required.
    public var accountAssignmentCreationRequestId: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        accountAssignmentCreationRequestId: Swift.String? = nil,
        instanceArn: Swift.String? = nil
    )
    {
        self.accountAssignmentCreationRequestId = accountAssignmentCreationRequestId
        self.instanceArn = instanceArn
    }
}

struct DescribeAccountAssignmentCreationStatusInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let accountAssignmentCreationRequestId: Swift.String?
}

extension DescribeAccountAssignmentCreationStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentCreationRequestId = "AccountAssignmentCreationRequestId"
        case instanceArn = "InstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let accountAssignmentCreationRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountAssignmentCreationRequestId)
        accountAssignmentCreationRequestId = accountAssignmentCreationRequestIdDecoded
    }
}

extension DescribeAccountAssignmentCreationStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAccountAssignmentCreationStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignmentCreationStatus = output.accountAssignmentCreationStatus
        } else {
            self.accountAssignmentCreationStatus = nil
        }
    }
}

public struct DescribeAccountAssignmentCreationStatusOutput: Swift.Equatable {
    /// The status object for the account assignment creation operation.
    public var accountAssignmentCreationStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus?

    public init(
        accountAssignmentCreationStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus? = nil
    )
    {
        self.accountAssignmentCreationStatus = accountAssignmentCreationStatus
    }
}

struct DescribeAccountAssignmentCreationStatusOutputBody: Swift.Equatable {
    let accountAssignmentCreationStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus?
}

extension DescribeAccountAssignmentCreationStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentCreationStatus = "AccountAssignmentCreationStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentCreationStatusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.AccountAssignmentOperationStatus.self, forKey: .accountAssignmentCreationStatus)
        accountAssignmentCreationStatus = accountAssignmentCreationStatusDecoded
    }
}

enum DescribeAccountAssignmentCreationStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAccountAssignmentDeletionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentDeletionRequestId = "AccountAssignmentDeletionRequestId"
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAssignmentDeletionRequestId = self.accountAssignmentDeletionRequestId {
            try encodeContainer.encode(accountAssignmentDeletionRequestId, forKey: .accountAssignmentDeletionRequestId)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension DescribeAccountAssignmentDeletionStatusInput {

    static func urlPathProvider(_ value: DescribeAccountAssignmentDeletionStatusInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeAccountAssignmentDeletionStatusInput: Swift.Equatable {
    /// The identifier that is used to track the request operation progress.
    /// This member is required.
    public var accountAssignmentDeletionRequestId: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        accountAssignmentDeletionRequestId: Swift.String? = nil,
        instanceArn: Swift.String? = nil
    )
    {
        self.accountAssignmentDeletionRequestId = accountAssignmentDeletionRequestId
        self.instanceArn = instanceArn
    }
}

struct DescribeAccountAssignmentDeletionStatusInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let accountAssignmentDeletionRequestId: Swift.String?
}

extension DescribeAccountAssignmentDeletionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentDeletionRequestId = "AccountAssignmentDeletionRequestId"
        case instanceArn = "InstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let accountAssignmentDeletionRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountAssignmentDeletionRequestId)
        accountAssignmentDeletionRequestId = accountAssignmentDeletionRequestIdDecoded
    }
}

extension DescribeAccountAssignmentDeletionStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAccountAssignmentDeletionStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignmentDeletionStatus = output.accountAssignmentDeletionStatus
        } else {
            self.accountAssignmentDeletionStatus = nil
        }
    }
}

public struct DescribeAccountAssignmentDeletionStatusOutput: Swift.Equatable {
    /// The status object for the account assignment deletion operation.
    public var accountAssignmentDeletionStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus?

    public init(
        accountAssignmentDeletionStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus? = nil
    )
    {
        self.accountAssignmentDeletionStatus = accountAssignmentDeletionStatus
    }
}

struct DescribeAccountAssignmentDeletionStatusOutputBody: Swift.Equatable {
    let accountAssignmentDeletionStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus?
}

extension DescribeAccountAssignmentDeletionStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentDeletionStatus = "AccountAssignmentDeletionStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentDeletionStatusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.AccountAssignmentOperationStatus.self, forKey: .accountAssignmentDeletionStatus)
        accountAssignmentDeletionStatus = accountAssignmentDeletionStatusDecoded
    }
}

enum DescribeAccountAssignmentDeletionStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeApplicationAssignmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }
}

extension DescribeApplicationAssignmentInput {

    static func urlPathProvider(_ value: DescribeApplicationAssignmentInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeApplicationAssignmentInput: Swift.Equatable {
    /// Specifies the ARN of the application. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// An identifier for an object in IAM Identity Center, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in IAM Identity Center, see the [IAM Identity Center Identity Store API Reference].
    /// This member is required.
    public var principalId: Swift.String?
    /// The entity type for which the assignment will be created.
    /// This member is required.
    public var principalType: SSOAdminClientTypes.PrincipalType?

    public init(
        applicationArn: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: SSOAdminClientTypes.PrincipalType? = nil
    )
    {
        self.applicationArn = applicationArn
        self.principalId = principalId
        self.principalType = principalType
    }
}

struct DescribeApplicationAssignmentInputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let principalId: Swift.String?
    let principalType: SSOAdminClientTypes.PrincipalType?
}

extension DescribeApplicationAssignmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
    }
}

extension DescribeApplicationAssignmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeApplicationAssignmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationArn = output.applicationArn
            self.principalId = output.principalId
            self.principalType = output.principalType
        } else {
            self.applicationArn = nil
            self.principalId = nil
            self.principalType = nil
        }
    }
}

public struct DescribeApplicationAssignmentOutput: Swift.Equatable {
    /// Specifies the ARN of the application. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    public var applicationArn: Swift.String?
    /// An identifier for an object in IAM Identity Center, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in IAM Identity Center, see the [IAM Identity Center Identity Store API Reference].
    public var principalId: Swift.String?
    /// The entity type for which the assignment will be created.
    public var principalType: SSOAdminClientTypes.PrincipalType?

    public init(
        applicationArn: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: SSOAdminClientTypes.PrincipalType? = nil
    )
    {
        self.applicationArn = applicationArn
        self.principalId = principalId
        self.principalType = principalType
    }
}

struct DescribeApplicationAssignmentOutputBody: Swift.Equatable {
    let principalType: SSOAdminClientTypes.PrincipalType?
    let principalId: Swift.String?
    let applicationArn: Swift.String?
}

extension DescribeApplicationAssignmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let principalTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

enum DescribeApplicationAssignmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
    }
}

extension DescribeApplicationInput {

    static func urlPathProvider(_ value: DescribeApplicationInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeApplicationInput: Swift.Equatable {
    /// Specifies the ARN of the application. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var applicationArn: Swift.String?

    public init(
        applicationArn: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
    }
}

struct DescribeApplicationInputBody: Swift.Equatable {
    let applicationArn: Swift.String?
}

extension DescribeApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

extension DescribeApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeApplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationAccount = output.applicationAccount
            self.applicationArn = output.applicationArn
            self.applicationProviderArn = output.applicationProviderArn
            self.createdDate = output.createdDate
            self.description = output.description
            self.instanceArn = output.instanceArn
            self.name = output.name
            self.portalOptions = output.portalOptions
            self.status = output.status
        } else {
            self.applicationAccount = nil
            self.applicationArn = nil
            self.applicationProviderArn = nil
            self.createdDate = nil
            self.description = nil
            self.instanceArn = nil
            self.name = nil
            self.portalOptions = nil
            self.status = nil
        }
    }
}

public struct DescribeApplicationOutput: Swift.Equatable {
    /// The account ID.
    public var applicationAccount: Swift.String?
    /// Specifies the ARN of the application.
    public var applicationArn: Swift.String?
    /// The ARN of the application provider under which the operation will run.
    public var applicationProviderArn: Swift.String?
    /// The date the application was created.
    public var createdDate: ClientRuntime.Date?
    /// The description of the .
    public var description: Swift.String?
    /// The ARN of the IAM Identity Center application under which the operation will run. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    public var instanceArn: Swift.String?
    /// The application name.
    public var name: Swift.String?
    /// A structure that describes the options for the portal associated with an application.
    public var portalOptions: SSOAdminClientTypes.PortalOptions?
    /// Specifies whether the application is enabled or disabled.
    public var status: SSOAdminClientTypes.ApplicationStatus?

    public init(
        applicationAccount: Swift.String? = nil,
        applicationArn: Swift.String? = nil,
        applicationProviderArn: Swift.String? = nil,
        createdDate: ClientRuntime.Date? = nil,
        description: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        name: Swift.String? = nil,
        portalOptions: SSOAdminClientTypes.PortalOptions? = nil,
        status: SSOAdminClientTypes.ApplicationStatus? = nil
    )
    {
        self.applicationAccount = applicationAccount
        self.applicationArn = applicationArn
        self.applicationProviderArn = applicationProviderArn
        self.createdDate = createdDate
        self.description = description
        self.instanceArn = instanceArn
        self.name = name
        self.portalOptions = portalOptions
        self.status = status
    }
}

struct DescribeApplicationOutputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let applicationProviderArn: Swift.String?
    let name: Swift.String?
    let applicationAccount: Swift.String?
    let instanceArn: Swift.String?
    let status: SSOAdminClientTypes.ApplicationStatus?
    let portalOptions: SSOAdminClientTypes.PortalOptions?
    let description: Swift.String?
    let createdDate: ClientRuntime.Date?
}

extension DescribeApplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationAccount = "ApplicationAccount"
        case applicationArn = "ApplicationArn"
        case applicationProviderArn = "ApplicationProviderArn"
        case createdDate = "CreatedDate"
        case description = "Description"
        case instanceArn = "InstanceArn"
        case name = "Name"
        case portalOptions = "PortalOptions"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let applicationProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationProviderArn)
        applicationProviderArn = applicationProviderArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let applicationAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationAccount)
        applicationAccount = applicationAccountDecoded
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.ApplicationStatus.self, forKey: .status)
        status = statusDecoded
        let portalOptionsDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PortalOptions.self, forKey: .portalOptions)
        portalOptions = portalOptionsDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

enum DescribeApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeApplicationProviderInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationProviderArn = "ApplicationProviderArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationProviderArn = self.applicationProviderArn {
            try encodeContainer.encode(applicationProviderArn, forKey: .applicationProviderArn)
        }
    }
}

extension DescribeApplicationProviderInput {

    static func urlPathProvider(_ value: DescribeApplicationProviderInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeApplicationProviderInput: Swift.Equatable {
    /// Specifies the ARN of the application provider for which you want details.
    /// This member is required.
    public var applicationProviderArn: Swift.String?

    public init(
        applicationProviderArn: Swift.String? = nil
    )
    {
        self.applicationProviderArn = applicationProviderArn
    }
}

struct DescribeApplicationProviderInputBody: Swift.Equatable {
    let applicationProviderArn: Swift.String?
}

extension DescribeApplicationProviderInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationProviderArn = "ApplicationProviderArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationProviderArn)
        applicationProviderArn = applicationProviderArnDecoded
    }
}

extension DescribeApplicationProviderOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeApplicationProviderOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationProviderArn = output.applicationProviderArn
            self.displayData = output.displayData
            self.federationProtocol = output.federationProtocol
            self.resourceServerConfig = output.resourceServerConfig
        } else {
            self.applicationProviderArn = nil
            self.displayData = nil
            self.federationProtocol = nil
            self.resourceServerConfig = nil
        }
    }
}

public struct DescribeApplicationProviderOutput: Swift.Equatable {
    /// The ARN of the application provider.
    /// This member is required.
    public var applicationProviderArn: Swift.String?
    /// A structure with details about the display data for the application provider.
    public var displayData: SSOAdminClientTypes.DisplayData?
    /// The protocol used to federate to the application provider.
    public var federationProtocol: SSOAdminClientTypes.FederationProtocol?
    /// A structure with details about the receiving application.
    public var resourceServerConfig: SSOAdminClientTypes.ResourceServerConfig?

    public init(
        applicationProviderArn: Swift.String? = nil,
        displayData: SSOAdminClientTypes.DisplayData? = nil,
        federationProtocol: SSOAdminClientTypes.FederationProtocol? = nil,
        resourceServerConfig: SSOAdminClientTypes.ResourceServerConfig? = nil
    )
    {
        self.applicationProviderArn = applicationProviderArn
        self.displayData = displayData
        self.federationProtocol = federationProtocol
        self.resourceServerConfig = resourceServerConfig
    }
}

struct DescribeApplicationProviderOutputBody: Swift.Equatable {
    let applicationProviderArn: Swift.String?
    let federationProtocol: SSOAdminClientTypes.FederationProtocol?
    let displayData: SSOAdminClientTypes.DisplayData?
    let resourceServerConfig: SSOAdminClientTypes.ResourceServerConfig?
}

extension DescribeApplicationProviderOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationProviderArn = "ApplicationProviderArn"
        case displayData = "DisplayData"
        case federationProtocol = "FederationProtocol"
        case resourceServerConfig = "ResourceServerConfig"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationProviderArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationProviderArn)
        applicationProviderArn = applicationProviderArnDecoded
        let federationProtocolDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.FederationProtocol.self, forKey: .federationProtocol)
        federationProtocol = federationProtocolDecoded
        let displayDataDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.DisplayData.self, forKey: .displayData)
        displayData = displayDataDecoded
        let resourceServerConfigDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.ResourceServerConfig.self, forKey: .resourceServerConfig)
        resourceServerConfig = resourceServerConfigDecoded
    }
}

enum DescribeApplicationProviderOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeInstanceAccessControlAttributeConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension DescribeInstanceAccessControlAttributeConfigurationInput {

    static func urlPathProvider(_ value: DescribeInstanceAccessControlAttributeConfigurationInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeInstanceAccessControlAttributeConfigurationInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
    }
}

struct DescribeInstanceAccessControlAttributeConfigurationInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
}

extension DescribeInstanceAccessControlAttributeConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
    }
}

extension DescribeInstanceAccessControlAttributeConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeInstanceAccessControlAttributeConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.instanceAccessControlAttributeConfiguration = output.instanceAccessControlAttributeConfiguration
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.instanceAccessControlAttributeConfiguration = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct DescribeInstanceAccessControlAttributeConfigurationOutput: Swift.Equatable {
    /// Gets the list of IAM Identity Center identity store attributes that have been added to your ABAC configuration.
    public var instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration?
    /// The status of the attribute configuration process.
    public var status: SSOAdminClientTypes.InstanceAccessControlAttributeConfigurationStatus?
    /// Provides more details about the current status of the specified attribute.
    public var statusReason: Swift.String?

    public init(
        instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration? = nil,
        status: SSOAdminClientTypes.InstanceAccessControlAttributeConfigurationStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfiguration
        self.status = status
        self.statusReason = statusReason
    }
}

struct DescribeInstanceAccessControlAttributeConfigurationOutputBody: Swift.Equatable {
    let status: SSOAdminClientTypes.InstanceAccessControlAttributeConfigurationStatus?
    let statusReason: Swift.String?
    let instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration?
}

extension DescribeInstanceAccessControlAttributeConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceAccessControlAttributeConfiguration = "InstanceAccessControlAttributeConfiguration"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.InstanceAccessControlAttributeConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let instanceAccessControlAttributeConfigurationDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration.self, forKey: .instanceAccessControlAttributeConfiguration)
        instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfigurationDecoded
    }
}

enum DescribeInstanceAccessControlAttributeConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension DescribeInstanceInput {

    static func urlPathProvider(_ value: DescribeInstanceInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeInstanceInput: Swift.Equatable {
    /// The ARN of the instance of IAM Identity Center under which the operation will run.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
    }
}

struct DescribeInstanceInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
}

extension DescribeInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
    }
}

extension DescribeInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdDate = output.createdDate
            self.identityStoreId = output.identityStoreId
            self.instanceArn = output.instanceArn
            self.name = output.name
            self.ownerAccountId = output.ownerAccountId
            self.status = output.status
        } else {
            self.createdDate = nil
            self.identityStoreId = nil
            self.instanceArn = nil
            self.name = nil
            self.ownerAccountId = nil
            self.status = nil
        }
    }
}

public struct DescribeInstanceOutput: Swift.Equatable {
    /// The date the instance was created.
    public var createdDate: ClientRuntime.Date?
    /// The identifier of the identity store that is connected to the instance of IAM Identity Center.
    public var identityStoreId: Swift.String?
    /// The ARN of the instance of IAM Identity Center under which the operation will run. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    public var instanceArn: Swift.String?
    /// Specifies the instance name.
    public var name: Swift.String?
    /// The identifier of the Amazon Web Services account for which the instance was created.
    public var ownerAccountId: Swift.String?
    /// The status of the instance.
    public var status: SSOAdminClientTypes.InstanceStatus?

    public init(
        createdDate: ClientRuntime.Date? = nil,
        identityStoreId: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        name: Swift.String? = nil,
        ownerAccountId: Swift.String? = nil,
        status: SSOAdminClientTypes.InstanceStatus? = nil
    )
    {
        self.createdDate = createdDate
        self.identityStoreId = identityStoreId
        self.instanceArn = instanceArn
        self.name = name
        self.ownerAccountId = ownerAccountId
        self.status = status
    }
}

struct DescribeInstanceOutputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let identityStoreId: Swift.String?
    let ownerAccountId: Swift.String?
    let name: Swift.String?
    let createdDate: ClientRuntime.Date?
    let status: SSOAdminClientTypes.InstanceStatus?
}

extension DescribeInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case identityStoreId = "IdentityStoreId"
        case instanceArn = "InstanceArn"
        case name = "Name"
        case ownerAccountId = "OwnerAccountId"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.InstanceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum DescribeInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension DescribePermissionSetInput {

    static func urlPathProvider(_ value: DescribePermissionSetInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribePermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct DescribePermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
}

extension DescribePermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
    }
}

extension DescribePermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePermissionSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.permissionSet = output.permissionSet
        } else {
            self.permissionSet = nil
        }
    }
}

public struct DescribePermissionSetOutput: Swift.Equatable {
    /// Describes the level of access on an Amazon Web Services account.
    public var permissionSet: SSOAdminClientTypes.PermissionSet?

    public init(
        permissionSet: SSOAdminClientTypes.PermissionSet? = nil
    )
    {
        self.permissionSet = permissionSet
    }
}

struct DescribePermissionSetOutputBody: Swift.Equatable {
    let permissionSet: SSOAdminClientTypes.PermissionSet?
}

extension DescribePermissionSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionSet = "PermissionSet"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PermissionSet.self, forKey: .permissionSet)
        permissionSet = permissionSetDecoded
    }
}

enum DescribePermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePermissionSetProvisioningStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case provisionPermissionSetRequestId = "ProvisionPermissionSetRequestId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let provisionPermissionSetRequestId = self.provisionPermissionSetRequestId {
            try encodeContainer.encode(provisionPermissionSetRequestId, forKey: .provisionPermissionSetRequestId)
        }
    }
}

extension DescribePermissionSetProvisioningStatusInput {

    static func urlPathProvider(_ value: DescribePermissionSetProvisioningStatusInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribePermissionSetProvisioningStatusInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The identifier that is provided by the [ProvisionPermissionSet] call to retrieve the current status of the provisioning workflow.
    /// This member is required.
    public var provisionPermissionSetRequestId: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        provisionPermissionSetRequestId: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.provisionPermissionSetRequestId = provisionPermissionSetRequestId
    }
}

struct DescribePermissionSetProvisioningStatusInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let provisionPermissionSetRequestId: Swift.String?
}

extension DescribePermissionSetProvisioningStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case provisionPermissionSetRequestId = "ProvisionPermissionSetRequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let provisionPermissionSetRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionPermissionSetRequestId)
        provisionPermissionSetRequestId = provisionPermissionSetRequestIdDecoded
    }
}

extension DescribePermissionSetProvisioningStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePermissionSetProvisioningStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.permissionSetProvisioningStatus = output.permissionSetProvisioningStatus
        } else {
            self.permissionSetProvisioningStatus = nil
        }
    }
}

public struct DescribePermissionSetProvisioningStatusOutput: Swift.Equatable {
    /// The status object for the permission set provisioning operation.
    public var permissionSetProvisioningStatus: SSOAdminClientTypes.PermissionSetProvisioningStatus?

    public init(
        permissionSetProvisioningStatus: SSOAdminClientTypes.PermissionSetProvisioningStatus? = nil
    )
    {
        self.permissionSetProvisioningStatus = permissionSetProvisioningStatus
    }
}

struct DescribePermissionSetProvisioningStatusOutputBody: Swift.Equatable {
    let permissionSetProvisioningStatus: SSOAdminClientTypes.PermissionSetProvisioningStatus?
}

extension DescribePermissionSetProvisioningStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionSetProvisioningStatus = "PermissionSetProvisioningStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetProvisioningStatusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PermissionSetProvisioningStatus.self, forKey: .permissionSetProvisioningStatus)
        permissionSetProvisioningStatus = permissionSetProvisioningStatusDecoded
    }
}

enum DescribePermissionSetProvisioningStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeTrustedTokenIssuerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustedTokenIssuerArn = "TrustedTokenIssuerArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let trustedTokenIssuerArn = self.trustedTokenIssuerArn {
            try encodeContainer.encode(trustedTokenIssuerArn, forKey: .trustedTokenIssuerArn)
        }
    }
}

extension DescribeTrustedTokenIssuerInput {

    static func urlPathProvider(_ value: DescribeTrustedTokenIssuerInput) -> Swift.String? {
        return "/"
    }
}

public struct DescribeTrustedTokenIssuerInput: Swift.Equatable {
    /// Specifies the ARN of the trusted token issuer configuration that you want details about.
    /// This member is required.
    public var trustedTokenIssuerArn: Swift.String?

    public init(
        trustedTokenIssuerArn: Swift.String? = nil
    )
    {
        self.trustedTokenIssuerArn = trustedTokenIssuerArn
    }
}

struct DescribeTrustedTokenIssuerInputBody: Swift.Equatable {
    let trustedTokenIssuerArn: Swift.String?
}

extension DescribeTrustedTokenIssuerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case trustedTokenIssuerArn = "TrustedTokenIssuerArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustedTokenIssuerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustedTokenIssuerArn)
        trustedTokenIssuerArn = trustedTokenIssuerArnDecoded
    }
}

extension DescribeTrustedTokenIssuerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeTrustedTokenIssuerOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
            self.trustedTokenIssuerArn = output.trustedTokenIssuerArn
            self.trustedTokenIssuerConfiguration = output.trustedTokenIssuerConfiguration
            self.trustedTokenIssuerType = output.trustedTokenIssuerType
        } else {
            self.name = nil
            self.trustedTokenIssuerArn = nil
            self.trustedTokenIssuerConfiguration = nil
            self.trustedTokenIssuerType = nil
        }
    }
}

public struct DescribeTrustedTokenIssuerOutput: Swift.Equatable {
    /// The name of the trusted token issuer configuration.
    public var name: Swift.String?
    /// The ARN of the trusted token issuer configuration.
    public var trustedTokenIssuerArn: Swift.String?
    /// A structure the describes the settings that apply of this trusted token issuer.
    public var trustedTokenIssuerConfiguration: SSOAdminClientTypes.TrustedTokenIssuerConfiguration?
    /// The type of the trusted token issuer.
    public var trustedTokenIssuerType: SSOAdminClientTypes.TrustedTokenIssuerType?

    public init(
        name: Swift.String? = nil,
        trustedTokenIssuerArn: Swift.String? = nil,
        trustedTokenIssuerConfiguration: SSOAdminClientTypes.TrustedTokenIssuerConfiguration? = nil,
        trustedTokenIssuerType: SSOAdminClientTypes.TrustedTokenIssuerType? = nil
    )
    {
        self.name = name
        self.trustedTokenIssuerArn = trustedTokenIssuerArn
        self.trustedTokenIssuerConfiguration = trustedTokenIssuerConfiguration
        self.trustedTokenIssuerType = trustedTokenIssuerType
    }
}

struct DescribeTrustedTokenIssuerOutputBody: Swift.Equatable {
    let trustedTokenIssuerArn: Swift.String?
    let name: Swift.String?
    let trustedTokenIssuerType: SSOAdminClientTypes.TrustedTokenIssuerType?
    let trustedTokenIssuerConfiguration: SSOAdminClientTypes.TrustedTokenIssuerConfiguration?
}

extension DescribeTrustedTokenIssuerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case trustedTokenIssuerArn = "TrustedTokenIssuerArn"
        case trustedTokenIssuerConfiguration = "TrustedTokenIssuerConfiguration"
        case trustedTokenIssuerType = "TrustedTokenIssuerType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustedTokenIssuerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustedTokenIssuerArn)
        trustedTokenIssuerArn = trustedTokenIssuerArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let trustedTokenIssuerTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.TrustedTokenIssuerType.self, forKey: .trustedTokenIssuerType)
        trustedTokenIssuerType = trustedTokenIssuerTypeDecoded
        let trustedTokenIssuerConfigurationDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.TrustedTokenIssuerConfiguration.self, forKey: .trustedTokenIssuerConfiguration)
        trustedTokenIssuerConfiguration = trustedTokenIssuerConfigurationDecoded
    }
}

enum DescribeTrustedTokenIssuerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DetachCustomerManagedPolicyReferenceFromPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerManagedPolicyReference = "CustomerManagedPolicyReference"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerManagedPolicyReference = self.customerManagedPolicyReference {
            try encodeContainer.encode(customerManagedPolicyReference, forKey: .customerManagedPolicyReference)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension DetachCustomerManagedPolicyReferenceFromPermissionSetInput {

    static func urlPathProvider(_ value: DetachCustomerManagedPolicyReferenceFromPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

public struct DetachCustomerManagedPolicyReferenceFromPermissionSetInput: Swift.Equatable {
    /// Specifies the name and path of a customer managed policy. You must have an IAM policy that matches the name and path in each Amazon Web Services account where you want to deploy your permission set.
    /// This member is required.
    public var customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the PermissionSet.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference? = nil,
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.customerManagedPolicyReference = customerManagedPolicyReference
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct DetachCustomerManagedPolicyReferenceFromPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference?
}

extension DetachCustomerManagedPolicyReferenceFromPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerManagedPolicyReference = "CustomerManagedPolicyReference"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let customerManagedPolicyReferenceDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.CustomerManagedPolicyReference.self, forKey: .customerManagedPolicyReference)
        customerManagedPolicyReference = customerManagedPolicyReferenceDecoded
    }
}

extension DetachCustomerManagedPolicyReferenceFromPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DetachCustomerManagedPolicyReferenceFromPermissionSetOutput: Swift.Equatable {

    public init() { }
}

enum DetachCustomerManagedPolicyReferenceFromPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DetachManagedPolicyFromPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case managedPolicyArn = "ManagedPolicyArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let managedPolicyArn = self.managedPolicyArn {
            try encodeContainer.encode(managedPolicyArn, forKey: .managedPolicyArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension DetachManagedPolicyFromPermissionSetInput {

    static func urlPathProvider(_ value: DetachManagedPolicyFromPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

public struct DetachManagedPolicyFromPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The Amazon Web Services managed policy ARN to be detached from a permission set.
    /// This member is required.
    public var managedPolicyArn: Swift.String?
    /// The ARN of the [PermissionSet] from which the policy should be detached.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        managedPolicyArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.managedPolicyArn = managedPolicyArn
        self.permissionSetArn = permissionSetArn
    }
}

struct DetachManagedPolicyFromPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let managedPolicyArn: Swift.String?
}

extension DetachManagedPolicyFromPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case managedPolicyArn = "ManagedPolicyArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let managedPolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedPolicyArn)
        managedPolicyArn = managedPolicyArnDecoded
    }
}

extension DetachManagedPolicyFromPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DetachManagedPolicyFromPermissionSetOutput: Swift.Equatable {

    public init() { }
}

enum DetachManagedPolicyFromPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSOAdminClientTypes.DisplayData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case displayName = "DisplayName"
        case iconUrl = "IconUrl"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let iconUrl = self.iconUrl {
            try encodeContainer.encode(iconUrl, forKey: .iconUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let iconUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .iconUrl)
        iconUrl = iconUrlDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes how the portal represents an application provider.
    public struct DisplayData: Swift.Equatable {
        /// The description of the application provider that appears in the portal.
        public var description: Swift.String?
        /// The name of the application provider that appears in the portal.
        public var displayName: Swift.String?
        /// A URL that points to an icon that represents the application provider.
        public var iconUrl: Swift.String?

        public init(
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            iconUrl: Swift.String? = nil
        )
        {
            self.description = description
            self.displayName = displayName
            self.iconUrl = iconUrl
        }
    }

}

extension SSOAdminClientTypes {
    public enum FederationProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case oauth
        case saml
        case sdkUnknown(Swift.String)

        public static var allCases: [FederationProtocol] {
            return [
                .oauth,
                .saml,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .oauth: return "OAUTH"
            case .saml: return "SAML"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FederationProtocol(rawValue: rawValue) ?? FederationProtocol.sdkUnknown(rawValue)
        }
    }
}

extension GetApplicationAccessScopeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case scope = "Scope"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope, forKey: .scope)
        }
    }
}

extension GetApplicationAccessScopeInput {

    static func urlPathProvider(_ value: GetApplicationAccessScopeInput) -> Swift.String? {
        return "/"
    }
}

public struct GetApplicationAccessScopeInput: Swift.Equatable {
    /// Specifies the ARN of the application with the access scope that you want to retrieve.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies the name of the access scope for which you want the authorized targets.
    /// This member is required.
    public var scope: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        scope: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.scope = scope
    }
}

struct GetApplicationAccessScopeInputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let scope: Swift.String?
}

extension GetApplicationAccessScopeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case scope = "Scope"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let scopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scope)
        scope = scopeDecoded
    }
}

extension GetApplicationAccessScopeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApplicationAccessScopeOutputBody = try responseDecoder.decode(responseBody: data)
            self.authorizedTargets = output.authorizedTargets
            self.scope = output.scope
        } else {
            self.authorizedTargets = nil
            self.scope = nil
        }
    }
}

public struct GetApplicationAccessScopeOutput: Swift.Equatable {
    /// An array of authorized targets associated with this access scope.
    public var authorizedTargets: [Swift.String]?
    /// The name of the access scope that can be used with the authorized targets.
    /// This member is required.
    public var scope: Swift.String?

    public init(
        authorizedTargets: [Swift.String]? = nil,
        scope: Swift.String? = nil
    )
    {
        self.authorizedTargets = authorizedTargets
        self.scope = scope
    }
}

struct GetApplicationAccessScopeOutputBody: Swift.Equatable {
    let scope: Swift.String?
    let authorizedTargets: [Swift.String]?
}

extension GetApplicationAccessScopeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizedTargets = "AuthorizedTargets"
        case scope = "Scope"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scope)
        scope = scopeDecoded
        let authorizedTargetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizedTargets)
        var authorizedTargetsDecoded0:[Swift.String]? = nil
        if let authorizedTargetsContainer = authorizedTargetsContainer {
            authorizedTargetsDecoded0 = [Swift.String]()
            for string0 in authorizedTargetsContainer {
                if let string0 = string0 {
                    authorizedTargetsDecoded0?.append(string0)
                }
            }
        }
        authorizedTargets = authorizedTargetsDecoded0
    }
}

enum GetApplicationAccessScopeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetApplicationAssignmentConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
    }
}

extension GetApplicationAssignmentConfigurationInput {

    static func urlPathProvider(_ value: GetApplicationAssignmentConfigurationInput) -> Swift.String? {
        return "/"
    }
}

public struct GetApplicationAssignmentConfigurationInput: Swift.Equatable {
    /// Specifies the ARN of the application. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var applicationArn: Swift.String?

    public init(
        applicationArn: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
    }
}

struct GetApplicationAssignmentConfigurationInputBody: Swift.Equatable {
    let applicationArn: Swift.String?
}

extension GetApplicationAssignmentConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

extension GetApplicationAssignmentConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApplicationAssignmentConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.assignmentRequired = output.assignmentRequired
        } else {
            self.assignmentRequired = nil
        }
    }
}

public struct GetApplicationAssignmentConfigurationOutput: Swift.Equatable {
    /// If AssignmentsRequired is true (default value), users dont have access to the application unless an assignment is created using the [CreateApplicationAssignment API](https://docs.aws.amazon.com/singlesignon/latest/APIReference/API_CreateApplicationAssignment.html). If false, all users have access to the application.
    /// This member is required.
    public var assignmentRequired: Swift.Bool?

    public init(
        assignmentRequired: Swift.Bool? = nil
    )
    {
        self.assignmentRequired = assignmentRequired
    }
}

struct GetApplicationAssignmentConfigurationOutputBody: Swift.Equatable {
    let assignmentRequired: Swift.Bool?
}

extension GetApplicationAssignmentConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assignmentRequired = "AssignmentRequired"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assignmentRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .assignmentRequired)
        assignmentRequired = assignmentRequiredDecoded
    }
}

enum GetApplicationAssignmentConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetApplicationAuthenticationMethodInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case authenticationMethodType = "AuthenticationMethodType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let authenticationMethodType = self.authenticationMethodType {
            try encodeContainer.encode(authenticationMethodType.rawValue, forKey: .authenticationMethodType)
        }
    }
}

extension GetApplicationAuthenticationMethodInput {

    static func urlPathProvider(_ value: GetApplicationAuthenticationMethodInput) -> Swift.String? {
        return "/"
    }
}

public struct GetApplicationAuthenticationMethodInput: Swift.Equatable {
    /// Specifies the ARN of the application.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies the type of authentication method for which you want details.
    /// This member is required.
    public var authenticationMethodType: SSOAdminClientTypes.AuthenticationMethodType?

    public init(
        applicationArn: Swift.String? = nil,
        authenticationMethodType: SSOAdminClientTypes.AuthenticationMethodType? = nil
    )
    {
        self.applicationArn = applicationArn
        self.authenticationMethodType = authenticationMethodType
    }
}

struct GetApplicationAuthenticationMethodInputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let authenticationMethodType: SSOAdminClientTypes.AuthenticationMethodType?
}

extension GetApplicationAuthenticationMethodInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case authenticationMethodType = "AuthenticationMethodType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let authenticationMethodTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.AuthenticationMethodType.self, forKey: .authenticationMethodType)
        authenticationMethodType = authenticationMethodTypeDecoded
    }
}

extension GetApplicationAuthenticationMethodOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApplicationAuthenticationMethodOutputBody = try responseDecoder.decode(responseBody: data)
            self.authenticationMethod = output.authenticationMethod
        } else {
            self.authenticationMethod = nil
        }
    }
}

public struct GetApplicationAuthenticationMethodOutput: Swift.Equatable {
    /// A structure that contains details about the requested authentication method.
    public var authenticationMethod: SSOAdminClientTypes.AuthenticationMethod?

    public init(
        authenticationMethod: SSOAdminClientTypes.AuthenticationMethod? = nil
    )
    {
        self.authenticationMethod = authenticationMethod
    }
}

struct GetApplicationAuthenticationMethodOutputBody: Swift.Equatable {
    let authenticationMethod: SSOAdminClientTypes.AuthenticationMethod?
}

extension GetApplicationAuthenticationMethodOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationMethod = "AuthenticationMethod"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationMethodDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.AuthenticationMethod.self, forKey: .authenticationMethod)
        authenticationMethod = authenticationMethodDecoded
    }
}

enum GetApplicationAuthenticationMethodOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetApplicationGrantInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case grantType = "GrantType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let grantType = self.grantType {
            try encodeContainer.encode(grantType.rawValue, forKey: .grantType)
        }
    }
}

extension GetApplicationGrantInput {

    static func urlPathProvider(_ value: GetApplicationGrantInput) -> Swift.String? {
        return "/"
    }
}

public struct GetApplicationGrantInput: Swift.Equatable {
    /// Specifies the ARN of the application that contains the grant.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies the type of grant.
    /// This member is required.
    public var grantType: SSOAdminClientTypes.GrantType?

    public init(
        applicationArn: Swift.String? = nil,
        grantType: SSOAdminClientTypes.GrantType? = nil
    )
    {
        self.applicationArn = applicationArn
        self.grantType = grantType
    }
}

struct GetApplicationGrantInputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let grantType: SSOAdminClientTypes.GrantType?
}

extension GetApplicationGrantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case grantType = "GrantType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let grantTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.GrantType.self, forKey: .grantType)
        grantType = grantTypeDecoded
    }
}

extension GetApplicationGrantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApplicationGrantOutputBody = try responseDecoder.decode(responseBody: data)
            self.grant = output.grant
        } else {
            self.grant = nil
        }
    }
}

public struct GetApplicationGrantOutput: Swift.Equatable {
    /// A structure that describes the requested grant.
    /// This member is required.
    public var grant: SSOAdminClientTypes.Grant?

    public init(
        grant: SSOAdminClientTypes.Grant? = nil
    )
    {
        self.grant = grant
    }
}

struct GetApplicationGrantOutputBody: Swift.Equatable {
    let grant: SSOAdminClientTypes.Grant?
}

extension GetApplicationGrantOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grant = "Grant"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.Grant.self, forKey: .grant)
        grant = grantDecoded
    }
}

enum GetApplicationGrantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetInlinePolicyForPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension GetInlinePolicyForPermissionSetInput {

    static func urlPathProvider(_ value: GetInlinePolicyForPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

public struct GetInlinePolicyForPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct GetInlinePolicyForPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
}

extension GetInlinePolicyForPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
    }
}

extension GetInlinePolicyForPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetInlinePolicyForPermissionSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.inlinePolicy = output.inlinePolicy
        } else {
            self.inlinePolicy = nil
        }
    }
}

public struct GetInlinePolicyForPermissionSetOutput: Swift.Equatable {
    /// The inline policy that is attached to the permission set. For Length Constraints, if a valid ARN is provided for a permission set, it is possible for an empty inline policy to be returned.
    public var inlinePolicy: Swift.String?

    public init(
        inlinePolicy: Swift.String? = nil
    )
    {
        self.inlinePolicy = inlinePolicy
    }
}

struct GetInlinePolicyForPermissionSetOutputBody: Swift.Equatable {
    let inlinePolicy: Swift.String?
}

extension GetInlinePolicyForPermissionSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inlinePolicy = "InlinePolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inlinePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inlinePolicy)
        inlinePolicy = inlinePolicyDecoded
    }
}

enum GetInlinePolicyForPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPermissionsBoundaryForPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension GetPermissionsBoundaryForPermissionSetInput {

    static func urlPathProvider(_ value: GetPermissionsBoundaryForPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

public struct GetPermissionsBoundaryForPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the PermissionSet.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct GetPermissionsBoundaryForPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
}

extension GetPermissionsBoundaryForPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
    }
}

extension GetPermissionsBoundaryForPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPermissionsBoundaryForPermissionSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.permissionsBoundary = output.permissionsBoundary
        } else {
            self.permissionsBoundary = nil
        }
    }
}

public struct GetPermissionsBoundaryForPermissionSetOutput: Swift.Equatable {
    /// The permissions boundary attached to the specified permission set.
    public var permissionsBoundary: SSOAdminClientTypes.PermissionsBoundary?

    public init(
        permissionsBoundary: SSOAdminClientTypes.PermissionsBoundary? = nil
    )
    {
        self.permissionsBoundary = permissionsBoundary
    }
}

struct GetPermissionsBoundaryForPermissionSetOutputBody: Swift.Equatable {
    let permissionsBoundary: SSOAdminClientTypes.PermissionsBoundary?
}

extension GetPermissionsBoundaryForPermissionSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionsBoundary = "PermissionsBoundary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PermissionsBoundary.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
    }
}

enum GetPermissionsBoundaryForPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSOAdminClientTypes.Grant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationcode = "AuthorizationCode"
        case jwtbearer = "JwtBearer"
        case refreshtoken = "RefreshToken"
        case tokenexchange = "TokenExchange"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .authorizationcode(authorizationcode):
                try container.encode(authorizationcode, forKey: .authorizationcode)
            case let .jwtbearer(jwtbearer):
                try container.encode(jwtbearer, forKey: .jwtbearer)
            case let .refreshtoken(refreshtoken):
                try container.encode(refreshtoken, forKey: .refreshtoken)
            case let .tokenexchange(tokenexchange):
                try container.encode(tokenexchange, forKey: .tokenexchange)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationcodeDecoded = try values.decodeIfPresent(SSOAdminClientTypes.AuthorizationCodeGrant.self, forKey: .authorizationcode)
        if let authorizationcode = authorizationcodeDecoded {
            self = .authorizationcode(authorizationcode)
            return
        }
        let jwtbearerDecoded = try values.decodeIfPresent(SSOAdminClientTypes.JwtBearerGrant.self, forKey: .jwtbearer)
        if let jwtbearer = jwtbearerDecoded {
            self = .jwtbearer(jwtbearer)
            return
        }
        let refreshtokenDecoded = try values.decodeIfPresent(SSOAdminClientTypes.RefreshTokenGrant.self, forKey: .refreshtoken)
        if let refreshtoken = refreshtokenDecoded {
            self = .refreshtoken(refreshtoken)
            return
        }
        let tokenexchangeDecoded = try values.decodeIfPresent(SSOAdminClientTypes.TokenExchangeGrant.self, forKey: .tokenexchange)
        if let tokenexchange = tokenexchangeDecoded {
            self = .tokenexchange(tokenexchange)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SSOAdminClientTypes {
    /// The Grant union represents the set of possible configuration options for the selected grant type. Exactly one member of the union must be specified, and must match the grant type selected.
    public enum Grant: Swift.Equatable {
        /// Configuration options for the authorization_code grant type.
        case authorizationcode(SSOAdminClientTypes.AuthorizationCodeGrant)
        /// Configuration options for the urn:ietf:params:oauth:grant-type:jwt-bearer grant type.
        case jwtbearer(SSOAdminClientTypes.JwtBearerGrant)
        /// Configuration options for the refresh_token grant type.
        case refreshtoken(SSOAdminClientTypes.RefreshTokenGrant)
        /// Configuration options for the urn:ietf:params:oauth:grant-type:token-exchange grant type.
        case tokenexchange(SSOAdminClientTypes.TokenExchangeGrant)
        case sdkUnknown(Swift.String)
    }

}

extension SSOAdminClientTypes.GrantItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grant = "Grant"
        case grantType = "GrantType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let grant = self.grant {
            try encodeContainer.encode(grant, forKey: .grant)
        }
        if let grantType = self.grantType {
            try encodeContainer.encode(grantType.rawValue, forKey: .grantType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.GrantType.self, forKey: .grantType)
        grantType = grantTypeDecoded
        let grantDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.Grant.self, forKey: .grant)
        grant = grantDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that defines a single grant and its configuration.
    public struct GrantItem: Swift.Equatable {
        /// The configuration structure for the selected grant.
        /// This member is required.
        public var grant: SSOAdminClientTypes.Grant?
        /// The type of the selected grant.
        /// This member is required.
        public var grantType: SSOAdminClientTypes.GrantType?

        public init(
            grant: SSOAdminClientTypes.Grant? = nil,
            grantType: SSOAdminClientTypes.GrantType? = nil
        )
        {
            self.grant = grant
            self.grantType = grantType
        }
    }

}

extension SSOAdminClientTypes {
    public enum GrantType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case authorizationCode
        case jwtBearer
        case refreshToken
        case tokenExchange
        case sdkUnknown(Swift.String)

        public static var allCases: [GrantType] {
            return [
                .authorizationCode,
                .jwtBearer,
                .refreshToken,
                .tokenExchange,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .authorizationCode: return "authorization_code"
            case .jwtBearer: return "urn:ietf:params:oauth:grant-type:jwt-bearer"
            case .refreshToken: return "refresh_token"
            case .tokenExchange: return "urn:ietf:params:oauth:grant-type:token-exchange"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GrantType(rawValue: rawValue) ?? GrantType.sdkUnknown(rawValue)
        }
    }
}

extension SSOAdminClientTypes.IamAuthenticationMethod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actorPolicy = "ActorPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actorPolicy = self.actorPolicy {
            try encodeContainer.encode(actorPolicy, forKey: .actorPolicy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actorPolicyDecoded = try containerValues.decodeIfPresent(ClientRuntime.Document.self, forKey: .actorPolicy)
        actorPolicy = actorPolicyDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes details for authentication that uses IAM.
    public struct IamAuthenticationMethod: Swift.Equatable {
        /// An IAM policy document in JSON.
        /// This member is required.
        public var actorPolicy: ClientRuntime.Document?

        public init(
            actorPolicy: ClientRuntime.Document? = nil
        )
        {
            self.actorPolicy = actorPolicy
        }
    }

}

extension SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlAttributes = "AccessControlAttributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessControlAttributes = accessControlAttributes {
            var accessControlAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessControlAttributes)
            for accesscontrolattribute0 in accessControlAttributes {
                try accessControlAttributesContainer.encode(accesscontrolattribute0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlAttributesContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.AccessControlAttribute?].self, forKey: .accessControlAttributes)
        var accessControlAttributesDecoded0:[SSOAdminClientTypes.AccessControlAttribute]? = nil
        if let accessControlAttributesContainer = accessControlAttributesContainer {
            accessControlAttributesDecoded0 = [SSOAdminClientTypes.AccessControlAttribute]()
            for structure0 in accessControlAttributesContainer {
                if let structure0 = structure0 {
                    accessControlAttributesDecoded0?.append(structure0)
                }
            }
        }
        accessControlAttributes = accessControlAttributesDecoded0
    }
}

extension SSOAdminClientTypes {
    /// Specifies the attributes to add to your attribute-based access control (ABAC) configuration.
    public struct InstanceAccessControlAttributeConfiguration: Swift.Equatable {
        /// Lists the attributes that are configured for ABAC in the specified IAM Identity Center instance.
        /// This member is required.
        public var accessControlAttributes: [SSOAdminClientTypes.AccessControlAttribute]?

        public init(
            accessControlAttributes: [SSOAdminClientTypes.AccessControlAttribute]? = nil
        )
        {
            self.accessControlAttributes = accessControlAttributes
        }
    }

}

extension SSOAdminClientTypes {
    public enum InstanceAccessControlAttributeConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creationFailed
        case creationInProgress
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceAccessControlAttributeConfigurationStatus] {
            return [
                .creationFailed,
                .creationInProgress,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creationFailed: return "CREATION_FAILED"
            case .creationInProgress: return "CREATION_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceAccessControlAttributeConfigurationStatus(rawValue: rawValue) ?? InstanceAccessControlAttributeConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension SSOAdminClientTypes.InstanceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case identityStoreId = "IdentityStoreId"
        case instanceArn = "InstanceArn"
        case name = "Name"
        case ownerAccountId = "OwnerAccountId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let ownerAccountId = self.ownerAccountId {
            try encodeContainer.encode(ownerAccountId, forKey: .ownerAccountId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
        let ownerAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ownerAccountId)
        ownerAccountId = ownerAccountIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.InstanceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension SSOAdminClientTypes {
    /// Provides information about the IAM Identity Center instance.
    public struct InstanceMetadata: Swift.Equatable {
        /// The date and time that the Identity Center instance was created.
        public var createdDate: ClientRuntime.Date?
        /// The identifier of the identity store that is connected to the Identity Center instance.
        public var identityStoreId: Swift.String?
        /// The ARN of the Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var instanceArn: Swift.String?
        /// The name of the Identity Center instance.
        public var name: Swift.String?
        /// The Amazon Web Services account ID number of the owner of the Identity Center instance.
        public var ownerAccountId: Swift.String?
        /// The current status of this Identity Center instance.
        public var status: SSOAdminClientTypes.InstanceStatus?

        public init(
            createdDate: ClientRuntime.Date? = nil,
            identityStoreId: Swift.String? = nil,
            instanceArn: Swift.String? = nil,
            name: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            status: SSOAdminClientTypes.InstanceStatus? = nil
        )
        {
            self.createdDate = createdDate
            self.identityStoreId = identityStoreId
            self.instanceArn = instanceArn
            self.name = name
            self.ownerAccountId = ownerAccountId
            self.status = status
        }
    }

}

extension SSOAdminClientTypes {
    public enum InstanceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case createInProgress
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceStatus] {
            return [
                .active,
                .createInProgress,
                .deleteInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceStatus(rawValue: rawValue) ?? InstanceStatus.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request processing has failed because of an unknown error, exception, or failure with an internal server.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SSOAdminClientTypes {
    public enum JwksRetrievalOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case openIdDiscovery
        case sdkUnknown(Swift.String)

        public static var allCases: [JwksRetrievalOption] {
            return [
                .openIdDiscovery,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .openIdDiscovery: return "OPEN_ID_DISCOVERY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JwksRetrievalOption(rawValue: rawValue) ?? JwksRetrievalOption.sdkUnknown(rawValue)
        }
    }
}

extension SSOAdminClientTypes.JwtBearerGrant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizedTokenIssuers = "AuthorizedTokenIssuers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizedTokenIssuers = authorizedTokenIssuers {
            var authorizedTokenIssuersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizedTokenIssuers)
            for authorizedtokenissuer0 in authorizedTokenIssuers {
                try authorizedTokenIssuersContainer.encode(authorizedtokenissuer0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizedTokenIssuersContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.AuthorizedTokenIssuer?].self, forKey: .authorizedTokenIssuers)
        var authorizedTokenIssuersDecoded0:[SSOAdminClientTypes.AuthorizedTokenIssuer]? = nil
        if let authorizedTokenIssuersContainer = authorizedTokenIssuersContainer {
            authorizedTokenIssuersDecoded0 = [SSOAdminClientTypes.AuthorizedTokenIssuer]()
            for structure0 in authorizedTokenIssuersContainer {
                if let structure0 = structure0 {
                    authorizedTokenIssuersDecoded0?.append(structure0)
                }
            }
        }
        authorizedTokenIssuers = authorizedTokenIssuersDecoded0
    }
}

extension SSOAdminClientTypes {
    /// A structure that defines configuration settings for an application that supports the JWT Bearer Token Authorization Grant.
    public struct JwtBearerGrant: Swift.Equatable {
        /// A list of allowed token issuers trusted by the Identity Center instances for this application.
        public var authorizedTokenIssuers: [SSOAdminClientTypes.AuthorizedTokenIssuer]?

        public init(
            authorizedTokenIssuers: [SSOAdminClientTypes.AuthorizedTokenIssuer]? = nil
        )
        {
            self.authorizedTokenIssuers = authorizedTokenIssuers
        }
    }

}

extension ListAccountAssignmentCreationStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAccountAssignmentCreationStatusInput {

    static func urlPathProvider(_ value: ListAccountAssignmentCreationStatusInput) -> Swift.String? {
        return "/"
    }
}

public struct ListAccountAssignmentCreationStatusInput: Swift.Equatable {
    /// Filters results based on the passed attribute value.
    public var filter: SSOAdminClientTypes.OperationStatusFilter?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        filter: SSOAdminClientTypes.OperationStatusFilter? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentCreationStatusInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filter: SSOAdminClientTypes.OperationStatusFilter?
}

extension ListAccountAssignmentCreationStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filterDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.OperationStatusFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListAccountAssignmentCreationStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccountAssignmentCreationStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignmentsCreationStatus = output.accountAssignmentsCreationStatus
            self.nextToken = output.nextToken
        } else {
            self.accountAssignmentsCreationStatus = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountAssignmentCreationStatusOutput: Swift.Equatable {
    /// The status object for the account assignment creation operation.
    public var accountAssignmentsCreationStatus: [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        accountAssignmentsCreationStatus: [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountAssignmentsCreationStatus = accountAssignmentsCreationStatus
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentCreationStatusOutputBody: Swift.Equatable {
    let accountAssignmentsCreationStatus: [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]?
    let nextToken: Swift.String?
}

extension ListAccountAssignmentCreationStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentsCreationStatus = "AccountAssignmentsCreationStatus"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentsCreationStatusContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata?].self, forKey: .accountAssignmentsCreationStatus)
        var accountAssignmentsCreationStatusDecoded0:[SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]? = nil
        if let accountAssignmentsCreationStatusContainer = accountAssignmentsCreationStatusContainer {
            accountAssignmentsCreationStatusDecoded0 = [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]()
            for structure0 in accountAssignmentsCreationStatusContainer {
                if let structure0 = structure0 {
                    accountAssignmentsCreationStatusDecoded0?.append(structure0)
                }
            }
        }
        accountAssignmentsCreationStatus = accountAssignmentsCreationStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccountAssignmentCreationStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAccountAssignmentDeletionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAccountAssignmentDeletionStatusInput {

    static func urlPathProvider(_ value: ListAccountAssignmentDeletionStatusInput) -> Swift.String? {
        return "/"
    }
}

public struct ListAccountAssignmentDeletionStatusInput: Swift.Equatable {
    /// Filters results based on the passed attribute value.
    public var filter: SSOAdminClientTypes.OperationStatusFilter?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        filter: SSOAdminClientTypes.OperationStatusFilter? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentDeletionStatusInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filter: SSOAdminClientTypes.OperationStatusFilter?
}

extension ListAccountAssignmentDeletionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filterDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.OperationStatusFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListAccountAssignmentDeletionStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccountAssignmentDeletionStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignmentsDeletionStatus = output.accountAssignmentsDeletionStatus
            self.nextToken = output.nextToken
        } else {
            self.accountAssignmentsDeletionStatus = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountAssignmentDeletionStatusOutput: Swift.Equatable {
    /// The status object for the account assignment deletion operation.
    public var accountAssignmentsDeletionStatus: [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        accountAssignmentsDeletionStatus: [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountAssignmentsDeletionStatus = accountAssignmentsDeletionStatus
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentDeletionStatusOutputBody: Swift.Equatable {
    let accountAssignmentsDeletionStatus: [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]?
    let nextToken: Swift.String?
}

extension ListAccountAssignmentDeletionStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentsDeletionStatus = "AccountAssignmentsDeletionStatus"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentsDeletionStatusContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata?].self, forKey: .accountAssignmentsDeletionStatus)
        var accountAssignmentsDeletionStatusDecoded0:[SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]? = nil
        if let accountAssignmentsDeletionStatusContainer = accountAssignmentsDeletionStatusContainer {
            accountAssignmentsDeletionStatusDecoded0 = [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]()
            for structure0 in accountAssignmentsDeletionStatusContainer {
                if let structure0 = structure0 {
                    accountAssignmentsDeletionStatusDecoded0?.append(structure0)
                }
            }
        }
        accountAssignmentsDeletionStatus = accountAssignmentsDeletionStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccountAssignmentDeletionStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSOAdminClientTypes.ListAccountAssignmentsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes a filter for account assignments.
    public struct ListAccountAssignmentsFilter: Swift.Equatable {
        /// The ID number of an Amazon Web Services account that filters the results in the response.
        public var accountId: Swift.String?

        public init(
            accountId: Swift.String? = nil
        )
        {
            self.accountId = accountId
        }
    }

}

extension ListAccountAssignmentsForPrincipalInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }
}

extension ListAccountAssignmentsForPrincipalInput {

    static func urlPathProvider(_ value: ListAccountAssignmentsForPrincipalInput) -> Swift.String? {
        return "/"
    }
}

public struct ListAccountAssignmentsForPrincipalInput: Swift.Equatable {
    /// Specifies an Amazon Web Services account ID number. Results are filtered to only those that match this ID number.
    public var filter: SSOAdminClientTypes.ListAccountAssignmentsFilter?
    /// Specifies the ARN of the instance of IAM Identity Center that contains the principal.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the principal for which you want to retrieve the list of account assignments.
    /// This member is required.
    public var principalId: Swift.String?
    /// Specifies the type of the principal.
    /// This member is required.
    public var principalType: SSOAdminClientTypes.PrincipalType?

    public init(
        filter: SSOAdminClientTypes.ListAccountAssignmentsFilter? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: SSOAdminClientTypes.PrincipalType? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalId = principalId
        self.principalType = principalType
    }
}

struct ListAccountAssignmentsForPrincipalInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let principalId: Swift.String?
    let principalType: SSOAdminClientTypes.PrincipalType?
    let filter: SSOAdminClientTypes.ListAccountAssignmentsFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListAccountAssignmentsForPrincipalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let filterDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.ListAccountAssignmentsFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListAccountAssignmentsForPrincipalOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccountAssignmentsForPrincipalOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignments = output.accountAssignments
            self.nextToken = output.nextToken
        } else {
            self.accountAssignments = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountAssignmentsForPrincipalOutput: Swift.Equatable {
    /// An array list of the account assignments for the principal.
    public var accountAssignments: [SSOAdminClientTypes.AccountAssignmentForPrincipal]?
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?

    public init(
        accountAssignments: [SSOAdminClientTypes.AccountAssignmentForPrincipal]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountAssignments = accountAssignments
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentsForPrincipalOutputBody: Swift.Equatable {
    let accountAssignments: [SSOAdminClientTypes.AccountAssignmentForPrincipal]?
    let nextToken: Swift.String?
}

extension ListAccountAssignmentsForPrincipalOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignments = "AccountAssignments"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentsContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.AccountAssignmentForPrincipal?].self, forKey: .accountAssignments)
        var accountAssignmentsDecoded0:[SSOAdminClientTypes.AccountAssignmentForPrincipal]? = nil
        if let accountAssignmentsContainer = accountAssignmentsContainer {
            accountAssignmentsDecoded0 = [SSOAdminClientTypes.AccountAssignmentForPrincipal]()
            for structure0 in accountAssignmentsContainer {
                if let structure0 = structure0 {
                    accountAssignmentsDecoded0?.append(structure0)
                }
            }
        }
        accountAssignments = accountAssignmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccountAssignmentsForPrincipalOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAccountAssignmentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension ListAccountAssignmentsInput {

    static func urlPathProvider(_ value: ListAccountAssignmentsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListAccountAssignmentsInput: Swift.Equatable {
    /// The identifier of the Amazon Web Services account from which to list the assignments.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The ARN of the permission set from which to list assignments.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionSetArn = permissionSetArn
    }
}

struct ListAccountAssignmentsInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let accountId: Swift.String?
    let permissionSetArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAccountAssignmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccountAssignmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccountAssignmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignments = output.accountAssignments
            self.nextToken = output.nextToken
        } else {
            self.accountAssignments = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountAssignmentsOutput: Swift.Equatable {
    /// The list of assignments that match the input Amazon Web Services account and permission set.
    public var accountAssignments: [SSOAdminClientTypes.AccountAssignment]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        accountAssignments: [SSOAdminClientTypes.AccountAssignment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountAssignments = accountAssignments
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentsOutputBody: Swift.Equatable {
    let accountAssignments: [SSOAdminClientTypes.AccountAssignment]?
    let nextToken: Swift.String?
}

extension ListAccountAssignmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignments = "AccountAssignments"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentsContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.AccountAssignment?].self, forKey: .accountAssignments)
        var accountAssignmentsDecoded0:[SSOAdminClientTypes.AccountAssignment]? = nil
        if let accountAssignmentsContainer = accountAssignmentsContainer {
            accountAssignmentsDecoded0 = [SSOAdminClientTypes.AccountAssignment]()
            for structure0 in accountAssignmentsContainer {
                if let structure0 = structure0 {
                    accountAssignmentsDecoded0?.append(structure0)
                }
            }
        }
        accountAssignments = accountAssignmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccountAssignmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAccountsForProvisionedPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
        case provisioningStatus = "ProvisioningStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let provisioningStatus = self.provisioningStatus {
            try encodeContainer.encode(provisioningStatus.rawValue, forKey: .provisioningStatus)
        }
    }
}

extension ListAccountsForProvisionedPermissionSetInput {

    static func urlPathProvider(_ value: ListAccountsForProvisionedPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

public struct ListAccountsForProvisionedPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the [PermissionSet].
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The ARN of the [PermissionSet] from which the associated Amazon Web Services accounts will be listed.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// The permission set provisioning status for an Amazon Web Services account.
    public var provisioningStatus: SSOAdminClientTypes.ProvisioningStatus?

    public init(
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        provisioningStatus: SSOAdminClientTypes.ProvisioningStatus? = nil
    )
    {
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionSetArn = permissionSetArn
        self.provisioningStatus = provisioningStatus
    }
}

struct ListAccountsForProvisionedPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let provisioningStatus: SSOAdminClientTypes.ProvisioningStatus?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAccountsForProvisionedPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
        case provisioningStatus = "ProvisioningStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let provisioningStatusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.ProvisioningStatus.self, forKey: .provisioningStatus)
        provisioningStatus = provisioningStatusDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccountsForProvisionedPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccountsForProvisionedPermissionSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountIds = output.accountIds
            self.nextToken = output.nextToken
        } else {
            self.accountIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountsForProvisionedPermissionSetOutput: Swift.Equatable {
    /// The list of Amazon Web Services AccountIds.
    public var accountIds: [Swift.String]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.nextToken = nextToken
    }
}

struct ListAccountsForProvisionedPermissionSetOutputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListAccountsForProvisionedPermissionSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccountsForProvisionedPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListApplicationAccessScopesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApplicationAccessScopesInput {

    static func urlPathProvider(_ value: ListApplicationAccessScopesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListApplicationAccessScopesInput: Swift.Equatable {
    /// Specifies the ARN of the application.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationAccessScopesInputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListApplicationAccessScopesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationAccessScopesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationAccessScopesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.scopes = output.scopes
        } else {
            self.nextToken = nil
            self.scopes = nil
        }
    }
}

public struct ListApplicationAccessScopesOutput: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array list of access scopes and their authorized targets that are associated with the application.
    /// This member is required.
    public var scopes: [SSOAdminClientTypes.ScopeDetails]?

    public init(
        nextToken: Swift.String? = nil,
        scopes: [SSOAdminClientTypes.ScopeDetails]? = nil
    )
    {
        self.nextToken = nextToken
        self.scopes = scopes
    }
}

struct ListApplicationAccessScopesOutputBody: Swift.Equatable {
    let scopes: [SSOAdminClientTypes.ScopeDetails]?
    let nextToken: Swift.String?
}

extension ListApplicationAccessScopesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case scopes = "Scopes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scopesContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.ScopeDetails?].self, forKey: .scopes)
        var scopesDecoded0:[SSOAdminClientTypes.ScopeDetails]? = nil
        if let scopesContainer = scopesContainer {
            scopesDecoded0 = [SSOAdminClientTypes.ScopeDetails]()
            for structure0 in scopesContainer {
                if let structure0 = structure0 {
                    scopesDecoded0?.append(structure0)
                }
            }
        }
        scopes = scopesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationAccessScopesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSOAdminClientTypes.ListApplicationAssignmentsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes a filter for application assignments.
    public struct ListApplicationAssignmentsFilter: Swift.Equatable {
        /// The ARN of an application.
        public var applicationArn: Swift.String?

        public init(
            applicationArn: Swift.String? = nil
        )
        {
            self.applicationArn = applicationArn
        }
    }

}

extension ListApplicationAssignmentsForPrincipalInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }
}

extension ListApplicationAssignmentsForPrincipalInput {

    static func urlPathProvider(_ value: ListApplicationAssignmentsForPrincipalInput) -> Swift.String? {
        return "/"
    }
}

public struct ListApplicationAssignmentsForPrincipalInput: Swift.Equatable {
    /// Filters the output to include only assignments associated with the application that has the specified ARN.
    public var filter: SSOAdminClientTypes.ListApplicationAssignmentsFilter?
    /// Specifies the instance of IAM Identity Center that contains principal and applications.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the unique identifier of the principal for which you want to retrieve its assignments.
    /// This member is required.
    public var principalId: Swift.String?
    /// Specifies the type of the principal for which you want to retrieve its assignments.
    /// This member is required.
    public var principalType: SSOAdminClientTypes.PrincipalType?

    public init(
        filter: SSOAdminClientTypes.ListApplicationAssignmentsFilter? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: SSOAdminClientTypes.PrincipalType? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalId = principalId
        self.principalType = principalType
    }
}

struct ListApplicationAssignmentsForPrincipalInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let principalId: Swift.String?
    let principalType: SSOAdminClientTypes.PrincipalType?
    let filter: SSOAdminClientTypes.ListApplicationAssignmentsFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListApplicationAssignmentsForPrincipalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let filterDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.ListApplicationAssignmentsFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListApplicationAssignmentsForPrincipalOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationAssignmentsForPrincipalOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationAssignments = output.applicationAssignments
            self.nextToken = output.nextToken
        } else {
            self.applicationAssignments = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationAssignmentsForPrincipalOutput: Swift.Equatable {
    /// An array list of the application assignments for the specified principal.
    public var applicationAssignments: [SSOAdminClientTypes.ApplicationAssignmentForPrincipal]?
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?

    public init(
        applicationAssignments: [SSOAdminClientTypes.ApplicationAssignmentForPrincipal]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationAssignments = applicationAssignments
        self.nextToken = nextToken
    }
}

struct ListApplicationAssignmentsForPrincipalOutputBody: Swift.Equatable {
    let applicationAssignments: [SSOAdminClientTypes.ApplicationAssignmentForPrincipal]?
    let nextToken: Swift.String?
}

extension ListApplicationAssignmentsForPrincipalOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationAssignments = "ApplicationAssignments"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationAssignmentsContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.ApplicationAssignmentForPrincipal?].self, forKey: .applicationAssignments)
        var applicationAssignmentsDecoded0:[SSOAdminClientTypes.ApplicationAssignmentForPrincipal]? = nil
        if let applicationAssignmentsContainer = applicationAssignmentsContainer {
            applicationAssignmentsDecoded0 = [SSOAdminClientTypes.ApplicationAssignmentForPrincipal]()
            for structure0 in applicationAssignmentsContainer {
                if let structure0 = structure0 {
                    applicationAssignmentsDecoded0?.append(structure0)
                }
            }
        }
        applicationAssignments = applicationAssignmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationAssignmentsForPrincipalOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListApplicationAssignmentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApplicationAssignmentsInput {

    static func urlPathProvider(_ value: ListApplicationAssignmentsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListApplicationAssignmentsInput: Swift.Equatable {
    /// Specifies the ARN of the application.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationAssignmentsInputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListApplicationAssignmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationAssignmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationAssignmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationAssignments = output.applicationAssignments
            self.nextToken = output.nextToken
        } else {
            self.applicationAssignments = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationAssignmentsOutput: Swift.Equatable {
    /// The list of users assigned to an application.
    public var applicationAssignments: [SSOAdminClientTypes.ApplicationAssignment]?
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?

    public init(
        applicationAssignments: [SSOAdminClientTypes.ApplicationAssignment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationAssignments = applicationAssignments
        self.nextToken = nextToken
    }
}

struct ListApplicationAssignmentsOutputBody: Swift.Equatable {
    let applicationAssignments: [SSOAdminClientTypes.ApplicationAssignment]?
    let nextToken: Swift.String?
}

extension ListApplicationAssignmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationAssignments = "ApplicationAssignments"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationAssignmentsContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.ApplicationAssignment?].self, forKey: .applicationAssignments)
        var applicationAssignmentsDecoded0:[SSOAdminClientTypes.ApplicationAssignment]? = nil
        if let applicationAssignmentsContainer = applicationAssignmentsContainer {
            applicationAssignmentsDecoded0 = [SSOAdminClientTypes.ApplicationAssignment]()
            for structure0 in applicationAssignmentsContainer {
                if let structure0 = structure0 {
                    applicationAssignmentsDecoded0?.append(structure0)
                }
            }
        }
        applicationAssignments = applicationAssignmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationAssignmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListApplicationAuthenticationMethodsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApplicationAuthenticationMethodsInput {

    static func urlPathProvider(_ value: ListApplicationAuthenticationMethodsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListApplicationAuthenticationMethodsInput: Swift.Equatable {
    /// Specifies the ARN of the application with the authentication methods you want to list.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.nextToken = nextToken
    }
}

struct ListApplicationAuthenticationMethodsInputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let nextToken: Swift.String?
}

extension ListApplicationAuthenticationMethodsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationAuthenticationMethodsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationAuthenticationMethodsOutputBody = try responseDecoder.decode(responseBody: data)
            self.authenticationMethods = output.authenticationMethods
            self.nextToken = output.nextToken
        } else {
            self.authenticationMethods = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationAuthenticationMethodsOutput: Swift.Equatable {
    /// An array list of authentication methods for the specified application.
    public var authenticationMethods: [SSOAdminClientTypes.AuthenticationMethodItem]?
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?

    public init(
        authenticationMethods: [SSOAdminClientTypes.AuthenticationMethodItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.authenticationMethods = authenticationMethods
        self.nextToken = nextToken
    }
}

struct ListApplicationAuthenticationMethodsOutputBody: Swift.Equatable {
    let authenticationMethods: [SSOAdminClientTypes.AuthenticationMethodItem]?
    let nextToken: Swift.String?
}

extension ListApplicationAuthenticationMethodsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authenticationMethods = "AuthenticationMethods"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authenticationMethodsContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.AuthenticationMethodItem?].self, forKey: .authenticationMethods)
        var authenticationMethodsDecoded0:[SSOAdminClientTypes.AuthenticationMethodItem]? = nil
        if let authenticationMethodsContainer = authenticationMethodsContainer {
            authenticationMethodsDecoded0 = [SSOAdminClientTypes.AuthenticationMethodItem]()
            for structure0 in authenticationMethodsContainer {
                if let structure0 = structure0 {
                    authenticationMethodsDecoded0?.append(structure0)
                }
            }
        }
        authenticationMethods = authenticationMethodsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationAuthenticationMethodsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListApplicationGrantsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApplicationGrantsInput {

    static func urlPathProvider(_ value: ListApplicationGrantsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListApplicationGrantsInput: Swift.Equatable {
    /// Specifies the ARN of the application whose grants you want to list.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.nextToken = nextToken
    }
}

struct ListApplicationGrantsInputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let nextToken: Swift.String?
}

extension ListApplicationGrantsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationGrantsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationGrantsOutputBody = try responseDecoder.decode(responseBody: data)
            self.grants = output.grants
            self.nextToken = output.nextToken
        } else {
            self.grants = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationGrantsOutput: Swift.Equatable {
    /// An array list of structures that describe the requested grants.
    /// This member is required.
    public var grants: [SSOAdminClientTypes.GrantItem]?
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?

    public init(
        grants: [SSOAdminClientTypes.GrantItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.grants = grants
        self.nextToken = nextToken
    }
}

struct ListApplicationGrantsOutputBody: Swift.Equatable {
    let grants: [SSOAdminClientTypes.GrantItem]?
    let nextToken: Swift.String?
}

extension ListApplicationGrantsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case grants = "Grants"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let grantsContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.GrantItem?].self, forKey: .grants)
        var grantsDecoded0:[SSOAdminClientTypes.GrantItem]? = nil
        if let grantsContainer = grantsContainer {
            grantsDecoded0 = [SSOAdminClientTypes.GrantItem]()
            for structure0 in grantsContainer {
                if let structure0 = structure0 {
                    grantsDecoded0?.append(structure0)
                }
            }
        }
        grants = grantsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationGrantsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListApplicationProvidersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApplicationProvidersInput {

    static func urlPathProvider(_ value: ListApplicationProvidersInput) -> Swift.String? {
        return "/"
    }
}

public struct ListApplicationProvidersInput: Swift.Equatable {
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationProvidersInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListApplicationProvidersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListApplicationProvidersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationProvidersOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationProviders = output.applicationProviders
            self.nextToken = output.nextToken
        } else {
            self.applicationProviders = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationProvidersOutput: Swift.Equatable {
    /// An array list of structures that describe application providers.
    public var applicationProviders: [SSOAdminClientTypes.ApplicationProvider]?
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?

    public init(
        applicationProviders: [SSOAdminClientTypes.ApplicationProvider]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationProviders = applicationProviders
        self.nextToken = nextToken
    }
}

struct ListApplicationProvidersOutputBody: Swift.Equatable {
    let applicationProviders: [SSOAdminClientTypes.ApplicationProvider]?
    let nextToken: Swift.String?
}

extension ListApplicationProvidersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationProviders = "ApplicationProviders"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationProvidersContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.ApplicationProvider?].self, forKey: .applicationProviders)
        var applicationProvidersDecoded0:[SSOAdminClientTypes.ApplicationProvider]? = nil
        if let applicationProvidersContainer = applicationProvidersContainer {
            applicationProvidersDecoded0 = [SSOAdminClientTypes.ApplicationProvider]()
            for structure0 in applicationProvidersContainer {
                if let structure0 = structure0 {
                    applicationProvidersDecoded0?.append(structure0)
                }
            }
        }
        applicationProviders = applicationProvidersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationProvidersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSOAdminClientTypes.ListApplicationsFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationAccount = "ApplicationAccount"
        case applicationProvider = "ApplicationProvider"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationAccount = self.applicationAccount {
            try encodeContainer.encode(applicationAccount, forKey: .applicationAccount)
        }
        if let applicationProvider = self.applicationProvider {
            try encodeContainer.encode(applicationProvider, forKey: .applicationProvider)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationAccountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationAccount)
        applicationAccount = applicationAccountDecoded
        let applicationProviderDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationProvider)
        applicationProvider = applicationProviderDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes a filter for applications.
    public struct ListApplicationsFilter: Swift.Equatable {
        /// An Amazon Web Services account ID number that filters the results in the response.
        public var applicationAccount: Swift.String?
        /// The ARN of an application provider that can filter the results in the response.
        public var applicationProvider: Swift.String?

        public init(
            applicationAccount: Swift.String? = nil,
            applicationProvider: Swift.String? = nil
        )
        {
            self.applicationAccount = applicationAccount
            self.applicationProvider = applicationProvider
        }
    }

}

extension ListApplicationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListApplicationsInput {

    static func urlPathProvider(_ value: ListApplicationsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListApplicationsInput: Swift.Equatable {
    /// Filters response results.
    public var filter: SSOAdminClientTypes.ListApplicationsFilter?
    /// The ARN of the IAM Identity Center application under which the operation will run. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        filter: SSOAdminClientTypes.ListApplicationsFilter? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListApplicationsInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filter: SSOAdminClientTypes.ListApplicationsFilter?
}

extension ListApplicationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filterDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.ListApplicationsFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListApplicationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.applications = output.applications
            self.nextToken = output.nextToken
        } else {
            self.applications = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationsOutput: Swift.Equatable {
    /// Retrieves all applications associated with the instance.
    public var applications: [SSOAdminClientTypes.Application]?
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?

    public init(
        applications: [SSOAdminClientTypes.Application]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

struct ListApplicationsOutputBody: Swift.Equatable {
    let applications: [SSOAdminClientTypes.Application]?
    let nextToken: Swift.String?
}

extension ListApplicationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applications = "Applications"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationsContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.Application?].self, forKey: .applications)
        var applicationsDecoded0:[SSOAdminClientTypes.Application]? = nil
        if let applicationsContainer = applicationsContainer {
            applicationsDecoded0 = [SSOAdminClientTypes.Application]()
            for structure0 in applicationsContainer {
                if let structure0 = structure0 {
                    applicationsDecoded0?.append(structure0)
                }
            }
        }
        applications = applicationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCustomerManagedPolicyReferencesInPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension ListCustomerManagedPolicyReferencesInPermissionSetInput {

    static func urlPathProvider(_ value: ListCustomerManagedPolicyReferencesInPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

public struct ListCustomerManagedPolicyReferencesInPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the list call.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The ARN of the PermissionSet.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionSetArn = permissionSetArn
    }
}

struct ListCustomerManagedPolicyReferencesInPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCustomerManagedPolicyReferencesInPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomerManagedPolicyReferencesInPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCustomerManagedPolicyReferencesInPermissionSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.customerManagedPolicyReferences = output.customerManagedPolicyReferences
            self.nextToken = output.nextToken
        } else {
            self.customerManagedPolicyReferences = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomerManagedPolicyReferencesInPermissionSetOutput: Swift.Equatable {
    /// Specifies the names and paths of the customer managed policies that you have attached to your permission set.
    public var customerManagedPolicyReferences: [SSOAdminClientTypes.CustomerManagedPolicyReference]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        customerManagedPolicyReferences: [SSOAdminClientTypes.CustomerManagedPolicyReference]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customerManagedPolicyReferences = customerManagedPolicyReferences
        self.nextToken = nextToken
    }
}

struct ListCustomerManagedPolicyReferencesInPermissionSetOutputBody: Swift.Equatable {
    let customerManagedPolicyReferences: [SSOAdminClientTypes.CustomerManagedPolicyReference]?
    let nextToken: Swift.String?
}

extension ListCustomerManagedPolicyReferencesInPermissionSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerManagedPolicyReferences = "CustomerManagedPolicyReferences"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerManagedPolicyReferencesContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.CustomerManagedPolicyReference?].self, forKey: .customerManagedPolicyReferences)
        var customerManagedPolicyReferencesDecoded0:[SSOAdminClientTypes.CustomerManagedPolicyReference]? = nil
        if let customerManagedPolicyReferencesContainer = customerManagedPolicyReferencesContainer {
            customerManagedPolicyReferencesDecoded0 = [SSOAdminClientTypes.CustomerManagedPolicyReference]()
            for structure0 in customerManagedPolicyReferencesContainer {
                if let structure0 = structure0 {
                    customerManagedPolicyReferencesDecoded0?.append(structure0)
                }
            }
        }
        customerManagedPolicyReferences = customerManagedPolicyReferencesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCustomerManagedPolicyReferencesInPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListInstancesInput {

    static func urlPathProvider(_ value: ListInstancesInput) -> Swift.String? {
        return "/"
    }
}

public struct ListInstancesInput: Swift.Equatable {
    /// The maximum number of results to display for the instance.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInstancesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.instances = output.instances
            self.nextToken = output.nextToken
        } else {
            self.instances = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstancesOutput: Swift.Equatable {
    /// Lists the IAM Identity Center instances that the caller has access to.
    public var instances: [SSOAdminClientTypes.InstanceMetadata]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        instances: [SSOAdminClientTypes.InstanceMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instances = instances
        self.nextToken = nextToken
    }
}

struct ListInstancesOutputBody: Swift.Equatable {
    let instances: [SSOAdminClientTypes.InstanceMetadata]?
    let nextToken: Swift.String?
}

extension ListInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.InstanceMetadata?].self, forKey: .instances)
        var instancesDecoded0:[SSOAdminClientTypes.InstanceMetadata]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [SSOAdminClientTypes.InstanceMetadata]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListManagedPoliciesInPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension ListManagedPoliciesInPermissionSetInput {

    static func urlPathProvider(_ value: ListManagedPoliciesInPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

public struct ListManagedPoliciesInPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the [PermissionSet].
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The ARN of the [PermissionSet] whose managed policies will be listed.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionSetArn = permissionSetArn
    }
}

struct ListManagedPoliciesInPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListManagedPoliciesInPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListManagedPoliciesInPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListManagedPoliciesInPermissionSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.attachedManagedPolicies = output.attachedManagedPolicies
            self.nextToken = output.nextToken
        } else {
            self.attachedManagedPolicies = nil
            self.nextToken = nil
        }
    }
}

public struct ListManagedPoliciesInPermissionSetOutput: Swift.Equatable {
    /// An array of the [AttachedManagedPolicy] data type object.
    public var attachedManagedPolicies: [SSOAdminClientTypes.AttachedManagedPolicy]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        attachedManagedPolicies: [SSOAdminClientTypes.AttachedManagedPolicy]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attachedManagedPolicies = attachedManagedPolicies
        self.nextToken = nextToken
    }
}

struct ListManagedPoliciesInPermissionSetOutputBody: Swift.Equatable {
    let attachedManagedPolicies: [SSOAdminClientTypes.AttachedManagedPolicy]?
    let nextToken: Swift.String?
}

extension ListManagedPoliciesInPermissionSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedManagedPoliciesContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.AttachedManagedPolicy?].self, forKey: .attachedManagedPolicies)
        var attachedManagedPoliciesDecoded0:[SSOAdminClientTypes.AttachedManagedPolicy]? = nil
        if let attachedManagedPoliciesContainer = attachedManagedPoliciesContainer {
            attachedManagedPoliciesDecoded0 = [SSOAdminClientTypes.AttachedManagedPolicy]()
            for structure0 in attachedManagedPoliciesContainer {
                if let structure0 = structure0 {
                    attachedManagedPoliciesDecoded0?.append(structure0)
                }
            }
        }
        attachedManagedPolicies = attachedManagedPoliciesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListManagedPoliciesInPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPermissionSetProvisioningStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPermissionSetProvisioningStatusInput {

    static func urlPathProvider(_ value: ListPermissionSetProvisioningStatusInput) -> Swift.String? {
        return "/"
    }
}

public struct ListPermissionSetProvisioningStatusInput: Swift.Equatable {
    /// Filters results based on the passed attribute value.
    public var filter: SSOAdminClientTypes.OperationStatusFilter?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        filter: SSOAdminClientTypes.OperationStatusFilter? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPermissionSetProvisioningStatusInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filter: SSOAdminClientTypes.OperationStatusFilter?
}

extension ListPermissionSetProvisioningStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filterDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.OperationStatusFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListPermissionSetProvisioningStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPermissionSetProvisioningStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissionSetsProvisioningStatus = output.permissionSetsProvisioningStatus
        } else {
            self.nextToken = nil
            self.permissionSetsProvisioningStatus = nil
        }
    }
}

public struct ListPermissionSetProvisioningStatusOutput: Swift.Equatable {
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The status object for the permission set provisioning operation.
    public var permissionSetsProvisioningStatus: [SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        permissionSetsProvisioningStatus: [SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissionSetsProvisioningStatus = permissionSetsProvisioningStatus
    }
}

struct ListPermissionSetProvisioningStatusOutputBody: Swift.Equatable {
    let permissionSetsProvisioningStatus: [SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata]?
    let nextToken: Swift.String?
}

extension ListPermissionSetProvisioningStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case permissionSetsProvisioningStatus = "PermissionSetsProvisioningStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetsProvisioningStatusContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata?].self, forKey: .permissionSetsProvisioningStatus)
        var permissionSetsProvisioningStatusDecoded0:[SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata]? = nil
        if let permissionSetsProvisioningStatusContainer = permissionSetsProvisioningStatusContainer {
            permissionSetsProvisioningStatusDecoded0 = [SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata]()
            for structure0 in permissionSetsProvisioningStatusContainer {
                if let structure0 = structure0 {
                    permissionSetsProvisioningStatusDecoded0?.append(structure0)
                }
            }
        }
        permissionSetsProvisioningStatus = permissionSetsProvisioningStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPermissionSetProvisioningStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPermissionSetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPermissionSetsInput {

    static func urlPathProvider(_ value: ListPermissionSetsInput) -> Swift.String? {
        return "/"
    }
}

public struct ListPermissionSetsInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPermissionSetsInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPermissionSetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPermissionSetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPermissionSetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissionSets = output.permissionSets
        } else {
            self.nextToken = nil
            self.permissionSets = nil
        }
    }
}

public struct ListPermissionSetsOutput: Swift.Equatable {
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// Defines the level of access on an Amazon Web Services account.
    public var permissionSets: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        permissionSets: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissionSets = permissionSets
    }
}

struct ListPermissionSetsOutputBody: Swift.Equatable {
    let permissionSets: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListPermissionSetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case permissionSets = "PermissionSets"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .permissionSets)
        var permissionSetsDecoded0:[Swift.String]? = nil
        if let permissionSetsContainer = permissionSetsContainer {
            permissionSetsDecoded0 = [Swift.String]()
            for string0 in permissionSetsContainer {
                if let string0 = string0 {
                    permissionSetsDecoded0?.append(string0)
                }
            }
        }
        permissionSets = permissionSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPermissionSetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPermissionSetsProvisionedToAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case provisioningStatus = "ProvisioningStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let provisioningStatus = self.provisioningStatus {
            try encodeContainer.encode(provisioningStatus.rawValue, forKey: .provisioningStatus)
        }
    }
}

extension ListPermissionSetsProvisionedToAccountInput {

    static func urlPathProvider(_ value: ListPermissionSetsProvisionedToAccountInput) -> Swift.String? {
        return "/"
    }
}

public struct ListPermissionSetsProvisionedToAccountInput: Swift.Equatable {
    /// The identifier of the Amazon Web Services account from which to list the assignments.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The status object for the permission set provisioning operation.
    public var provisioningStatus: SSOAdminClientTypes.ProvisioningStatus?

    public init(
        accountId: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        provisioningStatus: SSOAdminClientTypes.ProvisioningStatus? = nil
    )
    {
        self.accountId = accountId
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.provisioningStatus = provisioningStatus
    }
}

struct ListPermissionSetsProvisionedToAccountInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let accountId: Swift.String?
    let provisioningStatus: SSOAdminClientTypes.ProvisioningStatus?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListPermissionSetsProvisionedToAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case provisioningStatus = "ProvisioningStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let provisioningStatusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.ProvisioningStatus.self, forKey: .provisioningStatus)
        provisioningStatus = provisioningStatusDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPermissionSetsProvisionedToAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPermissionSetsProvisionedToAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissionSets = output.permissionSets
        } else {
            self.nextToken = nil
            self.permissionSets = nil
        }
    }
}

public struct ListPermissionSetsProvisionedToAccountOutput: Swift.Equatable {
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// Defines the level of access that an Amazon Web Services account has.
    public var permissionSets: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        permissionSets: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissionSets = permissionSets
    }
}

struct ListPermissionSetsProvisionedToAccountOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let permissionSets: [Swift.String]?
}

extension ListPermissionSetsProvisionedToAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case permissionSets = "PermissionSets"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let permissionSetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .permissionSets)
        var permissionSetsDecoded0:[Swift.String]? = nil
        if let permissionSetsContainer = permissionSetsContainer {
            permissionSetsDecoded0 = [Swift.String]()
            for string0 in permissionSetsContainer {
                if let string0 = string0 {
                    permissionSetsDecoded0?.append(string0)
                }
            }
        }
        permissionSets = permissionSetsDecoded0
    }
}

enum ListPermissionSetsProvisionedToAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    public var instanceArn: Swift.String?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The ARN of the resource with the tags to be listed.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let resourceArn: Swift.String?
    let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// A set of key-value pairs that are used to manage the resource.
    public var tags: [SSOAdminClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [SSOAdminClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [SSOAdminClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SSOAdminClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SSOAdminClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTrustedTokenIssuersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListTrustedTokenIssuersInput {

    static func urlPathProvider(_ value: ListTrustedTokenIssuersInput) -> Swift.String? {
        return "/"
    }
}

public struct ListTrustedTokenIssuersInput: Swift.Equatable {
    /// Specifies the ARN of the instance of IAM Identity Center with the trusted token issuer configurations that you want to list.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListTrustedTokenIssuersInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTrustedTokenIssuersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTrustedTokenIssuersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTrustedTokenIssuersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.trustedTokenIssuers = output.trustedTokenIssuers
        } else {
            self.nextToken = nil
            self.trustedTokenIssuers = nil
        }
    }
}

public struct ListTrustedTokenIssuersOutput: Swift.Equatable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array list of the trusted token issuer configurations.
    public var trustedTokenIssuers: [SSOAdminClientTypes.TrustedTokenIssuerMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        trustedTokenIssuers: [SSOAdminClientTypes.TrustedTokenIssuerMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.trustedTokenIssuers = trustedTokenIssuers
    }
}

struct ListTrustedTokenIssuersOutputBody: Swift.Equatable {
    let trustedTokenIssuers: [SSOAdminClientTypes.TrustedTokenIssuerMetadata]?
    let nextToken: Swift.String?
}

extension ListTrustedTokenIssuersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case trustedTokenIssuers = "TrustedTokenIssuers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustedTokenIssuersContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.TrustedTokenIssuerMetadata?].self, forKey: .trustedTokenIssuers)
        var trustedTokenIssuersDecoded0:[SSOAdminClientTypes.TrustedTokenIssuerMetadata]? = nil
        if let trustedTokenIssuersContainer = trustedTokenIssuersContainer {
            trustedTokenIssuersDecoded0 = [SSOAdminClientTypes.TrustedTokenIssuerMetadata]()
            for structure0 in trustedTokenIssuersContainer {
                if let structure0 = structure0 {
                    trustedTokenIssuersDecoded0?.append(structure0)
                }
            }
        }
        trustedTokenIssuers = trustedTokenIssuersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTrustedTokenIssuersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSOAdminClientTypes.OidcJwtConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case claimAttributePath = "ClaimAttributePath"
        case identityStoreAttributePath = "IdentityStoreAttributePath"
        case issuerUrl = "IssuerUrl"
        case jwksRetrievalOption = "JwksRetrievalOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let claimAttributePath = self.claimAttributePath {
            try encodeContainer.encode(claimAttributePath, forKey: .claimAttributePath)
        }
        if let identityStoreAttributePath = self.identityStoreAttributePath {
            try encodeContainer.encode(identityStoreAttributePath, forKey: .identityStoreAttributePath)
        }
        if let issuerUrl = self.issuerUrl {
            try encodeContainer.encode(issuerUrl, forKey: .issuerUrl)
        }
        if let jwksRetrievalOption = self.jwksRetrievalOption {
            try encodeContainer.encode(jwksRetrievalOption.rawValue, forKey: .jwksRetrievalOption)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let issuerUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issuerUrl)
        issuerUrl = issuerUrlDecoded
        let claimAttributePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .claimAttributePath)
        claimAttributePath = claimAttributePathDecoded
        let identityStoreAttributePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreAttributePath)
        identityStoreAttributePath = identityStoreAttributePathDecoded
        let jwksRetrievalOptionDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.JwksRetrievalOption.self, forKey: .jwksRetrievalOption)
        jwksRetrievalOption = jwksRetrievalOptionDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes configuration settings for a trusted token issuer that supports OpenID Connect (OIDC) and JSON Web Tokens (JWTs).
    public struct OidcJwtConfiguration: Swift.Equatable {
        /// The path of the source attribute in the JWT from the trusted token issuer. The attribute mapped by this JMESPath expression is compared against the attribute mapped by IdentityStoreAttributePath when a trusted token issuer token is exchanged for an IAM Identity Center token.
        /// This member is required.
        public var claimAttributePath: Swift.String?
        /// The path of the destination attribute in a JWT from IAM Identity Center. The attribute mapped by this JMESPath expression is compared against the attribute mapped by ClaimAttributePath when a trusted token issuer token is exchanged for an IAM Identity Center token.
        /// This member is required.
        public var identityStoreAttributePath: Swift.String?
        /// The URL that IAM Identity Center uses for OpenID Discovery. OpenID Discovery is used to obtain the information required to verify the tokens that the trusted token issuer generates.
        /// This member is required.
        public var issuerUrl: Swift.String?
        /// The method that the trusted token issuer can use to retrieve the JSON Web Key Set used to verify a JWT.
        /// This member is required.
        public var jwksRetrievalOption: SSOAdminClientTypes.JwksRetrievalOption?

        public init(
            claimAttributePath: Swift.String? = nil,
            identityStoreAttributePath: Swift.String? = nil,
            issuerUrl: Swift.String? = nil,
            jwksRetrievalOption: SSOAdminClientTypes.JwksRetrievalOption? = nil
        )
        {
            self.claimAttributePath = claimAttributePath
            self.identityStoreAttributePath = identityStoreAttributePath
            self.issuerUrl = issuerUrl
            self.jwksRetrievalOption = jwksRetrievalOption
        }
    }

}

extension SSOAdminClientTypes.OidcJwtUpdateConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case claimAttributePath = "ClaimAttributePath"
        case identityStoreAttributePath = "IdentityStoreAttributePath"
        case jwksRetrievalOption = "JwksRetrievalOption"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let claimAttributePath = self.claimAttributePath {
            try encodeContainer.encode(claimAttributePath, forKey: .claimAttributePath)
        }
        if let identityStoreAttributePath = self.identityStoreAttributePath {
            try encodeContainer.encode(identityStoreAttributePath, forKey: .identityStoreAttributePath)
        }
        if let jwksRetrievalOption = self.jwksRetrievalOption {
            try encodeContainer.encode(jwksRetrievalOption.rawValue, forKey: .jwksRetrievalOption)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let claimAttributePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .claimAttributePath)
        claimAttributePath = claimAttributePathDecoded
        let identityStoreAttributePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreAttributePath)
        identityStoreAttributePath = identityStoreAttributePathDecoded
        let jwksRetrievalOptionDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.JwksRetrievalOption.self, forKey: .jwksRetrievalOption)
        jwksRetrievalOption = jwksRetrievalOptionDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes updated configuration settings for a trusted token issuer that supports OpenID Connect (OIDC) and JSON Web Tokens (JWTs).
    public struct OidcJwtUpdateConfiguration: Swift.Equatable {
        /// The path of the source attribute in the JWT from the trusted token issuer. The attribute mapped by this JMESPath expression is compared against the attribute mapped by IdentityStoreAttributePath when a trusted token issuer token is exchanged for an IAM Identity Center token.
        public var claimAttributePath: Swift.String?
        /// The path of the destination attribute in a JWT from IAM Identity Center. The attribute mapped by this JMESPath expression is compared against the attribute mapped by ClaimAttributePath when a trusted token issuer token is exchanged for an IAM Identity Center token.
        public var identityStoreAttributePath: Swift.String?
        /// The method that the trusted token issuer can use to retrieve the JSON Web Key Set used to verify a JWT.
        public var jwksRetrievalOption: SSOAdminClientTypes.JwksRetrievalOption?

        public init(
            claimAttributePath: Swift.String? = nil,
            identityStoreAttributePath: Swift.String? = nil,
            jwksRetrievalOption: SSOAdminClientTypes.JwksRetrievalOption? = nil
        )
        {
            self.claimAttributePath = claimAttributePath
            self.identityStoreAttributePath = identityStoreAttributePath
            self.jwksRetrievalOption = jwksRetrievalOption
        }
    }

}

extension SSOAdminClientTypes.OperationStatusFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.StatusValues.self, forKey: .status)
        status = statusDecoded
    }
}

extension SSOAdminClientTypes {
    /// Filters the operation status list based on the passed attribute value.
    public struct OperationStatusFilter: Swift.Equatable {
        /// Filters the list operations result based on the status attribute.
        public var status: SSOAdminClientTypes.StatusValues?

        public init(
            status: SSOAdminClientTypes.StatusValues? = nil
        )
        {
            self.status = status
        }
    }

}

extension SSOAdminClientTypes.PermissionSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case description = "Description"
        case name = "Name"
        case permissionSetArn = "PermissionSetArn"
        case relayState = "RelayState"
        case sessionDuration = "SessionDuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let relayState = self.relayState {
            try encodeContainer.encode(relayState, forKey: .relayState)
        }
        if let sessionDuration = self.sessionDuration {
            try encodeContainer.encode(sessionDuration, forKey: .sessionDuration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let sessionDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionDuration)
        sessionDuration = sessionDurationDecoded
        let relayStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relayState)
        relayState = relayStateDecoded
    }
}

extension SSOAdminClientTypes {
    /// An entity that contains IAM policies.
    public struct PermissionSet: Swift.Equatable {
        /// The date that the permission set was created.
        public var createdDate: ClientRuntime.Date?
        /// The description of the [PermissionSet].
        public var description: Swift.String?
        /// The name of the permission set.
        public var name: Swift.String?
        /// The ARN of the permission set. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var permissionSetArn: Swift.String?
        /// Used to redirect users within the application during the federation authentication process.
        public var relayState: Swift.String?
        /// The length of time that the application user sessions are valid for in the ISO-8601 standard.
        public var sessionDuration: Swift.String?

        public init(
            createdDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            permissionSetArn: Swift.String? = nil,
            relayState: Swift.String? = nil,
            sessionDuration: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.name = name
            self.permissionSetArn = permissionSetArn
            self.relayState = relayState
            self.sessionDuration = sessionDuration
        }
    }

}

extension SSOAdminClientTypes.PermissionSetProvisioningStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case createdDate = "CreatedDate"
        case failureReason = "FailureReason"
        case permissionSetArn = "PermissionSetArn"
        case requestId = "RequestId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.StatusValues.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that is used to provide the status of the provisioning operation for a specified permission set.
    public struct PermissionSetProvisioningStatus: Swift.Equatable {
        /// The identifier of the Amazon Web Services account from which to list the assignments.
        public var accountId: Swift.String?
        /// The date that the permission set was created.
        public var createdDate: ClientRuntime.Date?
        /// The message that contains an error or exception in case of an operation failure.
        public var failureReason: Swift.String?
        /// The ARN of the permission set that is being provisioned. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var permissionSetArn: Swift.String?
        /// The identifier for tracking the request operation that is generated by the universally unique identifier (UUID) workflow.
        public var requestId: Swift.String?
        /// The status of the permission set provisioning process.
        public var status: SSOAdminClientTypes.StatusValues?

        public init(
            accountId: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            permissionSetArn: Swift.String? = nil,
            requestId: Swift.String? = nil,
            status: SSOAdminClientTypes.StatusValues? = nil
        )
        {
            self.accountId = accountId
            self.createdDate = createdDate
            self.failureReason = failureReason
            self.permissionSetArn = permissionSetArn
            self.requestId = requestId
            self.status = status
        }
    }

}

extension SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case requestId = "RequestId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.StatusValues.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension SSOAdminClientTypes {
    /// Provides information about the permission set provisioning status.
    public struct PermissionSetProvisioningStatusMetadata: Swift.Equatable {
        /// The date that the permission set was created.
        public var createdDate: ClientRuntime.Date?
        /// The identifier for tracking the request operation that is generated by the universally unique identifier (UUID) workflow.
        public var requestId: Swift.String?
        /// The status of the permission set provisioning process.
        public var status: SSOAdminClientTypes.StatusValues?

        public init(
            createdDate: ClientRuntime.Date? = nil,
            requestId: Swift.String? = nil,
            status: SSOAdminClientTypes.StatusValues? = nil
        )
        {
            self.createdDate = createdDate
            self.requestId = requestId
            self.status = status
        }
    }

}

extension SSOAdminClientTypes.PermissionsBoundary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerManagedPolicyReference = "CustomerManagedPolicyReference"
        case managedPolicyArn = "ManagedPolicyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerManagedPolicyReference = self.customerManagedPolicyReference {
            try encodeContainer.encode(customerManagedPolicyReference, forKey: .customerManagedPolicyReference)
        }
        if let managedPolicyArn = self.managedPolicyArn {
            try encodeContainer.encode(managedPolicyArn, forKey: .managedPolicyArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerManagedPolicyReferenceDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.CustomerManagedPolicyReference.self, forKey: .customerManagedPolicyReference)
        customerManagedPolicyReference = customerManagedPolicyReferenceDecoded
        let managedPolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedPolicyArn)
        managedPolicyArn = managedPolicyArnDecoded
    }
}

extension SSOAdminClientTypes {
    /// Specifies the configuration of the Amazon Web Services managed or customer managed policy that you want to set as a permissions boundary. Specify either CustomerManagedPolicyReference to use the name and path of a customer managed policy, or ManagedPolicyArn to use the ARN of an Amazon Web Services managed policy. A permissions boundary represents the maximum permissions that any policy can grant your role. For more information, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. Policies used as permissions boundaries don't provide permissions. You must also attach an IAM policy to the role. To learn how the effective permissions for a role are evaluated, see [IAM JSON policy evaluation logic](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_evaluation-logic.html) in the IAM User Guide.
    public struct PermissionsBoundary: Swift.Equatable {
        /// Specifies the name and path of a customer managed policy. You must have an IAM policy that matches the name and path in each Amazon Web Services account where you want to deploy your permission set.
        public var customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference?
        /// The Amazon Web Services managed policy ARN that you want to attach to a permission set as a permissions boundary.
        public var managedPolicyArn: Swift.String?

        public init(
            customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference? = nil,
            managedPolicyArn: Swift.String? = nil
        )
        {
            self.customerManagedPolicyReference = customerManagedPolicyReference
            self.managedPolicyArn = managedPolicyArn
        }
    }

}

extension SSOAdminClientTypes.PortalOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signInOptions = "SignInOptions"
        case visibility = "Visibility"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signInOptions = self.signInOptions {
            try encodeContainer.encode(signInOptions, forKey: .signInOptions)
        }
        if let visibility = self.visibility {
            try encodeContainer.encode(visibility.rawValue, forKey: .visibility)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signInOptionsDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.SignInOptions.self, forKey: .signInOptions)
        signInOptions = signInOptionsDecoded
        let visibilityDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.ApplicationVisibility.self, forKey: .visibility)
        visibility = visibilityDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes the options for the access portal associated with an application.
    public struct PortalOptions: Swift.Equatable {
        /// A structure that describes the sign-in options for the access portal.
        public var signInOptions: SSOAdminClientTypes.SignInOptions?
        /// Indicates whether this application is visible in the access portal.
        public var visibility: SSOAdminClientTypes.ApplicationVisibility?

        public init(
            signInOptions: SSOAdminClientTypes.SignInOptions? = nil,
            visibility: SSOAdminClientTypes.ApplicationVisibility? = nil
        )
        {
            self.signInOptions = signInOptions
            self.visibility = visibility
        }
    }

}

extension SSOAdminClientTypes {
    public enum PrincipalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case group
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [PrincipalType] {
            return [
                .group,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrincipalType(rawValue: rawValue) ?? PrincipalType.sdkUnknown(rawValue)
        }
    }
}

extension ProvisionPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let targetId = self.targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = self.targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }
}

extension ProvisionPermissionSetInput {

    static func urlPathProvider(_ value: ProvisionPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

public struct ProvisionPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// TargetID is an Amazon Web Services account identifier, (For example, 123456789012).
    public var targetId: Swift.String?
    /// The entity type for which the assignment will be created.
    /// This member is required.
    public var targetType: SSOAdminClientTypes.ProvisionTargetType?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        targetId: Swift.String? = nil,
        targetType: SSOAdminClientTypes.ProvisionTargetType? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.targetId = targetId
        self.targetType = targetType
    }
}

struct ProvisionPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let targetId: Swift.String?
    let targetType: SSOAdminClientTypes.ProvisionTargetType?
}

extension ProvisionPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.ProvisionTargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
    }
}

extension ProvisionPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ProvisionPermissionSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.permissionSetProvisioningStatus = output.permissionSetProvisioningStatus
        } else {
            self.permissionSetProvisioningStatus = nil
        }
    }
}

public struct ProvisionPermissionSetOutput: Swift.Equatable {
    /// The status object for the permission set provisioning operation.
    public var permissionSetProvisioningStatus: SSOAdminClientTypes.PermissionSetProvisioningStatus?

    public init(
        permissionSetProvisioningStatus: SSOAdminClientTypes.PermissionSetProvisioningStatus? = nil
    )
    {
        self.permissionSetProvisioningStatus = permissionSetProvisioningStatus
    }
}

struct ProvisionPermissionSetOutputBody: Swift.Equatable {
    let permissionSetProvisioningStatus: SSOAdminClientTypes.PermissionSetProvisioningStatus?
}

extension ProvisionPermissionSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionSetProvisioningStatus = "PermissionSetProvisioningStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetProvisioningStatusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PermissionSetProvisioningStatus.self, forKey: .permissionSetProvisioningStatus)
        permissionSetProvisioningStatus = permissionSetProvisioningStatusDecoded
    }
}

enum ProvisionPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSOAdminClientTypes {
    public enum ProvisionTargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allProvisionedAccounts
        case awsAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionTargetType] {
            return [
                .allProvisionedAccounts,
                .awsAccount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allProvisionedAccounts: return "ALL_PROVISIONED_ACCOUNTS"
            case .awsAccount: return "AWS_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisionTargetType(rawValue: rawValue) ?? ProvisionTargetType.sdkUnknown(rawValue)
        }
    }
}

extension SSOAdminClientTypes {
    public enum ProvisioningStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case latestPermissionSetNotProvisioned
        case latestPermissionSetProvisioned
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisioningStatus] {
            return [
                .latestPermissionSetNotProvisioned,
                .latestPermissionSetProvisioned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .latestPermissionSetNotProvisioned: return "LATEST_PERMISSION_SET_NOT_PROVISIONED"
            case .latestPermissionSetProvisioned: return "LATEST_PERMISSION_SET_PROVISIONED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisioningStatus(rawValue: rawValue) ?? ProvisioningStatus.sdkUnknown(rawValue)
        }
    }
}

extension PutApplicationAccessScopeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case authorizedTargets = "AuthorizedTargets"
        case scope = "Scope"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let authorizedTargets = authorizedTargets {
            var authorizedTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizedTargets)
            for scopetarget0 in authorizedTargets {
                try authorizedTargetsContainer.encode(scopetarget0)
            }
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope, forKey: .scope)
        }
    }
}

extension PutApplicationAccessScopeInput {

    static func urlPathProvider(_ value: PutApplicationAccessScopeInput) -> Swift.String? {
        return "/"
    }
}

public struct PutApplicationAccessScopeInput: Swift.Equatable {
    /// Specifies the ARN of the application with the access scope with the targets to add or update.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies an array list of ARNs that represent the authorized targets for this access scope.
    public var authorizedTargets: [Swift.String]?
    /// Specifies the name of the access scope to be associated with the specified targets.
    /// This member is required.
    public var scope: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        authorizedTargets: [Swift.String]? = nil,
        scope: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.authorizedTargets = authorizedTargets
        self.scope = scope
    }
}

struct PutApplicationAccessScopeInputBody: Swift.Equatable {
    let scope: Swift.String?
    let authorizedTargets: [Swift.String]?
    let applicationArn: Swift.String?
}

extension PutApplicationAccessScopeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case authorizedTargets = "AuthorizedTargets"
        case scope = "Scope"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scope)
        scope = scopeDecoded
        let authorizedTargetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizedTargets)
        var authorizedTargetsDecoded0:[Swift.String]? = nil
        if let authorizedTargetsContainer = authorizedTargetsContainer {
            authorizedTargetsDecoded0 = [Swift.String]()
            for string0 in authorizedTargetsContainer {
                if let string0 = string0 {
                    authorizedTargetsDecoded0?.append(string0)
                }
            }
        }
        authorizedTargets = authorizedTargetsDecoded0
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
    }
}

extension PutApplicationAccessScopeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutApplicationAccessScopeOutput: Swift.Equatable {

    public init() { }
}

enum PutApplicationAccessScopeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutApplicationAssignmentConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case assignmentRequired = "AssignmentRequired"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let assignmentRequired = self.assignmentRequired {
            try encodeContainer.encode(assignmentRequired, forKey: .assignmentRequired)
        }
    }
}

extension PutApplicationAssignmentConfigurationInput {

    static func urlPathProvider(_ value: PutApplicationAssignmentConfigurationInput) -> Swift.String? {
        return "/"
    }
}

public struct PutApplicationAssignmentConfigurationInput: Swift.Equatable {
    /// Specifies the ARN of the application. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// If AssignmentsRequired is true (default value), users dont have access to the application unless an assignment is created using the [CreateApplicationAssignment API](https://docs.aws.amazon.com/singlesignon/latest/APIReference/API_CreateApplicationAssignment.html). If false, all users have access to the application.
    /// This member is required.
    public var assignmentRequired: Swift.Bool?

    public init(
        applicationArn: Swift.String? = nil,
        assignmentRequired: Swift.Bool? = nil
    )
    {
        self.applicationArn = applicationArn
        self.assignmentRequired = assignmentRequired
    }
}

struct PutApplicationAssignmentConfigurationInputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let assignmentRequired: Swift.Bool?
}

extension PutApplicationAssignmentConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case assignmentRequired = "AssignmentRequired"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let assignmentRequiredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .assignmentRequired)
        assignmentRequired = assignmentRequiredDecoded
    }
}

extension PutApplicationAssignmentConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutApplicationAssignmentConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum PutApplicationAssignmentConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutApplicationAuthenticationMethodInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case authenticationMethod = "AuthenticationMethod"
        case authenticationMethodType = "AuthenticationMethodType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let authenticationMethod = self.authenticationMethod {
            try encodeContainer.encode(authenticationMethod, forKey: .authenticationMethod)
        }
        if let authenticationMethodType = self.authenticationMethodType {
            try encodeContainer.encode(authenticationMethodType.rawValue, forKey: .authenticationMethodType)
        }
    }
}

extension PutApplicationAuthenticationMethodInput {

    static func urlPathProvider(_ value: PutApplicationAuthenticationMethodInput) -> Swift.String? {
        return "/"
    }
}

public struct PutApplicationAuthenticationMethodInput: Swift.Equatable {
    /// Specifies the ARN of the application with the authentication method to add or update.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies a structure that describes the authentication method to add or update. The structure type you provide is determined by the AuthenticationMethodType parameter.
    /// This member is required.
    public var authenticationMethod: SSOAdminClientTypes.AuthenticationMethod?
    /// Specifies the type of the authentication method that you want to add or update.
    /// This member is required.
    public var authenticationMethodType: SSOAdminClientTypes.AuthenticationMethodType?

    public init(
        applicationArn: Swift.String? = nil,
        authenticationMethod: SSOAdminClientTypes.AuthenticationMethod? = nil,
        authenticationMethodType: SSOAdminClientTypes.AuthenticationMethodType? = nil
    )
    {
        self.applicationArn = applicationArn
        self.authenticationMethod = authenticationMethod
        self.authenticationMethodType = authenticationMethodType
    }
}

struct PutApplicationAuthenticationMethodInputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let authenticationMethodType: SSOAdminClientTypes.AuthenticationMethodType?
    let authenticationMethod: SSOAdminClientTypes.AuthenticationMethod?
}

extension PutApplicationAuthenticationMethodInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case authenticationMethod = "AuthenticationMethod"
        case authenticationMethodType = "AuthenticationMethodType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let authenticationMethodTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.AuthenticationMethodType.self, forKey: .authenticationMethodType)
        authenticationMethodType = authenticationMethodTypeDecoded
        let authenticationMethodDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.AuthenticationMethod.self, forKey: .authenticationMethod)
        authenticationMethod = authenticationMethodDecoded
    }
}

extension PutApplicationAuthenticationMethodOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutApplicationAuthenticationMethodOutput: Swift.Equatable {

    public init() { }
}

enum PutApplicationAuthenticationMethodOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutApplicationGrantInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case grant = "Grant"
        case grantType = "GrantType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let grant = self.grant {
            try encodeContainer.encode(grant, forKey: .grant)
        }
        if let grantType = self.grantType {
            try encodeContainer.encode(grantType.rawValue, forKey: .grantType)
        }
    }
}

extension PutApplicationGrantInput {

    static func urlPathProvider(_ value: PutApplicationGrantInput) -> Swift.String? {
        return "/"
    }
}

public struct PutApplicationGrantInput: Swift.Equatable {
    /// Specifies the ARN of the application to update.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies a structure that describes the grant to update.
    /// This member is required.
    public var grant: SSOAdminClientTypes.Grant?
    /// Specifies the type of grant to update.
    /// This member is required.
    public var grantType: SSOAdminClientTypes.GrantType?

    public init(
        applicationArn: Swift.String? = nil,
        grant: SSOAdminClientTypes.Grant? = nil,
        grantType: SSOAdminClientTypes.GrantType? = nil
    )
    {
        self.applicationArn = applicationArn
        self.grant = grant
        self.grantType = grantType
    }
}

struct PutApplicationGrantInputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let grantType: SSOAdminClientTypes.GrantType?
    let grant: SSOAdminClientTypes.Grant?
}

extension PutApplicationGrantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case grant = "Grant"
        case grantType = "GrantType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let grantTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.GrantType.self, forKey: .grantType)
        grantType = grantTypeDecoded
        let grantDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.Grant.self, forKey: .grant)
        grant = grantDecoded
    }
}

extension PutApplicationGrantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutApplicationGrantOutput: Swift.Equatable {

    public init() { }
}

enum PutApplicationGrantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutInlinePolicyToPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inlinePolicy = "InlinePolicy"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inlinePolicy = self.inlinePolicy {
            try encodeContainer.encode(inlinePolicy, forKey: .inlinePolicy)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension PutInlinePolicyToPermissionSetInput {

    static func urlPathProvider(_ value: PutInlinePolicyToPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

public struct PutInlinePolicyToPermissionSetInput: Swift.Equatable {
    /// The inline policy to attach to a [PermissionSet].
    /// This member is required.
    public var inlinePolicy: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        inlinePolicy: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.inlinePolicy = inlinePolicy
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct PutInlinePolicyToPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let inlinePolicy: Swift.String?
}

extension PutInlinePolicyToPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inlinePolicy = "InlinePolicy"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let inlinePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inlinePolicy)
        inlinePolicy = inlinePolicyDecoded
    }
}

extension PutInlinePolicyToPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutInlinePolicyToPermissionSetOutput: Swift.Equatable {

    public init() { }
}

enum PutInlinePolicyToPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutPermissionsBoundaryToPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case permissionsBoundary = "PermissionsBoundary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let permissionsBoundary = self.permissionsBoundary {
            try encodeContainer.encode(permissionsBoundary, forKey: .permissionsBoundary)
        }
    }
}

extension PutPermissionsBoundaryToPermissionSetInput {

    static func urlPathProvider(_ value: PutPermissionsBoundaryToPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

public struct PutPermissionsBoundaryToPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the PermissionSet.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// The permissions boundary that you want to attach to a PermissionSet.
    /// This member is required.
    public var permissionsBoundary: SSOAdminClientTypes.PermissionsBoundary?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        permissionsBoundary: SSOAdminClientTypes.PermissionsBoundary? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.permissionsBoundary = permissionsBoundary
    }
}

struct PutPermissionsBoundaryToPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let permissionsBoundary: SSOAdminClientTypes.PermissionsBoundary?
}

extension PutPermissionsBoundaryToPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case permissionsBoundary = "PermissionsBoundary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PermissionsBoundary.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
    }
}

extension PutPermissionsBoundaryToPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutPermissionsBoundaryToPermissionSetOutput: Swift.Equatable {

    public init() { }
}

enum PutPermissionsBoundaryToPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSOAdminClientTypes.RefreshTokenGrant: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension SSOAdminClientTypes {
    /// A structure that defines configuration settings for an application that supports the OAuth 2.0 Refresh Token Grant.
    public struct RefreshTokenGrant: Swift.Equatable {

        public init() { }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that a requested resource is not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SSOAdminClientTypes.ResourceServerConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scopes = "Scopes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scopes = scopes {
            var scopesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .scopes)
            for (dictKey0, resourceServerScopes0) in scopes {
                try scopesContainer.encode(resourceServerScopes0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scopesContainer = try containerValues.decodeIfPresent([Swift.String: SSOAdminClientTypes.ResourceServerScopeDetails?].self, forKey: .scopes)
        var scopesDecoded0: [Swift.String:SSOAdminClientTypes.ResourceServerScopeDetails]? = nil
        if let scopesContainer = scopesContainer {
            scopesDecoded0 = [Swift.String:SSOAdminClientTypes.ResourceServerScopeDetails]()
            for (key0, resourceserverscopedetails0) in scopesContainer {
                if let resourceserverscopedetails0 = resourceserverscopedetails0 {
                    scopesDecoded0?[key0] = resourceserverscopedetails0
                }
            }
        }
        scopes = scopesDecoded0
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes the configuration of a resource server.
    public struct ResourceServerConfig: Swift.Equatable {
        /// A list of the IAM Identity Center access scopes that are associated with this resource server.
        public var scopes: [Swift.String:SSOAdminClientTypes.ResourceServerScopeDetails]?

        public init(
            scopes: [Swift.String:SSOAdminClientTypes.ResourceServerScopeDetails]? = nil
        )
        {
            self.scopes = scopes
        }
    }

}

extension SSOAdminClientTypes.ResourceServerScopeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detailedTitle = "DetailedTitle"
        case longDescription = "LongDescription"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let detailedTitle = self.detailedTitle {
            try encodeContainer.encode(detailedTitle, forKey: .detailedTitle)
        }
        if let longDescription = self.longDescription {
            try encodeContainer.encode(longDescription, forKey: .longDescription)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let longDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .longDescription)
        longDescription = longDescriptionDecoded
        let detailedTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detailedTitle)
        detailedTitle = detailedTitleDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes details for an IAM Identity Center access scope that is associated with a resource server.
    public struct ResourceServerScopeDetails: Swift.Equatable {
        /// The title of an access scope for a resource server.
        public var detailedTitle: Swift.String?
        /// The description of an access scope for a resource server.
        public var longDescription: Swift.String?

        public init(
            detailedTitle: Swift.String? = nil,
            longDescription: Swift.String? = nil
        )
        {
            self.detailedTitle = detailedTitle
            self.longDescription = longDescription
        }
    }

}

extension SSOAdminClientTypes.ScopeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizedTargets = "AuthorizedTargets"
        case scope = "Scope"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizedTargets = authorizedTargets {
            var authorizedTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .authorizedTargets)
            for scopetarget0 in authorizedTargets {
                try authorizedTargetsContainer.encode(scopetarget0)
            }
        }
        if let scope = self.scope {
            try encodeContainer.encode(scope, forKey: .scope)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scopeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scope)
        scope = scopeDecoded
        let authorizedTargetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .authorizedTargets)
        var authorizedTargetsDecoded0:[Swift.String]? = nil
        if let authorizedTargetsContainer = authorizedTargetsContainer {
            authorizedTargetsDecoded0 = [Swift.String]()
            for string0 in authorizedTargetsContainer {
                if let string0 = string0 {
                    authorizedTargetsDecoded0?.append(string0)
                }
            }
        }
        authorizedTargets = authorizedTargetsDecoded0
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes an IAM Identity Center access scope and its authorized targets.
    public struct ScopeDetails: Swift.Equatable {
        /// An array list of ARNs of applications.
        public var authorizedTargets: [Swift.String]?
        /// The name of the access scope.
        /// This member is required.
        public var scope: Swift.String?

        public init(
            authorizedTargets: [Swift.String]? = nil,
            scope: Swift.String? = nil
        )
        {
            self.authorizedTargets = authorizedTargets
            self.scope = scope
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the principal has crossed the permitted number of resources that can be created.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SSOAdminClientTypes.SignInOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationUrl = "ApplicationUrl"
        case origin = "Origin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationUrl = self.applicationUrl {
            try encodeContainer.encode(applicationUrl, forKey: .applicationUrl)
        }
        if let origin = self.origin {
            try encodeContainer.encode(origin.rawValue, forKey: .origin)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.SignInOrigin.self, forKey: .origin)
        origin = originDecoded
        let applicationUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationUrl)
        applicationUrl = applicationUrlDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes the sign-in options for an application portal.
    public struct SignInOptions: Swift.Equatable {
        /// The URL that accepts authentication requests for an application. This is a required parameter if the Origin parameter is APPLICATION.
        public var applicationUrl: Swift.String?
        /// This determines how IAM Identity Center navigates the user to the target application. It can be one of the following values:
        ///
        /// * APPLICATION: IAM Identity Center redirects the customer to the configured ApplicationUrl.
        ///
        /// * IDENTITY_CENTER: IAM Identity Center uses SAML identity-provider initiated authentication to sign the customer directly into a SAML-based application.
        /// This member is required.
        public var origin: SSOAdminClientTypes.SignInOrigin?

        public init(
            applicationUrl: Swift.String? = nil,
            origin: SSOAdminClientTypes.SignInOrigin? = nil
        )
        {
            self.applicationUrl = applicationUrl
            self.origin = origin
        }
    }

}

extension SSOAdminClientTypes {
    public enum SignInOrigin: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case application
        case identityCenter
        case sdkUnknown(Swift.String)

        public static var allCases: [SignInOrigin] {
            return [
                .application,
                .identityCenter,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case .identityCenter: return "IDENTITY_CENTER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SignInOrigin(rawValue: rawValue) ?? SignInOrigin.sdkUnknown(rawValue)
        }
    }
}

extension SSOAdminClientTypes {
    public enum StatusValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusValues] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatusValues(rawValue: rawValue) ?? StatusValues.sdkUnknown(rawValue)
        }
    }
}

extension SSOAdminClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SSOAdminClientTypes {
    /// A set of key-value pairs that are used to manage the resource. Tags can only be applied to permission sets and cannot be applied to corresponding roles that IAM Identity Center creates in Amazon Web Services accounts.
    public struct Tag: Swift.Equatable {
        /// The key for the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    public var instanceArn: Swift.String?
    /// The ARN of the resource with the tags to be listed.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A set of key-value pairs that are used to manage the resource.
    /// This member is required.
    public var tags: [SSOAdminClientTypes.Tag]?

    public init(
        instanceArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tags: [SSOAdminClientTypes.Tag]? = nil
    )
    {
        self.instanceArn = instanceArn
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let resourceArn: Swift.String?
    let tags: [SSOAdminClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SSOAdminClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SSOAdminClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSOAdminClientTypes {
    public enum TargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetType] {
            return [
                .awsAccount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsAccount: return "AWS_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetType(rawValue: rawValue) ?? TargetType.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the principal has crossed the throttling limits of the API operations.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SSOAdminClientTypes.TokenExchangeGrant: Swift.Codable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension SSOAdminClientTypes {
    /// A structure that defines configuration settings for an application that supports the OAuth 2.0 Token Exchange Grant.
    public struct TokenExchangeGrant: Swift.Equatable {

        public init() { }
    }

}

extension SSOAdminClientTypes.TrustedTokenIssuerConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oidcjwtconfiguration = "OidcJwtConfiguration"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .oidcjwtconfiguration(oidcjwtconfiguration):
                try container.encode(oidcjwtconfiguration, forKey: .oidcjwtconfiguration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let oidcjwtconfigurationDecoded = try values.decodeIfPresent(SSOAdminClientTypes.OidcJwtConfiguration.self, forKey: .oidcjwtconfiguration)
        if let oidcjwtconfiguration = oidcjwtconfigurationDecoded {
            self = .oidcjwtconfiguration(oidcjwtconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes the configuration of a trusted token issuer. The structure and available settings are determined by the type of the trusted token issuer.
    public enum TrustedTokenIssuerConfiguration: Swift.Equatable {
        /// A structure that describes the settings for a trusted token issuer that works with OpenID Connect (OIDC) by using JSON Web Tokens (JWT).
        case oidcjwtconfiguration(SSOAdminClientTypes.OidcJwtConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension SSOAdminClientTypes.TrustedTokenIssuerMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case trustedTokenIssuerArn = "TrustedTokenIssuerArn"
        case trustedTokenIssuerType = "TrustedTokenIssuerType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let trustedTokenIssuerArn = self.trustedTokenIssuerArn {
            try encodeContainer.encode(trustedTokenIssuerArn, forKey: .trustedTokenIssuerArn)
        }
        if let trustedTokenIssuerType = self.trustedTokenIssuerType {
            try encodeContainer.encode(trustedTokenIssuerType.rawValue, forKey: .trustedTokenIssuerType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustedTokenIssuerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustedTokenIssuerArn)
        trustedTokenIssuerArn = trustedTokenIssuerArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let trustedTokenIssuerTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.TrustedTokenIssuerType.self, forKey: .trustedTokenIssuerType)
        trustedTokenIssuerType = trustedTokenIssuerTypeDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes a trusted token issuer.
    public struct TrustedTokenIssuerMetadata: Swift.Equatable {
        /// The name of the trusted token issuer configuration in the instance of IAM Identity Center.
        public var name: Swift.String?
        /// The ARN of the trusted token issuer configuration in the instance of IAM Identity Center.
        public var trustedTokenIssuerArn: Swift.String?
        /// The type of trusted token issuer.
        public var trustedTokenIssuerType: SSOAdminClientTypes.TrustedTokenIssuerType?

        public init(
            name: Swift.String? = nil,
            trustedTokenIssuerArn: Swift.String? = nil,
            trustedTokenIssuerType: SSOAdminClientTypes.TrustedTokenIssuerType? = nil
        )
        {
            self.name = name
            self.trustedTokenIssuerArn = trustedTokenIssuerArn
            self.trustedTokenIssuerType = trustedTokenIssuerType
        }
    }

}

extension SSOAdminClientTypes {
    public enum TrustedTokenIssuerType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case oidcJwt
        case sdkUnknown(Swift.String)

        public static var allCases: [TrustedTokenIssuerType] {
            return [
                .oidcJwt,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .oidcJwt: return "OIDC_JWT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TrustedTokenIssuerType(rawValue: rawValue) ?? TrustedTokenIssuerType.sdkUnknown(rawValue)
        }
    }
}

extension SSOAdminClientTypes.TrustedTokenIssuerUpdateConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case oidcjwtconfiguration = "OidcJwtConfiguration"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .oidcjwtconfiguration(oidcjwtconfiguration):
                try container.encode(oidcjwtconfiguration, forKey: .oidcjwtconfiguration)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let oidcjwtconfigurationDecoded = try values.decodeIfPresent(SSOAdminClientTypes.OidcJwtUpdateConfiguration.self, forKey: .oidcjwtconfiguration)
        if let oidcjwtconfiguration = oidcjwtconfigurationDecoded {
            self = .oidcjwtconfiguration(oidcjwtconfiguration)
            return
        }
        self = .sdkUnknown("")
    }
}

extension SSOAdminClientTypes {
    /// A structure that contains details to be updated for a trusted token issuer configuration. The structure and settings that you can include depend on the type of the trusted token issuer being updated.
    public enum TrustedTokenIssuerUpdateConfiguration: Swift.Equatable {
        /// A structure that describes an updated configuration for a trusted token issuer that uses OpenID Connect (OIDC) with JSON web tokens (JWT).
        case oidcjwtconfiguration(SSOAdminClientTypes.OidcJwtUpdateConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    public var instanceArn: Swift.String?
    /// The ARN of the resource with the tags to be listed.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of tags that are attached to the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        instanceArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.instanceArn = instanceArn
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateApplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case description = "Description"
        case name = "Name"
        case portalOptions = "PortalOptions"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationArn = self.applicationArn {
            try encodeContainer.encode(applicationArn, forKey: .applicationArn)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let portalOptions = self.portalOptions {
            try encodeContainer.encode(portalOptions, forKey: .portalOptions)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }
}

extension UpdateApplicationInput {

    static func urlPathProvider(_ value: UpdateApplicationInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateApplicationInput: Swift.Equatable {
    /// Specifies the ARN of the application. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// The description of the .
    public var description: Swift.String?
    /// Specifies the updated name for the application.
    public var name: Swift.String?
    /// A structure that describes the options for the portal associated with an application.
    public var portalOptions: SSOAdminClientTypes.UpdateApplicationPortalOptions?
    /// Specifies whether the application is enabled or disabled.
    public var status: SSOAdminClientTypes.ApplicationStatus?

    public init(
        applicationArn: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        portalOptions: SSOAdminClientTypes.UpdateApplicationPortalOptions? = nil,
        status: SSOAdminClientTypes.ApplicationStatus? = nil
    )
    {
        self.applicationArn = applicationArn
        self.description = description
        self.name = name
        self.portalOptions = portalOptions
        self.status = status
    }
}

struct UpdateApplicationInputBody: Swift.Equatable {
    let applicationArn: Swift.String?
    let name: Swift.String?
    let description: Swift.String?
    let status: SSOAdminClientTypes.ApplicationStatus?
    let portalOptions: SSOAdminClientTypes.UpdateApplicationPortalOptions?
}

extension UpdateApplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationArn = "ApplicationArn"
        case description = "Description"
        case name = "Name"
        case portalOptions = "PortalOptions"
        case status = "Status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationArn)
        applicationArn = applicationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let statusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.ApplicationStatus.self, forKey: .status)
        status = statusDecoded
        let portalOptionsDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.UpdateApplicationPortalOptions.self, forKey: .portalOptions)
        portalOptions = portalOptionsDecoded
    }
}

extension UpdateApplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateApplicationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateApplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSOAdminClientTypes.UpdateApplicationPortalOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case signInOptions = "SignInOptions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let signInOptions = self.signInOptions {
            try encodeContainer.encode(signInOptions, forKey: .signInOptions)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let signInOptionsDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.SignInOptions.self, forKey: .signInOptions)
        signInOptions = signInOptionsDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that describes the options for the access portal associated with an application that can be updated.
    public struct UpdateApplicationPortalOptions: Swift.Equatable {
        /// A structure that describes the sign-in options for an application portal.
        public var signInOptions: SSOAdminClientTypes.SignInOptions?

        public init(
            signInOptions: SSOAdminClientTypes.SignInOptions? = nil
        )
        {
            self.signInOptions = signInOptions
        }
    }

}

extension UpdateInstanceAccessControlAttributeConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceAccessControlAttributeConfiguration = "InstanceAccessControlAttributeConfiguration"
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceAccessControlAttributeConfiguration = self.instanceAccessControlAttributeConfiguration {
            try encodeContainer.encode(instanceAccessControlAttributeConfiguration, forKey: .instanceAccessControlAttributeConfiguration)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension UpdateInstanceAccessControlAttributeConfigurationInput {

    static func urlPathProvider(_ value: UpdateInstanceAccessControlAttributeConfigurationInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateInstanceAccessControlAttributeConfigurationInput: Swift.Equatable {
    /// Updates the attributes for your ABAC configuration.
    /// This member is required.
    public var instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration? = nil,
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfiguration
        self.instanceArn = instanceArn
    }
}

struct UpdateInstanceAccessControlAttributeConfigurationInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration?
}

extension UpdateInstanceAccessControlAttributeConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceAccessControlAttributeConfiguration = "InstanceAccessControlAttributeConfiguration"
        case instanceArn = "InstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let instanceAccessControlAttributeConfigurationDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration.self, forKey: .instanceAccessControlAttributeConfiguration)
        instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfigurationDecoded
    }
}

extension UpdateInstanceAccessControlAttributeConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateInstanceAccessControlAttributeConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateInstanceAccessControlAttributeConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateInstanceInput {

    static func urlPathProvider(_ value: UpdateInstanceInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateInstanceInput: Swift.Equatable {
    /// The ARN of the instance of IAM Identity Center under which the operation will run. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// Updates the instance name.
    /// This member is required.
    public var name: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.name = name
    }
}

struct UpdateInstanceInputBody: Swift.Equatable {
    let name: Swift.String?
    let instanceArn: Swift.String?
}

extension UpdateInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
    }
}

extension UpdateInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateInstanceOutput: Swift.Equatable {

    public init() { }
}

enum UpdateInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case relayState = "RelayState"
        case sessionDuration = "SessionDuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let relayState = self.relayState {
            try encodeContainer.encode(relayState, forKey: .relayState)
        }
        if let sessionDuration = self.sessionDuration {
            try encodeContainer.encode(sessionDuration, forKey: .sessionDuration)
        }
    }
}

extension UpdatePermissionSetInput {

    static func urlPathProvider(_ value: UpdatePermissionSetInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdatePermissionSetInput: Swift.Equatable {
    /// The description of the [PermissionSet].
    public var description: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// Used to redirect users within the application during the federation authentication process.
    public var relayState: Swift.String?
    /// The length of time that the application user sessions are valid for in the ISO-8601 standard.
    public var sessionDuration: Swift.String?

    public init(
        description: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        relayState: Swift.String? = nil,
        sessionDuration: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.relayState = relayState
        self.sessionDuration = sessionDuration
    }
}

struct UpdatePermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let description: Swift.String?
    let sessionDuration: Swift.String?
    let relayState: Swift.String?
}

extension UpdatePermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case relayState = "RelayState"
        case sessionDuration = "SessionDuration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sessionDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionDuration)
        sessionDuration = sessionDurationDecoded
        let relayStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relayState)
        relayState = relayStateDecoded
    }
}

extension UpdatePermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdatePermissionSetOutput: Swift.Equatable {

    public init() { }
}

enum UpdatePermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateTrustedTokenIssuerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case trustedTokenIssuerArn = "TrustedTokenIssuerArn"
        case trustedTokenIssuerConfiguration = "TrustedTokenIssuerConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let trustedTokenIssuerArn = self.trustedTokenIssuerArn {
            try encodeContainer.encode(trustedTokenIssuerArn, forKey: .trustedTokenIssuerArn)
        }
        if let trustedTokenIssuerConfiguration = self.trustedTokenIssuerConfiguration {
            try encodeContainer.encode(trustedTokenIssuerConfiguration, forKey: .trustedTokenIssuerConfiguration)
        }
    }
}

extension UpdateTrustedTokenIssuerInput {

    static func urlPathProvider(_ value: UpdateTrustedTokenIssuerInput) -> Swift.String? {
        return "/"
    }
}

public struct UpdateTrustedTokenIssuerInput: Swift.Equatable {
    /// Specifies the updated name to be applied to the trusted token issuer configuration.
    public var name: Swift.String?
    /// Specifies the ARN of the trusted token issuer configuration that you want to update.
    /// This member is required.
    public var trustedTokenIssuerArn: Swift.String?
    /// Specifies a structure with settings to apply to the specified trusted token issuer. The settings that you can provide are determined by the type of the trusted token issuer that you are updating.
    public var trustedTokenIssuerConfiguration: SSOAdminClientTypes.TrustedTokenIssuerUpdateConfiguration?

    public init(
        name: Swift.String? = nil,
        trustedTokenIssuerArn: Swift.String? = nil,
        trustedTokenIssuerConfiguration: SSOAdminClientTypes.TrustedTokenIssuerUpdateConfiguration? = nil
    )
    {
        self.name = name
        self.trustedTokenIssuerArn = trustedTokenIssuerArn
        self.trustedTokenIssuerConfiguration = trustedTokenIssuerConfiguration
    }
}

struct UpdateTrustedTokenIssuerInputBody: Swift.Equatable {
    let trustedTokenIssuerArn: Swift.String?
    let name: Swift.String?
    let trustedTokenIssuerConfiguration: SSOAdminClientTypes.TrustedTokenIssuerUpdateConfiguration?
}

extension UpdateTrustedTokenIssuerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case trustedTokenIssuerArn = "TrustedTokenIssuerArn"
        case trustedTokenIssuerConfiguration = "TrustedTokenIssuerConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let trustedTokenIssuerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .trustedTokenIssuerArn)
        trustedTokenIssuerArn = trustedTokenIssuerArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let trustedTokenIssuerConfigurationDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.TrustedTokenIssuerUpdateConfiguration.self, forKey: .trustedTokenIssuerConfiguration)
        trustedTokenIssuerConfiguration = trustedTokenIssuerConfigurationDecoded
    }
}

extension UpdateTrustedTokenIssuerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateTrustedTokenIssuerOutput: Swift.Equatable {

    public init() { }
}

enum UpdateTrustedTokenIssuerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed because it contains a syntax error.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
