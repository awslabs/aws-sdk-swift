// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension SSOAdminClientTypes.AccessControlAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.AccessControlAttributeValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension SSOAdminClientTypes {
    /// These are IAM Identity Center identity store attributes that you can configure for use in attributes-based access control (ABAC). You can create permissions policies that determine who can access your Amazon Web Services resources based upon the configured attribute values. When you enable ABAC and specify AccessControlAttributes, IAM Identity Center passes the attribute values of the authenticated user into IAM for use in policy evaluation.
    public struct AccessControlAttribute: Swift.Equatable {
        /// The name of the attribute associated with your identities in your identity source. This is used to map a specified attribute in your identity source with an attribute in IAM Identity Center.
        /// This member is required.
        public var key: Swift.String?
        /// The value used for mapping a specified attribute to an identity source.
        /// This member is required.
        public var value: SSOAdminClientTypes.AccessControlAttributeValue?

        public init(
            key: Swift.String? = nil,
            value: SSOAdminClientTypes.AccessControlAttributeValue? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension SSOAdminClientTypes.AccessControlAttributeValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case source = "Source"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let source = source {
            var sourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .source)
            for accesscontrolattributevaluesource0 in source {
                try sourceContainer.encode(accesscontrolattributevaluesource0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .source)
        var sourceDecoded0:[Swift.String]? = nil
        if let sourceContainer = sourceContainer {
            sourceDecoded0 = [Swift.String]()
            for string0 in sourceContainer {
                if let string0 = string0 {
                    sourceDecoded0?.append(string0)
                }
            }
        }
        source = sourceDecoded0
    }
}

extension SSOAdminClientTypes {
    /// The value used for mapping a specified attribute to an identity source. For more information, see [Attribute mappings](https://docs.aws.amazon.com/singlesignon/latest/userguide/attributemappingsconcept.html) in the IAM Identity Center User Guide.
    public struct AccessControlAttributeValue: Swift.Equatable {
        /// The identity source to use when mapping a specified attribute to IAM Identity Center.
        /// This member is required.
        public var source: [Swift.String]?

        public init(
            source: [Swift.String]? = nil
        )
        {
            self.source = source
        }
    }

}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SSOAdminClientTypes.AccountAssignment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension SSOAdminClientTypes {
    /// The assignment that indicates a principal's limited access to a specified Amazon Web Services account with a specified permission set. The term principal here refers to a user or group that is defined in IAM Identity Center.
    public struct AccountAssignment: Swift.Equatable {
        /// The identifier of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// The ARN of the permission set. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var permissionSetArn: Swift.String?
        /// An identifier for an object in IAM Identity Center, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in IAM Identity Center, see the [IAM Identity Center Identity Store API Reference].
        public var principalId: Swift.String?
        /// The entity type for which the assignment will be created.
        public var principalType: SSOAdminClientTypes.PrincipalType?

        public init(
            accountId: Swift.String? = nil,
            permissionSetArn: Swift.String? = nil,
            principalId: Swift.String? = nil,
            principalType: SSOAdminClientTypes.PrincipalType? = nil
        )
        {
            self.accountId = accountId
            self.permissionSetArn = permissionSetArn
            self.principalId = principalId
            self.principalType = principalType
        }
    }

}

extension SSOAdminClientTypes.AccountAssignmentOperationStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case failureReason = "FailureReason"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
        case requestId = "RequestId"
        case status = "Status"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let targetId = self.targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = self.targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.StatusValues.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension SSOAdminClientTypes {
    /// The status of the creation or deletion operation of an assignment that a principal needs to access an account.
    public struct AccountAssignmentOperationStatus: Swift.Equatable {
        /// The date that the permission set was created.
        public var createdDate: ClientRuntime.Date?
        /// The message that contains an error or exception in case of an operation failure.
        public var failureReason: Swift.String?
        /// The ARN of the permission set. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var permissionSetArn: Swift.String?
        /// An identifier for an object in IAM Identity Center, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in IAM Identity Center, see the [IAM Identity Center Identity Store API Reference].
        public var principalId: Swift.String?
        /// The entity type for which the assignment will be created.
        public var principalType: SSOAdminClientTypes.PrincipalType?
        /// The identifier for tracking the request operation that is generated by the universally unique identifier (UUID) workflow.
        public var requestId: Swift.String?
        /// The status of the permission set provisioning process.
        public var status: SSOAdminClientTypes.StatusValues?
        /// TargetID is an Amazon Web Services account identifier, (For example, 123456789012).
        public var targetId: Swift.String?
        /// The entity type for which the assignment will be created.
        public var targetType: SSOAdminClientTypes.TargetType?

        public init(
            createdDate: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            permissionSetArn: Swift.String? = nil,
            principalId: Swift.String? = nil,
            principalType: SSOAdminClientTypes.PrincipalType? = nil,
            requestId: Swift.String? = nil,
            status: SSOAdminClientTypes.StatusValues? = nil,
            targetId: Swift.String? = nil,
            targetType: SSOAdminClientTypes.TargetType? = nil
        )
        {
            self.createdDate = createdDate
            self.failureReason = failureReason
            self.permissionSetArn = permissionSetArn
            self.principalId = principalId
            self.principalType = principalType
            self.requestId = requestId
            self.status = status
            self.targetId = targetId
            self.targetType = targetType
        }
    }

}

extension SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case requestId = "RequestId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.StatusValues.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension SSOAdminClientTypes {
    /// Provides information about the [AccountAssignment] creation request.
    public struct AccountAssignmentOperationStatusMetadata: Swift.Equatable {
        /// The date that the permission set was created.
        public var createdDate: ClientRuntime.Date?
        /// The identifier for tracking the request operation that is generated by the universally unique identifier (UUID) workflow.
        public var requestId: Swift.String?
        /// The status of the permission set provisioning process.
        public var status: SSOAdminClientTypes.StatusValues?

        public init(
            createdDate: ClientRuntime.Date? = nil,
            requestId: Swift.String? = nil,
            status: SSOAdminClientTypes.StatusValues? = nil
        )
        {
            self.createdDate = createdDate
            self.requestId = requestId
            self.status = status
        }
    }

}

extension AttachCustomerManagedPolicyReferenceToPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerManagedPolicyReference = "CustomerManagedPolicyReference"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerManagedPolicyReference = self.customerManagedPolicyReference {
            try encodeContainer.encode(customerManagedPolicyReference, forKey: .customerManagedPolicyReference)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension AttachCustomerManagedPolicyReferenceToPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AttachCustomerManagedPolicyReferenceToPermissionSetInput: Swift.Equatable {
    /// Specifies the name and path of a customer managed policy. You must have an IAM policy that matches the name and path in each Amazon Web Services account where you want to deploy your permission set.
    /// This member is required.
    public var customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the PermissionSet.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference? = nil,
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.customerManagedPolicyReference = customerManagedPolicyReference
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct AttachCustomerManagedPolicyReferenceToPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference?
}

extension AttachCustomerManagedPolicyReferenceToPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerManagedPolicyReference = "CustomerManagedPolicyReference"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let customerManagedPolicyReferenceDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.CustomerManagedPolicyReference.self, forKey: .customerManagedPolicyReference)
        customerManagedPolicyReference = customerManagedPolicyReferenceDecoded
    }
}

extension AttachCustomerManagedPolicyReferenceToPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AttachCustomerManagedPolicyReferenceToPermissionSetOutput: Swift.Equatable {

    public init() { }
}

enum AttachCustomerManagedPolicyReferenceToPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AttachManagedPolicyToPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case managedPolicyArn = "ManagedPolicyArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let managedPolicyArn = self.managedPolicyArn {
            try encodeContainer.encode(managedPolicyArn, forKey: .managedPolicyArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension AttachManagedPolicyToPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct AttachManagedPolicyToPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The Amazon Web Services managed policy ARN to be attached to a permission set.
    /// This member is required.
    public var managedPolicyArn: Swift.String?
    /// The ARN of the [PermissionSet] that the managed policy should be attached to.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        managedPolicyArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.managedPolicyArn = managedPolicyArn
        self.permissionSetArn = permissionSetArn
    }
}

struct AttachManagedPolicyToPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let managedPolicyArn: Swift.String?
}

extension AttachManagedPolicyToPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case managedPolicyArn = "ManagedPolicyArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let managedPolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedPolicyArn)
        managedPolicyArn = managedPolicyArnDecoded
    }
}

extension AttachManagedPolicyToPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AttachManagedPolicyToPermissionSetOutput: Swift.Equatable {

    public init() { }
}

enum AttachManagedPolicyToPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSOAdminClientTypes.AttachedManagedPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that stores the details of the Amazon Web Services managed policy.
    public struct AttachedManagedPolicy: Swift.Equatable {
        /// The ARN of the Amazon Web Services managed policy. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// The name of the Amazon Web Services managed policy.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAccountAssignmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
        if let targetId = self.targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = self.targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }
}

extension CreateAccountAssignmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateAccountAssignmentInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set that the admin wants to grant the principal access to.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// An identifier for an object in IAM Identity Center, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in IAM Identity Center, see the [IAM Identity Center Identity Store API Reference].
    /// This member is required.
    public var principalId: Swift.String?
    /// The entity type for which the assignment will be created.
    /// This member is required.
    public var principalType: SSOAdminClientTypes.PrincipalType?
    /// TargetID is an Amazon Web Services account identifier, (For example, 123456789012).
    /// This member is required.
    public var targetId: Swift.String?
    /// The entity type for which the assignment will be created.
    /// This member is required.
    public var targetType: SSOAdminClientTypes.TargetType?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: SSOAdminClientTypes.PrincipalType? = nil,
        targetId: Swift.String? = nil,
        targetType: SSOAdminClientTypes.TargetType? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.principalId = principalId
        self.principalType = principalType
        self.targetId = targetId
        self.targetType = targetType
    }
}

struct CreateAccountAssignmentInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let targetId: Swift.String?
    let targetType: SSOAdminClientTypes.TargetType?
    let permissionSetArn: Swift.String?
    let principalType: SSOAdminClientTypes.PrincipalType?
    let principalId: Swift.String?
}

extension CreateAccountAssignmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension CreateAccountAssignmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAccountAssignmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignmentCreationStatus = output.accountAssignmentCreationStatus
        } else {
            self.accountAssignmentCreationStatus = nil
        }
    }
}

public struct CreateAccountAssignmentOutput: Swift.Equatable {
    /// The status object for the account assignment creation operation.
    public var accountAssignmentCreationStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus?

    public init(
        accountAssignmentCreationStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus? = nil
    )
    {
        self.accountAssignmentCreationStatus = accountAssignmentCreationStatus
    }
}

struct CreateAccountAssignmentOutputBody: Swift.Equatable {
    let accountAssignmentCreationStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus?
}

extension CreateAccountAssignmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentCreationStatus = "AccountAssignmentCreationStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentCreationStatusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.AccountAssignmentOperationStatus.self, forKey: .accountAssignmentCreationStatus)
        accountAssignmentCreationStatus = accountAssignmentCreationStatusDecoded
    }
}

enum CreateAccountAssignmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateInstanceAccessControlAttributeConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceAccessControlAttributeConfiguration = "InstanceAccessControlAttributeConfiguration"
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceAccessControlAttributeConfiguration = self.instanceAccessControlAttributeConfiguration {
            try encodeContainer.encode(instanceAccessControlAttributeConfiguration, forKey: .instanceAccessControlAttributeConfiguration)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension CreateInstanceAccessControlAttributeConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateInstanceAccessControlAttributeConfigurationInput: Swift.Equatable {
    /// Specifies the IAM Identity Center identity store attributes to add to your ABAC configuration. When using an external identity provider as an identity source, you can pass attributes through the SAML assertion. Doing so provides an alternative to configuring attributes from the IAM Identity Center identity store. If a SAML assertion passes any of these attributes, IAM Identity Center will replace the attribute value with the value from the IAM Identity Center identity store.
    /// This member is required.
    public var instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration? = nil,
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfiguration
        self.instanceArn = instanceArn
    }
}

struct CreateInstanceAccessControlAttributeConfigurationInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration?
}

extension CreateInstanceAccessControlAttributeConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceAccessControlAttributeConfiguration = "InstanceAccessControlAttributeConfiguration"
        case instanceArn = "InstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let instanceAccessControlAttributeConfigurationDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration.self, forKey: .instanceAccessControlAttributeConfiguration)
        instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfigurationDecoded
    }
}

extension CreateInstanceAccessControlAttributeConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateInstanceAccessControlAttributeConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum CreateInstanceAccessControlAttributeConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case instanceArn = "InstanceArn"
        case name = "Name"
        case relayState = "RelayState"
        case sessionDuration = "SessionDuration"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let relayState = self.relayState {
            try encodeContainer.encode(relayState, forKey: .relayState)
        }
        if let sessionDuration = self.sessionDuration {
            try encodeContainer.encode(sessionDuration, forKey: .sessionDuration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreatePermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePermissionSetInput: Swift.Equatable {
    /// The description of the [PermissionSet].
    public var description: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The name of the [PermissionSet].
    /// This member is required.
    public var name: Swift.String?
    /// Used to redirect users within the application during the federation authentication process.
    public var relayState: Swift.String?
    /// The length of time that the application user sessions are valid in the ISO-8601 standard.
    public var sessionDuration: Swift.String?
    /// The tags to attach to the new [PermissionSet].
    public var tags: [SSOAdminClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        name: Swift.String? = nil,
        relayState: Swift.String? = nil,
        sessionDuration: Swift.String? = nil,
        tags: [SSOAdminClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.instanceArn = instanceArn
        self.name = name
        self.relayState = relayState
        self.sessionDuration = sessionDuration
        self.tags = tags
    }
}

struct CreatePermissionSetInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let instanceArn: Swift.String?
    let sessionDuration: Swift.String?
    let relayState: Swift.String?
    let tags: [SSOAdminClientTypes.Tag]?
}

extension CreatePermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case instanceArn = "InstanceArn"
        case name = "Name"
        case relayState = "RelayState"
        case sessionDuration = "SessionDuration"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let sessionDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionDuration)
        sessionDuration = sessionDurationDecoded
        let relayStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relayState)
        relayState = relayStateDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SSOAdminClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SSOAdminClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePermissionSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.permissionSet = output.permissionSet
        } else {
            self.permissionSet = nil
        }
    }
}

public struct CreatePermissionSetOutput: Swift.Equatable {
    /// Defines the level of access on an Amazon Web Services account.
    public var permissionSet: SSOAdminClientTypes.PermissionSet?

    public init(
        permissionSet: SSOAdminClientTypes.PermissionSet? = nil
    )
    {
        self.permissionSet = permissionSet
    }
}

struct CreatePermissionSetOutputBody: Swift.Equatable {
    let permissionSet: SSOAdminClientTypes.PermissionSet?
}

extension CreatePermissionSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionSet = "PermissionSet"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PermissionSet.self, forKey: .permissionSet)
        permissionSet = permissionSetDecoded
    }
}

enum CreatePermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSOAdminClientTypes.CustomerManagedPolicyReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "Name"
        case path = "Path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension SSOAdminClientTypes {
    /// Specifies the name and path of a customer managed policy. You must have an IAM policy that matches the name and path in each Amazon Web Services account where you want to deploy your permission set.
    public struct CustomerManagedPolicyReference: Swift.Equatable {
        /// The name of the IAM policy that you have configured in each account where you want to deploy your permission set.
        /// This member is required.
        public var name: Swift.String?
        /// The path to the IAM policy that you have configured in each account where you want to deploy your permission set. The default is /. For more information, see [Friendly names and paths](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-friendly-names) in the IAM User Guide.
        public var path: Swift.String?

        public init(
            name: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.name = name
            self.path = path
        }
    }

}

extension DeleteAccountAssignmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let principalType = self.principalType {
            try encodeContainer.encode(principalType.rawValue, forKey: .principalType)
        }
        if let targetId = self.targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = self.targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }
}

extension DeleteAccountAssignmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteAccountAssignmentInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set that will be used to remove access.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// An identifier for an object in IAM Identity Center, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in IAM Identity Center, see the [IAM Identity Center Identity Store API Reference].
    /// This member is required.
    public var principalId: Swift.String?
    /// The entity type for which the assignment will be deleted.
    /// This member is required.
    public var principalType: SSOAdminClientTypes.PrincipalType?
    /// TargetID is an Amazon Web Services account identifier, (For example, 123456789012).
    /// This member is required.
    public var targetId: Swift.String?
    /// The entity type for which the assignment will be deleted.
    /// This member is required.
    public var targetType: SSOAdminClientTypes.TargetType?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: SSOAdminClientTypes.PrincipalType? = nil,
        targetId: Swift.String? = nil,
        targetType: SSOAdminClientTypes.TargetType? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.principalId = principalId
        self.principalType = principalType
        self.targetId = targetId
        self.targetType = targetType
    }
}

struct DeleteAccountAssignmentInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let targetId: Swift.String?
    let targetType: SSOAdminClientTypes.TargetType?
    let permissionSetArn: Swift.String?
    let principalType: SSOAdminClientTypes.PrincipalType?
    let principalId: Swift.String?
}

extension DeleteAccountAssignmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case principalId = "PrincipalId"
        case principalType = "PrincipalType"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.TargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let principalTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PrincipalType.self, forKey: .principalType)
        principalType = principalTypeDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
    }
}

extension DeleteAccountAssignmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteAccountAssignmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignmentDeletionStatus = output.accountAssignmentDeletionStatus
        } else {
            self.accountAssignmentDeletionStatus = nil
        }
    }
}

public struct DeleteAccountAssignmentOutput: Swift.Equatable {
    /// The status object for the account assignment deletion operation.
    public var accountAssignmentDeletionStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus?

    public init(
        accountAssignmentDeletionStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus? = nil
    )
    {
        self.accountAssignmentDeletionStatus = accountAssignmentDeletionStatus
    }
}

struct DeleteAccountAssignmentOutputBody: Swift.Equatable {
    let accountAssignmentDeletionStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus?
}

extension DeleteAccountAssignmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentDeletionStatus = "AccountAssignmentDeletionStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentDeletionStatusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.AccountAssignmentOperationStatus.self, forKey: .accountAssignmentDeletionStatus)
        accountAssignmentDeletionStatus = accountAssignmentDeletionStatusDecoded
    }
}

enum DeleteAccountAssignmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteInlinePolicyFromPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension DeleteInlinePolicyFromPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteInlinePolicyFromPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set that will be used to remove access.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct DeleteInlinePolicyFromPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
}

extension DeleteInlinePolicyFromPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
    }
}

extension DeleteInlinePolicyFromPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteInlinePolicyFromPermissionSetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteInlinePolicyFromPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteInstanceAccessControlAttributeConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension DeleteInstanceAccessControlAttributeConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteInstanceAccessControlAttributeConfigurationInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
    }
}

struct DeleteInstanceAccessControlAttributeConfigurationInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
}

extension DeleteInstanceAccessControlAttributeConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
    }
}

extension DeleteInstanceAccessControlAttributeConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteInstanceAccessControlAttributeConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteInstanceAccessControlAttributeConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension DeletePermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set that should be deleted.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct DeletePermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
}

extension DeletePermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
    }
}

extension DeletePermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePermissionSetOutput: Swift.Equatable {

    public init() { }
}

enum DeletePermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePermissionsBoundaryFromPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension DeletePermissionsBoundaryFromPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePermissionsBoundaryFromPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the PermissionSet.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct DeletePermissionsBoundaryFromPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
}

extension DeletePermissionsBoundaryFromPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
    }
}

extension DeletePermissionsBoundaryFromPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePermissionsBoundaryFromPermissionSetOutput: Swift.Equatable {

    public init() { }
}

enum DeletePermissionsBoundaryFromPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAccountAssignmentCreationStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentCreationRequestId = "AccountAssignmentCreationRequestId"
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAssignmentCreationRequestId = self.accountAssignmentCreationRequestId {
            try encodeContainer.encode(accountAssignmentCreationRequestId, forKey: .accountAssignmentCreationRequestId)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension DescribeAccountAssignmentCreationStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAccountAssignmentCreationStatusInput: Swift.Equatable {
    /// The identifier that is used to track the request operation progress.
    /// This member is required.
    public var accountAssignmentCreationRequestId: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        accountAssignmentCreationRequestId: Swift.String? = nil,
        instanceArn: Swift.String? = nil
    )
    {
        self.accountAssignmentCreationRequestId = accountAssignmentCreationRequestId
        self.instanceArn = instanceArn
    }
}

struct DescribeAccountAssignmentCreationStatusInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let accountAssignmentCreationRequestId: Swift.String?
}

extension DescribeAccountAssignmentCreationStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentCreationRequestId = "AccountAssignmentCreationRequestId"
        case instanceArn = "InstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let accountAssignmentCreationRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountAssignmentCreationRequestId)
        accountAssignmentCreationRequestId = accountAssignmentCreationRequestIdDecoded
    }
}

extension DescribeAccountAssignmentCreationStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAccountAssignmentCreationStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignmentCreationStatus = output.accountAssignmentCreationStatus
        } else {
            self.accountAssignmentCreationStatus = nil
        }
    }
}

public struct DescribeAccountAssignmentCreationStatusOutput: Swift.Equatable {
    /// The status object for the account assignment creation operation.
    public var accountAssignmentCreationStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus?

    public init(
        accountAssignmentCreationStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus? = nil
    )
    {
        self.accountAssignmentCreationStatus = accountAssignmentCreationStatus
    }
}

struct DescribeAccountAssignmentCreationStatusOutputBody: Swift.Equatable {
    let accountAssignmentCreationStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus?
}

extension DescribeAccountAssignmentCreationStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentCreationStatus = "AccountAssignmentCreationStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentCreationStatusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.AccountAssignmentOperationStatus.self, forKey: .accountAssignmentCreationStatus)
        accountAssignmentCreationStatus = accountAssignmentCreationStatusDecoded
    }
}

enum DescribeAccountAssignmentCreationStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAccountAssignmentDeletionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentDeletionRequestId = "AccountAssignmentDeletionRequestId"
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAssignmentDeletionRequestId = self.accountAssignmentDeletionRequestId {
            try encodeContainer.encode(accountAssignmentDeletionRequestId, forKey: .accountAssignmentDeletionRequestId)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension DescribeAccountAssignmentDeletionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAccountAssignmentDeletionStatusInput: Swift.Equatable {
    /// The identifier that is used to track the request operation progress.
    /// This member is required.
    public var accountAssignmentDeletionRequestId: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        accountAssignmentDeletionRequestId: Swift.String? = nil,
        instanceArn: Swift.String? = nil
    )
    {
        self.accountAssignmentDeletionRequestId = accountAssignmentDeletionRequestId
        self.instanceArn = instanceArn
    }
}

struct DescribeAccountAssignmentDeletionStatusInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let accountAssignmentDeletionRequestId: Swift.String?
}

extension DescribeAccountAssignmentDeletionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentDeletionRequestId = "AccountAssignmentDeletionRequestId"
        case instanceArn = "InstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let accountAssignmentDeletionRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountAssignmentDeletionRequestId)
        accountAssignmentDeletionRequestId = accountAssignmentDeletionRequestIdDecoded
    }
}

extension DescribeAccountAssignmentDeletionStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAccountAssignmentDeletionStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignmentDeletionStatus = output.accountAssignmentDeletionStatus
        } else {
            self.accountAssignmentDeletionStatus = nil
        }
    }
}

public struct DescribeAccountAssignmentDeletionStatusOutput: Swift.Equatable {
    /// The status object for the account assignment deletion operation.
    public var accountAssignmentDeletionStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus?

    public init(
        accountAssignmentDeletionStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus? = nil
    )
    {
        self.accountAssignmentDeletionStatus = accountAssignmentDeletionStatus
    }
}

struct DescribeAccountAssignmentDeletionStatusOutputBody: Swift.Equatable {
    let accountAssignmentDeletionStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus?
}

extension DescribeAccountAssignmentDeletionStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentDeletionStatus = "AccountAssignmentDeletionStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentDeletionStatusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.AccountAssignmentOperationStatus.self, forKey: .accountAssignmentDeletionStatus)
        accountAssignmentDeletionStatus = accountAssignmentDeletionStatusDecoded
    }
}

enum DescribeAccountAssignmentDeletionStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeInstanceAccessControlAttributeConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension DescribeInstanceAccessControlAttributeConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeInstanceAccessControlAttributeConfigurationInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
    }
}

struct DescribeInstanceAccessControlAttributeConfigurationInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
}

extension DescribeInstanceAccessControlAttributeConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
    }
}

extension DescribeInstanceAccessControlAttributeConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeInstanceAccessControlAttributeConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.instanceAccessControlAttributeConfiguration = output.instanceAccessControlAttributeConfiguration
            self.status = output.status
            self.statusReason = output.statusReason
        } else {
            self.instanceAccessControlAttributeConfiguration = nil
            self.status = nil
            self.statusReason = nil
        }
    }
}

public struct DescribeInstanceAccessControlAttributeConfigurationOutput: Swift.Equatable {
    /// Gets the list of IAM Identity Center identity store attributes that have been added to your ABAC configuration.
    public var instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration?
    /// The status of the attribute configuration process.
    public var status: SSOAdminClientTypes.InstanceAccessControlAttributeConfigurationStatus?
    /// Provides more details about the current status of the specified attribute.
    public var statusReason: Swift.String?

    public init(
        instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration? = nil,
        status: SSOAdminClientTypes.InstanceAccessControlAttributeConfigurationStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfiguration
        self.status = status
        self.statusReason = statusReason
    }
}

struct DescribeInstanceAccessControlAttributeConfigurationOutputBody: Swift.Equatable {
    let status: SSOAdminClientTypes.InstanceAccessControlAttributeConfigurationStatus?
    let statusReason: Swift.String?
    let instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration?
}

extension DescribeInstanceAccessControlAttributeConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceAccessControlAttributeConfiguration = "InstanceAccessControlAttributeConfiguration"
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.InstanceAccessControlAttributeConfigurationStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
        let instanceAccessControlAttributeConfigurationDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration.self, forKey: .instanceAccessControlAttributeConfiguration)
        instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfigurationDecoded
    }
}

enum DescribeInstanceAccessControlAttributeConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension DescribePermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct DescribePermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
}

extension DescribePermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
    }
}

extension DescribePermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePermissionSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.permissionSet = output.permissionSet
        } else {
            self.permissionSet = nil
        }
    }
}

public struct DescribePermissionSetOutput: Swift.Equatable {
    /// Describes the level of access on an Amazon Web Services account.
    public var permissionSet: SSOAdminClientTypes.PermissionSet?

    public init(
        permissionSet: SSOAdminClientTypes.PermissionSet? = nil
    )
    {
        self.permissionSet = permissionSet
    }
}

struct DescribePermissionSetOutputBody: Swift.Equatable {
    let permissionSet: SSOAdminClientTypes.PermissionSet?
}

extension DescribePermissionSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionSet = "PermissionSet"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PermissionSet.self, forKey: .permissionSet)
        permissionSet = permissionSetDecoded
    }
}

enum DescribePermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePermissionSetProvisioningStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case provisionPermissionSetRequestId = "ProvisionPermissionSetRequestId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let provisionPermissionSetRequestId = self.provisionPermissionSetRequestId {
            try encodeContainer.encode(provisionPermissionSetRequestId, forKey: .provisionPermissionSetRequestId)
        }
    }
}

extension DescribePermissionSetProvisioningStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePermissionSetProvisioningStatusInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The identifier that is provided by the [ProvisionPermissionSet] call to retrieve the current status of the provisioning workflow.
    /// This member is required.
    public var provisionPermissionSetRequestId: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        provisionPermissionSetRequestId: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.provisionPermissionSetRequestId = provisionPermissionSetRequestId
    }
}

struct DescribePermissionSetProvisioningStatusInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let provisionPermissionSetRequestId: Swift.String?
}

extension DescribePermissionSetProvisioningStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case provisionPermissionSetRequestId = "ProvisionPermissionSetRequestId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let provisionPermissionSetRequestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .provisionPermissionSetRequestId)
        provisionPermissionSetRequestId = provisionPermissionSetRequestIdDecoded
    }
}

extension DescribePermissionSetProvisioningStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePermissionSetProvisioningStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.permissionSetProvisioningStatus = output.permissionSetProvisioningStatus
        } else {
            self.permissionSetProvisioningStatus = nil
        }
    }
}

public struct DescribePermissionSetProvisioningStatusOutput: Swift.Equatable {
    /// The status object for the permission set provisioning operation.
    public var permissionSetProvisioningStatus: SSOAdminClientTypes.PermissionSetProvisioningStatus?

    public init(
        permissionSetProvisioningStatus: SSOAdminClientTypes.PermissionSetProvisioningStatus? = nil
    )
    {
        self.permissionSetProvisioningStatus = permissionSetProvisioningStatus
    }
}

struct DescribePermissionSetProvisioningStatusOutputBody: Swift.Equatable {
    let permissionSetProvisioningStatus: SSOAdminClientTypes.PermissionSetProvisioningStatus?
}

extension DescribePermissionSetProvisioningStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionSetProvisioningStatus = "PermissionSetProvisioningStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetProvisioningStatusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PermissionSetProvisioningStatus.self, forKey: .permissionSetProvisioningStatus)
        permissionSetProvisioningStatus = permissionSetProvisioningStatusDecoded
    }
}

enum DescribePermissionSetProvisioningStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DetachCustomerManagedPolicyReferenceFromPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerManagedPolicyReference = "CustomerManagedPolicyReference"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerManagedPolicyReference = self.customerManagedPolicyReference {
            try encodeContainer.encode(customerManagedPolicyReference, forKey: .customerManagedPolicyReference)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension DetachCustomerManagedPolicyReferenceFromPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DetachCustomerManagedPolicyReferenceFromPermissionSetInput: Swift.Equatable {
    /// Specifies the name and path of a customer managed policy. You must have an IAM policy that matches the name and path in each Amazon Web Services account where you want to deploy your permission set.
    /// This member is required.
    public var customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the PermissionSet.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference? = nil,
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.customerManagedPolicyReference = customerManagedPolicyReference
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct DetachCustomerManagedPolicyReferenceFromPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference?
}

extension DetachCustomerManagedPolicyReferenceFromPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerManagedPolicyReference = "CustomerManagedPolicyReference"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let customerManagedPolicyReferenceDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.CustomerManagedPolicyReference.self, forKey: .customerManagedPolicyReference)
        customerManagedPolicyReference = customerManagedPolicyReferenceDecoded
    }
}

extension DetachCustomerManagedPolicyReferenceFromPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DetachCustomerManagedPolicyReferenceFromPermissionSetOutput: Swift.Equatable {

    public init() { }
}

enum DetachCustomerManagedPolicyReferenceFromPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DetachManagedPolicyFromPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case managedPolicyArn = "ManagedPolicyArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let managedPolicyArn = self.managedPolicyArn {
            try encodeContainer.encode(managedPolicyArn, forKey: .managedPolicyArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension DetachManagedPolicyFromPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DetachManagedPolicyFromPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The Amazon Web Services managed policy ARN to be detached from a permission set.
    /// This member is required.
    public var managedPolicyArn: Swift.String?
    /// The ARN of the [PermissionSet] from which the policy should be detached.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        managedPolicyArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.managedPolicyArn = managedPolicyArn
        self.permissionSetArn = permissionSetArn
    }
}

struct DetachManagedPolicyFromPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let managedPolicyArn: Swift.String?
}

extension DetachManagedPolicyFromPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case managedPolicyArn = "ManagedPolicyArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let managedPolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedPolicyArn)
        managedPolicyArn = managedPolicyArnDecoded
    }
}

extension DetachManagedPolicyFromPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DetachManagedPolicyFromPermissionSetOutput: Swift.Equatable {

    public init() { }
}

enum DetachManagedPolicyFromPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetInlinePolicyForPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension GetInlinePolicyForPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetInlinePolicyForPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct GetInlinePolicyForPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
}

extension GetInlinePolicyForPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
    }
}

extension GetInlinePolicyForPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetInlinePolicyForPermissionSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.inlinePolicy = output.inlinePolicy
        } else {
            self.inlinePolicy = nil
        }
    }
}

public struct GetInlinePolicyForPermissionSetOutput: Swift.Equatable {
    /// The inline policy that is attached to the permission set. For Length Constraints, if a valid ARN is provided for a permission set, it is possible for an empty inline policy to be returned.
    public var inlinePolicy: Swift.String?

    public init(
        inlinePolicy: Swift.String? = nil
    )
    {
        self.inlinePolicy = inlinePolicy
    }
}

struct GetInlinePolicyForPermissionSetOutputBody: Swift.Equatable {
    let inlinePolicy: Swift.String?
}

extension GetInlinePolicyForPermissionSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inlinePolicy = "InlinePolicy"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inlinePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inlinePolicy)
        inlinePolicy = inlinePolicyDecoded
    }
}

enum GetInlinePolicyForPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPermissionsBoundaryForPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension GetPermissionsBoundaryForPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetPermissionsBoundaryForPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the PermissionSet.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct GetPermissionsBoundaryForPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
}

extension GetPermissionsBoundaryForPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
    }
}

extension GetPermissionsBoundaryForPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPermissionsBoundaryForPermissionSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.permissionsBoundary = output.permissionsBoundary
        } else {
            self.permissionsBoundary = nil
        }
    }
}

public struct GetPermissionsBoundaryForPermissionSetOutput: Swift.Equatable {
    /// The permissions boundary attached to the specified permission set.
    public var permissionsBoundary: SSOAdminClientTypes.PermissionsBoundary?

    public init(
        permissionsBoundary: SSOAdminClientTypes.PermissionsBoundary? = nil
    )
    {
        self.permissionsBoundary = permissionsBoundary
    }
}

struct GetPermissionsBoundaryForPermissionSetOutputBody: Swift.Equatable {
    let permissionsBoundary: SSOAdminClientTypes.PermissionsBoundary?
}

extension GetPermissionsBoundaryForPermissionSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionsBoundary = "PermissionsBoundary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PermissionsBoundary.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
    }
}

enum GetPermissionsBoundaryForPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlAttributes = "AccessControlAttributes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessControlAttributes = accessControlAttributes {
            var accessControlAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accessControlAttributes)
            for accesscontrolattribute0 in accessControlAttributes {
                try accessControlAttributesContainer.encode(accesscontrolattribute0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlAttributesContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.AccessControlAttribute?].self, forKey: .accessControlAttributes)
        var accessControlAttributesDecoded0:[SSOAdminClientTypes.AccessControlAttribute]? = nil
        if let accessControlAttributesContainer = accessControlAttributesContainer {
            accessControlAttributesDecoded0 = [SSOAdminClientTypes.AccessControlAttribute]()
            for structure0 in accessControlAttributesContainer {
                if let structure0 = structure0 {
                    accessControlAttributesDecoded0?.append(structure0)
                }
            }
        }
        accessControlAttributes = accessControlAttributesDecoded0
    }
}

extension SSOAdminClientTypes {
    /// Specifies the attributes to add to your attribute-based access control (ABAC) configuration.
    public struct InstanceAccessControlAttributeConfiguration: Swift.Equatable {
        /// Lists the attributes that are configured for ABAC in the specified IAM Identity Center instance.
        /// This member is required.
        public var accessControlAttributes: [SSOAdminClientTypes.AccessControlAttribute]?

        public init(
            accessControlAttributes: [SSOAdminClientTypes.AccessControlAttribute]? = nil
        )
        {
            self.accessControlAttributes = accessControlAttributes
        }
    }

}

extension SSOAdminClientTypes {
    public enum InstanceAccessControlAttributeConfigurationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creationFailed
        case creationInProgress
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceAccessControlAttributeConfigurationStatus] {
            return [
                .creationFailed,
                .creationInProgress,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creationFailed: return "CREATION_FAILED"
            case .creationInProgress: return "CREATION_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InstanceAccessControlAttributeConfigurationStatus(rawValue: rawValue) ?? InstanceAccessControlAttributeConfigurationStatus.sdkUnknown(rawValue)
        }
    }
}

extension SSOAdminClientTypes.InstanceMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case identityStoreId = "IdentityStoreId"
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let identityStoreId = self.identityStoreId {
            try encodeContainer.encode(identityStoreId, forKey: .identityStoreId)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let identityStoreIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .identityStoreId)
        identityStoreId = identityStoreIdDecoded
    }
}

extension SSOAdminClientTypes {
    /// Provides information about the IAM Identity Center instance.
    public struct InstanceMetadata: Swift.Equatable {
        /// The identifier of the identity store that is connected to the IAM Identity Center instance.
        public var identityStoreId: Swift.String?
        /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var instanceArn: Swift.String?

        public init(
            identityStoreId: Swift.String? = nil,
            instanceArn: Swift.String? = nil
        )
        {
            self.identityStoreId = identityStoreId
            self.instanceArn = instanceArn
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request processing has failed because of an unknown error, exception, or failure with an internal server.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAccountAssignmentCreationStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAccountAssignmentCreationStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAccountAssignmentCreationStatusInput: Swift.Equatable {
    /// Filters results based on the passed attribute value.
    public var filter: SSOAdminClientTypes.OperationStatusFilter?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        filter: SSOAdminClientTypes.OperationStatusFilter? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentCreationStatusInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filter: SSOAdminClientTypes.OperationStatusFilter?
}

extension ListAccountAssignmentCreationStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filterDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.OperationStatusFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListAccountAssignmentCreationStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccountAssignmentCreationStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignmentsCreationStatus = output.accountAssignmentsCreationStatus
            self.nextToken = output.nextToken
        } else {
            self.accountAssignmentsCreationStatus = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountAssignmentCreationStatusOutput: Swift.Equatable {
    /// The status object for the account assignment creation operation.
    public var accountAssignmentsCreationStatus: [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        accountAssignmentsCreationStatus: [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountAssignmentsCreationStatus = accountAssignmentsCreationStatus
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentCreationStatusOutputBody: Swift.Equatable {
    let accountAssignmentsCreationStatus: [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]?
    let nextToken: Swift.String?
}

extension ListAccountAssignmentCreationStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentsCreationStatus = "AccountAssignmentsCreationStatus"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentsCreationStatusContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata?].self, forKey: .accountAssignmentsCreationStatus)
        var accountAssignmentsCreationStatusDecoded0:[SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]? = nil
        if let accountAssignmentsCreationStatusContainer = accountAssignmentsCreationStatusContainer {
            accountAssignmentsCreationStatusDecoded0 = [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]()
            for structure0 in accountAssignmentsCreationStatusContainer {
                if let structure0 = structure0 {
                    accountAssignmentsCreationStatusDecoded0?.append(structure0)
                }
            }
        }
        accountAssignmentsCreationStatus = accountAssignmentsCreationStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccountAssignmentCreationStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAccountAssignmentDeletionStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListAccountAssignmentDeletionStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAccountAssignmentDeletionStatusInput: Swift.Equatable {
    /// Filters results based on the passed attribute value.
    public var filter: SSOAdminClientTypes.OperationStatusFilter?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        filter: SSOAdminClientTypes.OperationStatusFilter? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentDeletionStatusInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filter: SSOAdminClientTypes.OperationStatusFilter?
}

extension ListAccountAssignmentDeletionStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filterDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.OperationStatusFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListAccountAssignmentDeletionStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccountAssignmentDeletionStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignmentsDeletionStatus = output.accountAssignmentsDeletionStatus
            self.nextToken = output.nextToken
        } else {
            self.accountAssignmentsDeletionStatus = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountAssignmentDeletionStatusOutput: Swift.Equatable {
    /// The status object for the account assignment deletion operation.
    public var accountAssignmentsDeletionStatus: [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        accountAssignmentsDeletionStatus: [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountAssignmentsDeletionStatus = accountAssignmentsDeletionStatus
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentDeletionStatusOutputBody: Swift.Equatable {
    let accountAssignmentsDeletionStatus: [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]?
    let nextToken: Swift.String?
}

extension ListAccountAssignmentDeletionStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignmentsDeletionStatus = "AccountAssignmentsDeletionStatus"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentsDeletionStatusContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata?].self, forKey: .accountAssignmentsDeletionStatus)
        var accountAssignmentsDeletionStatusDecoded0:[SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]? = nil
        if let accountAssignmentsDeletionStatusContainer = accountAssignmentsDeletionStatusContainer {
            accountAssignmentsDeletionStatusDecoded0 = [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]()
            for structure0 in accountAssignmentsDeletionStatusContainer {
                if let structure0 = structure0 {
                    accountAssignmentsDeletionStatusDecoded0?.append(structure0)
                }
            }
        }
        accountAssignmentsDeletionStatus = accountAssignmentsDeletionStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccountAssignmentDeletionStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAccountAssignmentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension ListAccountAssignmentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAccountAssignmentsInput: Swift.Equatable {
    /// The identifier of the Amazon Web Services account from which to list the assignments.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The ARN of the permission set from which to list assignments.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionSetArn = permissionSetArn
    }
}

struct ListAccountAssignmentsInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let accountId: Swift.String?
    let permissionSetArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAccountAssignmentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccountAssignmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccountAssignmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountAssignments = output.accountAssignments
            self.nextToken = output.nextToken
        } else {
            self.accountAssignments = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountAssignmentsOutput: Swift.Equatable {
    /// The list of assignments that match the input Amazon Web Services account and permission set.
    public var accountAssignments: [SSOAdminClientTypes.AccountAssignment]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        accountAssignments: [SSOAdminClientTypes.AccountAssignment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountAssignments = accountAssignments
        self.nextToken = nextToken
    }
}

struct ListAccountAssignmentsOutputBody: Swift.Equatable {
    let accountAssignments: [SSOAdminClientTypes.AccountAssignment]?
    let nextToken: Swift.String?
}

extension ListAccountAssignmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAssignments = "AccountAssignments"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAssignmentsContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.AccountAssignment?].self, forKey: .accountAssignments)
        var accountAssignmentsDecoded0:[SSOAdminClientTypes.AccountAssignment]? = nil
        if let accountAssignmentsContainer = accountAssignmentsContainer {
            accountAssignmentsDecoded0 = [SSOAdminClientTypes.AccountAssignment]()
            for structure0 in accountAssignmentsContainer {
                if let structure0 = structure0 {
                    accountAssignmentsDecoded0?.append(structure0)
                }
            }
        }
        accountAssignments = accountAssignmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccountAssignmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAccountsForProvisionedPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
        case provisioningStatus = "ProvisioningStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let provisioningStatus = self.provisioningStatus {
            try encodeContainer.encode(provisioningStatus.rawValue, forKey: .provisioningStatus)
        }
    }
}

extension ListAccountsForProvisionedPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListAccountsForProvisionedPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the [PermissionSet].
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The ARN of the [PermissionSet] from which the associated Amazon Web Services accounts will be listed.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// The permission set provisioning status for an Amazon Web Services account.
    public var provisioningStatus: SSOAdminClientTypes.ProvisioningStatus?

    public init(
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        provisioningStatus: SSOAdminClientTypes.ProvisioningStatus? = nil
    )
    {
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionSetArn = permissionSetArn
        self.provisioningStatus = provisioningStatus
    }
}

struct ListAccountsForProvisionedPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let provisioningStatus: SSOAdminClientTypes.ProvisioningStatus?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListAccountsForProvisionedPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
        case provisioningStatus = "ProvisioningStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let provisioningStatusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.ProvisioningStatus.self, forKey: .provisioningStatus)
        provisioningStatus = provisioningStatusDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListAccountsForProvisionedPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccountsForProvisionedPermissionSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountIds = output.accountIds
            self.nextToken = output.nextToken
        } else {
            self.accountIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccountsForProvisionedPermissionSetOutput: Swift.Equatable {
    /// The list of Amazon Web Services AccountIds.
    public var accountIds: [Swift.String]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.nextToken = nextToken
    }
}

struct ListAccountsForProvisionedPermissionSetOutputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListAccountsForProvisionedPermissionSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "AccountIds"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccountsForProvisionedPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCustomerManagedPolicyReferencesInPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension ListCustomerManagedPolicyReferencesInPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListCustomerManagedPolicyReferencesInPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the list call.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The ARN of the PermissionSet.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionSetArn = permissionSetArn
    }
}

struct ListCustomerManagedPolicyReferencesInPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListCustomerManagedPolicyReferencesInPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListCustomerManagedPolicyReferencesInPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCustomerManagedPolicyReferencesInPermissionSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.customerManagedPolicyReferences = output.customerManagedPolicyReferences
            self.nextToken = output.nextToken
        } else {
            self.customerManagedPolicyReferences = nil
            self.nextToken = nil
        }
    }
}

public struct ListCustomerManagedPolicyReferencesInPermissionSetOutput: Swift.Equatable {
    /// Specifies the names and paths of the customer managed policies that you have attached to your permission set.
    public var customerManagedPolicyReferences: [SSOAdminClientTypes.CustomerManagedPolicyReference]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        customerManagedPolicyReferences: [SSOAdminClientTypes.CustomerManagedPolicyReference]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customerManagedPolicyReferences = customerManagedPolicyReferences
        self.nextToken = nextToken
    }
}

struct ListCustomerManagedPolicyReferencesInPermissionSetOutputBody: Swift.Equatable {
    let customerManagedPolicyReferences: [SSOAdminClientTypes.CustomerManagedPolicyReference]?
    let nextToken: Swift.String?
}

extension ListCustomerManagedPolicyReferencesInPermissionSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerManagedPolicyReferences = "CustomerManagedPolicyReferences"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerManagedPolicyReferencesContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.CustomerManagedPolicyReference?].self, forKey: .customerManagedPolicyReferences)
        var customerManagedPolicyReferencesDecoded0:[SSOAdminClientTypes.CustomerManagedPolicyReference]? = nil
        if let customerManagedPolicyReferencesContainer = customerManagedPolicyReferencesContainer {
            customerManagedPolicyReferencesDecoded0 = [SSOAdminClientTypes.CustomerManagedPolicyReference]()
            for structure0 in customerManagedPolicyReferencesContainer {
                if let structure0 = structure0 {
                    customerManagedPolicyReferencesDecoded0?.append(structure0)
                }
            }
        }
        customerManagedPolicyReferences = customerManagedPolicyReferencesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCustomerManagedPolicyReferencesInPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListInstancesInput: Swift.Equatable {
    /// The maximum number of results to display for the instance.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInstancesInputBody: Swift.Equatable {
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.instances = output.instances
            self.nextToken = output.nextToken
        } else {
            self.instances = nil
            self.nextToken = nil
        }
    }
}

public struct ListInstancesOutput: Swift.Equatable {
    /// Lists the IAM Identity Center instances that the caller has access to.
    public var instances: [SSOAdminClientTypes.InstanceMetadata]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        instances: [SSOAdminClientTypes.InstanceMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instances = instances
        self.nextToken = nextToken
    }
}

struct ListInstancesOutputBody: Swift.Equatable {
    let instances: [SSOAdminClientTypes.InstanceMetadata]?
    let nextToken: Swift.String?
}

extension ListInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instances = "Instances"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instancesContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.InstanceMetadata?].self, forKey: .instances)
        var instancesDecoded0:[SSOAdminClientTypes.InstanceMetadata]? = nil
        if let instancesContainer = instancesContainer {
            instancesDecoded0 = [SSOAdminClientTypes.InstanceMetadata]()
            for structure0 in instancesContainer {
                if let structure0 = structure0 {
                    instancesDecoded0?.append(structure0)
                }
            }
        }
        instances = instancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListManagedPoliciesInPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension ListManagedPoliciesInPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListManagedPoliciesInPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the [PermissionSet].
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The ARN of the [PermissionSet] whose managed policies will be listed.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionSetArn = permissionSetArn
    }
}

struct ListManagedPoliciesInPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListManagedPoliciesInPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListManagedPoliciesInPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListManagedPoliciesInPermissionSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.attachedManagedPolicies = output.attachedManagedPolicies
            self.nextToken = output.nextToken
        } else {
            self.attachedManagedPolicies = nil
            self.nextToken = nil
        }
    }
}

public struct ListManagedPoliciesInPermissionSetOutput: Swift.Equatable {
    /// An array of the [AttachedManagedPolicy] data type object.
    public var attachedManagedPolicies: [SSOAdminClientTypes.AttachedManagedPolicy]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        attachedManagedPolicies: [SSOAdminClientTypes.AttachedManagedPolicy]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attachedManagedPolicies = attachedManagedPolicies
        self.nextToken = nextToken
    }
}

struct ListManagedPoliciesInPermissionSetOutputBody: Swift.Equatable {
    let attachedManagedPolicies: [SSOAdminClientTypes.AttachedManagedPolicy]?
    let nextToken: Swift.String?
}

extension ListManagedPoliciesInPermissionSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachedManagedPolicies = "AttachedManagedPolicies"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachedManagedPoliciesContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.AttachedManagedPolicy?].self, forKey: .attachedManagedPolicies)
        var attachedManagedPoliciesDecoded0:[SSOAdminClientTypes.AttachedManagedPolicy]? = nil
        if let attachedManagedPoliciesContainer = attachedManagedPoliciesContainer {
            attachedManagedPoliciesDecoded0 = [SSOAdminClientTypes.AttachedManagedPolicy]()
            for structure0 in attachedManagedPoliciesContainer {
                if let structure0 = structure0 {
                    attachedManagedPoliciesDecoded0?.append(structure0)
                }
            }
        }
        attachedManagedPolicies = attachedManagedPoliciesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListManagedPoliciesInPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPermissionSetProvisioningStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPermissionSetProvisioningStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPermissionSetProvisioningStatusInput: Swift.Equatable {
    /// Filters results based on the passed attribute value.
    public var filter: SSOAdminClientTypes.OperationStatusFilter?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        filter: SSOAdminClientTypes.OperationStatusFilter? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPermissionSetProvisioningStatusInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let filter: SSOAdminClientTypes.OperationStatusFilter?
}

extension ListPermissionSetProvisioningStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter = "Filter"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let filterDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.OperationStatusFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListPermissionSetProvisioningStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPermissionSetProvisioningStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissionSetsProvisioningStatus = output.permissionSetsProvisioningStatus
        } else {
            self.nextToken = nil
            self.permissionSetsProvisioningStatus = nil
        }
    }
}

public struct ListPermissionSetProvisioningStatusOutput: Swift.Equatable {
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The status object for the permission set provisioning operation.
    public var permissionSetsProvisioningStatus: [SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        permissionSetsProvisioningStatus: [SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissionSetsProvisioningStatus = permissionSetsProvisioningStatus
    }
}

struct ListPermissionSetProvisioningStatusOutputBody: Swift.Equatable {
    let permissionSetsProvisioningStatus: [SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata]?
    let nextToken: Swift.String?
}

extension ListPermissionSetProvisioningStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case permissionSetsProvisioningStatus = "PermissionSetsProvisioningStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetsProvisioningStatusContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata?].self, forKey: .permissionSetsProvisioningStatus)
        var permissionSetsProvisioningStatusDecoded0:[SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata]? = nil
        if let permissionSetsProvisioningStatusContainer = permissionSetsProvisioningStatusContainer {
            permissionSetsProvisioningStatusDecoded0 = [SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata]()
            for structure0 in permissionSetsProvisioningStatusContainer {
                if let structure0 = structure0 {
                    permissionSetsProvisioningStatusDecoded0?.append(structure0)
                }
            }
        }
        permissionSetsProvisioningStatus = permissionSetsProvisioningStatusDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPermissionSetProvisioningStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPermissionSetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListPermissionSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPermissionSetsInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPermissionSetsInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListPermissionSetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListPermissionSetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPermissionSetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissionSets = output.permissionSets
        } else {
            self.nextToken = nil
            self.permissionSets = nil
        }
    }
}

public struct ListPermissionSetsOutput: Swift.Equatable {
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// Defines the level of access on an Amazon Web Services account.
    public var permissionSets: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        permissionSets: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissionSets = permissionSets
    }
}

struct ListPermissionSetsOutputBody: Swift.Equatable {
    let permissionSets: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListPermissionSetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case permissionSets = "PermissionSets"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .permissionSets)
        var permissionSetsDecoded0:[Swift.String]? = nil
        if let permissionSetsContainer = permissionSetsContainer {
            permissionSetsDecoded0 = [Swift.String]()
            for string0 in permissionSetsContainer {
                if let string0 = string0 {
                    permissionSetsDecoded0?.append(string0)
                }
            }
        }
        permissionSets = permissionSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPermissionSetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPermissionSetsProvisionedToAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case provisioningStatus = "ProvisioningStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let provisioningStatus = self.provisioningStatus {
            try encodeContainer.encode(provisioningStatus.rawValue, forKey: .provisioningStatus)
        }
    }
}

extension ListPermissionSetsProvisionedToAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListPermissionSetsProvisionedToAccountInput: Swift.Equatable {
    /// The identifier of the Amazon Web Services account from which to list the assignments.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The status object for the permission set provisioning operation.
    public var provisioningStatus: SSOAdminClientTypes.ProvisioningStatus?

    public init(
        accountId: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        provisioningStatus: SSOAdminClientTypes.ProvisioningStatus? = nil
    )
    {
        self.accountId = accountId
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.provisioningStatus = provisioningStatus
    }
}

struct ListPermissionSetsProvisionedToAccountInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let accountId: Swift.String?
    let provisioningStatus: SSOAdminClientTypes.ProvisioningStatus?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListPermissionSetsProvisionedToAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case instanceArn = "InstanceArn"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case provisioningStatus = "ProvisioningStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let provisioningStatusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.ProvisioningStatus.self, forKey: .provisioningStatus)
        provisioningStatus = provisioningStatusDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPermissionSetsProvisionedToAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPermissionSetsProvisionedToAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissionSets = output.permissionSets
        } else {
            self.nextToken = nil
            self.permissionSets = nil
        }
    }
}

public struct ListPermissionSetsProvisionedToAccountOutput: Swift.Equatable {
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// Defines the level of access that an Amazon Web Services account has.
    public var permissionSets: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        permissionSets: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissionSets = permissionSets
    }
}

struct ListPermissionSetsProvisionedToAccountOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let permissionSets: [Swift.String]?
}

extension ListPermissionSetsProvisionedToAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case permissionSets = "PermissionSets"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let permissionSetsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .permissionSets)
        var permissionSetsDecoded0:[Swift.String]? = nil
        if let permissionSetsContainer = permissionSetsContainer {
            permissionSetsDecoded0 = [Swift.String]()
            for string0 in permissionSetsContainer {
                if let string0 = string0 {
                    permissionSetsDecoded0?.append(string0)
                }
            }
        }
        permissionSets = permissionSetsDecoded0
    }
}

enum ListPermissionSetsProvisionedToAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The ARN of the resource with the tags to be listed.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let resourceArn: Swift.String?
    let nextToken: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case nextToken = "NextToken"
        case resourceArn = "ResourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tags = output.tags
        } else {
            self.nextToken = nil
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// A set of key-value pairs that are used to manage the resource.
    public var tags: [SSOAdminClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [SSOAdminClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [SSOAdminClientTypes.Tag]?
    let nextToken: Swift.String?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SSOAdminClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SSOAdminClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSOAdminClientTypes.OperationStatusFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.StatusValues.self, forKey: .status)
        status = statusDecoded
    }
}

extension SSOAdminClientTypes {
    /// Filters he operation status list based on the passed attribute value.
    public struct OperationStatusFilter: Swift.Equatable {
        /// Filters the list operations result based on the status attribute.
        public var status: SSOAdminClientTypes.StatusValues?

        public init(
            status: SSOAdminClientTypes.StatusValues? = nil
        )
        {
            self.status = status
        }
    }

}

extension SSOAdminClientTypes.PermissionSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case description = "Description"
        case name = "Name"
        case permissionSetArn = "PermissionSetArn"
        case relayState = "RelayState"
        case sessionDuration = "SessionDuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let relayState = self.relayState {
            try encodeContainer.encode(relayState, forKey: .relayState)
        }
        if let sessionDuration = self.sessionDuration {
            try encodeContainer.encode(sessionDuration, forKey: .sessionDuration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
        let sessionDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionDuration)
        sessionDuration = sessionDurationDecoded
        let relayStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relayState)
        relayState = relayStateDecoded
    }
}

extension SSOAdminClientTypes {
    /// An entity that contains IAM policies.
    public struct PermissionSet: Swift.Equatable {
        /// The date that the permission set was created.
        public var createdDate: ClientRuntime.Date?
        /// The description of the [PermissionSet].
        public var description: Swift.String?
        /// The name of the permission set.
        public var name: Swift.String?
        /// The ARN of the permission set. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var permissionSetArn: Swift.String?
        /// Used to redirect users within the application during the federation authentication process.
        public var relayState: Swift.String?
        /// The length of time that the application user sessions are valid for in the ISO-8601 standard.
        public var sessionDuration: Swift.String?

        public init(
            createdDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            permissionSetArn: Swift.String? = nil,
            relayState: Swift.String? = nil,
            sessionDuration: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.name = name
            self.permissionSetArn = permissionSetArn
            self.relayState = relayState
            self.sessionDuration = sessionDuration
        }
    }

}

extension SSOAdminClientTypes.PermissionSetProvisioningStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case createdDate = "CreatedDate"
        case failureReason = "FailureReason"
        case permissionSetArn = "PermissionSetArn"
        case requestId = "RequestId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.StatusValues.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension SSOAdminClientTypes {
    /// A structure that is used to provide the status of the provisioning operation for a specified permission set.
    public struct PermissionSetProvisioningStatus: Swift.Equatable {
        /// The identifier of the Amazon Web Services account from which to list the assignments.
        public var accountId: Swift.String?
        /// The date that the permission set was created.
        public var createdDate: ClientRuntime.Date?
        /// The message that contains an error or exception in case of an operation failure.
        public var failureReason: Swift.String?
        /// The ARN of the permission set that is being provisioned. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var permissionSetArn: Swift.String?
        /// The identifier for tracking the request operation that is generated by the universally unique identifier (UUID) workflow.
        public var requestId: Swift.String?
        /// The status of the permission set provisioning process.
        public var status: SSOAdminClientTypes.StatusValues?

        public init(
            accountId: Swift.String? = nil,
            createdDate: ClientRuntime.Date? = nil,
            failureReason: Swift.String? = nil,
            permissionSetArn: Swift.String? = nil,
            requestId: Swift.String? = nil,
            status: SSOAdminClientTypes.StatusValues? = nil
        )
        {
            self.accountId = accountId
            self.createdDate = createdDate
            self.failureReason = failureReason
            self.permissionSetArn = permissionSetArn
            self.requestId = requestId
            self.status = status
        }
    }

}

extension SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdDate = "CreatedDate"
        case requestId = "RequestId"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdDate = self.createdDate {
            try encodeContainer.encodeTimestamp(createdDate, format: .epochSeconds, forKey: .createdDate)
        }
        if let requestId = self.requestId {
            try encodeContainer.encode(requestId, forKey: .requestId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.StatusValues.self, forKey: .status)
        status = statusDecoded
        let requestIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestId)
        requestId = requestIdDecoded
        let createdDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdDate)
        createdDate = createdDateDecoded
    }
}

extension SSOAdminClientTypes {
    /// Provides information about the permission set provisioning status.
    public struct PermissionSetProvisioningStatusMetadata: Swift.Equatable {
        /// The date that the permission set was created.
        public var createdDate: ClientRuntime.Date?
        /// The identifier for tracking the request operation that is generated by the universally unique identifier (UUID) workflow.
        public var requestId: Swift.String?
        /// The status of the permission set provisioning process.
        public var status: SSOAdminClientTypes.StatusValues?

        public init(
            createdDate: ClientRuntime.Date? = nil,
            requestId: Swift.String? = nil,
            status: SSOAdminClientTypes.StatusValues? = nil
        )
        {
            self.createdDate = createdDate
            self.requestId = requestId
            self.status = status
        }
    }

}

extension SSOAdminClientTypes.PermissionsBoundary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerManagedPolicyReference = "CustomerManagedPolicyReference"
        case managedPolicyArn = "ManagedPolicyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerManagedPolicyReference = self.customerManagedPolicyReference {
            try encodeContainer.encode(customerManagedPolicyReference, forKey: .customerManagedPolicyReference)
        }
        if let managedPolicyArn = self.managedPolicyArn {
            try encodeContainer.encode(managedPolicyArn, forKey: .managedPolicyArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerManagedPolicyReferenceDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.CustomerManagedPolicyReference.self, forKey: .customerManagedPolicyReference)
        customerManagedPolicyReference = customerManagedPolicyReferenceDecoded
        let managedPolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .managedPolicyArn)
        managedPolicyArn = managedPolicyArnDecoded
    }
}

extension SSOAdminClientTypes {
    /// Specifies the configuration of the Amazon Web Services managed or customer managed policy that you want to set as a permissions boundary. Specify either CustomerManagedPolicyReference to use the name and path of a customer managed policy, or ManagedPolicyArn to use the ARN of an Amazon Web Services managed policy. A permissions boundary represents the maximum permissions that any policy can grant your role. For more information, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. Policies used as permissions boundaries don't provide permissions. You must also attach an IAM policy to the role. To learn how the effective permissions for a role are evaluated, see [IAM JSON policy evaluation logic](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_evaluation-logic.html) in the IAM User Guide.
    public struct PermissionsBoundary: Swift.Equatable {
        /// Specifies the name and path of a customer managed policy. You must have an IAM policy that matches the name and path in each Amazon Web Services account where you want to deploy your permission set.
        public var customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference?
        /// The Amazon Web Services managed policy ARN that you want to attach to a permission set as a permissions boundary.
        public var managedPolicyArn: Swift.String?

        public init(
            customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference? = nil,
            managedPolicyArn: Swift.String? = nil
        )
        {
            self.customerManagedPolicyReference = customerManagedPolicyReference
            self.managedPolicyArn = managedPolicyArn
        }
    }

}

extension SSOAdminClientTypes {
    public enum PrincipalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case group
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [PrincipalType] {
            return [
                .group,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrincipalType(rawValue: rawValue) ?? PrincipalType.sdkUnknown(rawValue)
        }
    }
}

extension ProvisionPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let targetId = self.targetId {
            try encodeContainer.encode(targetId, forKey: .targetId)
        }
        if let targetType = self.targetType {
            try encodeContainer.encode(targetType.rawValue, forKey: .targetType)
        }
    }
}

extension ProvisionPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ProvisionPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// TargetID is an Amazon Web Services account identifier, (For example, 123456789012).
    public var targetId: Swift.String?
    /// The entity type for which the assignment will be created.
    /// This member is required.
    public var targetType: SSOAdminClientTypes.ProvisionTargetType?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        targetId: Swift.String? = nil,
        targetType: SSOAdminClientTypes.ProvisionTargetType? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.targetId = targetId
        self.targetType = targetType
    }
}

struct ProvisionPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let targetId: Swift.String?
    let targetType: SSOAdminClientTypes.ProvisionTargetType?
}

extension ProvisionPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case targetId = "TargetId"
        case targetType = "TargetType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let targetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetId)
        targetId = targetIdDecoded
        let targetTypeDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.ProvisionTargetType.self, forKey: .targetType)
        targetType = targetTypeDecoded
    }
}

extension ProvisionPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ProvisionPermissionSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.permissionSetProvisioningStatus = output.permissionSetProvisioningStatus
        } else {
            self.permissionSetProvisioningStatus = nil
        }
    }
}

public struct ProvisionPermissionSetOutput: Swift.Equatable {
    /// The status object for the permission set provisioning operation.
    public var permissionSetProvisioningStatus: SSOAdminClientTypes.PermissionSetProvisioningStatus?

    public init(
        permissionSetProvisioningStatus: SSOAdminClientTypes.PermissionSetProvisioningStatus? = nil
    )
    {
        self.permissionSetProvisioningStatus = permissionSetProvisioningStatus
    }
}

struct ProvisionPermissionSetOutputBody: Swift.Equatable {
    let permissionSetProvisioningStatus: SSOAdminClientTypes.PermissionSetProvisioningStatus?
}

extension ProvisionPermissionSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionSetProvisioningStatus = "PermissionSetProvisioningStatus"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionSetProvisioningStatusDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PermissionSetProvisioningStatus.self, forKey: .permissionSetProvisioningStatus)
        permissionSetProvisioningStatus = permissionSetProvisioningStatusDecoded
    }
}

enum ProvisionPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSOAdminClientTypes {
    public enum ProvisionTargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allProvisionedAccounts
        case awsAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionTargetType] {
            return [
                .allProvisionedAccounts,
                .awsAccount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allProvisionedAccounts: return "ALL_PROVISIONED_ACCOUNTS"
            case .awsAccount: return "AWS_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisionTargetType(rawValue: rawValue) ?? ProvisionTargetType.sdkUnknown(rawValue)
        }
    }
}

extension SSOAdminClientTypes {
    public enum ProvisioningStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case latestPermissionSetNotProvisioned
        case latestPermissionSetProvisioned
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisioningStatus] {
            return [
                .latestPermissionSetNotProvisioned,
                .latestPermissionSetProvisioned,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .latestPermissionSetNotProvisioned: return "LATEST_PERMISSION_SET_NOT_PROVISIONED"
            case .latestPermissionSetProvisioned: return "LATEST_PERMISSION_SET_PROVISIONED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProvisioningStatus(rawValue: rawValue) ?? ProvisioningStatus.sdkUnknown(rawValue)
        }
    }
}

extension PutInlinePolicyToPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inlinePolicy = "InlinePolicy"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let inlinePolicy = self.inlinePolicy {
            try encodeContainer.encode(inlinePolicy, forKey: .inlinePolicy)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
    }
}

extension PutInlinePolicyToPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutInlinePolicyToPermissionSetInput: Swift.Equatable {
    /// The inline policy to attach to a [PermissionSet].
    /// This member is required.
    public var inlinePolicy: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        inlinePolicy: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.inlinePolicy = inlinePolicy
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

struct PutInlinePolicyToPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let inlinePolicy: Swift.String?
}

extension PutInlinePolicyToPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case inlinePolicy = "InlinePolicy"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let inlinePolicyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inlinePolicy)
        inlinePolicy = inlinePolicyDecoded
    }
}

extension PutInlinePolicyToPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutInlinePolicyToPermissionSetOutput: Swift.Equatable {

    public init() { }
}

enum PutInlinePolicyToPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutPermissionsBoundaryToPermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case permissionsBoundary = "PermissionsBoundary"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let permissionsBoundary = self.permissionsBoundary {
            try encodeContainer.encode(permissionsBoundary, forKey: .permissionsBoundary)
        }
    }
}

extension PutPermissionsBoundaryToPermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutPermissionsBoundaryToPermissionSetInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the PermissionSet.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// The permissions boundary that you want to attach to a PermissionSet.
    /// This member is required.
    public var permissionsBoundary: SSOAdminClientTypes.PermissionsBoundary?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        permissionsBoundary: SSOAdminClientTypes.PermissionsBoundary? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.permissionsBoundary = permissionsBoundary
    }
}

struct PutPermissionsBoundaryToPermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let permissionsBoundary: SSOAdminClientTypes.PermissionsBoundary?
}

extension PutPermissionsBoundaryToPermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case permissionsBoundary = "PermissionsBoundary"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let permissionsBoundaryDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.PermissionsBoundary.self, forKey: .permissionsBoundary)
        permissionsBoundary = permissionsBoundaryDecoded
    }
}

extension PutPermissionsBoundaryToPermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutPermissionsBoundaryToPermissionSetOutput: Swift.Equatable {

    public init() { }
}

enum PutPermissionsBoundaryToPermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that a requested resource is not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the principal has crossed the permitted number of resources that can be created.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SSOAdminClientTypes {
    public enum StatusValues: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusValues] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StatusValues(rawValue: rawValue) ?? StatusValues.sdkUnknown(rawValue)
        }
    }
}

extension SSOAdminClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension SSOAdminClientTypes {
    /// A set of key-value pairs that are used to manage the resource. Tags can only be applied to permission sets and cannot be applied to corresponding roles that IAM Identity Center creates in Amazon Web Services accounts.
    public struct Tag: Swift.Equatable {
        /// The key for the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the resource with the tags to be listed.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A set of key-value pairs that are used to manage the resource.
    /// This member is required.
    public var tags: [SSOAdminClientTypes.Tag]?

    public init(
        instanceArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tags: [SSOAdminClientTypes.Tag]? = nil
    )
    {
        self.instanceArn = instanceArn
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let resourceArn: Swift.String?
    let tags: [SSOAdminClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case resourceArn = "ResourceArn"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([SSOAdminClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[SSOAdminClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [SSOAdminClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SSOAdminClientTypes {
    public enum TargetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetType] {
            return [
                .awsAccount,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsAccount: return "AWS_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetType(rawValue: rawValue) ?? TargetType.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Indicates that the principal has crossed the throttling limits of the API operations.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the resource with the tags to be listed.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of tags that are attached to the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        instanceArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.instanceArn = instanceArn
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "InstanceArn"
        case resourceArn = "ResourceArn"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateInstanceAccessControlAttributeConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceAccessControlAttributeConfiguration = "InstanceAccessControlAttributeConfiguration"
        case instanceArn = "InstanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceAccessControlAttributeConfiguration = self.instanceAccessControlAttributeConfiguration {
            try encodeContainer.encode(instanceAccessControlAttributeConfiguration, forKey: .instanceAccessControlAttributeConfiguration)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }
}

extension UpdateInstanceAccessControlAttributeConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateInstanceAccessControlAttributeConfigurationInput: Swift.Equatable {
    /// Updates the attributes for your ABAC configuration.
    /// This member is required.
    public var instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration? = nil,
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfiguration
        self.instanceArn = instanceArn
    }
}

struct UpdateInstanceAccessControlAttributeConfigurationInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration?
}

extension UpdateInstanceAccessControlAttributeConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceAccessControlAttributeConfiguration = "InstanceAccessControlAttributeConfiguration"
        case instanceArn = "InstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let instanceAccessControlAttributeConfigurationDecoded = try containerValues.decodeIfPresent(SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration.self, forKey: .instanceAccessControlAttributeConfiguration)
        instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfigurationDecoded
    }
}

extension UpdateInstanceAccessControlAttributeConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateInstanceAccessControlAttributeConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateInstanceAccessControlAttributeConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePermissionSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case relayState = "RelayState"
        case sessionDuration = "SessionDuration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
        if let permissionSetArn = self.permissionSetArn {
            try encodeContainer.encode(permissionSetArn, forKey: .permissionSetArn)
        }
        if let relayState = self.relayState {
            try encodeContainer.encode(relayState, forKey: .relayState)
        }
        if let sessionDuration = self.sessionDuration {
            try encodeContainer.encode(sessionDuration, forKey: .sessionDuration)
        }
    }
}

extension UpdatePermissionSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdatePermissionSetInput: Swift.Equatable {
    /// The description of the [PermissionSet].
    public var description: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// Used to redirect users within the application during the federation authentication process.
    public var relayState: Swift.String?
    /// The length of time that the application user sessions are valid for in the ISO-8601 standard.
    public var sessionDuration: Swift.String?

    public init(
        description: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        relayState: Swift.String? = nil,
        sessionDuration: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.relayState = relayState
        self.sessionDuration = sessionDuration
    }
}

struct UpdatePermissionSetInputBody: Swift.Equatable {
    let instanceArn: Swift.String?
    let permissionSetArn: Swift.String?
    let description: Swift.String?
    let sessionDuration: Swift.String?
    let relayState: Swift.String?
}

extension UpdatePermissionSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "Description"
        case instanceArn = "InstanceArn"
        case permissionSetArn = "PermissionSetArn"
        case relayState = "RelayState"
        case sessionDuration = "SessionDuration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
        let permissionSetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionSetArn)
        permissionSetArn = permissionSetArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let sessionDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionDuration)
        sessionDuration = sessionDurationDecoded
        let relayStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relayState)
        relayState = relayStateDecoded
    }
}

extension UpdatePermissionSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdatePermissionSetOutput: Swift.Equatable {

    public init() { }
}

enum UpdatePermissionSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request failed because it contains a syntax error.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
