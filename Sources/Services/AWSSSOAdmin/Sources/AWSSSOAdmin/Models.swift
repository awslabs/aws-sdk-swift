//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import SmithyJSON
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document


public struct DeleteApplicationAccessScopeOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteApplicationAuthenticationMethodOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteApplicationGrantOutput: Swift.Sendable {

    public init() { }
}

public struct PutApplicationAccessScopeOutput: Swift.Sendable {

    public init() { }
}

public struct PutApplicationAuthenticationMethodOutput: Swift.Sendable {

    public init() { }
}

public struct PutApplicationGrantOutput: Swift.Sendable {

    public init() { }
}

extension SSOAdminClientTypes {

    /// The value used for mapping a specified attribute to an identity source. For more information, see [Attribute mappings](https://docs.aws.amazon.com/singlesignon/latest/userguide/attributemappingsconcept.html) in the IAM Identity Center User Guide.
    public struct AccessControlAttributeValue: Swift.Sendable {
        /// The identity source to use when mapping a specified attribute to IAM Identity Center.
        /// This member is required.
        public var source: [Swift.String]?

        public init(
            source: [Swift.String]? = nil
        )
        {
            self.source = source
        }
    }
}

extension SSOAdminClientTypes {

    /// These are IAM Identity Center identity store attributes that you can configure for use in attributes-based access control (ABAC). You can create permissions policies that determine who can access your Amazon Web Services resources based upon the configured attribute values. When you enable ABAC and specify AccessControlAttributes, IAM Identity Center passes the attribute values of the authenticated user into IAM for use in policy evaluation.
    public struct AccessControlAttribute: Swift.Sendable {
        /// The name of the attribute associated with your identities in your identity source. This is used to map a specified attribute in your identity source with an attribute in IAM Identity Center.
        /// This member is required.
        public var key: Swift.String?
        /// The value used for mapping a specified attribute to an identity source.
        /// This member is required.
        public var value: SSOAdminClientTypes.AccessControlAttributeValue?

        public init(
            key: Swift.String? = nil,
            value: SSOAdminClientTypes.AccessControlAttributeValue? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSOAdminClientTypes {

    public enum PrincipalType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case group
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [PrincipalType] {
            return [
                .group,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSOAdminClientTypes {

    /// The assignment that indicates a principal's limited access to a specified Amazon Web Services account with a specified permission set. The term principal here refers to a user or group that is defined in IAM Identity Center.
    public struct AccountAssignment: Swift.Sendable {
        /// The identifier of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// The ARN of the permission set. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var permissionSetArn: Swift.String?
        /// An identifier for an object in IAM Identity Center, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in IAM Identity Center, see the [IAM Identity Center Identity Store API Reference].
        public var principalId: Swift.String?
        /// The entity type for which the assignment will be created.
        public var principalType: SSOAdminClientTypes.PrincipalType?

        public init(
            accountId: Swift.String? = nil,
            permissionSetArn: Swift.String? = nil,
            principalId: Swift.String? = nil,
            principalType: SSOAdminClientTypes.PrincipalType? = nil
        )
        {
            self.accountId = accountId
            self.permissionSetArn = permissionSetArn
            self.principalId = principalId
            self.principalType = principalType
        }
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes an assignment of an Amazon Web Services account to a principal and the permissions that principal has in the account.
    public struct AccountAssignmentForPrincipal: Swift.Sendable {
        /// The account ID number of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// The ARN of the IAM Identity Center permission set assigned to this principal for this Amazon Web Services account.
        public var permissionSetArn: Swift.String?
        /// The ID of the principal.
        public var principalId: Swift.String?
        /// The type of the principal.
        public var principalType: SSOAdminClientTypes.PrincipalType?

        public init(
            accountId: Swift.String? = nil,
            permissionSetArn: Swift.String? = nil,
            principalId: Swift.String? = nil,
            principalType: SSOAdminClientTypes.PrincipalType? = nil
        )
        {
            self.accountId = accountId
            self.permissionSetArn = permissionSetArn
            self.principalId = principalId
            self.principalType = principalType
        }
    }
}

extension SSOAdminClientTypes {

    public enum StatusValues: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [StatusValues] {
            return [
                .failed,
                .inProgress,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSOAdminClientTypes {

    public enum TargetType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetType] {
            return [
                .awsAccount
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsAccount: return "AWS_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSOAdminClientTypes {

    /// The status of the creation or deletion operation of an assignment that a principal needs to access an account.
    public struct AccountAssignmentOperationStatus: Swift.Sendable {
        /// The date that the permission set was created.
        public var createdDate: Foundation.Date?
        /// The message that contains an error or exception in case of an operation failure.
        public var failureReason: Swift.String?
        /// The ARN of the permission set. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var permissionSetArn: Swift.String?
        /// An identifier for an object in IAM Identity Center, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in IAM Identity Center, see the [IAM Identity Center Identity Store API Reference].
        public var principalId: Swift.String?
        /// The entity type for which the assignment will be created.
        public var principalType: SSOAdminClientTypes.PrincipalType?
        /// The identifier for tracking the request operation that is generated by the universally unique identifier (UUID) workflow.
        public var requestId: Swift.String?
        /// The status of the permission set provisioning process.
        public var status: SSOAdminClientTypes.StatusValues?
        /// TargetID is an Amazon Web Services account identifier, (For example, 123456789012).
        public var targetId: Swift.String?
        /// The entity type for which the assignment will be created.
        public var targetType: SSOAdminClientTypes.TargetType?

        public init(
            createdDate: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            permissionSetArn: Swift.String? = nil,
            principalId: Swift.String? = nil,
            principalType: SSOAdminClientTypes.PrincipalType? = nil,
            requestId: Swift.String? = nil,
            status: SSOAdminClientTypes.StatusValues? = nil,
            targetId: Swift.String? = nil,
            targetType: SSOAdminClientTypes.TargetType? = nil
        )
        {
            self.createdDate = createdDate
            self.failureReason = failureReason
            self.permissionSetArn = permissionSetArn
            self.principalId = principalId
            self.principalType = principalType
            self.requestId = requestId
            self.status = status
            self.targetId = targetId
            self.targetType = targetType
        }
    }
}

extension SSOAdminClientTypes {

    /// Provides information about the [AccountAssignment] creation request.
    public struct AccountAssignmentOperationStatusMetadata: Swift.Sendable {
        /// The date that the permission set was created.
        public var createdDate: Foundation.Date?
        /// The identifier for tracking the request operation that is generated by the universally unique identifier (UUID) workflow.
        public var requestId: Swift.String?
        /// The status of the permission set provisioning process.
        public var status: SSOAdminClientTypes.StatusValues?

        public init(
            createdDate: Foundation.Date? = nil,
            requestId: Swift.String? = nil,
            status: SSOAdminClientTypes.StatusValues? = nil
        )
        {
            self.createdDate = createdDate
            self.requestId = requestId
            self.status = status
        }
    }
}

extension SSOAdminClientTypes {

    public enum SignInOrigin: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case application
        case identityCenter
        case sdkUnknown(Swift.String)

        public static var allCases: [SignInOrigin] {
            return [
                .application,
                .identityCenter
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .application: return "APPLICATION"
            case .identityCenter: return "IDENTITY_CENTER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes the sign-in options for an application portal.
    public struct SignInOptions: Swift.Sendable {
        /// The URL that accepts authentication requests for an application. This is a required parameter if the Origin parameter is APPLICATION.
        public var applicationUrl: Swift.String?
        /// This determines how IAM Identity Center navigates the user to the target application. It can be one of the following values:
        ///
        /// * APPLICATION: IAM Identity Center redirects the customer to the configured ApplicationUrl.
        ///
        /// * IDENTITY_CENTER: IAM Identity Center uses SAML identity-provider initiated authentication to sign the customer directly into a SAML-based application.
        /// This member is required.
        public var origin: SSOAdminClientTypes.SignInOrigin?

        public init(
            applicationUrl: Swift.String? = nil,
            origin: SSOAdminClientTypes.SignInOrigin? = nil
        )
        {
            self.applicationUrl = applicationUrl
            self.origin = origin
        }
    }
}

extension SSOAdminClientTypes {

    public enum ApplicationVisibility: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationVisibility] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes the options for the access portal associated with an application.
    public struct PortalOptions: Swift.Sendable {
        /// A structure that describes the sign-in options for the access portal.
        public var signInOptions: SSOAdminClientTypes.SignInOptions?
        /// Indicates whether this application is visible in the access portal.
        public var visibility: SSOAdminClientTypes.ApplicationVisibility?

        public init(
            signInOptions: SSOAdminClientTypes.SignInOptions? = nil,
            visibility: SSOAdminClientTypes.ApplicationVisibility? = .enabled
        )
        {
            self.signInOptions = signInOptions
            self.visibility = visibility
        }
    }
}

extension SSOAdminClientTypes {

    public enum ApplicationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes an application that uses IAM Identity Center for access management.
    public struct Application: Swift.Sendable {
        /// The Amazon Web Services account ID number of the application.
        public var applicationAccount: Swift.String?
        /// The ARN of the application.
        public var applicationArn: Swift.String?
        /// The ARN of the application provider for this application.
        public var applicationProviderArn: Swift.String?
        /// The date and time when the application was originally created.
        public var createdDate: Foundation.Date?
        /// The description of the application.
        public var description: Swift.String?
        /// The ARN of the instance of IAM Identity Center that is configured with this application.
        public var instanceArn: Swift.String?
        /// The name of the application.
        public var name: Swift.String?
        /// A structure that describes the options for the access portal associated with this application.
        public var portalOptions: SSOAdminClientTypes.PortalOptions?
        /// The current status of the application in this instance of IAM Identity Center.
        public var status: SSOAdminClientTypes.ApplicationStatus?

        public init(
            applicationAccount: Swift.String? = nil,
            applicationArn: Swift.String? = nil,
            applicationProviderArn: Swift.String? = nil,
            createdDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            instanceArn: Swift.String? = nil,
            name: Swift.String? = nil,
            portalOptions: SSOAdminClientTypes.PortalOptions? = nil,
            status: SSOAdminClientTypes.ApplicationStatus? = nil
        )
        {
            self.applicationAccount = applicationAccount
            self.applicationArn = applicationArn
            self.applicationProviderArn = applicationProviderArn
            self.createdDate = createdDate
            self.description = description
            self.instanceArn = instanceArn
            self.name = name
            self.portalOptions = portalOptions
            self.status = status
        }
    }
}

/// Occurs when a conflict with a previous successful write is detected. This generally occurs when the previous write did not have time to propagate to the host serving the current request. A retry (with appropriate backoff logic) is the recommended response to this exception.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request processing has failed because of an unknown error, exception, or failure with an internal server.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Indicates that a requested resource is not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Indicates that the principal has crossed the throttling limits of the API operations.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request failed because it contains a syntax error.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteApplicationAccessScopeInput: Swift.Sendable {
    /// Specifies the ARN of the application with the access scope to delete.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies the name of the access scope to remove from the application.
    /// This member is required.
    public var scope: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        scope: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.scope = scope
    }
}

public struct GetApplicationAccessScopeInput: Swift.Sendable {
    /// Specifies the ARN of the application with the access scope that you want to retrieve.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies the name of the access scope for which you want the authorized targets.
    /// This member is required.
    public var scope: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        scope: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.scope = scope
    }
}

public struct GetApplicationAccessScopeOutput: Swift.Sendable {
    /// An array of authorized targets associated with this access scope.
    public var authorizedTargets: [Swift.String]?
    /// The name of the access scope that can be used with the authorized targets.
    /// This member is required.
    public var scope: Swift.String?

    public init(
        authorizedTargets: [Swift.String]? = nil,
        scope: Swift.String? = nil
    )
    {
        self.authorizedTargets = authorizedTargets
        self.scope = scope
    }
}

public struct ListApplicationAccessScopesInput: Swift.Sendable {
    /// Specifies the ARN of the application.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes an IAM Identity Center access scope and its authorized targets.
    public struct ScopeDetails: Swift.Sendable {
        /// An array list of ARNs of applications.
        public var authorizedTargets: [Swift.String]?
        /// The name of the access scope.
        /// This member is required.
        public var scope: Swift.String?

        public init(
            authorizedTargets: [Swift.String]? = nil,
            scope: Swift.String? = nil
        )
        {
            self.authorizedTargets = authorizedTargets
            self.scope = scope
        }
    }
}

public struct ListApplicationAccessScopesOutput: Swift.Sendable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array list of access scopes and their authorized targets that are associated with the application.
    /// This member is required.
    public var scopes: [SSOAdminClientTypes.ScopeDetails]?

    public init(
        nextToken: Swift.String? = nil,
        scopes: [SSOAdminClientTypes.ScopeDetails]? = nil
    )
    {
        self.nextToken = nextToken
        self.scopes = scopes
    }
}

public struct PutApplicationAccessScopeInput: Swift.Sendable {
    /// Specifies the ARN of the application with the access scope with the targets to add or update.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies an array list of ARNs that represent the authorized targets for this access scope.
    public var authorizedTargets: [Swift.String]?
    /// Specifies the name of the access scope to be associated with the specified targets.
    /// This member is required.
    public var scope: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        authorizedTargets: [Swift.String]? = nil,
        scope: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.authorizedTargets = authorizedTargets
        self.scope = scope
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes an assignment of a principal to an application.
    public struct ApplicationAssignment: Swift.Sendable {
        /// The ARN of the application that has principals assigned.
        /// This member is required.
        public var applicationArn: Swift.String?
        /// The unique identifier of the principal assigned to the application.
        /// This member is required.
        public var principalId: Swift.String?
        /// The type of the principal assigned to the application.
        /// This member is required.
        public var principalType: SSOAdminClientTypes.PrincipalType?

        public init(
            applicationArn: Swift.String? = nil,
            principalId: Swift.String? = nil,
            principalType: SSOAdminClientTypes.PrincipalType? = nil
        )
        {
            self.applicationArn = applicationArn
            self.principalId = principalId
            self.principalType = principalType
        }
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes an application to which a principal is assigned.
    public struct ApplicationAssignmentForPrincipal: Swift.Sendable {
        /// The ARN of the application to which the specified principal is assigned.
        public var applicationArn: Swift.String?
        /// The unique identifier of the principal assigned to the application.
        public var principalId: Swift.String?
        /// The type of the principal assigned to the application.
        public var principalType: SSOAdminClientTypes.PrincipalType?

        public init(
            applicationArn: Swift.String? = nil,
            principalId: Swift.String? = nil,
            principalType: SSOAdminClientTypes.PrincipalType? = nil
        )
        {
            self.applicationArn = applicationArn
            self.principalId = principalId
            self.principalType = principalType
        }
    }
}

extension SSOAdminClientTypes {

    public enum AuthenticationMethodType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iam
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationMethodType] {
            return [
                .iam
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iam: return "IAM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteApplicationAuthenticationMethodInput: Swift.Sendable {
    /// Specifies the ARN of the application with the authentication method to delete.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies the authentication method type to delete from the application.
    /// This member is required.
    public var authenticationMethodType: SSOAdminClientTypes.AuthenticationMethodType?

    public init(
        applicationArn: Swift.String? = nil,
        authenticationMethodType: SSOAdminClientTypes.AuthenticationMethodType? = nil
    )
    {
        self.applicationArn = applicationArn
        self.authenticationMethodType = authenticationMethodType
    }
}

public struct GetApplicationAuthenticationMethodInput: Swift.Sendable {
    /// Specifies the ARN of the application.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies the type of authentication method for which you want details.
    /// This member is required.
    public var authenticationMethodType: SSOAdminClientTypes.AuthenticationMethodType?

    public init(
        applicationArn: Swift.String? = nil,
        authenticationMethodType: SSOAdminClientTypes.AuthenticationMethodType? = nil
    )
    {
        self.applicationArn = applicationArn
        self.authenticationMethodType = authenticationMethodType
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes details for authentication that uses IAM.
    public struct IamAuthenticationMethod: Swift.Sendable {
        /// An IAM policy document in JSON.
        /// This member is required.
        public var actorPolicy: Smithy.Document?

        public init(
            actorPolicy: Smithy.Document? = nil
        )
        {
            self.actorPolicy = actorPolicy
        }
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes an authentication method that can be used by an application.
    public enum AuthenticationMethod: Swift.Sendable {
        /// A structure that describes details for IAM authentication.
        case iam(SSOAdminClientTypes.IamAuthenticationMethod)
        case sdkUnknown(Swift.String)
    }
}

public struct GetApplicationAuthenticationMethodOutput: Swift.Sendable {
    /// A structure that contains details about the requested authentication method.
    public var authenticationMethod: SSOAdminClientTypes.AuthenticationMethod?

    public init(
        authenticationMethod: SSOAdminClientTypes.AuthenticationMethod? = nil
    )
    {
        self.authenticationMethod = authenticationMethod
    }
}

public struct ListApplicationAuthenticationMethodsInput: Swift.Sendable {
    /// Specifies the ARN of the application with the authentication methods you want to list.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.nextToken = nextToken
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes an authentication method and its type.
    public struct AuthenticationMethodItem: Swift.Sendable {
        /// A structure that describes an authentication method. The contents of this structure is determined by the AuthenticationMethodType.
        public var authenticationMethod: SSOAdminClientTypes.AuthenticationMethod?
        /// The type of authentication that is used by this method.
        public var authenticationMethodType: SSOAdminClientTypes.AuthenticationMethodType?

        public init(
            authenticationMethod: SSOAdminClientTypes.AuthenticationMethod? = nil,
            authenticationMethodType: SSOAdminClientTypes.AuthenticationMethodType? = nil
        )
        {
            self.authenticationMethod = authenticationMethod
            self.authenticationMethodType = authenticationMethodType
        }
    }
}

public struct ListApplicationAuthenticationMethodsOutput: Swift.Sendable {
    /// An array list of authentication methods for the specified application.
    public var authenticationMethods: [SSOAdminClientTypes.AuthenticationMethodItem]?
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?

    public init(
        authenticationMethods: [SSOAdminClientTypes.AuthenticationMethodItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.authenticationMethods = authenticationMethods
        self.nextToken = nextToken
    }
}

public struct PutApplicationAuthenticationMethodInput: Swift.Sendable {
    /// Specifies the ARN of the application with the authentication method to add or update.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies a structure that describes the authentication method to add or update. The structure type you provide is determined by the AuthenticationMethodType parameter.
    /// This member is required.
    public var authenticationMethod: SSOAdminClientTypes.AuthenticationMethod?
    /// Specifies the type of the authentication method that you want to add or update.
    /// This member is required.
    public var authenticationMethodType: SSOAdminClientTypes.AuthenticationMethodType?

    public init(
        applicationArn: Swift.String? = nil,
        authenticationMethod: SSOAdminClientTypes.AuthenticationMethod? = nil,
        authenticationMethodType: SSOAdminClientTypes.AuthenticationMethodType? = nil
    )
    {
        self.applicationArn = applicationArn
        self.authenticationMethod = authenticationMethod
        self.authenticationMethodType = authenticationMethodType
    }
}

extension SSOAdminClientTypes {

    public enum GrantType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case authorizationCode
        case jwtBearer
        case refreshToken
        case tokenExchange
        case sdkUnknown(Swift.String)

        public static var allCases: [GrantType] {
            return [
                .authorizationCode,
                .jwtBearer,
                .refreshToken,
                .tokenExchange
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .authorizationCode: return "authorization_code"
            case .jwtBearer: return "urn:ietf:params:oauth:grant-type:jwt-bearer"
            case .refreshToken: return "refresh_token"
            case .tokenExchange: return "urn:ietf:params:oauth:grant-type:token-exchange"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeleteApplicationGrantInput: Swift.Sendable {
    /// Specifies the ARN of the application with the grant to delete.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies the type of grant to delete from the application.
    /// This member is required.
    public var grantType: SSOAdminClientTypes.GrantType?

    public init(
        applicationArn: Swift.String? = nil,
        grantType: SSOAdminClientTypes.GrantType? = nil
    )
    {
        self.applicationArn = applicationArn
        self.grantType = grantType
    }
}

public struct GetApplicationGrantInput: Swift.Sendable {
    /// Specifies the ARN of the application that contains the grant.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies the type of grant.
    /// This member is required.
    public var grantType: SSOAdminClientTypes.GrantType?

    public init(
        applicationArn: Swift.String? = nil,
        grantType: SSOAdminClientTypes.GrantType? = nil
    )
    {
        self.applicationArn = applicationArn
        self.grantType = grantType
    }
}

extension SSOAdminClientTypes {

    /// A structure that defines configuration settings for an application that supports the OAuth 2.0 Authorization Code Grant.
    public struct AuthorizationCodeGrant: Swift.Sendable {
        /// A list of URIs that are valid locations to redirect a user's browser after the user is authorized.
        public var redirectUris: [Swift.String]?

        public init(
            redirectUris: [Swift.String]? = nil
        )
        {
            self.redirectUris = redirectUris
        }
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes a trusted token issuer and associates it with a set of authorized audiences.
    public struct AuthorizedTokenIssuer: Swift.Sendable {
        /// An array list of authorized audiences, or applications, that can consume the tokens generated by the associated trusted token issuer.
        public var authorizedAudiences: [Swift.String]?
        /// The ARN of the trusted token issuer.
        public var trustedTokenIssuerArn: Swift.String?

        public init(
            authorizedAudiences: [Swift.String]? = nil,
            trustedTokenIssuerArn: Swift.String? = nil
        )
        {
            self.authorizedAudiences = authorizedAudiences
            self.trustedTokenIssuerArn = trustedTokenIssuerArn
        }
    }
}

extension SSOAdminClientTypes {

    /// A structure that defines configuration settings for an application that supports the JWT Bearer Token Authorization Grant.
    public struct JwtBearerGrant: Swift.Sendable {
        /// A list of allowed token issuers trusted by the Identity Center instances for this application.
        public var authorizedTokenIssuers: [SSOAdminClientTypes.AuthorizedTokenIssuer]?

        public init(
            authorizedTokenIssuers: [SSOAdminClientTypes.AuthorizedTokenIssuer]? = nil
        )
        {
            self.authorizedTokenIssuers = authorizedTokenIssuers
        }
    }
}

extension SSOAdminClientTypes {

    /// A structure that defines configuration settings for an application that supports the OAuth 2.0 Refresh Token Grant.
    public struct RefreshTokenGrant: Swift.Sendable {

        public init() { }
    }
}

extension SSOAdminClientTypes {

    /// A structure that defines configuration settings for an application that supports the OAuth 2.0 Token Exchange Grant.
    public struct TokenExchangeGrant: Swift.Sendable {

        public init() { }
    }
}

extension SSOAdminClientTypes {

    /// The Grant union represents the set of possible configuration options for the selected grant type. Exactly one member of the union must be specified, and must match the grant type selected.
    public enum Grant: Swift.Sendable {
        /// Configuration options for the authorization_code grant type.
        case authorizationcode(SSOAdminClientTypes.AuthorizationCodeGrant)
        /// Configuration options for the urn:ietf:params:oauth:grant-type:jwt-bearer grant type.
        case jwtbearer(SSOAdminClientTypes.JwtBearerGrant)
        /// Configuration options for the refresh_token grant type.
        case refreshtoken(SSOAdminClientTypes.RefreshTokenGrant)
        /// Configuration options for the urn:ietf:params:oauth:grant-type:token-exchange grant type.
        case tokenexchange(SSOAdminClientTypes.TokenExchangeGrant)
        case sdkUnknown(Swift.String)
    }
}

public struct GetApplicationGrantOutput: Swift.Sendable {
    /// A structure that describes the requested grant.
    /// This member is required.
    public var grant: SSOAdminClientTypes.Grant?

    public init(
        grant: SSOAdminClientTypes.Grant? = nil
    )
    {
        self.grant = grant
    }
}

public struct ListApplicationGrantsInput: Swift.Sendable {
    /// Specifies the ARN of the application whose grants you want to list.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.nextToken = nextToken
    }
}

extension SSOAdminClientTypes {

    /// A structure that defines a single grant and its configuration.
    public struct GrantItem: Swift.Sendable {
        /// The configuration structure for the selected grant.
        /// This member is required.
        public var grant: SSOAdminClientTypes.Grant?
        /// The type of the selected grant.
        /// This member is required.
        public var grantType: SSOAdminClientTypes.GrantType?

        public init(
            grant: SSOAdminClientTypes.Grant? = nil,
            grantType: SSOAdminClientTypes.GrantType? = nil
        )
        {
            self.grant = grant
            self.grantType = grantType
        }
    }
}

public struct ListApplicationGrantsOutput: Swift.Sendable {
    /// An array list of structures that describe the requested grants.
    /// This member is required.
    public var grants: [SSOAdminClientTypes.GrantItem]?
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?

    public init(
        grants: [SSOAdminClientTypes.GrantItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.grants = grants
        self.nextToken = nextToken
    }
}

public struct PutApplicationGrantInput: Swift.Sendable {
    /// Specifies the ARN of the application to update.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies a structure that describes the grant to update.
    /// This member is required.
    public var grant: SSOAdminClientTypes.Grant?
    /// Specifies the type of grant to update.
    /// This member is required.
    public var grantType: SSOAdminClientTypes.GrantType?

    public init(
        applicationArn: Swift.String? = nil,
        grant: SSOAdminClientTypes.Grant? = nil,
        grantType: SSOAdminClientTypes.GrantType? = nil
    )
    {
        self.applicationArn = applicationArn
        self.grant = grant
        self.grantType = grantType
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes how the portal represents an application provider.
    public struct DisplayData: Swift.Sendable {
        /// The description of the application provider that appears in the portal.
        public var description: Swift.String?
        /// The name of the application provider that appears in the portal.
        public var displayName: Swift.String?
        /// A URL that points to an icon that represents the application provider.
        public var iconUrl: Swift.String?

        public init(
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            iconUrl: Swift.String? = nil
        )
        {
            self.description = description
            self.displayName = displayName
            self.iconUrl = iconUrl
        }
    }
}

extension SSOAdminClientTypes {

    public enum FederationProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oauth
        case saml
        case sdkUnknown(Swift.String)

        public static var allCases: [FederationProtocol] {
            return [
                .oauth,
                .saml
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oauth: return "OAUTH"
            case .saml: return "SAML"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes details for an IAM Identity Center access scope that is associated with a resource server.
    public struct ResourceServerScopeDetails: Swift.Sendable {
        /// The title of an access scope for a resource server.
        public var detailedTitle: Swift.String?
        /// The description of an access scope for a resource server.
        public var longDescription: Swift.String?

        public init(
            detailedTitle: Swift.String? = nil,
            longDescription: Swift.String? = nil
        )
        {
            self.detailedTitle = detailedTitle
            self.longDescription = longDescription
        }
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes the configuration of a resource server.
    public struct ResourceServerConfig: Swift.Sendable {
        /// A list of the IAM Identity Center access scopes that are associated with this resource server.
        public var scopes: [Swift.String: SSOAdminClientTypes.ResourceServerScopeDetails]?

        public init(
            scopes: [Swift.String: SSOAdminClientTypes.ResourceServerScopeDetails]? = nil
        )
        {
            self.scopes = scopes
        }
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes a provider that can be used to connect an Amazon Web Services managed application or customer managed application to IAM Identity Center.
    public struct ApplicationProvider: Swift.Sendable {
        /// The ARN of the application provider.
        /// This member is required.
        public var applicationProviderArn: Swift.String?
        /// A structure that describes how IAM Identity Center represents the application provider in the portal.
        public var displayData: SSOAdminClientTypes.DisplayData?
        /// The protocol that the application provider uses to perform federation.
        public var federationProtocol: SSOAdminClientTypes.FederationProtocol?
        /// A structure that describes the application provider's resource server.
        public var resourceServerConfig: SSOAdminClientTypes.ResourceServerConfig?

        public init(
            applicationProviderArn: Swift.String? = nil,
            displayData: SSOAdminClientTypes.DisplayData? = nil,
            federationProtocol: SSOAdminClientTypes.FederationProtocol? = nil,
            resourceServerConfig: SSOAdminClientTypes.ResourceServerConfig? = nil
        )
        {
            self.applicationProviderArn = applicationProviderArn
            self.displayData = displayData
            self.federationProtocol = federationProtocol
            self.resourceServerConfig = resourceServerConfig
        }
    }
}

/// Indicates that the principal has crossed the permitted number of resources that can be created.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension SSOAdminClientTypes {

    /// Specifies the name and path of a customer managed policy. You must have an IAM policy that matches the name and path in each Amazon Web Services account where you want to deploy your permission set.
    public struct CustomerManagedPolicyReference: Swift.Sendable {
        /// The name of the IAM policy that you have configured in each account where you want to deploy your permission set.
        /// This member is required.
        public var name: Swift.String?
        /// The path to the IAM policy that you have configured in each account where you want to deploy your permission set. The default is /. For more information, see [Friendly names and paths](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-friendly-names) in the IAM User Guide.
        public var path: Swift.String?

        public init(
            name: Swift.String? = nil,
            path: Swift.String? = nil
        )
        {
            self.name = name
            self.path = path
        }
    }
}

public struct AttachCustomerManagedPolicyReferenceToPermissionSetInput: Swift.Sendable {
    /// Specifies the name and path of a customer managed policy. You must have an IAM policy that matches the name and path in each Amazon Web Services account where you want to deploy your permission set.
    /// This member is required.
    public var customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the PermissionSet.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference? = nil,
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.customerManagedPolicyReference = customerManagedPolicyReference
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

public struct AttachCustomerManagedPolicyReferenceToPermissionSetOutput: Swift.Sendable {

    public init() { }
}

extension SSOAdminClientTypes {

    /// A structure that stores the details of the Amazon Web Services managed policy.
    public struct AttachedManagedPolicy: Swift.Sendable {
        /// The ARN of the Amazon Web Services managed policy. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var arn: Swift.String?
        /// The name of the Amazon Web Services managed policy.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }
}

public struct AttachManagedPolicyToPermissionSetInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The Amazon Web Services managed policy ARN to be attached to a permission set.
    /// This member is required.
    public var managedPolicyArn: Swift.String?
    /// The ARN of the [PermissionSet] that the managed policy should be attached to.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        managedPolicyArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.managedPolicyArn = managedPolicyArn
        self.permissionSetArn = permissionSetArn
    }
}

public struct AttachManagedPolicyToPermissionSetOutput: Swift.Sendable {

    public init() { }
}

public struct CreateAccountAssignmentInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set that the admin wants to grant the principal access to.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// An identifier for an object in IAM Identity Center, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in IAM Identity Center, see the [IAM Identity Center Identity Store API Reference].
    /// This member is required.
    public var principalId: Swift.String?
    /// The entity type for which the assignment will be created.
    /// This member is required.
    public var principalType: SSOAdminClientTypes.PrincipalType?
    /// TargetID is an Amazon Web Services account identifier, (For example, 123456789012).
    /// This member is required.
    public var targetId: Swift.String?
    /// The entity type for which the assignment will be created.
    /// This member is required.
    public var targetType: SSOAdminClientTypes.TargetType?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: SSOAdminClientTypes.PrincipalType? = nil,
        targetId: Swift.String? = nil,
        targetType: SSOAdminClientTypes.TargetType? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.principalId = principalId
        self.principalType = principalType
        self.targetId = targetId
        self.targetType = targetType
    }
}

public struct CreateAccountAssignmentOutput: Swift.Sendable {
    /// The status object for the account assignment creation operation.
    public var accountAssignmentCreationStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus?

    public init(
        accountAssignmentCreationStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus? = nil
    )
    {
        self.accountAssignmentCreationStatus = accountAssignmentCreationStatus
    }
}

extension SSOAdminClientTypes {

    /// A set of key-value pairs that are used to manage the resource. Tags can only be applied to permission sets and cannot be applied to corresponding roles that IAM Identity Center creates in Amazon Web Services accounts.
    public struct Tag: Swift.Sendable {
        /// The key for the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }
}

public struct CreateApplicationInput: Swift.Sendable {
    /// The ARN of the application provider under which the operation will run.
    /// This member is required.
    public var applicationProviderArn: Swift.String?
    /// Specifies a unique, case-sensitive ID that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// The description of the .
    public var description: Swift.String?
    /// The ARN of the instance of IAM Identity Center under which the operation will run. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The name of the .
    /// This member is required.
    public var name: Swift.String?
    /// A structure that describes the options for the portal associated with an application.
    public var portalOptions: SSOAdminClientTypes.PortalOptions?
    /// Specifies whether the application is enabled or disabled.
    public var status: SSOAdminClientTypes.ApplicationStatus?
    /// Specifies tags to be attached to the application.
    public var tags: [SSOAdminClientTypes.Tag]?

    public init(
        applicationProviderArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        name: Swift.String? = nil,
        portalOptions: SSOAdminClientTypes.PortalOptions? = nil,
        status: SSOAdminClientTypes.ApplicationStatus? = nil,
        tags: [SSOAdminClientTypes.Tag]? = nil
    )
    {
        self.applicationProviderArn = applicationProviderArn
        self.clientToken = clientToken
        self.description = description
        self.instanceArn = instanceArn
        self.name = name
        self.portalOptions = portalOptions
        self.status = status
        self.tags = tags
    }
}

public struct CreateApplicationOutput: Swift.Sendable {
    /// Specifies the ARN of the application.
    public var applicationArn: Swift.String?

    public init(
        applicationArn: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
    }
}

public struct CreateApplicationAssignmentInput: Swift.Sendable {
    /// The ARN of the application provider under which the operation will run.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// An identifier for an object in IAM Identity Center, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in IAM Identity Center, see the [IAM Identity Center Identity Store API Reference].
    /// This member is required.
    public var principalId: Swift.String?
    /// The entity type for which the assignment will be created.
    /// This member is required.
    public var principalType: SSOAdminClientTypes.PrincipalType?

    public init(
        applicationArn: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: SSOAdminClientTypes.PrincipalType? = nil
    )
    {
        self.applicationArn = applicationArn
        self.principalId = principalId
        self.principalType = principalType
    }
}

public struct CreateApplicationAssignmentOutput: Swift.Sendable {

    public init() { }
}

public struct CreateInstanceInput: Swift.Sendable {
    /// Specifies a unique, case-sensitive ID that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// The name of the instance of IAM Identity Center.
    public var name: Swift.String?
    /// Specifies tags to be attached to the instance of IAM Identity Center.
    public var tags: [SSOAdminClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [SSOAdminClientTypes.Tag]? = nil
    )
    {
        self.clientToken = clientToken
        self.name = name
        self.tags = tags
    }
}

public struct CreateInstanceOutput: Swift.Sendable {
    /// The ARN of the instance of IAM Identity Center under which the operation will run. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    public var instanceArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
    }
}

extension SSOAdminClientTypes {

    /// Specifies the attributes to add to your attribute-based access control (ABAC) configuration.
    public struct InstanceAccessControlAttributeConfiguration: Swift.Sendable {
        /// Lists the attributes that are configured for ABAC in the specified IAM Identity Center instance.
        /// This member is required.
        public var accessControlAttributes: [SSOAdminClientTypes.AccessControlAttribute]?

        public init(
            accessControlAttributes: [SSOAdminClientTypes.AccessControlAttribute]? = nil
        )
        {
            self.accessControlAttributes = accessControlAttributes
        }
    }
}

public struct CreateInstanceAccessControlAttributeConfigurationInput: Swift.Sendable {
    /// Specifies the IAM Identity Center identity store attributes to add to your ABAC configuration. When using an external identity provider as an identity source, you can pass attributes through the SAML assertion. Doing so provides an alternative to configuring attributes from the IAM Identity Center identity store. If a SAML assertion passes any of these attributes, IAM Identity Center will replace the attribute value with the value from the IAM Identity Center identity store.
    /// This member is required.
    public var instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration? = nil,
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfiguration
        self.instanceArn = instanceArn
    }
}

public struct CreateInstanceAccessControlAttributeConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct CreatePermissionSetInput: Swift.Sendable {
    /// The description of the [PermissionSet].
    public var description: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The name of the [PermissionSet].
    /// This member is required.
    public var name: Swift.String?
    /// Used to redirect users within the application during the federation authentication process.
    public var relayState: Swift.String?
    /// The length of time that the application user sessions are valid in the ISO-8601 standard.
    public var sessionDuration: Swift.String?
    /// The tags to attach to the new [PermissionSet].
    public var tags: [SSOAdminClientTypes.Tag]?

    public init(
        description: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        name: Swift.String? = nil,
        relayState: Swift.String? = nil,
        sessionDuration: Swift.String? = nil,
        tags: [SSOAdminClientTypes.Tag]? = nil
    )
    {
        self.description = description
        self.instanceArn = instanceArn
        self.name = name
        self.relayState = relayState
        self.sessionDuration = sessionDuration
        self.tags = tags
    }
}

extension SSOAdminClientTypes {

    /// An entity that contains IAM policies.
    public struct PermissionSet: Swift.Sendable {
        /// The date that the permission set was created.
        public var createdDate: Foundation.Date?
        /// The description of the [PermissionSet].
        public var description: Swift.String?
        /// The name of the permission set.
        public var name: Swift.String?
        /// The ARN of the permission set. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var permissionSetArn: Swift.String?
        /// Used to redirect users within the application during the federation authentication process.
        public var relayState: Swift.String?
        /// The length of time that the application user sessions are valid for in the ISO-8601 standard.
        public var sessionDuration: Swift.String?

        public init(
            createdDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            permissionSetArn: Swift.String? = nil,
            relayState: Swift.String? = nil,
            sessionDuration: Swift.String? = nil
        )
        {
            self.createdDate = createdDate
            self.description = description
            self.name = name
            self.permissionSetArn = permissionSetArn
            self.relayState = relayState
            self.sessionDuration = sessionDuration
        }
    }
}

public struct CreatePermissionSetOutput: Swift.Sendable {
    /// Defines the level of access on an Amazon Web Services account.
    public var permissionSet: SSOAdminClientTypes.PermissionSet?

    public init(
        permissionSet: SSOAdminClientTypes.PermissionSet? = nil
    )
    {
        self.permissionSet = permissionSet
    }
}

extension SSOAdminClientTypes {

    public enum JwksRetrievalOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case openIdDiscovery
        case sdkUnknown(Swift.String)

        public static var allCases: [JwksRetrievalOption] {
            return [
                .openIdDiscovery
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .openIdDiscovery: return "OPEN_ID_DISCOVERY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes configuration settings for a trusted token issuer that supports OpenID Connect (OIDC) and JSON Web Tokens (JWTs).
    public struct OidcJwtConfiguration: Swift.Sendable {
        /// The path of the source attribute in the JWT from the trusted token issuer. The attribute mapped by this JMESPath expression is compared against the attribute mapped by IdentityStoreAttributePath when a trusted token issuer token is exchanged for an IAM Identity Center token.
        /// This member is required.
        public var claimAttributePath: Swift.String?
        /// The path of the destination attribute in a JWT from IAM Identity Center. The attribute mapped by this JMESPath expression is compared against the attribute mapped by ClaimAttributePath when a trusted token issuer token is exchanged for an IAM Identity Center token.
        /// This member is required.
        public var identityStoreAttributePath: Swift.String?
        /// The URL that IAM Identity Center uses for OpenID Discovery. OpenID Discovery is used to obtain the information required to verify the tokens that the trusted token issuer generates.
        /// This member is required.
        public var issuerUrl: Swift.String?
        /// The method that the trusted token issuer can use to retrieve the JSON Web Key Set used to verify a JWT.
        /// This member is required.
        public var jwksRetrievalOption: SSOAdminClientTypes.JwksRetrievalOption?

        public init(
            claimAttributePath: Swift.String? = nil,
            identityStoreAttributePath: Swift.String? = nil,
            issuerUrl: Swift.String? = nil,
            jwksRetrievalOption: SSOAdminClientTypes.JwksRetrievalOption? = nil
        )
        {
            self.claimAttributePath = claimAttributePath
            self.identityStoreAttributePath = identityStoreAttributePath
            self.issuerUrl = issuerUrl
            self.jwksRetrievalOption = jwksRetrievalOption
        }
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes the configuration of a trusted token issuer. The structure and available settings are determined by the type of the trusted token issuer.
    public enum TrustedTokenIssuerConfiguration: Swift.Sendable {
        /// A structure that describes the settings for a trusted token issuer that works with OpenID Connect (OIDC) by using JSON Web Tokens (JWT).
        case oidcjwtconfiguration(SSOAdminClientTypes.OidcJwtConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension SSOAdminClientTypes {

    public enum TrustedTokenIssuerType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oidcJwt
        case sdkUnknown(Swift.String)

        public static var allCases: [TrustedTokenIssuerType] {
            return [
                .oidcJwt
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oidcJwt: return "OIDC_JWT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateTrustedTokenIssuerInput: Swift.Sendable {
    /// Specifies a unique, case-sensitive ID that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value.](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// Specifies the ARN of the instance of IAM Identity Center to contain the new trusted token issuer configuration.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// Specifies the name of the new trusted token issuer configuration.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies tags to be attached to the new trusted token issuer configuration.
    public var tags: [SSOAdminClientTypes.Tag]?
    /// Specifies settings that apply to the new trusted token issuer configuration. The settings that are available depend on what TrustedTokenIssuerType you specify.
    /// This member is required.
    public var trustedTokenIssuerConfiguration: SSOAdminClientTypes.TrustedTokenIssuerConfiguration?
    /// Specifies the type of the new trusted token issuer.
    /// This member is required.
    public var trustedTokenIssuerType: SSOAdminClientTypes.TrustedTokenIssuerType?

    public init(
        clientToken: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [SSOAdminClientTypes.Tag]? = nil,
        trustedTokenIssuerConfiguration: SSOAdminClientTypes.TrustedTokenIssuerConfiguration? = nil,
        trustedTokenIssuerType: SSOAdminClientTypes.TrustedTokenIssuerType? = nil
    )
    {
        self.clientToken = clientToken
        self.instanceArn = instanceArn
        self.name = name
        self.tags = tags
        self.trustedTokenIssuerConfiguration = trustedTokenIssuerConfiguration
        self.trustedTokenIssuerType = trustedTokenIssuerType
    }
}

public struct CreateTrustedTokenIssuerOutput: Swift.Sendable {
    /// The ARN of the new trusted token issuer configuration.
    public var trustedTokenIssuerArn: Swift.String?

    public init(
        trustedTokenIssuerArn: Swift.String? = nil
    )
    {
        self.trustedTokenIssuerArn = trustedTokenIssuerArn
    }
}

public struct DeleteAccountAssignmentInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set that will be used to remove access.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// An identifier for an object in IAM Identity Center, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in IAM Identity Center, see the [IAM Identity Center Identity Store API Reference].
    /// This member is required.
    public var principalId: Swift.String?
    /// The entity type for which the assignment will be deleted.
    /// This member is required.
    public var principalType: SSOAdminClientTypes.PrincipalType?
    /// TargetID is an Amazon Web Services account identifier, (For example, 123456789012).
    /// This member is required.
    public var targetId: Swift.String?
    /// The entity type for which the assignment will be deleted.
    /// This member is required.
    public var targetType: SSOAdminClientTypes.TargetType?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: SSOAdminClientTypes.PrincipalType? = nil,
        targetId: Swift.String? = nil,
        targetType: SSOAdminClientTypes.TargetType? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.principalId = principalId
        self.principalType = principalType
        self.targetId = targetId
        self.targetType = targetType
    }
}

public struct DeleteAccountAssignmentOutput: Swift.Sendable {
    /// The status object for the account assignment deletion operation.
    public var accountAssignmentDeletionStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus?

    public init(
        accountAssignmentDeletionStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus? = nil
    )
    {
        self.accountAssignmentDeletionStatus = accountAssignmentDeletionStatus
    }
}

public struct DeleteApplicationInput: Swift.Sendable {
    /// Specifies the ARN of the application. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var applicationArn: Swift.String?

    public init(
        applicationArn: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
    }
}

public struct DeleteApplicationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteApplicationAssignmentInput: Swift.Sendable {
    /// Specifies the ARN of the application.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// An identifier for an object in IAM Identity Center, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in IAM Identity Center, see the [IAM Identity Center Identity Store API Reference].
    /// This member is required.
    public var principalId: Swift.String?
    /// The entity type for which the assignment will be deleted.
    /// This member is required.
    public var principalType: SSOAdminClientTypes.PrincipalType?

    public init(
        applicationArn: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: SSOAdminClientTypes.PrincipalType? = nil
    )
    {
        self.applicationArn = applicationArn
        self.principalId = principalId
        self.principalType = principalType
    }
}

public struct DeleteApplicationAssignmentOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteInlinePolicyFromPermissionSetInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set that will be used to remove access.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

public struct DeleteInlinePolicyFromPermissionSetOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteInstanceInput: Swift.Sendable {
    /// The ARN of the instance of IAM Identity Center under which the operation will run.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
    }
}

public struct DeleteInstanceOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteInstanceAccessControlAttributeConfigurationInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
    }
}

public struct DeleteInstanceAccessControlAttributeConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct DeletePermissionsBoundaryFromPermissionSetInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the PermissionSet.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

public struct DeletePermissionsBoundaryFromPermissionSetOutput: Swift.Sendable {

    public init() { }
}

public struct DeletePermissionSetInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set that should be deleted.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

public struct DeletePermissionSetOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTrustedTokenIssuerInput: Swift.Sendable {
    /// Specifies the ARN of the trusted token issuer configuration to delete.
    /// This member is required.
    public var trustedTokenIssuerArn: Swift.String?

    public init(
        trustedTokenIssuerArn: Swift.String? = nil
    )
    {
        self.trustedTokenIssuerArn = trustedTokenIssuerArn
    }
}

public struct DeleteTrustedTokenIssuerOutput: Swift.Sendable {

    public init() { }
}

public struct DescribeAccountAssignmentCreationStatusInput: Swift.Sendable {
    /// The identifier that is used to track the request operation progress.
    /// This member is required.
    public var accountAssignmentCreationRequestId: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        accountAssignmentCreationRequestId: Swift.String? = nil,
        instanceArn: Swift.String? = nil
    )
    {
        self.accountAssignmentCreationRequestId = accountAssignmentCreationRequestId
        self.instanceArn = instanceArn
    }
}

public struct DescribeAccountAssignmentCreationStatusOutput: Swift.Sendable {
    /// The status object for the account assignment creation operation.
    public var accountAssignmentCreationStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus?

    public init(
        accountAssignmentCreationStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus? = nil
    )
    {
        self.accountAssignmentCreationStatus = accountAssignmentCreationStatus
    }
}

public struct DescribeAccountAssignmentDeletionStatusInput: Swift.Sendable {
    /// The identifier that is used to track the request operation progress.
    /// This member is required.
    public var accountAssignmentDeletionRequestId: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        accountAssignmentDeletionRequestId: Swift.String? = nil,
        instanceArn: Swift.String? = nil
    )
    {
        self.accountAssignmentDeletionRequestId = accountAssignmentDeletionRequestId
        self.instanceArn = instanceArn
    }
}

public struct DescribeAccountAssignmentDeletionStatusOutput: Swift.Sendable {
    /// The status object for the account assignment deletion operation.
    public var accountAssignmentDeletionStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus?

    public init(
        accountAssignmentDeletionStatus: SSOAdminClientTypes.AccountAssignmentOperationStatus? = nil
    )
    {
        self.accountAssignmentDeletionStatus = accountAssignmentDeletionStatus
    }
}

public struct DescribeApplicationInput: Swift.Sendable {
    /// Specifies the ARN of the application. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var applicationArn: Swift.String?

    public init(
        applicationArn: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
    }
}

public struct DescribeApplicationOutput: Swift.Sendable {
    /// The account ID.
    public var applicationAccount: Swift.String?
    /// Specifies the ARN of the application.
    public var applicationArn: Swift.String?
    /// The ARN of the application provider under which the operation will run.
    public var applicationProviderArn: Swift.String?
    /// The date the application was created.
    public var createdDate: Foundation.Date?
    /// The description of the .
    public var description: Swift.String?
    /// The ARN of the IAM Identity Center application under which the operation will run. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    public var instanceArn: Swift.String?
    /// The application name.
    public var name: Swift.String?
    /// A structure that describes the options for the portal associated with an application.
    public var portalOptions: SSOAdminClientTypes.PortalOptions?
    /// Specifies whether the application is enabled or disabled.
    public var status: SSOAdminClientTypes.ApplicationStatus?

    public init(
        applicationAccount: Swift.String? = nil,
        applicationArn: Swift.String? = nil,
        applicationProviderArn: Swift.String? = nil,
        createdDate: Foundation.Date? = nil,
        description: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        name: Swift.String? = nil,
        portalOptions: SSOAdminClientTypes.PortalOptions? = nil,
        status: SSOAdminClientTypes.ApplicationStatus? = nil
    )
    {
        self.applicationAccount = applicationAccount
        self.applicationArn = applicationArn
        self.applicationProviderArn = applicationProviderArn
        self.createdDate = createdDate
        self.description = description
        self.instanceArn = instanceArn
        self.name = name
        self.portalOptions = portalOptions
        self.status = status
    }
}

public struct DescribeApplicationAssignmentInput: Swift.Sendable {
    /// Specifies the ARN of the application. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// An identifier for an object in IAM Identity Center, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in IAM Identity Center, see the [IAM Identity Center Identity Store API Reference].
    /// This member is required.
    public var principalId: Swift.String?
    /// The entity type for which the assignment will be created.
    /// This member is required.
    public var principalType: SSOAdminClientTypes.PrincipalType?

    public init(
        applicationArn: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: SSOAdminClientTypes.PrincipalType? = nil
    )
    {
        self.applicationArn = applicationArn
        self.principalId = principalId
        self.principalType = principalType
    }
}

public struct DescribeApplicationAssignmentOutput: Swift.Sendable {
    /// Specifies the ARN of the application. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    public var applicationArn: Swift.String?
    /// An identifier for an object in IAM Identity Center, such as a user or group. PrincipalIds are GUIDs (For example, f81d4fae-7dec-11d0-a765-00a0c91e6bf6). For more information about PrincipalIds in IAM Identity Center, see the [IAM Identity Center Identity Store API Reference].
    public var principalId: Swift.String?
    /// The entity type for which the assignment will be created.
    public var principalType: SSOAdminClientTypes.PrincipalType?

    public init(
        applicationArn: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: SSOAdminClientTypes.PrincipalType? = nil
    )
    {
        self.applicationArn = applicationArn
        self.principalId = principalId
        self.principalType = principalType
    }
}

public struct DescribeApplicationProviderInput: Swift.Sendable {
    /// Specifies the ARN of the application provider for which you want details.
    /// This member is required.
    public var applicationProviderArn: Swift.String?

    public init(
        applicationProviderArn: Swift.String? = nil
    )
    {
        self.applicationProviderArn = applicationProviderArn
    }
}

public struct DescribeApplicationProviderOutput: Swift.Sendable {
    /// The ARN of the application provider.
    /// This member is required.
    public var applicationProviderArn: Swift.String?
    /// A structure with details about the display data for the application provider.
    public var displayData: SSOAdminClientTypes.DisplayData?
    /// The protocol used to federate to the application provider.
    public var federationProtocol: SSOAdminClientTypes.FederationProtocol?
    /// A structure with details about the receiving application.
    public var resourceServerConfig: SSOAdminClientTypes.ResourceServerConfig?

    public init(
        applicationProviderArn: Swift.String? = nil,
        displayData: SSOAdminClientTypes.DisplayData? = nil,
        federationProtocol: SSOAdminClientTypes.FederationProtocol? = nil,
        resourceServerConfig: SSOAdminClientTypes.ResourceServerConfig? = nil
    )
    {
        self.applicationProviderArn = applicationProviderArn
        self.displayData = displayData
        self.federationProtocol = federationProtocol
        self.resourceServerConfig = resourceServerConfig
    }
}

public struct DescribeInstanceInput: Swift.Sendable {
    /// The ARN of the instance of IAM Identity Center under which the operation will run.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
    }
}

extension SSOAdminClientTypes {

    public enum InstanceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case createInProgress
        case deleteInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceStatus] {
            return [
                .active,
                .createInProgress,
                .deleteInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .createInProgress: return "CREATE_IN_PROGRESS"
            case .deleteInProgress: return "DELETE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeInstanceOutput: Swift.Sendable {
    /// The date the instance was created.
    public var createdDate: Foundation.Date?
    /// The identifier of the identity store that is connected to the instance of IAM Identity Center.
    public var identityStoreId: Swift.String?
    /// The ARN of the instance of IAM Identity Center under which the operation will run. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    public var instanceArn: Swift.String?
    /// Specifies the instance name.
    public var name: Swift.String?
    /// The identifier of the Amazon Web Services account for which the instance was created.
    public var ownerAccountId: Swift.String?
    /// The status of the instance.
    public var status: SSOAdminClientTypes.InstanceStatus?

    public init(
        createdDate: Foundation.Date? = nil,
        identityStoreId: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        name: Swift.String? = nil,
        ownerAccountId: Swift.String? = nil,
        status: SSOAdminClientTypes.InstanceStatus? = nil
    )
    {
        self.createdDate = createdDate
        self.identityStoreId = identityStoreId
        self.instanceArn = instanceArn
        self.name = name
        self.ownerAccountId = ownerAccountId
        self.status = status
    }
}

public struct DescribeInstanceAccessControlAttributeConfigurationInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
    }
}

extension SSOAdminClientTypes {

    public enum InstanceAccessControlAttributeConfigurationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case creationFailed
        case creationInProgress
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceAccessControlAttributeConfigurationStatus] {
            return [
                .creationFailed,
                .creationInProgress,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .creationFailed: return "CREATION_FAILED"
            case .creationInProgress: return "CREATION_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeInstanceAccessControlAttributeConfigurationOutput: Swift.Sendable {
    /// Gets the list of IAM Identity Center identity store attributes that have been added to your ABAC configuration.
    public var instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration?
    /// The status of the attribute configuration process.
    public var status: SSOAdminClientTypes.InstanceAccessControlAttributeConfigurationStatus?
    /// Provides more details about the current status of the specified attribute.
    public var statusReason: Swift.String?

    public init(
        instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration? = nil,
        status: SSOAdminClientTypes.InstanceAccessControlAttributeConfigurationStatus? = nil,
        statusReason: Swift.String? = nil
    )
    {
        self.instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfiguration
        self.status = status
        self.statusReason = statusReason
    }
}

public struct DescribePermissionSetInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

public struct DescribePermissionSetOutput: Swift.Sendable {
    /// Describes the level of access on an Amazon Web Services account.
    public var permissionSet: SSOAdminClientTypes.PermissionSet?

    public init(
        permissionSet: SSOAdminClientTypes.PermissionSet? = nil
    )
    {
        self.permissionSet = permissionSet
    }
}

public struct DescribePermissionSetProvisioningStatusInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The identifier that is provided by the [ProvisionPermissionSet] call to retrieve the current status of the provisioning workflow.
    /// This member is required.
    public var provisionPermissionSetRequestId: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        provisionPermissionSetRequestId: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.provisionPermissionSetRequestId = provisionPermissionSetRequestId
    }
}

extension SSOAdminClientTypes {

    /// A structure that is used to provide the status of the provisioning operation for a specified permission set.
    public struct PermissionSetProvisioningStatus: Swift.Sendable {
        /// The identifier of the Amazon Web Services account from which to list the assignments.
        public var accountId: Swift.String?
        /// The date that the permission set was created.
        public var createdDate: Foundation.Date?
        /// The message that contains an error or exception in case of an operation failure.
        public var failureReason: Swift.String?
        /// The ARN of the permission set that is being provisioned. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var permissionSetArn: Swift.String?
        /// The identifier for tracking the request operation that is generated by the universally unique identifier (UUID) workflow.
        public var requestId: Swift.String?
        /// The status of the permission set provisioning process.
        public var status: SSOAdminClientTypes.StatusValues?

        public init(
            accountId: Swift.String? = nil,
            createdDate: Foundation.Date? = nil,
            failureReason: Swift.String? = nil,
            permissionSetArn: Swift.String? = nil,
            requestId: Swift.String? = nil,
            status: SSOAdminClientTypes.StatusValues? = nil
        )
        {
            self.accountId = accountId
            self.createdDate = createdDate
            self.failureReason = failureReason
            self.permissionSetArn = permissionSetArn
            self.requestId = requestId
            self.status = status
        }
    }
}

public struct DescribePermissionSetProvisioningStatusOutput: Swift.Sendable {
    /// The status object for the permission set provisioning operation.
    public var permissionSetProvisioningStatus: SSOAdminClientTypes.PermissionSetProvisioningStatus?

    public init(
        permissionSetProvisioningStatus: SSOAdminClientTypes.PermissionSetProvisioningStatus? = nil
    )
    {
        self.permissionSetProvisioningStatus = permissionSetProvisioningStatus
    }
}

public struct DescribeTrustedTokenIssuerInput: Swift.Sendable {
    /// Specifies the ARN of the trusted token issuer configuration that you want details about.
    /// This member is required.
    public var trustedTokenIssuerArn: Swift.String?

    public init(
        trustedTokenIssuerArn: Swift.String? = nil
    )
    {
        self.trustedTokenIssuerArn = trustedTokenIssuerArn
    }
}

public struct DescribeTrustedTokenIssuerOutput: Swift.Sendable {
    /// The name of the trusted token issuer configuration.
    public var name: Swift.String?
    /// The ARN of the trusted token issuer configuration.
    public var trustedTokenIssuerArn: Swift.String?
    /// A structure the describes the settings that apply of this trusted token issuer.
    public var trustedTokenIssuerConfiguration: SSOAdminClientTypes.TrustedTokenIssuerConfiguration?
    /// The type of the trusted token issuer.
    public var trustedTokenIssuerType: SSOAdminClientTypes.TrustedTokenIssuerType?

    public init(
        name: Swift.String? = nil,
        trustedTokenIssuerArn: Swift.String? = nil,
        trustedTokenIssuerConfiguration: SSOAdminClientTypes.TrustedTokenIssuerConfiguration? = nil,
        trustedTokenIssuerType: SSOAdminClientTypes.TrustedTokenIssuerType? = nil
    )
    {
        self.name = name
        self.trustedTokenIssuerArn = trustedTokenIssuerArn
        self.trustedTokenIssuerConfiguration = trustedTokenIssuerConfiguration
        self.trustedTokenIssuerType = trustedTokenIssuerType
    }
}

public struct DetachCustomerManagedPolicyReferenceFromPermissionSetInput: Swift.Sendable {
    /// Specifies the name and path of a customer managed policy. You must have an IAM policy that matches the name and path in each Amazon Web Services account where you want to deploy your permission set.
    /// This member is required.
    public var customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the PermissionSet.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference? = nil,
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.customerManagedPolicyReference = customerManagedPolicyReference
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

public struct DetachCustomerManagedPolicyReferenceFromPermissionSetOutput: Swift.Sendable {

    public init() { }
}

public struct DetachManagedPolicyFromPermissionSetInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The Amazon Web Services managed policy ARN to be detached from a permission set.
    /// This member is required.
    public var managedPolicyArn: Swift.String?
    /// The ARN of the [PermissionSet] from which the policy should be detached.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        managedPolicyArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.managedPolicyArn = managedPolicyArn
        self.permissionSetArn = permissionSetArn
    }
}

public struct DetachManagedPolicyFromPermissionSetOutput: Swift.Sendable {

    public init() { }
}

public struct GetApplicationAssignmentConfigurationInput: Swift.Sendable {
    /// Specifies the ARN of the application. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var applicationArn: Swift.String?

    public init(
        applicationArn: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
    }
}

public struct GetApplicationAssignmentConfigurationOutput: Swift.Sendable {
    /// If AssignmentsRequired is true (default value), users don’t have access to the application unless an assignment is created using the [CreateApplicationAssignment API](https://docs.aws.amazon.com/singlesignon/latest/APIReference/API_CreateApplicationAssignment.html). If false, all users have access to the application.
    /// This member is required.
    public var assignmentRequired: Swift.Bool?

    public init(
        assignmentRequired: Swift.Bool? = true
    )
    {
        self.assignmentRequired = assignmentRequired
    }
}

public struct GetInlinePolicyForPermissionSetInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

public struct GetInlinePolicyForPermissionSetOutput: Swift.Sendable {
    /// The inline policy that is attached to the permission set. For Length Constraints, if a valid ARN is provided for a permission set, it is possible for an empty inline policy to be returned.
    public var inlinePolicy: Swift.String?

    public init(
        inlinePolicy: Swift.String? = nil
    )
    {
        self.inlinePolicy = inlinePolicy
    }
}

public struct GetPermissionsBoundaryForPermissionSetInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the PermissionSet.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

extension SSOAdminClientTypes {

    /// Specifies the configuration of the Amazon Web Services managed or customer managed policy that you want to set as a permissions boundary. Specify either CustomerManagedPolicyReference to use the name and path of a customer managed policy, or ManagedPolicyArn to use the ARN of an Amazon Web Services managed policy. A permissions boundary represents the maximum permissions that any policy can grant your role. For more information, see [Permissions boundaries for IAM entities](https://docs.aws.amazon.com/IAM/latest/UserGuide/access_policies_boundaries.html) in the IAM User Guide. Policies used as permissions boundaries don't provide permissions. You must also attach an IAM policy to the role. To learn how the effective permissions for a role are evaluated, see [IAM JSON policy evaluation logic](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_policies_evaluation-logic.html) in the IAM User Guide.
    public struct PermissionsBoundary: Swift.Sendable {
        /// Specifies the name and path of a customer managed policy. You must have an IAM policy that matches the name and path in each Amazon Web Services account where you want to deploy your permission set.
        public var customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference?
        /// The Amazon Web Services managed policy ARN that you want to attach to a permission set as a permissions boundary.
        public var managedPolicyArn: Swift.String?

        public init(
            customerManagedPolicyReference: SSOAdminClientTypes.CustomerManagedPolicyReference? = nil,
            managedPolicyArn: Swift.String? = nil
        )
        {
            self.customerManagedPolicyReference = customerManagedPolicyReference
            self.managedPolicyArn = managedPolicyArn
        }
    }
}

public struct GetPermissionsBoundaryForPermissionSetOutput: Swift.Sendable {
    /// The permissions boundary attached to the specified permission set.
    public var permissionsBoundary: SSOAdminClientTypes.PermissionsBoundary?

    public init(
        permissionsBoundary: SSOAdminClientTypes.PermissionsBoundary? = nil
    )
    {
        self.permissionsBoundary = permissionsBoundary
    }
}

extension SSOAdminClientTypes {

    /// Provides information about the IAM Identity Center instance.
    public struct InstanceMetadata: Swift.Sendable {
        /// The date and time that the Identity Center instance was created.
        public var createdDate: Foundation.Date?
        /// The identifier of the identity store that is connected to the Identity Center instance.
        public var identityStoreId: Swift.String?
        /// The ARN of the Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
        public var instanceArn: Swift.String?
        /// The name of the Identity Center instance.
        public var name: Swift.String?
        /// The Amazon Web Services account ID number of the owner of the Identity Center instance.
        public var ownerAccountId: Swift.String?
        /// The current status of this Identity Center instance.
        public var status: SSOAdminClientTypes.InstanceStatus?

        public init(
            createdDate: Foundation.Date? = nil,
            identityStoreId: Swift.String? = nil,
            instanceArn: Swift.String? = nil,
            name: Swift.String? = nil,
            ownerAccountId: Swift.String? = nil,
            status: SSOAdminClientTypes.InstanceStatus? = nil
        )
        {
            self.createdDate = createdDate
            self.identityStoreId = identityStoreId
            self.instanceArn = instanceArn
            self.name = name
            self.ownerAccountId = ownerAccountId
            self.status = status
        }
    }
}

extension SSOAdminClientTypes {

    /// Filters the operation status list based on the passed attribute value.
    public struct OperationStatusFilter: Swift.Sendable {
        /// Filters the list operations result based on the status attribute.
        public var status: SSOAdminClientTypes.StatusValues?

        public init(
            status: SSOAdminClientTypes.StatusValues? = nil
        )
        {
            self.status = status
        }
    }
}

public struct ListAccountAssignmentCreationStatusInput: Swift.Sendable {
    /// Filters results based on the passed attribute value.
    public var filter: SSOAdminClientTypes.OperationStatusFilter?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        filter: SSOAdminClientTypes.OperationStatusFilter? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAccountAssignmentCreationStatusOutput: Swift.Sendable {
    /// The status object for the account assignment creation operation.
    public var accountAssignmentsCreationStatus: [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        accountAssignmentsCreationStatus: [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountAssignmentsCreationStatus = accountAssignmentsCreationStatus
        self.nextToken = nextToken
    }
}

public struct ListAccountAssignmentDeletionStatusInput: Swift.Sendable {
    /// Filters results based on the passed attribute value.
    public var filter: SSOAdminClientTypes.OperationStatusFilter?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        filter: SSOAdminClientTypes.OperationStatusFilter? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAccountAssignmentDeletionStatusOutput: Swift.Sendable {
    /// The status object for the account assignment deletion operation.
    public var accountAssignmentsDeletionStatus: [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        accountAssignmentsDeletionStatus: [SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountAssignmentsDeletionStatus = accountAssignmentsDeletionStatus
        self.nextToken = nextToken
    }
}

public struct ListAccountAssignmentsInput: Swift.Sendable {
    /// The identifier of the Amazon Web Services account from which to list the assignments.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The ARN of the permission set from which to list assignments.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionSetArn = permissionSetArn
    }
}

public struct ListAccountAssignmentsOutput: Swift.Sendable {
    /// The list of assignments that match the input Amazon Web Services account and permission set.
    public var accountAssignments: [SSOAdminClientTypes.AccountAssignment]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        accountAssignments: [SSOAdminClientTypes.AccountAssignment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountAssignments = accountAssignments
        self.nextToken = nextToken
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes a filter for account assignments.
    public struct ListAccountAssignmentsFilter: Swift.Sendable {
        /// The ID number of an Amazon Web Services account that filters the results in the response.
        public var accountId: Swift.String?

        public init(
            accountId: Swift.String? = nil
        )
        {
            self.accountId = accountId
        }
    }
}

public struct ListAccountAssignmentsForPrincipalInput: Swift.Sendable {
    /// Specifies an Amazon Web Services account ID number. Results are filtered to only those that match this ID number.
    public var filter: SSOAdminClientTypes.ListAccountAssignmentsFilter?
    /// Specifies the ARN of the instance of IAM Identity Center that contains the principal.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the principal for which you want to retrieve the list of account assignments.
    /// This member is required.
    public var principalId: Swift.String?
    /// Specifies the type of the principal.
    /// This member is required.
    public var principalType: SSOAdminClientTypes.PrincipalType?

    public init(
        filter: SSOAdminClientTypes.ListAccountAssignmentsFilter? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: SSOAdminClientTypes.PrincipalType? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalId = principalId
        self.principalType = principalType
    }
}

public struct ListAccountAssignmentsForPrincipalOutput: Swift.Sendable {
    /// An array list of the account assignments for the principal.
    public var accountAssignments: [SSOAdminClientTypes.AccountAssignmentForPrincipal]?
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?

    public init(
        accountAssignments: [SSOAdminClientTypes.AccountAssignmentForPrincipal]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountAssignments = accountAssignments
        self.nextToken = nextToken
    }
}

extension SSOAdminClientTypes {

    public enum ProvisioningStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case latestPermissionSetNotProvisioned
        case latestPermissionSetProvisioned
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisioningStatus] {
            return [
                .latestPermissionSetNotProvisioned,
                .latestPermissionSetProvisioned
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .latestPermissionSetNotProvisioned: return "LATEST_PERMISSION_SET_NOT_PROVISIONED"
            case .latestPermissionSetProvisioned: return "LATEST_PERMISSION_SET_PROVISIONED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListAccountsForProvisionedPermissionSetInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the [PermissionSet].
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The ARN of the [PermissionSet] from which the associated Amazon Web Services accounts will be listed.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// The permission set provisioning status for an Amazon Web Services account.
    public var provisioningStatus: SSOAdminClientTypes.ProvisioningStatus?

    public init(
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        provisioningStatus: SSOAdminClientTypes.ProvisioningStatus? = nil
    )
    {
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionSetArn = permissionSetArn
        self.provisioningStatus = provisioningStatus
    }
}

public struct ListAccountsForProvisionedPermissionSetOutput: Swift.Sendable {
    /// The list of Amazon Web Services AccountIds.
    public var accountIds: [Swift.String]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.nextToken = nextToken
    }
}

public struct ListApplicationAssignmentsInput: Swift.Sendable {
    /// Specifies the ARN of the application.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        applicationArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationArn = applicationArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListApplicationAssignmentsOutput: Swift.Sendable {
    /// The list of users assigned to an application.
    public var applicationAssignments: [SSOAdminClientTypes.ApplicationAssignment]?
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?

    public init(
        applicationAssignments: [SSOAdminClientTypes.ApplicationAssignment]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationAssignments = applicationAssignments
        self.nextToken = nextToken
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes a filter for application assignments.
    public struct ListApplicationAssignmentsFilter: Swift.Sendable {
        /// The ARN of an application.
        public var applicationArn: Swift.String?

        public init(
            applicationArn: Swift.String? = nil
        )
        {
            self.applicationArn = applicationArn
        }
    }
}

public struct ListApplicationAssignmentsForPrincipalInput: Swift.Sendable {
    /// Filters the output to include only assignments associated with the application that has the specified ARN.
    public var filter: SSOAdminClientTypes.ListApplicationAssignmentsFilter?
    /// Specifies the instance of IAM Identity Center that contains principal and applications.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the unique identifier of the principal for which you want to retrieve its assignments.
    /// This member is required.
    public var principalId: Swift.String?
    /// Specifies the type of the principal for which you want to retrieve its assignments.
    /// This member is required.
    public var principalType: SSOAdminClientTypes.PrincipalType?

    public init(
        filter: SSOAdminClientTypes.ListApplicationAssignmentsFilter? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        principalId: Swift.String? = nil,
        principalType: SSOAdminClientTypes.PrincipalType? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.principalId = principalId
        self.principalType = principalType
    }
}

public struct ListApplicationAssignmentsForPrincipalOutput: Swift.Sendable {
    /// An array list of the application assignments for the specified principal.
    public var applicationAssignments: [SSOAdminClientTypes.ApplicationAssignmentForPrincipal]?
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?

    public init(
        applicationAssignments: [SSOAdminClientTypes.ApplicationAssignmentForPrincipal]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationAssignments = applicationAssignments
        self.nextToken = nextToken
    }
}

public struct ListApplicationProvidersInput: Swift.Sendable {
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListApplicationProvidersOutput: Swift.Sendable {
    /// An array list of structures that describe application providers.
    public var applicationProviders: [SSOAdminClientTypes.ApplicationProvider]?
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?

    public init(
        applicationProviders: [SSOAdminClientTypes.ApplicationProvider]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationProviders = applicationProviders
        self.nextToken = nextToken
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes a filter for applications.
    public struct ListApplicationsFilter: Swift.Sendable {
        /// An Amazon Web Services account ID number that filters the results in the response.
        public var applicationAccount: Swift.String?
        /// The ARN of an application provider that can filter the results in the response.
        public var applicationProvider: Swift.String?

        public init(
            applicationAccount: Swift.String? = nil,
            applicationProvider: Swift.String? = nil
        )
        {
            self.applicationAccount = applicationAccount
            self.applicationProvider = applicationProvider
        }
    }
}

public struct ListApplicationsInput: Swift.Sendable {
    /// Filters response results.
    public var filter: SSOAdminClientTypes.ListApplicationsFilter?
    /// The ARN of the IAM Identity Center application under which the operation will run. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        filter: SSOAdminClientTypes.ListApplicationsFilter? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListApplicationsOutput: Swift.Sendable {
    /// Retrieves all applications associated with the instance.
    public var applications: [SSOAdminClientTypes.Application]?
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?

    public init(
        applications: [SSOAdminClientTypes.Application]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applications = applications
        self.nextToken = nextToken
    }
}

public struct ListCustomerManagedPolicyReferencesInPermissionSetInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the list call.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The ARN of the PermissionSet.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionSetArn = permissionSetArn
    }
}

public struct ListCustomerManagedPolicyReferencesInPermissionSetOutput: Swift.Sendable {
    /// Specifies the names and paths of the customer managed policies that you have attached to your permission set.
    public var customerManagedPolicyReferences: [SSOAdminClientTypes.CustomerManagedPolicyReference]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        customerManagedPolicyReferences: [SSOAdminClientTypes.CustomerManagedPolicyReference]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.customerManagedPolicyReferences = customerManagedPolicyReferences
        self.nextToken = nextToken
    }
}

public struct ListInstancesInput: Swift.Sendable {
    /// The maximum number of results to display for the instance.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListInstancesOutput: Swift.Sendable {
    /// Lists the IAM Identity Center instances that the caller has access to.
    public var instances: [SSOAdminClientTypes.InstanceMetadata]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        instances: [SSOAdminClientTypes.InstanceMetadata]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instances = instances
        self.nextToken = nextToken
    }
}

public struct ListManagedPoliciesInPermissionSetInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the [PermissionSet].
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The ARN of the [PermissionSet] whose managed policies will be listed.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionSetArn = permissionSetArn
    }
}

public struct ListManagedPoliciesInPermissionSetOutput: Swift.Sendable {
    /// An array of the [AttachedManagedPolicy] data type object.
    public var attachedManagedPolicies: [SSOAdminClientTypes.AttachedManagedPolicy]?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        attachedManagedPolicies: [SSOAdminClientTypes.AttachedManagedPolicy]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.attachedManagedPolicies = attachedManagedPolicies
        self.nextToken = nextToken
    }
}

public struct ListPermissionSetProvisioningStatusInput: Swift.Sendable {
    /// Filters results based on the passed attribute value.
    public var filter: SSOAdminClientTypes.OperationStatusFilter?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        filter: SSOAdminClientTypes.OperationStatusFilter? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSOAdminClientTypes {

    /// Provides information about the permission set provisioning status.
    public struct PermissionSetProvisioningStatusMetadata: Swift.Sendable {
        /// The date that the permission set was created.
        public var createdDate: Foundation.Date?
        /// The identifier for tracking the request operation that is generated by the universally unique identifier (UUID) workflow.
        public var requestId: Swift.String?
        /// The status of the permission set provisioning process.
        public var status: SSOAdminClientTypes.StatusValues?

        public init(
            createdDate: Foundation.Date? = nil,
            requestId: Swift.String? = nil,
            status: SSOAdminClientTypes.StatusValues? = nil
        )
        {
            self.createdDate = createdDate
            self.requestId = requestId
            self.status = status
        }
    }
}

public struct ListPermissionSetProvisioningStatusOutput: Swift.Sendable {
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The status object for the permission set provisioning operation.
    public var permissionSetsProvisioningStatus: [SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        permissionSetsProvisioningStatus: [SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissionSetsProvisioningStatus = permissionSetsProvisioningStatus
    }
}

public struct ListPermissionSetsInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListPermissionSetsOutput: Swift.Sendable {
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// Defines the level of access on an Amazon Web Services account.
    public var permissionSets: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        permissionSets: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissionSets = permissionSets
    }
}

public struct ListPermissionSetsProvisionedToAccountInput: Swift.Sendable {
    /// The identifier of the Amazon Web Services account from which to list the assignments.
    /// This member is required.
    public var accountId: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The maximum number of results to display for the assignment.
    public var maxResults: Swift.Int?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The status object for the permission set provisioning operation.
    public var provisioningStatus: SSOAdminClientTypes.ProvisioningStatus?

    public init(
        accountId: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        provisioningStatus: SSOAdminClientTypes.ProvisioningStatus? = nil
    )
    {
        self.accountId = accountId
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.provisioningStatus = provisioningStatus
    }
}

public struct ListPermissionSetsProvisionedToAccountOutput: Swift.Sendable {
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// Defines the level of access that an Amazon Web Services account has.
    public var permissionSets: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        permissionSets: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissionSets = permissionSets
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    public var instanceArn: Swift.String?
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// The ARN of the resource with the tags to be listed.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.nextToken = nextToken
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The pagination token for the list API. Initially the value is null. Use the output of previous API calls to make subsequent calls.
    public var nextToken: Swift.String?
    /// A set of key-value pairs that are used to manage the resource.
    public var tags: [SSOAdminClientTypes.Tag]?

    public init(
        nextToken: Swift.String? = nil,
        tags: [SSOAdminClientTypes.Tag]? = nil
    )
    {
        self.nextToken = nextToken
        self.tags = tags
    }
}

public struct ListTrustedTokenIssuersInput: Swift.Sendable {
    /// Specifies the ARN of the instance of IAM Identity Center with the trusted token issuer configurations that you want to list.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// Specifies the total number of results that you want included in each response. If additional items exist beyond the number you specify, the NextToken response element is returned with a value (not null). Include the specified value as the NextToken request parameter in the next call to the operation to get the next set of results. Note that the service might return fewer results than the maximum even when there are more results available. You should check NextToken after every operation to ensure that you receive all of the results.
    public var maxResults: Swift.Int?
    /// Specifies that you want to receive the next page of results. Valid only if you received a NextToken response in the previous request. If you did, it indicates that more output is available. Set this parameter to the value provided by the previous call's NextToken response to request the next page of results.
    public var nextToken: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes a trusted token issuer.
    public struct TrustedTokenIssuerMetadata: Swift.Sendable {
        /// The name of the trusted token issuer configuration in the instance of IAM Identity Center.
        public var name: Swift.String?
        /// The ARN of the trusted token issuer configuration in the instance of IAM Identity Center.
        public var trustedTokenIssuerArn: Swift.String?
        /// The type of trusted token issuer.
        public var trustedTokenIssuerType: SSOAdminClientTypes.TrustedTokenIssuerType?

        public init(
            name: Swift.String? = nil,
            trustedTokenIssuerArn: Swift.String? = nil,
            trustedTokenIssuerType: SSOAdminClientTypes.TrustedTokenIssuerType? = nil
        )
        {
            self.name = name
            self.trustedTokenIssuerArn = trustedTokenIssuerArn
            self.trustedTokenIssuerType = trustedTokenIssuerType
        }
    }
}

public struct ListTrustedTokenIssuersOutput: Swift.Sendable {
    /// If present, this value indicates that more output is available than is included in the current response. Use this value in the NextToken request parameter in a subsequent call to the operation to get the next part of the output. You should repeat this until the NextToken response element comes back as null. This indicates that this is the last page of results.
    public var nextToken: Swift.String?
    /// An array list of the trusted token issuer configurations.
    public var trustedTokenIssuers: [SSOAdminClientTypes.TrustedTokenIssuerMetadata]?

    public init(
        nextToken: Swift.String? = nil,
        trustedTokenIssuers: [SSOAdminClientTypes.TrustedTokenIssuerMetadata]? = nil
    )
    {
        self.nextToken = nextToken
        self.trustedTokenIssuers = trustedTokenIssuers
    }
}

extension SSOAdminClientTypes {

    /// A structure that describes updated configuration settings for a trusted token issuer that supports OpenID Connect (OIDC) and JSON Web Tokens (JWTs).
    public struct OidcJwtUpdateConfiguration: Swift.Sendable {
        /// The path of the source attribute in the JWT from the trusted token issuer. The attribute mapped by this JMESPath expression is compared against the attribute mapped by IdentityStoreAttributePath when a trusted token issuer token is exchanged for an IAM Identity Center token.
        public var claimAttributePath: Swift.String?
        /// The path of the destination attribute in a JWT from IAM Identity Center. The attribute mapped by this JMESPath expression is compared against the attribute mapped by ClaimAttributePath when a trusted token issuer token is exchanged for an IAM Identity Center token.
        public var identityStoreAttributePath: Swift.String?
        /// The method that the trusted token issuer can use to retrieve the JSON Web Key Set used to verify a JWT.
        public var jwksRetrievalOption: SSOAdminClientTypes.JwksRetrievalOption?

        public init(
            claimAttributePath: Swift.String? = nil,
            identityStoreAttributePath: Swift.String? = nil,
            jwksRetrievalOption: SSOAdminClientTypes.JwksRetrievalOption? = nil
        )
        {
            self.claimAttributePath = claimAttributePath
            self.identityStoreAttributePath = identityStoreAttributePath
            self.jwksRetrievalOption = jwksRetrievalOption
        }
    }
}

extension SSOAdminClientTypes {

    public enum ProvisionTargetType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allProvisionedAccounts
        case awsAccount
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionTargetType] {
            return [
                .allProvisionedAccounts,
                .awsAccount
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allProvisionedAccounts: return "ALL_PROVISIONED_ACCOUNTS"
            case .awsAccount: return "AWS_ACCOUNT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ProvisionPermissionSetInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// TargetID is an Amazon Web Services account identifier, (For example, 123456789012).
    public var targetId: Swift.String?
    /// The entity type for which the assignment will be created.
    /// This member is required.
    public var targetType: SSOAdminClientTypes.ProvisionTargetType?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        targetId: Swift.String? = nil,
        targetType: SSOAdminClientTypes.ProvisionTargetType? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.targetId = targetId
        self.targetType = targetType
    }
}

public struct ProvisionPermissionSetOutput: Swift.Sendable {
    /// The status object for the permission set provisioning operation.
    public var permissionSetProvisioningStatus: SSOAdminClientTypes.PermissionSetProvisioningStatus?

    public init(
        permissionSetProvisioningStatus: SSOAdminClientTypes.PermissionSetProvisioningStatus? = nil
    )
    {
        self.permissionSetProvisioningStatus = permissionSetProvisioningStatus
    }
}

public struct PutApplicationAssignmentConfigurationInput: Swift.Sendable {
    /// Specifies the ARN of the application. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// If AssignmentsRequired is true (default value), users don’t have access to the application unless an assignment is created using the [CreateApplicationAssignment API](https://docs.aws.amazon.com/singlesignon/latest/APIReference/API_CreateApplicationAssignment.html). If false, all users have access to the application.
    /// This member is required.
    public var assignmentRequired: Swift.Bool?

    public init(
        applicationArn: Swift.String? = nil,
        assignmentRequired: Swift.Bool? = true
    )
    {
        self.applicationArn = applicationArn
        self.assignmentRequired = assignmentRequired
    }
}

public struct PutApplicationAssignmentConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct PutInlinePolicyToPermissionSetInput: Swift.Sendable {
    /// The inline policy to attach to a [PermissionSet].
    /// This member is required.
    public var inlinePolicy: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set.
    /// This member is required.
    public var permissionSetArn: Swift.String?

    public init(
        inlinePolicy: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil
    )
    {
        self.inlinePolicy = inlinePolicy
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
    }
}

public struct PutInlinePolicyToPermissionSetOutput: Swift.Sendable {

    public init() { }
}

public struct PutPermissionsBoundaryToPermissionSetInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the PermissionSet.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// The permissions boundary that you want to attach to a PermissionSet.
    /// This member is required.
    public var permissionsBoundary: SSOAdminClientTypes.PermissionsBoundary?

    public init(
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        permissionsBoundary: SSOAdminClientTypes.PermissionsBoundary? = nil
    )
    {
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.permissionsBoundary = permissionsBoundary
    }
}

public struct PutPermissionsBoundaryToPermissionSetOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    public var instanceArn: Swift.String?
    /// The ARN of the resource with the tags to be listed.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A set of key-value pairs that are used to manage the resource.
    /// This member is required.
    public var tags: [SSOAdminClientTypes.Tag]?

    public init(
        instanceArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tags: [SSOAdminClientTypes.Tag]? = nil
    )
    {
        self.instanceArn = instanceArn
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    public var instanceArn: Swift.String?
    /// The ARN of the resource with the tags to be listed.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of tags that are attached to the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        instanceArn: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.instanceArn = instanceArn
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension SSOAdminClientTypes {

    /// A structure that describes the options for the access portal associated with an application that can be updated.
    public struct UpdateApplicationPortalOptions: Swift.Sendable {
        /// A structure that describes the sign-in options for an application portal.
        public var signInOptions: SSOAdminClientTypes.SignInOptions?

        public init(
            signInOptions: SSOAdminClientTypes.SignInOptions? = nil
        )
        {
            self.signInOptions = signInOptions
        }
    }
}

public struct UpdateApplicationInput: Swift.Sendable {
    /// Specifies the ARN of the application. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var applicationArn: Swift.String?
    /// The description of the .
    public var description: Swift.String?
    /// Specifies the updated name for the application.
    public var name: Swift.String?
    /// A structure that describes the options for the portal associated with an application.
    public var portalOptions: SSOAdminClientTypes.UpdateApplicationPortalOptions?
    /// Specifies whether the application is enabled or disabled.
    public var status: SSOAdminClientTypes.ApplicationStatus?

    public init(
        applicationArn: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        portalOptions: SSOAdminClientTypes.UpdateApplicationPortalOptions? = nil,
        status: SSOAdminClientTypes.ApplicationStatus? = nil
    )
    {
        self.applicationArn = applicationArn
        self.description = description
        self.name = name
        self.portalOptions = portalOptions
        self.status = status
    }
}

public struct UpdateApplicationOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateInstanceInput: Swift.Sendable {
    /// The ARN of the instance of IAM Identity Center under which the operation will run. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// Updates the instance name.
    /// This member is required.
    public var name: Swift.String?

    public init(
        instanceArn: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.instanceArn = instanceArn
        self.name = name
    }
}

public struct UpdateInstanceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateInstanceAccessControlAttributeConfigurationInput: Swift.Sendable {
    /// Updates the attributes for your ABAC configuration.
    /// This member is required.
    public var instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed.
    /// This member is required.
    public var instanceArn: Swift.String?

    public init(
        instanceAccessControlAttributeConfiguration: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration? = nil,
        instanceArn: Swift.String? = nil
    )
    {
        self.instanceAccessControlAttributeConfiguration = instanceAccessControlAttributeConfiguration
        self.instanceArn = instanceArn
    }
}

public struct UpdateInstanceAccessControlAttributeConfigurationOutput: Swift.Sendable {

    public init() { }
}

public struct UpdatePermissionSetInput: Swift.Sendable {
    /// The description of the [PermissionSet].
    public var description: Swift.String?
    /// The ARN of the IAM Identity Center instance under which the operation will be executed. For more information about ARNs, see [Amazon Resource Names (ARNs) and Amazon Web Services Service Namespaces] in the Amazon Web Services General Reference.
    /// This member is required.
    public var instanceArn: Swift.String?
    /// The ARN of the permission set.
    /// This member is required.
    public var permissionSetArn: Swift.String?
    /// Used to redirect users within the application during the federation authentication process.
    public var relayState: Swift.String?
    /// The length of time that the application user sessions are valid for in the ISO-8601 standard.
    public var sessionDuration: Swift.String?

    public init(
        description: Swift.String? = nil,
        instanceArn: Swift.String? = nil,
        permissionSetArn: Swift.String? = nil,
        relayState: Swift.String? = nil,
        sessionDuration: Swift.String? = nil
    )
    {
        self.description = description
        self.instanceArn = instanceArn
        self.permissionSetArn = permissionSetArn
        self.relayState = relayState
        self.sessionDuration = sessionDuration
    }
}

public struct UpdatePermissionSetOutput: Swift.Sendable {

    public init() { }
}

extension SSOAdminClientTypes {

    /// A structure that contains details to be updated for a trusted token issuer configuration. The structure and settings that you can include depend on the type of the trusted token issuer being updated.
    public enum TrustedTokenIssuerUpdateConfiguration: Swift.Sendable {
        /// A structure that describes an updated configuration for a trusted token issuer that uses OpenID Connect (OIDC) with JSON web tokens (JWT).
        case oidcjwtconfiguration(SSOAdminClientTypes.OidcJwtUpdateConfiguration)
        case sdkUnknown(Swift.String)
    }
}

public struct UpdateTrustedTokenIssuerInput: Swift.Sendable {
    /// Specifies the updated name to be applied to the trusted token issuer configuration.
    public var name: Swift.String?
    /// Specifies the ARN of the trusted token issuer configuration that you want to update.
    /// This member is required.
    public var trustedTokenIssuerArn: Swift.String?
    /// Specifies a structure with settings to apply to the specified trusted token issuer. The settings that you can provide are determined by the type of the trusted token issuer that you are updating.
    public var trustedTokenIssuerConfiguration: SSOAdminClientTypes.TrustedTokenIssuerUpdateConfiguration?

    public init(
        name: Swift.String? = nil,
        trustedTokenIssuerArn: Swift.String? = nil,
        trustedTokenIssuerConfiguration: SSOAdminClientTypes.TrustedTokenIssuerUpdateConfiguration? = nil
    )
    {
        self.name = name
        self.trustedTokenIssuerArn = trustedTokenIssuerArn
        self.trustedTokenIssuerConfiguration = trustedTokenIssuerConfiguration
    }
}

public struct UpdateTrustedTokenIssuerOutput: Swift.Sendable {

    public init() { }
}

extension AttachCustomerManagedPolicyReferenceToPermissionSetInput {

    static func urlPathProvider(_ value: AttachCustomerManagedPolicyReferenceToPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

extension AttachManagedPolicyToPermissionSetInput {

    static func urlPathProvider(_ value: AttachManagedPolicyToPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

extension CreateAccountAssignmentInput {

    static func urlPathProvider(_ value: CreateAccountAssignmentInput) -> Swift.String? {
        return "/"
    }
}

extension CreateApplicationInput {

    static func urlPathProvider(_ value: CreateApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateApplicationAssignmentInput {

    static func urlPathProvider(_ value: CreateApplicationAssignmentInput) -> Swift.String? {
        return "/"
    }
}

extension CreateInstanceInput {

    static func urlPathProvider(_ value: CreateInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension CreateInstanceAccessControlAttributeConfigurationInput {

    static func urlPathProvider(_ value: CreateInstanceAccessControlAttributeConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePermissionSetInput {

    static func urlPathProvider(_ value: CreatePermissionSetInput) -> Swift.String? {
        return "/"
    }
}

extension CreateTrustedTokenIssuerInput {

    static func urlPathProvider(_ value: CreateTrustedTokenIssuerInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteAccountAssignmentInput {

    static func urlPathProvider(_ value: DeleteAccountAssignmentInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApplicationInput {

    static func urlPathProvider(_ value: DeleteApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApplicationAccessScopeInput {

    static func urlPathProvider(_ value: DeleteApplicationAccessScopeInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApplicationAssignmentInput {

    static func urlPathProvider(_ value: DeleteApplicationAssignmentInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApplicationAuthenticationMethodInput {

    static func urlPathProvider(_ value: DeleteApplicationAuthenticationMethodInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteApplicationGrantInput {

    static func urlPathProvider(_ value: DeleteApplicationGrantInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteInlinePolicyFromPermissionSetInput {

    static func urlPathProvider(_ value: DeleteInlinePolicyFromPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteInstanceInput {

    static func urlPathProvider(_ value: DeleteInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteInstanceAccessControlAttributeConfigurationInput {

    static func urlPathProvider(_ value: DeleteInstanceAccessControlAttributeConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePermissionsBoundaryFromPermissionSetInput {

    static func urlPathProvider(_ value: DeletePermissionsBoundaryFromPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

extension DeletePermissionSetInput {

    static func urlPathProvider(_ value: DeletePermissionSetInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteTrustedTokenIssuerInput {

    static func urlPathProvider(_ value: DeleteTrustedTokenIssuerInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAccountAssignmentCreationStatusInput {

    static func urlPathProvider(_ value: DescribeAccountAssignmentCreationStatusInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeAccountAssignmentDeletionStatusInput {

    static func urlPathProvider(_ value: DescribeAccountAssignmentDeletionStatusInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeApplicationInput {

    static func urlPathProvider(_ value: DescribeApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeApplicationAssignmentInput {

    static func urlPathProvider(_ value: DescribeApplicationAssignmentInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeApplicationProviderInput {

    static func urlPathProvider(_ value: DescribeApplicationProviderInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeInstanceInput {

    static func urlPathProvider(_ value: DescribeInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeInstanceAccessControlAttributeConfigurationInput {

    static func urlPathProvider(_ value: DescribeInstanceAccessControlAttributeConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension DescribePermissionSetInput {

    static func urlPathProvider(_ value: DescribePermissionSetInput) -> Swift.String? {
        return "/"
    }
}

extension DescribePermissionSetProvisioningStatusInput {

    static func urlPathProvider(_ value: DescribePermissionSetProvisioningStatusInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeTrustedTokenIssuerInput {

    static func urlPathProvider(_ value: DescribeTrustedTokenIssuerInput) -> Swift.String? {
        return "/"
    }
}

extension DetachCustomerManagedPolicyReferenceFromPermissionSetInput {

    static func urlPathProvider(_ value: DetachCustomerManagedPolicyReferenceFromPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

extension DetachManagedPolicyFromPermissionSetInput {

    static func urlPathProvider(_ value: DetachManagedPolicyFromPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

extension GetApplicationAccessScopeInput {

    static func urlPathProvider(_ value: GetApplicationAccessScopeInput) -> Swift.String? {
        return "/"
    }
}

extension GetApplicationAssignmentConfigurationInput {

    static func urlPathProvider(_ value: GetApplicationAssignmentConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension GetApplicationAuthenticationMethodInput {

    static func urlPathProvider(_ value: GetApplicationAuthenticationMethodInput) -> Swift.String? {
        return "/"
    }
}

extension GetApplicationGrantInput {

    static func urlPathProvider(_ value: GetApplicationGrantInput) -> Swift.String? {
        return "/"
    }
}

extension GetInlinePolicyForPermissionSetInput {

    static func urlPathProvider(_ value: GetInlinePolicyForPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

extension GetPermissionsBoundaryForPermissionSetInput {

    static func urlPathProvider(_ value: GetPermissionsBoundaryForPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

extension ListAccountAssignmentCreationStatusInput {

    static func urlPathProvider(_ value: ListAccountAssignmentCreationStatusInput) -> Swift.String? {
        return "/"
    }
}

extension ListAccountAssignmentDeletionStatusInput {

    static func urlPathProvider(_ value: ListAccountAssignmentDeletionStatusInput) -> Swift.String? {
        return "/"
    }
}

extension ListAccountAssignmentsInput {

    static func urlPathProvider(_ value: ListAccountAssignmentsInput) -> Swift.String? {
        return "/"
    }
}

extension ListAccountAssignmentsForPrincipalInput {

    static func urlPathProvider(_ value: ListAccountAssignmentsForPrincipalInput) -> Swift.String? {
        return "/"
    }
}

extension ListAccountsForProvisionedPermissionSetInput {

    static func urlPathProvider(_ value: ListAccountsForProvisionedPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

extension ListApplicationAccessScopesInput {

    static func urlPathProvider(_ value: ListApplicationAccessScopesInput) -> Swift.String? {
        return "/"
    }
}

extension ListApplicationAssignmentsInput {

    static func urlPathProvider(_ value: ListApplicationAssignmentsInput) -> Swift.String? {
        return "/"
    }
}

extension ListApplicationAssignmentsForPrincipalInput {

    static func urlPathProvider(_ value: ListApplicationAssignmentsForPrincipalInput) -> Swift.String? {
        return "/"
    }
}

extension ListApplicationAuthenticationMethodsInput {

    static func urlPathProvider(_ value: ListApplicationAuthenticationMethodsInput) -> Swift.String? {
        return "/"
    }
}

extension ListApplicationGrantsInput {

    static func urlPathProvider(_ value: ListApplicationGrantsInput) -> Swift.String? {
        return "/"
    }
}

extension ListApplicationProvidersInput {

    static func urlPathProvider(_ value: ListApplicationProvidersInput) -> Swift.String? {
        return "/"
    }
}

extension ListApplicationsInput {

    static func urlPathProvider(_ value: ListApplicationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListCustomerManagedPolicyReferencesInPermissionSetInput {

    static func urlPathProvider(_ value: ListCustomerManagedPolicyReferencesInPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

extension ListInstancesInput {

    static func urlPathProvider(_ value: ListInstancesInput) -> Swift.String? {
        return "/"
    }
}

extension ListManagedPoliciesInPermissionSetInput {

    static func urlPathProvider(_ value: ListManagedPoliciesInPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

extension ListPermissionSetProvisioningStatusInput {

    static func urlPathProvider(_ value: ListPermissionSetProvisioningStatusInput) -> Swift.String? {
        return "/"
    }
}

extension ListPermissionSetsInput {

    static func urlPathProvider(_ value: ListPermissionSetsInput) -> Swift.String? {
        return "/"
    }
}

extension ListPermissionSetsProvisionedToAccountInput {

    static func urlPathProvider(_ value: ListPermissionSetsProvisionedToAccountInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListTrustedTokenIssuersInput {

    static func urlPathProvider(_ value: ListTrustedTokenIssuersInput) -> Swift.String? {
        return "/"
    }
}

extension ProvisionPermissionSetInput {

    static func urlPathProvider(_ value: ProvisionPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

extension PutApplicationAccessScopeInput {

    static func urlPathProvider(_ value: PutApplicationAccessScopeInput) -> Swift.String? {
        return "/"
    }
}

extension PutApplicationAssignmentConfigurationInput {

    static func urlPathProvider(_ value: PutApplicationAssignmentConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension PutApplicationAuthenticationMethodInput {

    static func urlPathProvider(_ value: PutApplicationAuthenticationMethodInput) -> Swift.String? {
        return "/"
    }
}

extension PutApplicationGrantInput {

    static func urlPathProvider(_ value: PutApplicationGrantInput) -> Swift.String? {
        return "/"
    }
}

extension PutInlinePolicyToPermissionSetInput {

    static func urlPathProvider(_ value: PutInlinePolicyToPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

extension PutPermissionsBoundaryToPermissionSetInput {

    static func urlPathProvider(_ value: PutPermissionsBoundaryToPermissionSetInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateApplicationInput {

    static func urlPathProvider(_ value: UpdateApplicationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateInstanceInput {

    static func urlPathProvider(_ value: UpdateInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateInstanceAccessControlAttributeConfigurationInput {

    static func urlPathProvider(_ value: UpdateInstanceAccessControlAttributeConfigurationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdatePermissionSetInput {

    static func urlPathProvider(_ value: UpdatePermissionSetInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateTrustedTokenIssuerInput {

    static func urlPathProvider(_ value: UpdateTrustedTokenIssuerInput) -> Swift.String? {
        return "/"
    }
}

extension AttachCustomerManagedPolicyReferenceToPermissionSetInput {

    static func write(value: AttachCustomerManagedPolicyReferenceToPermissionSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomerManagedPolicyReference"].write(value.customerManagedPolicyReference, with: SSOAdminClientTypes.CustomerManagedPolicyReference.write(value:to:))
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["PermissionSetArn"].write(value.permissionSetArn)
    }
}

extension AttachManagedPolicyToPermissionSetInput {

    static func write(value: AttachManagedPolicyToPermissionSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["ManagedPolicyArn"].write(value.managedPolicyArn)
        try writer["PermissionSetArn"].write(value.permissionSetArn)
    }
}

extension CreateAccountAssignmentInput {

    static func write(value: CreateAccountAssignmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["PermissionSetArn"].write(value.permissionSetArn)
        try writer["PrincipalId"].write(value.principalId)
        try writer["PrincipalType"].write(value.principalType)
        try writer["TargetId"].write(value.targetId)
        try writer["TargetType"].write(value.targetType)
    }
}

extension CreateApplicationInput {

    static func write(value: CreateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationProviderArn"].write(value.applicationProviderArn)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Description"].write(value.description)
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["Name"].write(value.name)
        try writer["PortalOptions"].write(value.portalOptions, with: SSOAdminClientTypes.PortalOptions.write(value:to:))
        try writer["Status"].write(value.status)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SSOAdminClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateApplicationAssignmentInput {

    static func write(value: CreateApplicationAssignmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["PrincipalId"].write(value.principalId)
        try writer["PrincipalType"].write(value.principalType)
    }
}

extension CreateInstanceInput {

    static func write(value: CreateInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SSOAdminClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateInstanceAccessControlAttributeConfigurationInput {

    static func write(value: CreateInstanceAccessControlAttributeConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceAccessControlAttributeConfiguration"].write(value.instanceAccessControlAttributeConfiguration, with: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration.write(value:to:))
        try writer["InstanceArn"].write(value.instanceArn)
    }
}

extension CreatePermissionSetInput {

    static func write(value: CreatePermissionSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["Name"].write(value.name)
        try writer["RelayState"].write(value.relayState)
        try writer["SessionDuration"].write(value.sessionDuration)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SSOAdminClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateTrustedTokenIssuerInput {

    static func write(value: CreateTrustedTokenIssuerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["Name"].write(value.name)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SSOAdminClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TrustedTokenIssuerConfiguration"].write(value.trustedTokenIssuerConfiguration, with: SSOAdminClientTypes.TrustedTokenIssuerConfiguration.write(value:to:))
        try writer["TrustedTokenIssuerType"].write(value.trustedTokenIssuerType)
    }
}

extension DeleteAccountAssignmentInput {

    static func write(value: DeleteAccountAssignmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["PermissionSetArn"].write(value.permissionSetArn)
        try writer["PrincipalId"].write(value.principalId)
        try writer["PrincipalType"].write(value.principalType)
        try writer["TargetId"].write(value.targetId)
        try writer["TargetType"].write(value.targetType)
    }
}

extension DeleteApplicationInput {

    static func write(value: DeleteApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
    }
}

extension DeleteApplicationAccessScopeInput {

    static func write(value: DeleteApplicationAccessScopeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["Scope"].write(value.scope)
    }
}

extension DeleteApplicationAssignmentInput {

    static func write(value: DeleteApplicationAssignmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["PrincipalId"].write(value.principalId)
        try writer["PrincipalType"].write(value.principalType)
    }
}

extension DeleteApplicationAuthenticationMethodInput {

    static func write(value: DeleteApplicationAuthenticationMethodInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["AuthenticationMethodType"].write(value.authenticationMethodType)
    }
}

extension DeleteApplicationGrantInput {

    static func write(value: DeleteApplicationGrantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["GrantType"].write(value.grantType)
    }
}

extension DeleteInlinePolicyFromPermissionSetInput {

    static func write(value: DeleteInlinePolicyFromPermissionSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["PermissionSetArn"].write(value.permissionSetArn)
    }
}

extension DeleteInstanceInput {

    static func write(value: DeleteInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
    }
}

extension DeleteInstanceAccessControlAttributeConfigurationInput {

    static func write(value: DeleteInstanceAccessControlAttributeConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
    }
}

extension DeletePermissionsBoundaryFromPermissionSetInput {

    static func write(value: DeletePermissionsBoundaryFromPermissionSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["PermissionSetArn"].write(value.permissionSetArn)
    }
}

extension DeletePermissionSetInput {

    static func write(value: DeletePermissionSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["PermissionSetArn"].write(value.permissionSetArn)
    }
}

extension DeleteTrustedTokenIssuerInput {

    static func write(value: DeleteTrustedTokenIssuerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TrustedTokenIssuerArn"].write(value.trustedTokenIssuerArn)
    }
}

extension DescribeAccountAssignmentCreationStatusInput {

    static func write(value: DescribeAccountAssignmentCreationStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountAssignmentCreationRequestId"].write(value.accountAssignmentCreationRequestId)
        try writer["InstanceArn"].write(value.instanceArn)
    }
}

extension DescribeAccountAssignmentDeletionStatusInput {

    static func write(value: DescribeAccountAssignmentDeletionStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountAssignmentDeletionRequestId"].write(value.accountAssignmentDeletionRequestId)
        try writer["InstanceArn"].write(value.instanceArn)
    }
}

extension DescribeApplicationInput {

    static func write(value: DescribeApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
    }
}

extension DescribeApplicationAssignmentInput {

    static func write(value: DescribeApplicationAssignmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["PrincipalId"].write(value.principalId)
        try writer["PrincipalType"].write(value.principalType)
    }
}

extension DescribeApplicationProviderInput {

    static func write(value: DescribeApplicationProviderInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationProviderArn"].write(value.applicationProviderArn)
    }
}

extension DescribeInstanceInput {

    static func write(value: DescribeInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
    }
}

extension DescribeInstanceAccessControlAttributeConfigurationInput {

    static func write(value: DescribeInstanceAccessControlAttributeConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
    }
}

extension DescribePermissionSetInput {

    static func write(value: DescribePermissionSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["PermissionSetArn"].write(value.permissionSetArn)
    }
}

extension DescribePermissionSetProvisioningStatusInput {

    static func write(value: DescribePermissionSetProvisioningStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["ProvisionPermissionSetRequestId"].write(value.provisionPermissionSetRequestId)
    }
}

extension DescribeTrustedTokenIssuerInput {

    static func write(value: DescribeTrustedTokenIssuerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TrustedTokenIssuerArn"].write(value.trustedTokenIssuerArn)
    }
}

extension DetachCustomerManagedPolicyReferenceFromPermissionSetInput {

    static func write(value: DetachCustomerManagedPolicyReferenceFromPermissionSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomerManagedPolicyReference"].write(value.customerManagedPolicyReference, with: SSOAdminClientTypes.CustomerManagedPolicyReference.write(value:to:))
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["PermissionSetArn"].write(value.permissionSetArn)
    }
}

extension DetachManagedPolicyFromPermissionSetInput {

    static func write(value: DetachManagedPolicyFromPermissionSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["ManagedPolicyArn"].write(value.managedPolicyArn)
        try writer["PermissionSetArn"].write(value.permissionSetArn)
    }
}

extension GetApplicationAccessScopeInput {

    static func write(value: GetApplicationAccessScopeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["Scope"].write(value.scope)
    }
}

extension GetApplicationAssignmentConfigurationInput {

    static func write(value: GetApplicationAssignmentConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
    }
}

extension GetApplicationAuthenticationMethodInput {

    static func write(value: GetApplicationAuthenticationMethodInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["AuthenticationMethodType"].write(value.authenticationMethodType)
    }
}

extension GetApplicationGrantInput {

    static func write(value: GetApplicationGrantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["GrantType"].write(value.grantType)
    }
}

extension GetInlinePolicyForPermissionSetInput {

    static func write(value: GetInlinePolicyForPermissionSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["PermissionSetArn"].write(value.permissionSetArn)
    }
}

extension GetPermissionsBoundaryForPermissionSetInput {

    static func write(value: GetPermissionsBoundaryForPermissionSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["PermissionSetArn"].write(value.permissionSetArn)
    }
}

extension ListAccountAssignmentCreationStatusInput {

    static func write(value: ListAccountAssignmentCreationStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: SSOAdminClientTypes.OperationStatusFilter.write(value:to:))
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListAccountAssignmentDeletionStatusInput {

    static func write(value: ListAccountAssignmentDeletionStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: SSOAdminClientTypes.OperationStatusFilter.write(value:to:))
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListAccountAssignmentsInput {

    static func write(value: ListAccountAssignmentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PermissionSetArn"].write(value.permissionSetArn)
    }
}

extension ListAccountAssignmentsForPrincipalInput {

    static func write(value: ListAccountAssignmentsForPrincipalInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: SSOAdminClientTypes.ListAccountAssignmentsFilter.write(value:to:))
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PrincipalId"].write(value.principalId)
        try writer["PrincipalType"].write(value.principalType)
    }
}

extension ListAccountsForProvisionedPermissionSetInput {

    static func write(value: ListAccountsForProvisionedPermissionSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PermissionSetArn"].write(value.permissionSetArn)
        try writer["ProvisioningStatus"].write(value.provisioningStatus)
    }
}

extension ListApplicationAccessScopesInput {

    static func write(value: ListApplicationAccessScopesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListApplicationAssignmentsInput {

    static func write(value: ListApplicationAssignmentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListApplicationAssignmentsForPrincipalInput {

    static func write(value: ListApplicationAssignmentsForPrincipalInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: SSOAdminClientTypes.ListApplicationAssignmentsFilter.write(value:to:))
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PrincipalId"].write(value.principalId)
        try writer["PrincipalType"].write(value.principalType)
    }
}

extension ListApplicationAuthenticationMethodsInput {

    static func write(value: ListApplicationAuthenticationMethodsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListApplicationGrantsInput {

    static func write(value: ListApplicationGrantsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListApplicationProvidersInput {

    static func write(value: ListApplicationProvidersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListApplicationsInput {

    static func write(value: ListApplicationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: SSOAdminClientTypes.ListApplicationsFilter.write(value:to:))
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListCustomerManagedPolicyReferencesInPermissionSetInput {

    static func write(value: ListCustomerManagedPolicyReferencesInPermissionSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PermissionSetArn"].write(value.permissionSetArn)
    }
}

extension ListInstancesInput {

    static func write(value: ListInstancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListManagedPoliciesInPermissionSetInput {

    static func write(value: ListManagedPoliciesInPermissionSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["PermissionSetArn"].write(value.permissionSetArn)
    }
}

extension ListPermissionSetProvisioningStatusInput {

    static func write(value: ListPermissionSetProvisioningStatusInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Filter"].write(value.filter, with: SSOAdminClientTypes.OperationStatusFilter.write(value:to:))
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListPermissionSetsInput {

    static func write(value: ListPermissionSetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListPermissionSetsProvisionedToAccountInput {

    static func write(value: ListPermissionSetsProvisionedToAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ProvisioningStatus"].write(value.provisioningStatus)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["NextToken"].write(value.nextToken)
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension ListTrustedTokenIssuersInput {

    static func write(value: ListTrustedTokenIssuersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ProvisionPermissionSetInput {

    static func write(value: ProvisionPermissionSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["PermissionSetArn"].write(value.permissionSetArn)
        try writer["TargetId"].write(value.targetId)
        try writer["TargetType"].write(value.targetType)
    }
}

extension PutApplicationAccessScopeInput {

    static func write(value: PutApplicationAccessScopeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["AuthorizedTargets"].writeList(value.authorizedTargets, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Scope"].write(value.scope)
    }
}

extension PutApplicationAssignmentConfigurationInput {

    static func write(value: PutApplicationAssignmentConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["AssignmentRequired"].write(value.assignmentRequired)
    }
}

extension PutApplicationAuthenticationMethodInput {

    static func write(value: PutApplicationAuthenticationMethodInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["AuthenticationMethod"].write(value.authenticationMethod, with: SSOAdminClientTypes.AuthenticationMethod.write(value:to:))
        try writer["AuthenticationMethodType"].write(value.authenticationMethodType)
    }
}

extension PutApplicationGrantInput {

    static func write(value: PutApplicationGrantInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["Grant"].write(value.grant, with: SSOAdminClientTypes.Grant.write(value:to:))
        try writer["GrantType"].write(value.grantType)
    }
}

extension PutInlinePolicyToPermissionSetInput {

    static func write(value: PutInlinePolicyToPermissionSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InlinePolicy"].write(value.inlinePolicy)
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["PermissionSetArn"].write(value.permissionSetArn)
    }
}

extension PutPermissionsBoundaryToPermissionSetInput {

    static func write(value: PutPermissionsBoundaryToPermissionSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["PermissionSetArn"].write(value.permissionSetArn)
        try writer["PermissionsBoundary"].write(value.permissionsBoundary, with: SSOAdminClientTypes.PermissionsBoundary.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: SSOAdminClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateApplicationInput {

    static func write(value: UpdateApplicationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
        try writer["Description"].write(value.description)
        try writer["Name"].write(value.name)
        try writer["PortalOptions"].write(value.portalOptions, with: SSOAdminClientTypes.UpdateApplicationPortalOptions.write(value:to:))
        try writer["Status"].write(value.status)
    }
}

extension UpdateInstanceInput {

    static func write(value: UpdateInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["Name"].write(value.name)
    }
}

extension UpdateInstanceAccessControlAttributeConfigurationInput {

    static func write(value: UpdateInstanceAccessControlAttributeConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceAccessControlAttributeConfiguration"].write(value.instanceAccessControlAttributeConfiguration, with: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration.write(value:to:))
        try writer["InstanceArn"].write(value.instanceArn)
    }
}

extension UpdatePermissionSetInput {

    static func write(value: UpdatePermissionSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["InstanceArn"].write(value.instanceArn)
        try writer["PermissionSetArn"].write(value.permissionSetArn)
        try writer["RelayState"].write(value.relayState)
        try writer["SessionDuration"].write(value.sessionDuration)
    }
}

extension UpdateTrustedTokenIssuerInput {

    static func write(value: UpdateTrustedTokenIssuerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["TrustedTokenIssuerArn"].write(value.trustedTokenIssuerArn)
        try writer["TrustedTokenIssuerConfiguration"].write(value.trustedTokenIssuerConfiguration, with: SSOAdminClientTypes.TrustedTokenIssuerUpdateConfiguration.write(value:to:))
    }
}

extension AttachCustomerManagedPolicyReferenceToPermissionSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AttachCustomerManagedPolicyReferenceToPermissionSetOutput {
        return AttachCustomerManagedPolicyReferenceToPermissionSetOutput()
    }
}

extension AttachManagedPolicyToPermissionSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AttachManagedPolicyToPermissionSetOutput {
        return AttachManagedPolicyToPermissionSetOutput()
    }
}

extension CreateAccountAssignmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAccountAssignmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAccountAssignmentOutput()
        value.accountAssignmentCreationStatus = try reader["AccountAssignmentCreationStatus"].readIfPresent(with: SSOAdminClientTypes.AccountAssignmentOperationStatus.read(from:))
        return value
    }
}

extension CreateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateApplicationOutput()
        value.applicationArn = try reader["ApplicationArn"].readIfPresent()
        return value
    }
}

extension CreateApplicationAssignmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateApplicationAssignmentOutput {
        return CreateApplicationAssignmentOutput()
    }
}

extension CreateInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateInstanceOutput()
        value.instanceArn = try reader["InstanceArn"].readIfPresent()
        return value
    }
}

extension CreateInstanceAccessControlAttributeConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateInstanceAccessControlAttributeConfigurationOutput {
        return CreateInstanceAccessControlAttributeConfigurationOutput()
    }
}

extension CreatePermissionSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePermissionSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePermissionSetOutput()
        value.permissionSet = try reader["PermissionSet"].readIfPresent(with: SSOAdminClientTypes.PermissionSet.read(from:))
        return value
    }
}

extension CreateTrustedTokenIssuerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateTrustedTokenIssuerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateTrustedTokenIssuerOutput()
        value.trustedTokenIssuerArn = try reader["TrustedTokenIssuerArn"].readIfPresent()
        return value
    }
}

extension DeleteAccountAssignmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccountAssignmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAccountAssignmentOutput()
        value.accountAssignmentDeletionStatus = try reader["AccountAssignmentDeletionStatus"].readIfPresent(with: SSOAdminClientTypes.AccountAssignmentOperationStatus.read(from:))
        return value
    }
}

extension DeleteApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationOutput {
        return DeleteApplicationOutput()
    }
}

extension DeleteApplicationAccessScopeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationAccessScopeOutput {
        return DeleteApplicationAccessScopeOutput()
    }
}

extension DeleteApplicationAssignmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationAssignmentOutput {
        return DeleteApplicationAssignmentOutput()
    }
}

extension DeleteApplicationAuthenticationMethodOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationAuthenticationMethodOutput {
        return DeleteApplicationAuthenticationMethodOutput()
    }
}

extension DeleteApplicationGrantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteApplicationGrantOutput {
        return DeleteApplicationGrantOutput()
    }
}

extension DeleteInlinePolicyFromPermissionSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInlinePolicyFromPermissionSetOutput {
        return DeleteInlinePolicyFromPermissionSetOutput()
    }
}

extension DeleteInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInstanceOutput {
        return DeleteInstanceOutput()
    }
}

extension DeleteInstanceAccessControlAttributeConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteInstanceAccessControlAttributeConfigurationOutput {
        return DeleteInstanceAccessControlAttributeConfigurationOutput()
    }
}

extension DeletePermissionsBoundaryFromPermissionSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePermissionsBoundaryFromPermissionSetOutput {
        return DeletePermissionsBoundaryFromPermissionSetOutput()
    }
}

extension DeletePermissionSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePermissionSetOutput {
        return DeletePermissionSetOutput()
    }
}

extension DeleteTrustedTokenIssuerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTrustedTokenIssuerOutput {
        return DeleteTrustedTokenIssuerOutput()
    }
}

extension DescribeAccountAssignmentCreationStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAccountAssignmentCreationStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAccountAssignmentCreationStatusOutput()
        value.accountAssignmentCreationStatus = try reader["AccountAssignmentCreationStatus"].readIfPresent(with: SSOAdminClientTypes.AccountAssignmentOperationStatus.read(from:))
        return value
    }
}

extension DescribeAccountAssignmentDeletionStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAccountAssignmentDeletionStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAccountAssignmentDeletionStatusOutput()
        value.accountAssignmentDeletionStatus = try reader["AccountAssignmentDeletionStatus"].readIfPresent(with: SSOAdminClientTypes.AccountAssignmentOperationStatus.read(from:))
        return value
    }
}

extension DescribeApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeApplicationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeApplicationOutput()
        value.applicationAccount = try reader["ApplicationAccount"].readIfPresent()
        value.applicationArn = try reader["ApplicationArn"].readIfPresent()
        value.applicationProviderArn = try reader["ApplicationProviderArn"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.description = try reader["Description"].readIfPresent()
        value.instanceArn = try reader["InstanceArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.portalOptions = try reader["PortalOptions"].readIfPresent(with: SSOAdminClientTypes.PortalOptions.read(from:))
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DescribeApplicationAssignmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeApplicationAssignmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeApplicationAssignmentOutput()
        value.applicationArn = try reader["ApplicationArn"].readIfPresent()
        value.principalId = try reader["PrincipalId"].readIfPresent()
        value.principalType = try reader["PrincipalType"].readIfPresent()
        return value
    }
}

extension DescribeApplicationProviderOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeApplicationProviderOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeApplicationProviderOutput()
        value.applicationProviderArn = try reader["ApplicationProviderArn"].readIfPresent() ?? ""
        value.displayData = try reader["DisplayData"].readIfPresent(with: SSOAdminClientTypes.DisplayData.read(from:))
        value.federationProtocol = try reader["FederationProtocol"].readIfPresent()
        value.resourceServerConfig = try reader["ResourceServerConfig"].readIfPresent(with: SSOAdminClientTypes.ResourceServerConfig.read(from:))
        return value
    }
}

extension DescribeInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInstanceOutput()
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.identityStoreId = try reader["IdentityStoreId"].readIfPresent()
        value.instanceArn = try reader["InstanceArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.ownerAccountId = try reader["OwnerAccountId"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension DescribeInstanceAccessControlAttributeConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeInstanceAccessControlAttributeConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeInstanceAccessControlAttributeConfigurationOutput()
        value.instanceAccessControlAttributeConfiguration = try reader["InstanceAccessControlAttributeConfiguration"].readIfPresent(with: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration.read(from:))
        value.status = try reader["Status"].readIfPresent()
        value.statusReason = try reader["StatusReason"].readIfPresent()
        return value
    }
}

extension DescribePermissionSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePermissionSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePermissionSetOutput()
        value.permissionSet = try reader["PermissionSet"].readIfPresent(with: SSOAdminClientTypes.PermissionSet.read(from:))
        return value
    }
}

extension DescribePermissionSetProvisioningStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePermissionSetProvisioningStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePermissionSetProvisioningStatusOutput()
        value.permissionSetProvisioningStatus = try reader["PermissionSetProvisioningStatus"].readIfPresent(with: SSOAdminClientTypes.PermissionSetProvisioningStatus.read(from:))
        return value
    }
}

extension DescribeTrustedTokenIssuerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTrustedTokenIssuerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTrustedTokenIssuerOutput()
        value.name = try reader["Name"].readIfPresent()
        value.trustedTokenIssuerArn = try reader["TrustedTokenIssuerArn"].readIfPresent()
        value.trustedTokenIssuerConfiguration = try reader["TrustedTokenIssuerConfiguration"].readIfPresent(with: SSOAdminClientTypes.TrustedTokenIssuerConfiguration.read(from:))
        value.trustedTokenIssuerType = try reader["TrustedTokenIssuerType"].readIfPresent()
        return value
    }
}

extension DetachCustomerManagedPolicyReferenceFromPermissionSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DetachCustomerManagedPolicyReferenceFromPermissionSetOutput {
        return DetachCustomerManagedPolicyReferenceFromPermissionSetOutput()
    }
}

extension DetachManagedPolicyFromPermissionSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DetachManagedPolicyFromPermissionSetOutput {
        return DetachManagedPolicyFromPermissionSetOutput()
    }
}

extension GetApplicationAccessScopeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApplicationAccessScopeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApplicationAccessScopeOutput()
        value.authorizedTargets = try reader["AuthorizedTargets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.scope = try reader["Scope"].readIfPresent() ?? ""
        return value
    }
}

extension GetApplicationAssignmentConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApplicationAssignmentConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApplicationAssignmentConfigurationOutput()
        value.assignmentRequired = try reader["AssignmentRequired"].readIfPresent() ?? true
        return value
    }
}

extension GetApplicationAuthenticationMethodOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApplicationAuthenticationMethodOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApplicationAuthenticationMethodOutput()
        value.authenticationMethod = try reader["AuthenticationMethod"].readIfPresent(with: SSOAdminClientTypes.AuthenticationMethod.read(from:))
        return value
    }
}

extension GetApplicationGrantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApplicationGrantOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApplicationGrantOutput()
        value.grant = try reader["Grant"].readIfPresent(with: SSOAdminClientTypes.Grant.read(from:))
        return value
    }
}

extension GetInlinePolicyForPermissionSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInlinePolicyForPermissionSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInlinePolicyForPermissionSetOutput()
        value.inlinePolicy = try reader["InlinePolicy"].readIfPresent()
        return value
    }
}

extension GetPermissionsBoundaryForPermissionSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPermissionsBoundaryForPermissionSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPermissionsBoundaryForPermissionSetOutput()
        value.permissionsBoundary = try reader["PermissionsBoundary"].readIfPresent(with: SSOAdminClientTypes.PermissionsBoundary.read(from:))
        return value
    }
}

extension ListAccountAssignmentCreationStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccountAssignmentCreationStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccountAssignmentCreationStatusOutput()
        value.accountAssignmentsCreationStatus = try reader["AccountAssignmentsCreationStatus"].readListIfPresent(memberReadingClosure: SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAccountAssignmentDeletionStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccountAssignmentDeletionStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccountAssignmentDeletionStatusOutput()
        value.accountAssignmentsDeletionStatus = try reader["AccountAssignmentsDeletionStatus"].readListIfPresent(memberReadingClosure: SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAccountAssignmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccountAssignmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccountAssignmentsOutput()
        value.accountAssignments = try reader["AccountAssignments"].readListIfPresent(memberReadingClosure: SSOAdminClientTypes.AccountAssignment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAccountAssignmentsForPrincipalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccountAssignmentsForPrincipalOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccountAssignmentsForPrincipalOutput()
        value.accountAssignments = try reader["AccountAssignments"].readListIfPresent(memberReadingClosure: SSOAdminClientTypes.AccountAssignmentForPrincipal.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListAccountsForProvisionedPermissionSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccountsForProvisionedPermissionSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccountsForProvisionedPermissionSetOutput()
        value.accountIds = try reader["AccountIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListApplicationAccessScopesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationAccessScopesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationAccessScopesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.scopes = try reader["Scopes"].readListIfPresent(memberReadingClosure: SSOAdminClientTypes.ScopeDetails.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListApplicationAssignmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationAssignmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationAssignmentsOutput()
        value.applicationAssignments = try reader["ApplicationAssignments"].readListIfPresent(memberReadingClosure: SSOAdminClientTypes.ApplicationAssignment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListApplicationAssignmentsForPrincipalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationAssignmentsForPrincipalOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationAssignmentsForPrincipalOutput()
        value.applicationAssignments = try reader["ApplicationAssignments"].readListIfPresent(memberReadingClosure: SSOAdminClientTypes.ApplicationAssignmentForPrincipal.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListApplicationAuthenticationMethodsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationAuthenticationMethodsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationAuthenticationMethodsOutput()
        value.authenticationMethods = try reader["AuthenticationMethods"].readListIfPresent(memberReadingClosure: SSOAdminClientTypes.AuthenticationMethodItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListApplicationGrantsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationGrantsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationGrantsOutput()
        value.grants = try reader["Grants"].readListIfPresent(memberReadingClosure: SSOAdminClientTypes.GrantItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListApplicationProvidersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationProvidersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationProvidersOutput()
        value.applicationProviders = try reader["ApplicationProviders"].readListIfPresent(memberReadingClosure: SSOAdminClientTypes.ApplicationProvider.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListApplicationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationsOutput()
        value.applications = try reader["Applications"].readListIfPresent(memberReadingClosure: SSOAdminClientTypes.Application.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListCustomerManagedPolicyReferencesInPermissionSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCustomerManagedPolicyReferencesInPermissionSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCustomerManagedPolicyReferencesInPermissionSetOutput()
        value.customerManagedPolicyReferences = try reader["CustomerManagedPolicyReferences"].readListIfPresent(memberReadingClosure: SSOAdminClientTypes.CustomerManagedPolicyReference.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInstancesOutput()
        value.instances = try reader["Instances"].readListIfPresent(memberReadingClosure: SSOAdminClientTypes.InstanceMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListManagedPoliciesInPermissionSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListManagedPoliciesInPermissionSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListManagedPoliciesInPermissionSetOutput()
        value.attachedManagedPolicies = try reader["AttachedManagedPolicies"].readListIfPresent(memberReadingClosure: SSOAdminClientTypes.AttachedManagedPolicy.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListPermissionSetProvisioningStatusOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPermissionSetProvisioningStatusOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPermissionSetProvisioningStatusOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.permissionSetsProvisioningStatus = try reader["PermissionSetsProvisioningStatus"].readListIfPresent(memberReadingClosure: SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPermissionSetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPermissionSetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPermissionSetsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.permissionSets = try reader["PermissionSets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListPermissionSetsProvisionedToAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPermissionSetsProvisionedToAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPermissionSetsProvisionedToAccountOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.permissionSets = try reader["PermissionSets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: SSOAdminClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTrustedTokenIssuersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTrustedTokenIssuersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTrustedTokenIssuersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.trustedTokenIssuers = try reader["TrustedTokenIssuers"].readListIfPresent(memberReadingClosure: SSOAdminClientTypes.TrustedTokenIssuerMetadata.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ProvisionPermissionSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ProvisionPermissionSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ProvisionPermissionSetOutput()
        value.permissionSetProvisioningStatus = try reader["PermissionSetProvisioningStatus"].readIfPresent(with: SSOAdminClientTypes.PermissionSetProvisioningStatus.read(from:))
        return value
    }
}

extension PutApplicationAccessScopeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutApplicationAccessScopeOutput {
        return PutApplicationAccessScopeOutput()
    }
}

extension PutApplicationAssignmentConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutApplicationAssignmentConfigurationOutput {
        return PutApplicationAssignmentConfigurationOutput()
    }
}

extension PutApplicationAuthenticationMethodOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutApplicationAuthenticationMethodOutput {
        return PutApplicationAuthenticationMethodOutput()
    }
}

extension PutApplicationGrantOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutApplicationGrantOutput {
        return PutApplicationGrantOutput()
    }
}

extension PutInlinePolicyToPermissionSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutInlinePolicyToPermissionSetOutput {
        return PutInlinePolicyToPermissionSetOutput()
    }
}

extension PutPermissionsBoundaryToPermissionSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutPermissionsBoundaryToPermissionSetOutput {
        return PutPermissionsBoundaryToPermissionSetOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateApplicationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApplicationOutput {
        return UpdateApplicationOutput()
    }
}

extension UpdateInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateInstanceOutput {
        return UpdateInstanceOutput()
    }
}

extension UpdateInstanceAccessControlAttributeConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateInstanceAccessControlAttributeConfigurationOutput {
        return UpdateInstanceAccessControlAttributeConfigurationOutput()
    }
}

extension UpdatePermissionSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePermissionSetOutput {
        return UpdatePermissionSetOutput()
    }
}

extension UpdateTrustedTokenIssuerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateTrustedTokenIssuerOutput {
        return UpdateTrustedTokenIssuerOutput()
    }
}

enum AttachCustomerManagedPolicyReferenceToPermissionSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AttachManagedPolicyToPermissionSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAccountAssignmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateApplicationAssignmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateInstanceAccessControlAttributeConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePermissionSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateTrustedTokenIssuerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccountAssignmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationAccessScopeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationAssignmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationAuthenticationMethodOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteApplicationGrantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInlinePolicyFromPermissionSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteInstanceAccessControlAttributeConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePermissionsBoundaryFromPermissionSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePermissionSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTrustedTokenIssuerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAccountAssignmentCreationStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAccountAssignmentDeletionStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeApplicationAssignmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeApplicationProviderOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeInstanceAccessControlAttributeConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePermissionSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePermissionSetProvisioningStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTrustedTokenIssuerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DetachCustomerManagedPolicyReferenceFromPermissionSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DetachManagedPolicyFromPermissionSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApplicationAccessScopeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApplicationAssignmentConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApplicationAuthenticationMethodOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApplicationGrantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInlinePolicyForPermissionSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPermissionsBoundaryForPermissionSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccountAssignmentCreationStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccountAssignmentDeletionStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccountAssignmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccountAssignmentsForPrincipalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccountsForProvisionedPermissionSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationAccessScopesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationAssignmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationAssignmentsForPrincipalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationAuthenticationMethodsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationGrantsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationProvidersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCustomerManagedPolicyReferencesInPermissionSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListManagedPoliciesInPermissionSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPermissionSetProvisioningStatusOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPermissionSetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPermissionSetsProvisionedToAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTrustedTokenIssuersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ProvisionPermissionSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutApplicationAccessScopeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutApplicationAssignmentConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutApplicationAuthenticationMethodOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutApplicationGrantOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutInlinePolicyToPermissionSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutPermissionsBoundaryToPermissionSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApplicationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateInstanceAccessControlAttributeConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePermissionSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateTrustedTokenIssuerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension SSOAdminClientTypes.AccountAssignmentOperationStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.AccountAssignmentOperationStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.AccountAssignmentOperationStatus()
        value.status = try reader["Status"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.targetId = try reader["TargetId"].readIfPresent()
        value.targetType = try reader["TargetType"].readIfPresent()
        value.permissionSetArn = try reader["PermissionSetArn"].readIfPresent()
        value.principalType = try reader["PrincipalType"].readIfPresent()
        value.principalId = try reader["PrincipalId"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension SSOAdminClientTypes.PermissionSet {

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.PermissionSet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.PermissionSet()
        value.name = try reader["Name"].readIfPresent()
        value.permissionSetArn = try reader["PermissionSetArn"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.sessionDuration = try reader["SessionDuration"].readIfPresent()
        value.relayState = try reader["RelayState"].readIfPresent()
        return value
    }
}

extension SSOAdminClientTypes.PortalOptions {

    static func write(value: SSOAdminClientTypes.PortalOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SignInOptions"].write(value.signInOptions, with: SSOAdminClientTypes.SignInOptions.write(value:to:))
        try writer["Visibility"].write(value.visibility)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.PortalOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.PortalOptions()
        value.signInOptions = try reader["SignInOptions"].readIfPresent(with: SSOAdminClientTypes.SignInOptions.read(from:))
        value.visibility = try reader["Visibility"].readIfPresent() ?? .enabled
        return value
    }
}

extension SSOAdminClientTypes.SignInOptions {

    static func write(value: SSOAdminClientTypes.SignInOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationUrl"].write(value.applicationUrl)
        try writer["Origin"].write(value.origin)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.SignInOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.SignInOptions()
        value.origin = try reader["Origin"].readIfPresent() ?? .sdkUnknown("")
        value.applicationUrl = try reader["ApplicationUrl"].readIfPresent()
        return value
    }
}

extension SSOAdminClientTypes.DisplayData {

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.DisplayData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.DisplayData()
        value.displayName = try reader["DisplayName"].readIfPresent()
        value.iconUrl = try reader["IconUrl"].readIfPresent()
        value.description = try reader["Description"].readIfPresent()
        return value
    }
}

extension SSOAdminClientTypes.ResourceServerConfig {

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.ResourceServerConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.ResourceServerConfig()
        value.scopes = try reader["Scopes"].readMapIfPresent(valueReadingClosure: SSOAdminClientTypes.ResourceServerScopeDetails.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension SSOAdminClientTypes.ResourceServerScopeDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.ResourceServerScopeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.ResourceServerScopeDetails()
        value.longDescription = try reader["LongDescription"].readIfPresent()
        value.detailedTitle = try reader["DetailedTitle"].readIfPresent()
        return value
    }
}

extension SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration {

    static func write(value: SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessControlAttributes"].writeList(value.accessControlAttributes, memberWritingClosure: SSOAdminClientTypes.AccessControlAttribute.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.InstanceAccessControlAttributeConfiguration()
        value.accessControlAttributes = try reader["AccessControlAttributes"].readListIfPresent(memberReadingClosure: SSOAdminClientTypes.AccessControlAttribute.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SSOAdminClientTypes.AccessControlAttribute {

    static func write(value: SSOAdminClientTypes.AccessControlAttribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value, with: SSOAdminClientTypes.AccessControlAttributeValue.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.AccessControlAttribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.AccessControlAttribute()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent(with: SSOAdminClientTypes.AccessControlAttributeValue.read(from:))
        return value
    }
}

extension SSOAdminClientTypes.AccessControlAttributeValue {

    static func write(value: SSOAdminClientTypes.AccessControlAttributeValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Source"].writeList(value.source, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.AccessControlAttributeValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.AccessControlAttributeValue()
        value.source = try reader["Source"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension SSOAdminClientTypes.PermissionSetProvisioningStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.PermissionSetProvisioningStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.PermissionSetProvisioningStatus()
        value.status = try reader["Status"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.permissionSetArn = try reader["PermissionSetArn"].readIfPresent()
        value.failureReason = try reader["FailureReason"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension SSOAdminClientTypes.TrustedTokenIssuerConfiguration {

    static func write(value: SSOAdminClientTypes.TrustedTokenIssuerConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .oidcjwtconfiguration(oidcjwtconfiguration):
                try writer["OidcJwtConfiguration"].write(oidcjwtconfiguration, with: SSOAdminClientTypes.OidcJwtConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.TrustedTokenIssuerConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "OidcJwtConfiguration":
                return .oidcjwtconfiguration(try reader["OidcJwtConfiguration"].read(with: SSOAdminClientTypes.OidcJwtConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension SSOAdminClientTypes.OidcJwtConfiguration {

    static func write(value: SSOAdminClientTypes.OidcJwtConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClaimAttributePath"].write(value.claimAttributePath)
        try writer["IdentityStoreAttributePath"].write(value.identityStoreAttributePath)
        try writer["IssuerUrl"].write(value.issuerUrl)
        try writer["JwksRetrievalOption"].write(value.jwksRetrievalOption)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.OidcJwtConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.OidcJwtConfiguration()
        value.issuerUrl = try reader["IssuerUrl"].readIfPresent() ?? ""
        value.claimAttributePath = try reader["ClaimAttributePath"].readIfPresent() ?? ""
        value.identityStoreAttributePath = try reader["IdentityStoreAttributePath"].readIfPresent() ?? ""
        value.jwksRetrievalOption = try reader["JwksRetrievalOption"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension SSOAdminClientTypes.AuthenticationMethod {

    static func write(value: SSOAdminClientTypes.AuthenticationMethod?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .iam(iam):
                try writer["Iam"].write(iam, with: SSOAdminClientTypes.IamAuthenticationMethod.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.AuthenticationMethod {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "Iam":
                return .iam(try reader["Iam"].read(with: SSOAdminClientTypes.IamAuthenticationMethod.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension SSOAdminClientTypes.IamAuthenticationMethod {

    static func write(value: SSOAdminClientTypes.IamAuthenticationMethod?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActorPolicy"].write(value.actorPolicy)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.IamAuthenticationMethod {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.IamAuthenticationMethod()
        value.actorPolicy = try reader["ActorPolicy"].readIfPresent() ?? [:]
        return value
    }
}

extension SSOAdminClientTypes.Grant {

    static func write(value: SSOAdminClientTypes.Grant?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .authorizationcode(authorizationcode):
                try writer["AuthorizationCode"].write(authorizationcode, with: SSOAdminClientTypes.AuthorizationCodeGrant.write(value:to:))
            case let .jwtbearer(jwtbearer):
                try writer["JwtBearer"].write(jwtbearer, with: SSOAdminClientTypes.JwtBearerGrant.write(value:to:))
            case let .refreshtoken(refreshtoken):
                try writer["RefreshToken"].write(refreshtoken, with: SSOAdminClientTypes.RefreshTokenGrant.write(value:to:))
            case let .tokenexchange(tokenexchange):
                try writer["TokenExchange"].write(tokenexchange, with: SSOAdminClientTypes.TokenExchangeGrant.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.Grant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "AuthorizationCode":
                return .authorizationcode(try reader["AuthorizationCode"].read(with: SSOAdminClientTypes.AuthorizationCodeGrant.read(from:)))
            case "JwtBearer":
                return .jwtbearer(try reader["JwtBearer"].read(with: SSOAdminClientTypes.JwtBearerGrant.read(from:)))
            case "RefreshToken":
                return .refreshtoken(try reader["RefreshToken"].read(with: SSOAdminClientTypes.RefreshTokenGrant.read(from:)))
            case "TokenExchange":
                return .tokenexchange(try reader["TokenExchange"].read(with: SSOAdminClientTypes.TokenExchangeGrant.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension SSOAdminClientTypes.TokenExchangeGrant {

    static func write(value: SSOAdminClientTypes.TokenExchangeGrant?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.TokenExchangeGrant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return SSOAdminClientTypes.TokenExchangeGrant()
    }
}

extension SSOAdminClientTypes.RefreshTokenGrant {

    static func write(value: SSOAdminClientTypes.RefreshTokenGrant?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.RefreshTokenGrant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return SSOAdminClientTypes.RefreshTokenGrant()
    }
}

extension SSOAdminClientTypes.JwtBearerGrant {

    static func write(value: SSOAdminClientTypes.JwtBearerGrant?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthorizedTokenIssuers"].writeList(value.authorizedTokenIssuers, memberWritingClosure: SSOAdminClientTypes.AuthorizedTokenIssuer.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.JwtBearerGrant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.JwtBearerGrant()
        value.authorizedTokenIssuers = try reader["AuthorizedTokenIssuers"].readListIfPresent(memberReadingClosure: SSOAdminClientTypes.AuthorizedTokenIssuer.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSOAdminClientTypes.AuthorizedTokenIssuer {

    static func write(value: SSOAdminClientTypes.AuthorizedTokenIssuer?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AuthorizedAudiences"].writeList(value.authorizedAudiences, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["TrustedTokenIssuerArn"].write(value.trustedTokenIssuerArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.AuthorizedTokenIssuer {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.AuthorizedTokenIssuer()
        value.trustedTokenIssuerArn = try reader["TrustedTokenIssuerArn"].readIfPresent()
        value.authorizedAudiences = try reader["AuthorizedAudiences"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSOAdminClientTypes.AuthorizationCodeGrant {

    static func write(value: SSOAdminClientTypes.AuthorizationCodeGrant?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RedirectUris"].writeList(value.redirectUris, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.AuthorizationCodeGrant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.AuthorizationCodeGrant()
        value.redirectUris = try reader["RedirectUris"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSOAdminClientTypes.PermissionsBoundary {

    static func write(value: SSOAdminClientTypes.PermissionsBoundary?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CustomerManagedPolicyReference"].write(value.customerManagedPolicyReference, with: SSOAdminClientTypes.CustomerManagedPolicyReference.write(value:to:))
        try writer["ManagedPolicyArn"].write(value.managedPolicyArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.PermissionsBoundary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.PermissionsBoundary()
        value.customerManagedPolicyReference = try reader["CustomerManagedPolicyReference"].readIfPresent(with: SSOAdminClientTypes.CustomerManagedPolicyReference.read(from:))
        value.managedPolicyArn = try reader["ManagedPolicyArn"].readIfPresent()
        return value
    }
}

extension SSOAdminClientTypes.CustomerManagedPolicyReference {

    static func write(value: SSOAdminClientTypes.CustomerManagedPolicyReference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["Path"].write(value.path)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.CustomerManagedPolicyReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.CustomerManagedPolicyReference()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.path = try reader["Path"].readIfPresent()
        return value
    }
}

extension SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.AccountAssignmentOperationStatusMetadata()
        value.status = try reader["Status"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension SSOAdminClientTypes.AccountAssignment {

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.AccountAssignment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.AccountAssignment()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.permissionSetArn = try reader["PermissionSetArn"].readIfPresent()
        value.principalType = try reader["PrincipalType"].readIfPresent()
        value.principalId = try reader["PrincipalId"].readIfPresent()
        return value
    }
}

extension SSOAdminClientTypes.AccountAssignmentForPrincipal {

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.AccountAssignmentForPrincipal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.AccountAssignmentForPrincipal()
        value.accountId = try reader["AccountId"].readIfPresent()
        value.permissionSetArn = try reader["PermissionSetArn"].readIfPresent()
        value.principalId = try reader["PrincipalId"].readIfPresent()
        value.principalType = try reader["PrincipalType"].readIfPresent()
        return value
    }
}

extension SSOAdminClientTypes.ScopeDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.ScopeDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.ScopeDetails()
        value.scope = try reader["Scope"].readIfPresent() ?? ""
        value.authorizedTargets = try reader["AuthorizedTargets"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension SSOAdminClientTypes.ApplicationAssignment {

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.ApplicationAssignment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.ApplicationAssignment()
        value.applicationArn = try reader["ApplicationArn"].readIfPresent() ?? ""
        value.principalId = try reader["PrincipalId"].readIfPresent() ?? ""
        value.principalType = try reader["PrincipalType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension SSOAdminClientTypes.ApplicationAssignmentForPrincipal {

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.ApplicationAssignmentForPrincipal {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.ApplicationAssignmentForPrincipal()
        value.applicationArn = try reader["ApplicationArn"].readIfPresent()
        value.principalId = try reader["PrincipalId"].readIfPresent()
        value.principalType = try reader["PrincipalType"].readIfPresent()
        return value
    }
}

extension SSOAdminClientTypes.AuthenticationMethodItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.AuthenticationMethodItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.AuthenticationMethodItem()
        value.authenticationMethodType = try reader["AuthenticationMethodType"].readIfPresent()
        value.authenticationMethod = try reader["AuthenticationMethod"].readIfPresent(with: SSOAdminClientTypes.AuthenticationMethod.read(from:))
        return value
    }
}

extension SSOAdminClientTypes.GrantItem {

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.GrantItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.GrantItem()
        value.grantType = try reader["GrantType"].readIfPresent() ?? .sdkUnknown("")
        value.grant = try reader["Grant"].readIfPresent(with: SSOAdminClientTypes.Grant.read(from:))
        return value
    }
}

extension SSOAdminClientTypes.ApplicationProvider {

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.ApplicationProvider {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.ApplicationProvider()
        value.applicationProviderArn = try reader["ApplicationProviderArn"].readIfPresent() ?? ""
        value.federationProtocol = try reader["FederationProtocol"].readIfPresent()
        value.displayData = try reader["DisplayData"].readIfPresent(with: SSOAdminClientTypes.DisplayData.read(from:))
        value.resourceServerConfig = try reader["ResourceServerConfig"].readIfPresent(with: SSOAdminClientTypes.ResourceServerConfig.read(from:))
        return value
    }
}

extension SSOAdminClientTypes.Application {

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.Application {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.Application()
        value.applicationArn = try reader["ApplicationArn"].readIfPresent()
        value.applicationProviderArn = try reader["ApplicationProviderArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.applicationAccount = try reader["ApplicationAccount"].readIfPresent()
        value.instanceArn = try reader["InstanceArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.portalOptions = try reader["PortalOptions"].readIfPresent(with: SSOAdminClientTypes.PortalOptions.read(from:))
        value.description = try reader["Description"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension SSOAdminClientTypes.InstanceMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.InstanceMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.InstanceMetadata()
        value.instanceArn = try reader["InstanceArn"].readIfPresent()
        value.identityStoreId = try reader["IdentityStoreId"].readIfPresent()
        value.ownerAccountId = try reader["OwnerAccountId"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["Status"].readIfPresent()
        return value
    }
}

extension SSOAdminClientTypes.AttachedManagedPolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.AttachedManagedPolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.AttachedManagedPolicy()
        value.name = try reader["Name"].readIfPresent()
        value.arn = try reader["Arn"].readIfPresent()
        return value
    }
}

extension SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.PermissionSetProvisioningStatusMetadata()
        value.status = try reader["Status"].readIfPresent()
        value.requestId = try reader["RequestId"].readIfPresent()
        value.createdDate = try reader["CreatedDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension SSOAdminClientTypes.Tag {

    static func write(value: SSOAdminClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension SSOAdminClientTypes.TrustedTokenIssuerMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> SSOAdminClientTypes.TrustedTokenIssuerMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = SSOAdminClientTypes.TrustedTokenIssuerMetadata()
        value.trustedTokenIssuerArn = try reader["TrustedTokenIssuerArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.trustedTokenIssuerType = try reader["TrustedTokenIssuerType"].readIfPresent()
        return value
    }
}

extension SSOAdminClientTypes.OperationStatusFilter {

    static func write(value: SSOAdminClientTypes.OperationStatusFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Status"].write(value.status)
    }
}

extension SSOAdminClientTypes.ListAccountAssignmentsFilter {

    static func write(value: SSOAdminClientTypes.ListAccountAssignmentsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
    }
}

extension SSOAdminClientTypes.ListApplicationAssignmentsFilter {

    static func write(value: SSOAdminClientTypes.ListApplicationAssignmentsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationArn"].write(value.applicationArn)
    }
}

extension SSOAdminClientTypes.ListApplicationsFilter {

    static func write(value: SSOAdminClientTypes.ListApplicationsFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ApplicationAccount"].write(value.applicationAccount)
        try writer["ApplicationProvider"].write(value.applicationProvider)
    }
}

extension SSOAdminClientTypes.UpdateApplicationPortalOptions {

    static func write(value: SSOAdminClientTypes.UpdateApplicationPortalOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["SignInOptions"].write(value.signInOptions, with: SSOAdminClientTypes.SignInOptions.write(value:to:))
    }
}

extension SSOAdminClientTypes.TrustedTokenIssuerUpdateConfiguration {

    static func write(value: SSOAdminClientTypes.TrustedTokenIssuerUpdateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .oidcjwtconfiguration(oidcjwtconfiguration):
                try writer["OidcJwtConfiguration"].write(oidcjwtconfiguration, with: SSOAdminClientTypes.OidcJwtUpdateConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension SSOAdminClientTypes.OidcJwtUpdateConfiguration {

    static func write(value: SSOAdminClientTypes.OidcJwtUpdateConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClaimAttributePath"].write(value.claimAttributePath)
        try writer["IdentityStoreAttributePath"].write(value.identityStoreAttributePath)
        try writer["JwksRetrievalOption"].write(value.jwksRetrievalOption)
    }
}

public enum SSOAdminClientTypes {}
