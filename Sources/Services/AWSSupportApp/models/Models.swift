// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You don't have sufficient permission to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SupportAppClientTypes {
    public enum AccountType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case management
        case member
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountType] {
            return [
                .management,
                .member,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .management: return "management"
            case .member: return "member"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountType(rawValue: rawValue) ?? AccountType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request has a conflict. For example, you might receive this error if you try the following:
///
/// * Add, update, or delete a Slack channel configuration before you add a Slack workspace to your Amazon Web Services account.
///
/// * Add a Slack channel configuration that already exists in your Amazon Web Services account.
///
/// * Delete a Slack channel configuration for a live chat channel.
///
/// * Delete a Slack workspace from your Amazon Web Services account that has an active live chat channel.
///
/// * Call the RegisterSlackWorkspaceForOrganization API from an Amazon Web Services account that doesn't belong to an organization.
///
/// * Call the RegisterSlackWorkspaceForOrganization API from a member account, but the management account hasn't registered that workspace yet for the organization.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateSlackChannelConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId
        case channelName
        case channelRoleArn
        case notifyOnAddCorrespondenceToCase
        case notifyOnCaseSeverity
        case notifyOnCreateOrReopenCase
        case notifyOnResolveCase
        case teamId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelId = self.channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelRoleArn = self.channelRoleArn {
            try encodeContainer.encode(channelRoleArn, forKey: .channelRoleArn)
        }
        if let notifyOnAddCorrespondenceToCase = self.notifyOnAddCorrespondenceToCase {
            try encodeContainer.encode(notifyOnAddCorrespondenceToCase, forKey: .notifyOnAddCorrespondenceToCase)
        }
        if let notifyOnCaseSeverity = self.notifyOnCaseSeverity {
            try encodeContainer.encode(notifyOnCaseSeverity.rawValue, forKey: .notifyOnCaseSeverity)
        }
        if let notifyOnCreateOrReopenCase = self.notifyOnCreateOrReopenCase {
            try encodeContainer.encode(notifyOnCreateOrReopenCase, forKey: .notifyOnCreateOrReopenCase)
        }
        if let notifyOnResolveCase = self.notifyOnResolveCase {
            try encodeContainer.encode(notifyOnResolveCase, forKey: .notifyOnResolveCase)
        }
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
    }
}

extension CreateSlackChannelConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/control/create-slack-channel-configuration"
    }
}

public struct CreateSlackChannelConfigurationInput: Swift.Equatable {
    /// The channel ID in Slack. This ID identifies a channel within a Slack workspace.
    /// This member is required.
    public var channelId: Swift.String?
    /// The name of the Slack channel that you configure for the Amazon Web Services Support App.
    public var channelName: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations on Amazon Web Services. For more information, see [Managing access to the Amazon Web Services Support App](https://docs.aws.amazon.com/awssupport/latest/user/support-app-permissions.html) in the Amazon Web Services Support User Guide.
    /// This member is required.
    public var channelRoleArn: Swift.String?
    /// Whether you want to get notified when a support case has a new correspondence.
    public var notifyOnAddCorrespondenceToCase: Swift.Bool?
    /// The case severity for a support case that you want to receive notifications. If you specify high or all, you must specify true for at least one of the following parameters:
    ///
    /// * notifyOnAddCorrespondenceToCase
    ///
    /// * notifyOnCreateOrReopenCase
    ///
    /// * notifyOnResolveCase
    ///
    ///
    /// If you specify none, the following parameters must be null or false:
    ///
    /// * notifyOnAddCorrespondenceToCase
    ///
    /// * notifyOnCreateOrReopenCase
    ///
    /// * notifyOnResolveCase
    ///
    ///
    /// If you don't specify these parameters in your request, they default to false.
    /// This member is required.
    public var notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel?
    /// Whether you want to get notified when a support case is created or reopened.
    public var notifyOnCreateOrReopenCase: Swift.Bool?
    /// Whether you want to get notified when a support case is resolved.
    public var notifyOnResolveCase: Swift.Bool?
    /// The team ID in Slack. This ID uniquely identifies a Slack workspace, such as T012ABCDEFG.
    /// This member is required.
    public var teamId: Swift.String?

    public init(
        channelId: Swift.String? = nil,
        channelName: Swift.String? = nil,
        channelRoleArn: Swift.String? = nil,
        notifyOnAddCorrespondenceToCase: Swift.Bool? = nil,
        notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel? = nil,
        notifyOnCreateOrReopenCase: Swift.Bool? = nil,
        notifyOnResolveCase: Swift.Bool? = nil,
        teamId: Swift.String? = nil
    )
    {
        self.channelId = channelId
        self.channelName = channelName
        self.channelRoleArn = channelRoleArn
        self.notifyOnAddCorrespondenceToCase = notifyOnAddCorrespondenceToCase
        self.notifyOnCaseSeverity = notifyOnCaseSeverity
        self.notifyOnCreateOrReopenCase = notifyOnCreateOrReopenCase
        self.notifyOnResolveCase = notifyOnResolveCase
        self.teamId = teamId
    }
}

struct CreateSlackChannelConfigurationInputBody: Swift.Equatable {
    let teamId: Swift.String?
    let channelId: Swift.String?
    let channelName: Swift.String?
    let notifyOnCreateOrReopenCase: Swift.Bool?
    let notifyOnAddCorrespondenceToCase: Swift.Bool?
    let notifyOnResolveCase: Swift.Bool?
    let notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel?
    let channelRoleArn: Swift.String?
}

extension CreateSlackChannelConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId
        case channelName
        case channelRoleArn
        case notifyOnAddCorrespondenceToCase
        case notifyOnCaseSeverity
        case notifyOnCreateOrReopenCase
        case notifyOnResolveCase
        case teamId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let notifyOnCreateOrReopenCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnCreateOrReopenCase)
        notifyOnCreateOrReopenCase = notifyOnCreateOrReopenCaseDecoded
        let notifyOnAddCorrespondenceToCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnAddCorrespondenceToCase)
        notifyOnAddCorrespondenceToCase = notifyOnAddCorrespondenceToCaseDecoded
        let notifyOnResolveCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnResolveCase)
        notifyOnResolveCase = notifyOnResolveCaseDecoded
        let notifyOnCaseSeverityDecoded = try containerValues.decodeIfPresent(SupportAppClientTypes.NotificationSeverityLevel.self, forKey: .notifyOnCaseSeverity)
        notifyOnCaseSeverity = notifyOnCaseSeverityDecoded
        let channelRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelRoleArn)
        channelRoleArn = channelRoleArnDecoded
    }
}

extension CreateSlackChannelConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateSlackChannelConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum CreateSlackChannelConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAccountAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/control/delete-account-alias"
    }
}

public struct DeleteAccountAliasInput: Swift.Equatable {

    public init() { }
}

struct DeleteAccountAliasInputBody: Swift.Equatable {
}

extension DeleteAccountAliasInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccountAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccountAliasOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccountAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSlackChannelConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId
        case teamId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelId = self.channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
    }
}

extension DeleteSlackChannelConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/control/delete-slack-channel-configuration"
    }
}

public struct DeleteSlackChannelConfigurationInput: Swift.Equatable {
    /// The channel ID in Slack. This ID identifies a channel within a Slack workspace.
    /// This member is required.
    public var channelId: Swift.String?
    /// The team ID in Slack. This ID uniquely identifies a Slack workspace, such as T012ABCDEFG.
    /// This member is required.
    public var teamId: Swift.String?

    public init(
        channelId: Swift.String? = nil,
        teamId: Swift.String? = nil
    )
    {
        self.channelId = channelId
        self.teamId = teamId
    }
}

struct DeleteSlackChannelConfigurationInputBody: Swift.Equatable {
    let teamId: Swift.String?
    let channelId: Swift.String?
}

extension DeleteSlackChannelConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId
        case teamId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
    }
}

extension DeleteSlackChannelConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSlackChannelConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSlackChannelConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSlackWorkspaceConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case teamId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
    }
}

extension DeleteSlackWorkspaceConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/control/delete-slack-workspace-configuration"
    }
}

public struct DeleteSlackWorkspaceConfigurationInput: Swift.Equatable {
    /// The team ID in Slack. This ID uniquely identifies a Slack workspace, such as T012ABCDEFG.
    /// This member is required.
    public var teamId: Swift.String?

    public init(
        teamId: Swift.String? = nil
    )
    {
        self.teamId = teamId
    }
}

struct DeleteSlackWorkspaceConfigurationInputBody: Swift.Equatable {
    let teamId: Swift.String?
}

extension DeleteSlackWorkspaceConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case teamId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
    }
}

extension DeleteSlackWorkspaceConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSlackWorkspaceConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSlackWorkspaceConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAccountAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/control/get-account-alias"
    }
}

public struct GetAccountAliasInput: Swift.Equatable {

    public init() { }
}

struct GetAccountAliasInputBody: Swift.Equatable {
}

extension GetAccountAliasInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAccountAliasOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountAlias = output.accountAlias
        } else {
            self.accountAlias = nil
        }
    }
}

public struct GetAccountAliasOutput: Swift.Equatable {
    /// An alias or short name for an Amazon Web Services account.
    public var accountAlias: Swift.String?

    public init(
        accountAlias: Swift.String? = nil
    )
    {
        self.accountAlias = accountAlias
    }
}

struct GetAccountAliasOutputBody: Swift.Equatable {
    let accountAlias: Swift.String?
}

extension GetAccountAliasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAlias
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountAlias)
        accountAlias = accountAliasDecoded
    }
}

enum GetAccountAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListSlackChannelConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSlackChannelConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/control/list-slack-channel-configurations"
    }
}

public struct ListSlackChannelConfigurationsInput: Swift.Equatable {
    /// If the results of a search are large, the API only returns a portion of the results and includes a nextToken pagination token in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When the API returns the last set of results, the response doesn't include a pagination token value.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListSlackChannelConfigurationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListSlackChannelConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSlackChannelConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSlackChannelConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.slackChannelConfigurations = output.slackChannelConfigurations
        } else {
            self.nextToken = nil
            self.slackChannelConfigurations = nil
        }
    }
}

public struct ListSlackChannelConfigurationsOutput: Swift.Equatable {
    /// The point where pagination should resume when the response returns only partial results.
    public var nextToken: Swift.String?
    /// The configurations for a Slack channel.
    /// This member is required.
    public var slackChannelConfigurations: [SupportAppClientTypes.SlackChannelConfiguration]?

    public init(
        nextToken: Swift.String? = nil,
        slackChannelConfigurations: [SupportAppClientTypes.SlackChannelConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.slackChannelConfigurations = slackChannelConfigurations
    }
}

struct ListSlackChannelConfigurationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let slackChannelConfigurations: [SupportAppClientTypes.SlackChannelConfiguration]?
}

extension ListSlackChannelConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case slackChannelConfigurations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let slackChannelConfigurationsContainer = try containerValues.decodeIfPresent([SupportAppClientTypes.SlackChannelConfiguration?].self, forKey: .slackChannelConfigurations)
        var slackChannelConfigurationsDecoded0:[SupportAppClientTypes.SlackChannelConfiguration]? = nil
        if let slackChannelConfigurationsContainer = slackChannelConfigurationsContainer {
            slackChannelConfigurationsDecoded0 = [SupportAppClientTypes.SlackChannelConfiguration]()
            for structure0 in slackChannelConfigurationsContainer {
                if let structure0 = structure0 {
                    slackChannelConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        slackChannelConfigurations = slackChannelConfigurationsDecoded0
    }
}

enum ListSlackChannelConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSlackWorkspaceConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSlackWorkspaceConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/control/list-slack-workspace-configurations"
    }
}

public struct ListSlackWorkspaceConfigurationsInput: Swift.Equatable {
    /// If the results of a search are large, the API only returns a portion of the results and includes a nextToken pagination token in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When the API returns the last set of results, the response doesn't include a pagination token value.
    public var nextToken: Swift.String?

    public init(
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListSlackWorkspaceConfigurationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListSlackWorkspaceConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSlackWorkspaceConfigurationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSlackWorkspaceConfigurationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.slackWorkspaceConfigurations = output.slackWorkspaceConfigurations
        } else {
            self.nextToken = nil
            self.slackWorkspaceConfigurations = nil
        }
    }
}

public struct ListSlackWorkspaceConfigurationsOutput: Swift.Equatable {
    /// The point where pagination should resume when the response returns only partial results.
    public var nextToken: Swift.String?
    /// The configurations for a Slack workspace.
    public var slackWorkspaceConfigurations: [SupportAppClientTypes.SlackWorkspaceConfiguration]?

    public init(
        nextToken: Swift.String? = nil,
        slackWorkspaceConfigurations: [SupportAppClientTypes.SlackWorkspaceConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.slackWorkspaceConfigurations = slackWorkspaceConfigurations
    }
}

struct ListSlackWorkspaceConfigurationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let slackWorkspaceConfigurations: [SupportAppClientTypes.SlackWorkspaceConfiguration]?
}

extension ListSlackWorkspaceConfigurationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case slackWorkspaceConfigurations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let slackWorkspaceConfigurationsContainer = try containerValues.decodeIfPresent([SupportAppClientTypes.SlackWorkspaceConfiguration?].self, forKey: .slackWorkspaceConfigurations)
        var slackWorkspaceConfigurationsDecoded0:[SupportAppClientTypes.SlackWorkspaceConfiguration]? = nil
        if let slackWorkspaceConfigurationsContainer = slackWorkspaceConfigurationsContainer {
            slackWorkspaceConfigurationsDecoded0 = [SupportAppClientTypes.SlackWorkspaceConfiguration]()
            for structure0 in slackWorkspaceConfigurationsContainer {
                if let structure0 = structure0 {
                    slackWorkspaceConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        slackWorkspaceConfigurations = slackWorkspaceConfigurationsDecoded0
    }
}

enum ListSlackWorkspaceConfigurationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SupportAppClientTypes {
    public enum NotificationSeverityLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case high
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationSeverityLevel] {
            return [
                .all,
                .high,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .high: return "high"
            case .none: return "none"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationSeverityLevel(rawValue: rawValue) ?? NotificationSeverityLevel.sdkUnknown(rawValue)
        }
    }
}

extension PutAccountAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAlias
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAlias = self.accountAlias {
            try encodeContainer.encode(accountAlias, forKey: .accountAlias)
        }
    }
}

extension PutAccountAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/control/put-account-alias"
    }
}

public struct PutAccountAliasInput: Swift.Equatable {
    /// An alias or short name for an Amazon Web Services account.
    /// This member is required.
    public var accountAlias: Swift.String?

    public init(
        accountAlias: Swift.String? = nil
    )
    {
        self.accountAlias = accountAlias
    }
}

struct PutAccountAliasInputBody: Swift.Equatable {
    let accountAlias: Swift.String?
}

extension PutAccountAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAlias
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountAlias)
        accountAlias = accountAliasDecoded
    }
}

extension PutAccountAliasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutAccountAliasOutput: Swift.Equatable {

    public init() { }
}

enum PutAccountAliasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RegisterSlackWorkspaceForOrganizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case teamId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
    }
}

extension RegisterSlackWorkspaceForOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/control/register-slack-workspace-for-organization"
    }
}

public struct RegisterSlackWorkspaceForOrganizationInput: Swift.Equatable {
    /// The team ID in Slack. This ID uniquely identifies a Slack workspace, such as T012ABCDEFG. Specify the Slack workspace that you want to use for your organization.
    /// This member is required.
    public var teamId: Swift.String?

    public init(
        teamId: Swift.String? = nil
    )
    {
        self.teamId = teamId
    }
}

struct RegisterSlackWorkspaceForOrganizationInputBody: Swift.Equatable {
    let teamId: Swift.String?
}

extension RegisterSlackWorkspaceForOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case teamId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
    }
}

extension RegisterSlackWorkspaceForOrganizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterSlackWorkspaceForOrganizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountType = output.accountType
            self.teamId = output.teamId
            self.teamName = output.teamName
        } else {
            self.accountType = nil
            self.teamId = nil
            self.teamName = nil
        }
    }
}

public struct RegisterSlackWorkspaceForOrganizationOutput: Swift.Equatable {
    /// Whether the Amazon Web Services account is a management or member account that's part of an organization in Organizations.
    public var accountType: SupportAppClientTypes.AccountType?
    /// The team ID in Slack. This ID uniquely identifies a Slack workspace, such as T012ABCDEFG.
    public var teamId: Swift.String?
    /// The name of the Slack workspace.
    public var teamName: Swift.String?

    public init(
        accountType: SupportAppClientTypes.AccountType? = nil,
        teamId: Swift.String? = nil,
        teamName: Swift.String? = nil
    )
    {
        self.accountType = accountType
        self.teamId = teamId
        self.teamName = teamName
    }
}

struct RegisterSlackWorkspaceForOrganizationOutputBody: Swift.Equatable {
    let teamId: Swift.String?
    let teamName: Swift.String?
    let accountType: SupportAppClientTypes.AccountType?
}

extension RegisterSlackWorkspaceForOrganizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountType
        case teamId
        case teamName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let teamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamName)
        teamName = teamNameDecoded
        let accountTypeDecoded = try containerValues.decodeIfPresent(SupportAppClientTypes.AccountType.self, forKey: .accountType)
        accountType = accountTypeDecoded
    }
}

enum RegisterSlackWorkspaceForOrganizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource is missing or doesn't exist, such as an account alias, Slack channel configuration, or Slack workspace configuration.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your Service Quotas request exceeds the quota for the service. For example, your Service Quotas request to Amazon Web Services Support App might exceed the maximum number of workspaces or channels per account, or the maximum number of accounts per Slack channel.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SupportAppClientTypes.SlackChannelConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId
        case channelName
        case channelRoleArn
        case notifyOnAddCorrespondenceToCase
        case notifyOnCaseSeverity
        case notifyOnCreateOrReopenCase
        case notifyOnResolveCase
        case teamId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelId = self.channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelRoleArn = self.channelRoleArn {
            try encodeContainer.encode(channelRoleArn, forKey: .channelRoleArn)
        }
        if let notifyOnAddCorrespondenceToCase = self.notifyOnAddCorrespondenceToCase {
            try encodeContainer.encode(notifyOnAddCorrespondenceToCase, forKey: .notifyOnAddCorrespondenceToCase)
        }
        if let notifyOnCaseSeverity = self.notifyOnCaseSeverity {
            try encodeContainer.encode(notifyOnCaseSeverity.rawValue, forKey: .notifyOnCaseSeverity)
        }
        if let notifyOnCreateOrReopenCase = self.notifyOnCreateOrReopenCase {
            try encodeContainer.encode(notifyOnCreateOrReopenCase, forKey: .notifyOnCreateOrReopenCase)
        }
        if let notifyOnResolveCase = self.notifyOnResolveCase {
            try encodeContainer.encode(notifyOnResolveCase, forKey: .notifyOnResolveCase)
        }
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let notifyOnCreateOrReopenCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnCreateOrReopenCase)
        notifyOnCreateOrReopenCase = notifyOnCreateOrReopenCaseDecoded
        let notifyOnAddCorrespondenceToCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnAddCorrespondenceToCase)
        notifyOnAddCorrespondenceToCase = notifyOnAddCorrespondenceToCaseDecoded
        let notifyOnResolveCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnResolveCase)
        notifyOnResolveCase = notifyOnResolveCaseDecoded
        let notifyOnCaseSeverityDecoded = try containerValues.decodeIfPresent(SupportAppClientTypes.NotificationSeverityLevel.self, forKey: .notifyOnCaseSeverity)
        notifyOnCaseSeverity = notifyOnCaseSeverityDecoded
        let channelRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelRoleArn)
        channelRoleArn = channelRoleArnDecoded
    }
}

extension SupportAppClientTypes {
    /// The configuration for a Slack channel that you added for your Amazon Web Services account.
    public struct SlackChannelConfiguration: Swift.Equatable {
        /// The channel ID in Slack. This ID identifies a channel within a Slack workspace.
        /// This member is required.
        public var channelId: Swift.String?
        /// The name of the Slack channel that you configured with the Amazon Web Services Support App for your Amazon Web Services account.
        public var channelName: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations on Amazon Web Services. For more information, see [Managing access to the Amazon Web Services Support App](https://docs.aws.amazon.com/awssupport/latest/user/support-app-permissions.html) in the Amazon Web Services Support User Guide.
        public var channelRoleArn: Swift.String?
        /// Whether you want to get notified when a support case has a new correspondence.
        public var notifyOnAddCorrespondenceToCase: Swift.Bool?
        /// The case severity for a support case that you want to receive notifications.
        public var notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel?
        /// Whether you want to get notified when a support case is created or reopened.
        public var notifyOnCreateOrReopenCase: Swift.Bool?
        /// Whether you want to get notified when a support case is resolved.
        public var notifyOnResolveCase: Swift.Bool?
        /// The team ID in Slack. This ID uniquely identifies a Slack workspace, such as T012ABCDEFG.
        /// This member is required.
        public var teamId: Swift.String?

        public init(
            channelId: Swift.String? = nil,
            channelName: Swift.String? = nil,
            channelRoleArn: Swift.String? = nil,
            notifyOnAddCorrespondenceToCase: Swift.Bool? = nil,
            notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel? = nil,
            notifyOnCreateOrReopenCase: Swift.Bool? = nil,
            notifyOnResolveCase: Swift.Bool? = nil,
            teamId: Swift.String? = nil
        )
        {
            self.channelId = channelId
            self.channelName = channelName
            self.channelRoleArn = channelRoleArn
            self.notifyOnAddCorrespondenceToCase = notifyOnAddCorrespondenceToCase
            self.notifyOnCaseSeverity = notifyOnCaseSeverity
            self.notifyOnCreateOrReopenCase = notifyOnCreateOrReopenCase
            self.notifyOnResolveCase = notifyOnResolveCase
            self.teamId = teamId
        }
    }

}

extension SupportAppClientTypes.SlackWorkspaceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowOrganizationMemberAccount
        case teamId
        case teamName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowOrganizationMemberAccount = self.allowOrganizationMemberAccount {
            try encodeContainer.encode(allowOrganizationMemberAccount, forKey: .allowOrganizationMemberAccount)
        }
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
        if let teamName = self.teamName {
            try encodeContainer.encode(teamName, forKey: .teamName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let teamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamName)
        teamName = teamNameDecoded
        let allowOrganizationMemberAccountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowOrganizationMemberAccount)
        allowOrganizationMemberAccount = allowOrganizationMemberAccountDecoded
    }
}

extension SupportAppClientTypes {
    /// The configuration for a Slack workspace that you added to an Amazon Web Services account.
    public struct SlackWorkspaceConfiguration: Swift.Equatable {
        /// Whether to allow member accounts to authorize Slack workspaces. Member accounts must be part of an organization in Organizations.
        public var allowOrganizationMemberAccount: Swift.Bool?
        /// The team ID in Slack. This ID uniquely identifies a Slack workspace, such as T012ABCDEFG.
        /// This member is required.
        public var teamId: Swift.String?
        /// The name of the Slack workspace.
        public var teamName: Swift.String?

        public init(
            allowOrganizationMemberAccount: Swift.Bool? = nil,
            teamId: Swift.String? = nil,
            teamName: Swift.String? = nil
        )
        {
            self.allowOrganizationMemberAccount = allowOrganizationMemberAccount
            self.teamId = teamId
            self.teamName = teamName
        }
    }

}

extension UpdateSlackChannelConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId
        case channelName
        case channelRoleArn
        case notifyOnAddCorrespondenceToCase
        case notifyOnCaseSeverity
        case notifyOnCreateOrReopenCase
        case notifyOnResolveCase
        case teamId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelId = self.channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelRoleArn = self.channelRoleArn {
            try encodeContainer.encode(channelRoleArn, forKey: .channelRoleArn)
        }
        if let notifyOnAddCorrespondenceToCase = self.notifyOnAddCorrespondenceToCase {
            try encodeContainer.encode(notifyOnAddCorrespondenceToCase, forKey: .notifyOnAddCorrespondenceToCase)
        }
        if let notifyOnCaseSeverity = self.notifyOnCaseSeverity {
            try encodeContainer.encode(notifyOnCaseSeverity.rawValue, forKey: .notifyOnCaseSeverity)
        }
        if let notifyOnCreateOrReopenCase = self.notifyOnCreateOrReopenCase {
            try encodeContainer.encode(notifyOnCreateOrReopenCase, forKey: .notifyOnCreateOrReopenCase)
        }
        if let notifyOnResolveCase = self.notifyOnResolveCase {
            try encodeContainer.encode(notifyOnResolveCase, forKey: .notifyOnResolveCase)
        }
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
    }
}

extension UpdateSlackChannelConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/control/update-slack-channel-configuration"
    }
}

public struct UpdateSlackChannelConfigurationInput: Swift.Equatable {
    /// The channel ID in Slack. This ID identifies a channel within a Slack workspace.
    /// This member is required.
    public var channelId: Swift.String?
    /// The Slack channel name that you want to update.
    public var channelName: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations on Amazon Web Services. For more information, see [Managing access to the Amazon Web Services Support App](https://docs.aws.amazon.com/awssupport/latest/user/support-app-permissions.html) in the Amazon Web Services Support User Guide.
    public var channelRoleArn: Swift.String?
    /// Whether you want to get notified when a support case has a new correspondence.
    public var notifyOnAddCorrespondenceToCase: Swift.Bool?
    /// The case severity for a support case that you want to receive notifications. If you specify high or all, at least one of the following parameters must be true:
    ///
    /// * notifyOnAddCorrespondenceToCase
    ///
    /// * notifyOnCreateOrReopenCase
    ///
    /// * notifyOnResolveCase
    ///
    ///
    /// If you specify none, any of the following parameters that you specify in your request must be false:
    ///
    /// * notifyOnAddCorrespondenceToCase
    ///
    /// * notifyOnCreateOrReopenCase
    ///
    /// * notifyOnResolveCase
    ///
    ///
    /// If you don't specify these parameters in your request, the Amazon Web Services Support App uses the current values by default.
    public var notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel?
    /// Whether you want to get notified when a support case is created or reopened.
    public var notifyOnCreateOrReopenCase: Swift.Bool?
    /// Whether you want to get notified when a support case is resolved.
    public var notifyOnResolveCase: Swift.Bool?
    /// The team ID in Slack. This ID uniquely identifies a Slack workspace, such as T012ABCDEFG.
    /// This member is required.
    public var teamId: Swift.String?

    public init(
        channelId: Swift.String? = nil,
        channelName: Swift.String? = nil,
        channelRoleArn: Swift.String? = nil,
        notifyOnAddCorrespondenceToCase: Swift.Bool? = nil,
        notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel? = nil,
        notifyOnCreateOrReopenCase: Swift.Bool? = nil,
        notifyOnResolveCase: Swift.Bool? = nil,
        teamId: Swift.String? = nil
    )
    {
        self.channelId = channelId
        self.channelName = channelName
        self.channelRoleArn = channelRoleArn
        self.notifyOnAddCorrespondenceToCase = notifyOnAddCorrespondenceToCase
        self.notifyOnCaseSeverity = notifyOnCaseSeverity
        self.notifyOnCreateOrReopenCase = notifyOnCreateOrReopenCase
        self.notifyOnResolveCase = notifyOnResolveCase
        self.teamId = teamId
    }
}

struct UpdateSlackChannelConfigurationInputBody: Swift.Equatable {
    let teamId: Swift.String?
    let channelId: Swift.String?
    let channelName: Swift.String?
    let notifyOnCreateOrReopenCase: Swift.Bool?
    let notifyOnAddCorrespondenceToCase: Swift.Bool?
    let notifyOnResolveCase: Swift.Bool?
    let notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel?
    let channelRoleArn: Swift.String?
}

extension UpdateSlackChannelConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId
        case channelName
        case channelRoleArn
        case notifyOnAddCorrespondenceToCase
        case notifyOnCaseSeverity
        case notifyOnCreateOrReopenCase
        case notifyOnResolveCase
        case teamId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let notifyOnCreateOrReopenCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnCreateOrReopenCase)
        notifyOnCreateOrReopenCase = notifyOnCreateOrReopenCaseDecoded
        let notifyOnAddCorrespondenceToCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnAddCorrespondenceToCase)
        notifyOnAddCorrespondenceToCase = notifyOnAddCorrespondenceToCaseDecoded
        let notifyOnResolveCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnResolveCase)
        notifyOnResolveCase = notifyOnResolveCaseDecoded
        let notifyOnCaseSeverityDecoded = try containerValues.decodeIfPresent(SupportAppClientTypes.NotificationSeverityLevel.self, forKey: .notifyOnCaseSeverity)
        notifyOnCaseSeverity = notifyOnCaseSeverityDecoded
        let channelRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelRoleArn)
        channelRoleArn = channelRoleArnDecoded
    }
}

extension UpdateSlackChannelConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSlackChannelConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.channelId = output.channelId
            self.channelName = output.channelName
            self.channelRoleArn = output.channelRoleArn
            self.notifyOnAddCorrespondenceToCase = output.notifyOnAddCorrespondenceToCase
            self.notifyOnCaseSeverity = output.notifyOnCaseSeverity
            self.notifyOnCreateOrReopenCase = output.notifyOnCreateOrReopenCase
            self.notifyOnResolveCase = output.notifyOnResolveCase
            self.teamId = output.teamId
        } else {
            self.channelId = nil
            self.channelName = nil
            self.channelRoleArn = nil
            self.notifyOnAddCorrespondenceToCase = nil
            self.notifyOnCaseSeverity = nil
            self.notifyOnCreateOrReopenCase = nil
            self.notifyOnResolveCase = nil
            self.teamId = nil
        }
    }
}

public struct UpdateSlackChannelConfigurationOutput: Swift.Equatable {
    /// The channel ID in Slack. This ID identifies a channel within a Slack workspace.
    public var channelId: Swift.String?
    /// The name of the Slack channel that you configure for the Amazon Web Services Support App.
    public var channelName: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations on Amazon Web Services. For more information, see [Managing access to the Amazon Web Services Support App](https://docs.aws.amazon.com/awssupport/latest/user/support-app-permissions.html) in the Amazon Web Services Support User Guide.
    public var channelRoleArn: Swift.String?
    /// Whether you want to get notified when a support case has a new correspondence.
    public var notifyOnAddCorrespondenceToCase: Swift.Bool?
    /// The case severity for a support case that you want to receive notifications.
    public var notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel?
    /// Whether you want to get notified when a support case is created or reopened.
    public var notifyOnCreateOrReopenCase: Swift.Bool?
    /// Whether you want to get notified when a support case is resolved.
    public var notifyOnResolveCase: Swift.Bool?
    /// The team ID in Slack. This ID uniquely identifies a Slack workspace, such as T012ABCDEFG.
    public var teamId: Swift.String?

    public init(
        channelId: Swift.String? = nil,
        channelName: Swift.String? = nil,
        channelRoleArn: Swift.String? = nil,
        notifyOnAddCorrespondenceToCase: Swift.Bool? = nil,
        notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel? = nil,
        notifyOnCreateOrReopenCase: Swift.Bool? = nil,
        notifyOnResolveCase: Swift.Bool? = nil,
        teamId: Swift.String? = nil
    )
    {
        self.channelId = channelId
        self.channelName = channelName
        self.channelRoleArn = channelRoleArn
        self.notifyOnAddCorrespondenceToCase = notifyOnAddCorrespondenceToCase
        self.notifyOnCaseSeverity = notifyOnCaseSeverity
        self.notifyOnCreateOrReopenCase = notifyOnCreateOrReopenCase
        self.notifyOnResolveCase = notifyOnResolveCase
        self.teamId = teamId
    }
}

struct UpdateSlackChannelConfigurationOutputBody: Swift.Equatable {
    let teamId: Swift.String?
    let channelId: Swift.String?
    let channelName: Swift.String?
    let notifyOnCreateOrReopenCase: Swift.Bool?
    let notifyOnAddCorrespondenceToCase: Swift.Bool?
    let notifyOnResolveCase: Swift.Bool?
    let notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel?
    let channelRoleArn: Swift.String?
}

extension UpdateSlackChannelConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId
        case channelName
        case channelRoleArn
        case notifyOnAddCorrespondenceToCase
        case notifyOnCaseSeverity
        case notifyOnCreateOrReopenCase
        case notifyOnResolveCase
        case teamId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let notifyOnCreateOrReopenCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnCreateOrReopenCase)
        notifyOnCreateOrReopenCase = notifyOnCreateOrReopenCaseDecoded
        let notifyOnAddCorrespondenceToCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnAddCorrespondenceToCase)
        notifyOnAddCorrespondenceToCase = notifyOnAddCorrespondenceToCaseDecoded
        let notifyOnResolveCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnResolveCase)
        notifyOnResolveCase = notifyOnResolveCaseDecoded
        let notifyOnCaseSeverityDecoded = try containerValues.decodeIfPresent(SupportAppClientTypes.NotificationSeverityLevel.self, forKey: .notifyOnCaseSeverity)
        notifyOnCaseSeverity = notifyOnCaseSeverityDecoded
        let channelRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelRoleArn)
        channelRoleArn = channelRoleArnDecoded
    }
}

enum UpdateSlackChannelConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request input doesn't meet the constraints that the Amazon Web Services Support App specifies.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
