// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You don't have sufficient permission to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SupportAppClientTypes {
    public enum AccountType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case management
        case member
        case sdkUnknown(Swift.String)

        public static var allCases: [AccountType] {
            return [
                .management,
                .member,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .management: return "management"
            case .member: return "member"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccountType(rawValue: rawValue) ?? AccountType.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request has a conflict. For example, you might receive this error if you try the following:
///
/// * Add, update, or delete a Slack channel configuration before you add a Slack workspace to your Amazon Web Services account.
///
/// * Add a Slack channel configuration that already exists in your Amazon Web Services account.
///
/// * Delete a Slack channel configuration for a live chat channel.
///
/// * Delete a Slack workspace from your Amazon Web Services account that has an active live chat channel.
///
/// * Call the RegisterSlackWorkspaceForOrganization API from an Amazon Web Services account that doesn't belong to an organization.
///
/// * Call the RegisterSlackWorkspaceForOrganization API from a member account, but the management account hasn't registered that workspace yet for the organization.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateSlackChannelConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId
        case channelName
        case channelRoleArn
        case notifyOnAddCorrespondenceToCase
        case notifyOnCaseSeverity
        case notifyOnCreateOrReopenCase
        case notifyOnResolveCase
        case teamId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelId = self.channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelRoleArn = self.channelRoleArn {
            try encodeContainer.encode(channelRoleArn, forKey: .channelRoleArn)
        }
        if let notifyOnAddCorrespondenceToCase = self.notifyOnAddCorrespondenceToCase {
            try encodeContainer.encode(notifyOnAddCorrespondenceToCase, forKey: .notifyOnAddCorrespondenceToCase)
        }
        if let notifyOnCaseSeverity = self.notifyOnCaseSeverity {
            try encodeContainer.encode(notifyOnCaseSeverity.rawValue, forKey: .notifyOnCaseSeverity)
        }
        if let notifyOnCreateOrReopenCase = self.notifyOnCreateOrReopenCase {
            try encodeContainer.encode(notifyOnCreateOrReopenCase, forKey: .notifyOnCreateOrReopenCase)
        }
        if let notifyOnResolveCase = self.notifyOnResolveCase {
            try encodeContainer.encode(notifyOnResolveCase, forKey: .notifyOnResolveCase)
        }
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
    }
}

extension CreateSlackChannelConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/control/create-slack-channel-configuration"
    }
}

public struct CreateSlackChannelConfigurationInput: Swift.Equatable {
    /// The channel ID in Slack. This ID identifies a channel within a Slack workspace.
    /// This member is required.
    public var channelId: Swift.String?
    /// The name of the Slack channel that you configure for the Amazon Web Services Support App.
    public var channelName: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations on Amazon Web Services. For more information, see [Managing access to the Amazon Web Services Support App](https://docs.aws.amazon.com/awssupport/latest/user/support-app-permissions.html) in the Amazon Web Services Support User Guide.
    /// This member is required.
    public var channelRoleArn: Swift.String?
    /// Whether you want to get notified when a support case has a new correspondence.
    public var notifyOnAddCorrespondenceToCase: Swift.Bool?
    /// The case severity for a support case that you want to receive notifications. If you specify high or all, you must specify true for at least one of the following parameters:
    ///
    /// * notifyOnAddCorrespondenceToCase
    ///
    /// * notifyOnCreateOrReopenCase
    ///
    /// * notifyOnResolveCase
    ///
    ///
    /// If you specify none, the following parameters must be null or false:
    ///
    /// * notifyOnAddCorrespondenceToCase
    ///
    /// * notifyOnCreateOrReopenCase
    ///
    /// * notifyOnResolveCase
    ///
    ///
    /// If you don't specify these parameters in your request, they default to false.
    /// This member is required.
    public var notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel?
    /// Whether you want to get notified when a support case is created or reopened.
    public var notifyOnCreateOrReopenCase: Swift.Bool?
    /// Whether you want to get notified when a support case is resolved.
    public var notifyOnResolveCase: Swift.Bool?
    /// The team ID in Slack. This ID uniquely identifies a Slack workspace, such as T012ABCDEFG.
    /// This member is required.
    public var teamId: Swift.String?

    public init (
        channelId: Swift.String? = nil,
        channelName: Swift.String? = nil,
        channelRoleArn: Swift.String? = nil,
        notifyOnAddCorrespondenceToCase: Swift.Bool? = nil,
        notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel? = nil,
        notifyOnCreateOrReopenCase: Swift.Bool? = nil,
        notifyOnResolveCase: Swift.Bool? = nil,
        teamId: Swift.String? = nil
    )
    {
        self.channelId = channelId
        self.channelName = channelName
        self.channelRoleArn = channelRoleArn
        self.notifyOnAddCorrespondenceToCase = notifyOnAddCorrespondenceToCase
        self.notifyOnCaseSeverity = notifyOnCaseSeverity
        self.notifyOnCreateOrReopenCase = notifyOnCreateOrReopenCase
        self.notifyOnResolveCase = notifyOnResolveCase
        self.teamId = teamId
    }
}

struct CreateSlackChannelConfigurationInputBody: Swift.Equatable {
    let teamId: Swift.String?
    let channelId: Swift.String?
    let channelName: Swift.String?
    let notifyOnCreateOrReopenCase: Swift.Bool?
    let notifyOnAddCorrespondenceToCase: Swift.Bool?
    let notifyOnResolveCase: Swift.Bool?
    let notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel?
    let channelRoleArn: Swift.String?
}

extension CreateSlackChannelConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId
        case channelName
        case channelRoleArn
        case notifyOnAddCorrespondenceToCase
        case notifyOnCaseSeverity
        case notifyOnCreateOrReopenCase
        case notifyOnResolveCase
        case teamId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let notifyOnCreateOrReopenCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnCreateOrReopenCase)
        notifyOnCreateOrReopenCase = notifyOnCreateOrReopenCaseDecoded
        let notifyOnAddCorrespondenceToCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnAddCorrespondenceToCase)
        notifyOnAddCorrespondenceToCase = notifyOnAddCorrespondenceToCaseDecoded
        let notifyOnResolveCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnResolveCase)
        notifyOnResolveCase = notifyOnResolveCaseDecoded
        let notifyOnCaseSeverityDecoded = try containerValues.decodeIfPresent(SupportAppClientTypes.NotificationSeverityLevel.self, forKey: .notifyOnCaseSeverity)
        notifyOnCaseSeverity = notifyOnCaseSeverityDecoded
        let channelRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelRoleArn)
        channelRoleArn = channelRoleArnDecoded
    }
}

extension CreateSlackChannelConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSlackChannelConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSlackChannelConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSlackChannelConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateSlackChannelConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteAccountAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/control/delete-account-alias"
    }
}

public struct DeleteAccountAliasInput: Swift.Equatable {

    public init () { }
}

struct DeleteAccountAliasInputBody: Swift.Equatable {
}

extension DeleteAccountAliasInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccountAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteAccountAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteAccountAliasOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteAccountAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteAccountAliasOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSlackChannelConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId
        case teamId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelId = self.channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
    }
}

extension DeleteSlackChannelConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/control/delete-slack-channel-configuration"
    }
}

public struct DeleteSlackChannelConfigurationInput: Swift.Equatable {
    /// The channel ID in Slack. This ID identifies a channel within a Slack workspace.
    /// This member is required.
    public var channelId: Swift.String?
    /// The team ID in Slack. This ID uniquely identifies a Slack workspace, such as T012ABCDEFG.
    /// This member is required.
    public var teamId: Swift.String?

    public init (
        channelId: Swift.String? = nil,
        teamId: Swift.String? = nil
    )
    {
        self.channelId = channelId
        self.teamId = teamId
    }
}

struct DeleteSlackChannelConfigurationInputBody: Swift.Equatable {
    let teamId: Swift.String?
    let channelId: Swift.String?
}

extension DeleteSlackChannelConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId
        case teamId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
    }
}

extension DeleteSlackChannelConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSlackChannelConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSlackChannelConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSlackChannelConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSlackChannelConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSlackWorkspaceConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case teamId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
    }
}

extension DeleteSlackWorkspaceConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/control/delete-slack-workspace-configuration"
    }
}

public struct DeleteSlackWorkspaceConfigurationInput: Swift.Equatable {
    /// The team ID in Slack. This ID uniquely identifies a Slack workspace, such as T012ABCDEFG.
    /// This member is required.
    public var teamId: Swift.String?

    public init (
        teamId: Swift.String? = nil
    )
    {
        self.teamId = teamId
    }
}

struct DeleteSlackWorkspaceConfigurationInputBody: Swift.Equatable {
    let teamId: Swift.String?
}

extension DeleteSlackWorkspaceConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case teamId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
    }
}

extension DeleteSlackWorkspaceConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSlackWorkspaceConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSlackWorkspaceConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSlackWorkspaceConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSlackWorkspaceConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension GetAccountAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/control/get-account-alias"
    }
}

public struct GetAccountAliasInput: Swift.Equatable {

    public init () { }
}

struct GetAccountAliasInputBody: Swift.Equatable {
}

extension GetAccountAliasInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAccountAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAccountAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAccountAliasOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAccountAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAccountAliasOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountAlias = output.accountAlias
        } else {
            self.accountAlias = nil
        }
    }
}

public struct GetAccountAliasOutputResponse: Swift.Equatable {
    /// An alias or short name for an Amazon Web Services account.
    public var accountAlias: Swift.String?

    public init (
        accountAlias: Swift.String? = nil
    )
    {
        self.accountAlias = accountAlias
    }
}

struct GetAccountAliasOutputResponseBody: Swift.Equatable {
    let accountAlias: Swift.String?
}

extension GetAccountAliasOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAlias
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountAlias)
        accountAlias = accountAliasDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// We can’t process your request right now because of a server issue. Try again later.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListSlackChannelConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSlackChannelConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/control/list-slack-channel-configurations"
    }
}

public struct ListSlackChannelConfigurationsInput: Swift.Equatable {
    /// If the results of a search are large, the API only returns a portion of the results and includes a nextToken pagination token in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When the API returns the last set of results, the response doesn't include a pagination token value.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListSlackChannelConfigurationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListSlackChannelConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSlackChannelConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSlackChannelConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSlackChannelConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSlackChannelConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSlackChannelConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.slackChannelConfigurations = output.slackChannelConfigurations
        } else {
            self.nextToken = nil
            self.slackChannelConfigurations = nil
        }
    }
}

public struct ListSlackChannelConfigurationsOutputResponse: Swift.Equatable {
    /// The point where pagination should resume when the response returns only partial results.
    public var nextToken: Swift.String?
    /// The configurations for a Slack channel.
    /// This member is required.
    public var slackChannelConfigurations: [SupportAppClientTypes.SlackChannelConfiguration]?

    public init (
        nextToken: Swift.String? = nil,
        slackChannelConfigurations: [SupportAppClientTypes.SlackChannelConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.slackChannelConfigurations = slackChannelConfigurations
    }
}

struct ListSlackChannelConfigurationsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let slackChannelConfigurations: [SupportAppClientTypes.SlackChannelConfiguration]?
}

extension ListSlackChannelConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case slackChannelConfigurations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let slackChannelConfigurationsContainer = try containerValues.decodeIfPresent([SupportAppClientTypes.SlackChannelConfiguration?].self, forKey: .slackChannelConfigurations)
        var slackChannelConfigurationsDecoded0:[SupportAppClientTypes.SlackChannelConfiguration]? = nil
        if let slackChannelConfigurationsContainer = slackChannelConfigurationsContainer {
            slackChannelConfigurationsDecoded0 = [SupportAppClientTypes.SlackChannelConfiguration]()
            for structure0 in slackChannelConfigurationsContainer {
                if let structure0 = structure0 {
                    slackChannelConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        slackChannelConfigurations = slackChannelConfigurationsDecoded0
    }
}

extension ListSlackWorkspaceConfigurationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension ListSlackWorkspaceConfigurationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/control/list-slack-workspace-configurations"
    }
}

public struct ListSlackWorkspaceConfigurationsInput: Swift.Equatable {
    /// If the results of a search are large, the API only returns a portion of the results and includes a nextToken pagination token in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When the API returns the last set of results, the response doesn't include a pagination token value.
    public var nextToken: Swift.String?

    public init (
        nextToken: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
    }
}

struct ListSlackWorkspaceConfigurationsInputBody: Swift.Equatable {
    let nextToken: Swift.String?
}

extension ListSlackWorkspaceConfigurationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSlackWorkspaceConfigurationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSlackWorkspaceConfigurationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSlackWorkspaceConfigurationsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSlackWorkspaceConfigurationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSlackWorkspaceConfigurationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.slackWorkspaceConfigurations = output.slackWorkspaceConfigurations
        } else {
            self.nextToken = nil
            self.slackWorkspaceConfigurations = nil
        }
    }
}

public struct ListSlackWorkspaceConfigurationsOutputResponse: Swift.Equatable {
    /// The point where pagination should resume when the response returns only partial results.
    public var nextToken: Swift.String?
    /// The configurations for a Slack workspace.
    public var slackWorkspaceConfigurations: [SupportAppClientTypes.SlackWorkspaceConfiguration]?

    public init (
        nextToken: Swift.String? = nil,
        slackWorkspaceConfigurations: [SupportAppClientTypes.SlackWorkspaceConfiguration]? = nil
    )
    {
        self.nextToken = nextToken
        self.slackWorkspaceConfigurations = slackWorkspaceConfigurations
    }
}

struct ListSlackWorkspaceConfigurationsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let slackWorkspaceConfigurations: [SupportAppClientTypes.SlackWorkspaceConfiguration]?
}

extension ListSlackWorkspaceConfigurationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case slackWorkspaceConfigurations
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let slackWorkspaceConfigurationsContainer = try containerValues.decodeIfPresent([SupportAppClientTypes.SlackWorkspaceConfiguration?].self, forKey: .slackWorkspaceConfigurations)
        var slackWorkspaceConfigurationsDecoded0:[SupportAppClientTypes.SlackWorkspaceConfiguration]? = nil
        if let slackWorkspaceConfigurationsContainer = slackWorkspaceConfigurationsContainer {
            slackWorkspaceConfigurationsDecoded0 = [SupportAppClientTypes.SlackWorkspaceConfiguration]()
            for structure0 in slackWorkspaceConfigurationsContainer {
                if let structure0 = structure0 {
                    slackWorkspaceConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        slackWorkspaceConfigurations = slackWorkspaceConfigurationsDecoded0
    }
}

extension SupportAppClientTypes {
    public enum NotificationSeverityLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case high
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationSeverityLevel] {
            return [
                .all,
                .high,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "all"
            case .high: return "high"
            case .none: return "none"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationSeverityLevel(rawValue: rawValue) ?? NotificationSeverityLevel.sdkUnknown(rawValue)
        }
    }
}

extension PutAccountAliasInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAlias
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountAlias = self.accountAlias {
            try encodeContainer.encode(accountAlias, forKey: .accountAlias)
        }
    }
}

extension PutAccountAliasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/control/put-account-alias"
    }
}

public struct PutAccountAliasInput: Swift.Equatable {
    /// An alias or short name for an Amazon Web Services account.
    /// This member is required.
    public var accountAlias: Swift.String?

    public init (
        accountAlias: Swift.String? = nil
    )
    {
        self.accountAlias = accountAlias
    }
}

struct PutAccountAliasInputBody: Swift.Equatable {
    let accountAlias: Swift.String?
}

extension PutAccountAliasInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountAlias
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountAlias)
        accountAlias = accountAliasDecoded
    }
}

extension PutAccountAliasOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension PutAccountAliasOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum PutAccountAliasOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension PutAccountAliasOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct PutAccountAliasOutputResponse: Swift.Equatable {

    public init () { }
}

extension RegisterSlackWorkspaceForOrganizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case teamId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
    }
}

extension RegisterSlackWorkspaceForOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/control/register-slack-workspace-for-organization"
    }
}

public struct RegisterSlackWorkspaceForOrganizationInput: Swift.Equatable {
    /// The team ID in Slack. This ID uniquely identifies a Slack workspace, such as T012ABCDEFG. Specify the Slack workspace that you want to use for your organization.
    /// This member is required.
    public var teamId: Swift.String?

    public init (
        teamId: Swift.String? = nil
    )
    {
        self.teamId = teamId
    }
}

struct RegisterSlackWorkspaceForOrganizationInputBody: Swift.Equatable {
    let teamId: Swift.String?
}

extension RegisterSlackWorkspaceForOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case teamId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
    }
}

extension RegisterSlackWorkspaceForOrganizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension RegisterSlackWorkspaceForOrganizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum RegisterSlackWorkspaceForOrganizationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension RegisterSlackWorkspaceForOrganizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: RegisterSlackWorkspaceForOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountType = output.accountType
            self.teamId = output.teamId
            self.teamName = output.teamName
        } else {
            self.accountType = nil
            self.teamId = nil
            self.teamName = nil
        }
    }
}

public struct RegisterSlackWorkspaceForOrganizationOutputResponse: Swift.Equatable {
    /// Whether the Amazon Web Services account is a management or member account that's part of an organization in Organizations.
    public var accountType: SupportAppClientTypes.AccountType?
    /// The team ID in Slack. This ID uniquely identifies a Slack workspace, such as T012ABCDEFG.
    public var teamId: Swift.String?
    /// The name of the Slack workspace.
    public var teamName: Swift.String?

    public init (
        accountType: SupportAppClientTypes.AccountType? = nil,
        teamId: Swift.String? = nil,
        teamName: Swift.String? = nil
    )
    {
        self.accountType = accountType
        self.teamId = teamId
        self.teamName = teamName
    }
}

struct RegisterSlackWorkspaceForOrganizationOutputResponseBody: Swift.Equatable {
    let teamId: Swift.String?
    let teamName: Swift.String?
    let accountType: SupportAppClientTypes.AccountType?
}

extension RegisterSlackWorkspaceForOrganizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountType
        case teamId
        case teamName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let teamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamName)
        teamName = teamNameDecoded
        let accountTypeDecoded = try containerValues.decodeIfPresent(SupportAppClientTypes.AccountType.self, forKey: .accountType)
        accountType = accountTypeDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified resource is missing or doesn't exist, such as an account alias, Slack channel configuration, or Slack workspace configuration.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your Service Quotas request exceeds the quota for the service. For example, your Service Quotas request to Amazon Web Services Support App might exceed the maximum number of workspaces or channels per account, or the maximum number of accounts per Slack channel.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SupportAppClientTypes.SlackChannelConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId
        case channelName
        case channelRoleArn
        case notifyOnAddCorrespondenceToCase
        case notifyOnCaseSeverity
        case notifyOnCreateOrReopenCase
        case notifyOnResolveCase
        case teamId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelId = self.channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelRoleArn = self.channelRoleArn {
            try encodeContainer.encode(channelRoleArn, forKey: .channelRoleArn)
        }
        if let notifyOnAddCorrespondenceToCase = self.notifyOnAddCorrespondenceToCase {
            try encodeContainer.encode(notifyOnAddCorrespondenceToCase, forKey: .notifyOnAddCorrespondenceToCase)
        }
        if let notifyOnCaseSeverity = self.notifyOnCaseSeverity {
            try encodeContainer.encode(notifyOnCaseSeverity.rawValue, forKey: .notifyOnCaseSeverity)
        }
        if let notifyOnCreateOrReopenCase = self.notifyOnCreateOrReopenCase {
            try encodeContainer.encode(notifyOnCreateOrReopenCase, forKey: .notifyOnCreateOrReopenCase)
        }
        if let notifyOnResolveCase = self.notifyOnResolveCase {
            try encodeContainer.encode(notifyOnResolveCase, forKey: .notifyOnResolveCase)
        }
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let notifyOnCreateOrReopenCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnCreateOrReopenCase)
        notifyOnCreateOrReopenCase = notifyOnCreateOrReopenCaseDecoded
        let notifyOnAddCorrespondenceToCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnAddCorrespondenceToCase)
        notifyOnAddCorrespondenceToCase = notifyOnAddCorrespondenceToCaseDecoded
        let notifyOnResolveCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnResolveCase)
        notifyOnResolveCase = notifyOnResolveCaseDecoded
        let notifyOnCaseSeverityDecoded = try containerValues.decodeIfPresent(SupportAppClientTypes.NotificationSeverityLevel.self, forKey: .notifyOnCaseSeverity)
        notifyOnCaseSeverity = notifyOnCaseSeverityDecoded
        let channelRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelRoleArn)
        channelRoleArn = channelRoleArnDecoded
    }
}

extension SupportAppClientTypes {
    /// The configuration for a Slack channel that you added for your Amazon Web Services account.
    public struct SlackChannelConfiguration: Swift.Equatable {
        /// The channel ID in Slack. This ID identifies a channel within a Slack workspace.
        /// This member is required.
        public var channelId: Swift.String?
        /// The name of the Slack channel that you configured with the Amazon Web Services Support App for your Amazon Web Services account.
        public var channelName: Swift.String?
        /// The Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations on Amazon Web Services. For more information, see [Managing access to the Amazon Web Services Support App](https://docs.aws.amazon.com/awssupport/latest/user/support-app-permissions.html) in the Amazon Web Services Support User Guide.
        public var channelRoleArn: Swift.String?
        /// Whether you want to get notified when a support case has a new correspondence.
        public var notifyOnAddCorrespondenceToCase: Swift.Bool?
        /// The case severity for a support case that you want to receive notifications.
        public var notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel?
        /// Whether you want to get notified when a support case is created or reopened.
        public var notifyOnCreateOrReopenCase: Swift.Bool?
        /// Whether you want to get notified when a support case is resolved.
        public var notifyOnResolveCase: Swift.Bool?
        /// The team ID in Slack. This ID uniquely identifies a Slack workspace, such as T012ABCDEFG.
        /// This member is required.
        public var teamId: Swift.String?

        public init (
            channelId: Swift.String? = nil,
            channelName: Swift.String? = nil,
            channelRoleArn: Swift.String? = nil,
            notifyOnAddCorrespondenceToCase: Swift.Bool? = nil,
            notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel? = nil,
            notifyOnCreateOrReopenCase: Swift.Bool? = nil,
            notifyOnResolveCase: Swift.Bool? = nil,
            teamId: Swift.String? = nil
        )
        {
            self.channelId = channelId
            self.channelName = channelName
            self.channelRoleArn = channelRoleArn
            self.notifyOnAddCorrespondenceToCase = notifyOnAddCorrespondenceToCase
            self.notifyOnCaseSeverity = notifyOnCaseSeverity
            self.notifyOnCreateOrReopenCase = notifyOnCreateOrReopenCase
            self.notifyOnResolveCase = notifyOnResolveCase
            self.teamId = teamId
        }
    }

}

extension SupportAppClientTypes.SlackWorkspaceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowOrganizationMemberAccount
        case teamId
        case teamName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowOrganizationMemberAccount = self.allowOrganizationMemberAccount {
            try encodeContainer.encode(allowOrganizationMemberAccount, forKey: .allowOrganizationMemberAccount)
        }
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
        if let teamName = self.teamName {
            try encodeContainer.encode(teamName, forKey: .teamName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let teamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamName)
        teamName = teamNameDecoded
        let allowOrganizationMemberAccountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowOrganizationMemberAccount)
        allowOrganizationMemberAccount = allowOrganizationMemberAccountDecoded
    }
}

extension SupportAppClientTypes {
    /// The configuration for a Slack workspace that you added to an Amazon Web Services account.
    public struct SlackWorkspaceConfiguration: Swift.Equatable {
        /// Whether to allow member accounts to authorize Slack workspaces. Member accounts must be part of an organization in Organizations.
        public var allowOrganizationMemberAccount: Swift.Bool?
        /// The team ID in Slack. This ID uniquely identifies a Slack workspace, such as T012ABCDEFG.
        /// This member is required.
        public var teamId: Swift.String?
        /// The name of the Slack workspace.
        public var teamName: Swift.String?

        public init (
            allowOrganizationMemberAccount: Swift.Bool? = nil,
            teamId: Swift.String? = nil,
            teamName: Swift.String? = nil
        )
        {
            self.allowOrganizationMemberAccount = allowOrganizationMemberAccount
            self.teamId = teamId
            self.teamName = teamName
        }
    }

}

extension UpdateSlackChannelConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId
        case channelName
        case channelRoleArn
        case notifyOnAddCorrespondenceToCase
        case notifyOnCaseSeverity
        case notifyOnCreateOrReopenCase
        case notifyOnResolveCase
        case teamId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelId = self.channelId {
            try encodeContainer.encode(channelId, forKey: .channelId)
        }
        if let channelName = self.channelName {
            try encodeContainer.encode(channelName, forKey: .channelName)
        }
        if let channelRoleArn = self.channelRoleArn {
            try encodeContainer.encode(channelRoleArn, forKey: .channelRoleArn)
        }
        if let notifyOnAddCorrespondenceToCase = self.notifyOnAddCorrespondenceToCase {
            try encodeContainer.encode(notifyOnAddCorrespondenceToCase, forKey: .notifyOnAddCorrespondenceToCase)
        }
        if let notifyOnCaseSeverity = self.notifyOnCaseSeverity {
            try encodeContainer.encode(notifyOnCaseSeverity.rawValue, forKey: .notifyOnCaseSeverity)
        }
        if let notifyOnCreateOrReopenCase = self.notifyOnCreateOrReopenCase {
            try encodeContainer.encode(notifyOnCreateOrReopenCase, forKey: .notifyOnCreateOrReopenCase)
        }
        if let notifyOnResolveCase = self.notifyOnResolveCase {
            try encodeContainer.encode(notifyOnResolveCase, forKey: .notifyOnResolveCase)
        }
        if let teamId = self.teamId {
            try encodeContainer.encode(teamId, forKey: .teamId)
        }
    }
}

extension UpdateSlackChannelConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/control/update-slack-channel-configuration"
    }
}

public struct UpdateSlackChannelConfigurationInput: Swift.Equatable {
    /// The channel ID in Slack. This ID identifies a channel within a Slack workspace.
    /// This member is required.
    public var channelId: Swift.String?
    /// The Slack channel name that you want to update.
    public var channelName: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations on Amazon Web Services. For more information, see [Managing access to the Amazon Web Services Support App](https://docs.aws.amazon.com/awssupport/latest/user/support-app-permissions.html) in the Amazon Web Services Support User Guide.
    public var channelRoleArn: Swift.String?
    /// Whether you want to get notified when a support case has a new correspondence.
    public var notifyOnAddCorrespondenceToCase: Swift.Bool?
    /// The case severity for a support case that you want to receive notifications. If you specify high or all, at least one of the following parameters must be true:
    ///
    /// * notifyOnAddCorrespondenceToCase
    ///
    /// * notifyOnCreateOrReopenCase
    ///
    /// * notifyOnResolveCase
    ///
    ///
    /// If you specify none, any of the following parameters that you specify in your request must be false:
    ///
    /// * notifyOnAddCorrespondenceToCase
    ///
    /// * notifyOnCreateOrReopenCase
    ///
    /// * notifyOnResolveCase
    ///
    ///
    /// If you don't specify these parameters in your request, the Amazon Web Services Support App uses the current values by default.
    public var notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel?
    /// Whether you want to get notified when a support case is created or reopened.
    public var notifyOnCreateOrReopenCase: Swift.Bool?
    /// Whether you want to get notified when a support case is resolved.
    public var notifyOnResolveCase: Swift.Bool?
    /// The team ID in Slack. This ID uniquely identifies a Slack workspace, such as T012ABCDEFG.
    /// This member is required.
    public var teamId: Swift.String?

    public init (
        channelId: Swift.String? = nil,
        channelName: Swift.String? = nil,
        channelRoleArn: Swift.String? = nil,
        notifyOnAddCorrespondenceToCase: Swift.Bool? = nil,
        notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel? = nil,
        notifyOnCreateOrReopenCase: Swift.Bool? = nil,
        notifyOnResolveCase: Swift.Bool? = nil,
        teamId: Swift.String? = nil
    )
    {
        self.channelId = channelId
        self.channelName = channelName
        self.channelRoleArn = channelRoleArn
        self.notifyOnAddCorrespondenceToCase = notifyOnAddCorrespondenceToCase
        self.notifyOnCaseSeverity = notifyOnCaseSeverity
        self.notifyOnCreateOrReopenCase = notifyOnCreateOrReopenCase
        self.notifyOnResolveCase = notifyOnResolveCase
        self.teamId = teamId
    }
}

struct UpdateSlackChannelConfigurationInputBody: Swift.Equatable {
    let teamId: Swift.String?
    let channelId: Swift.String?
    let channelName: Swift.String?
    let notifyOnCreateOrReopenCase: Swift.Bool?
    let notifyOnAddCorrespondenceToCase: Swift.Bool?
    let notifyOnResolveCase: Swift.Bool?
    let notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel?
    let channelRoleArn: Swift.String?
}

extension UpdateSlackChannelConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId
        case channelName
        case channelRoleArn
        case notifyOnAddCorrespondenceToCase
        case notifyOnCaseSeverity
        case notifyOnCreateOrReopenCase
        case notifyOnResolveCase
        case teamId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let notifyOnCreateOrReopenCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnCreateOrReopenCase)
        notifyOnCreateOrReopenCase = notifyOnCreateOrReopenCaseDecoded
        let notifyOnAddCorrespondenceToCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnAddCorrespondenceToCase)
        notifyOnAddCorrespondenceToCase = notifyOnAddCorrespondenceToCaseDecoded
        let notifyOnResolveCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnResolveCase)
        notifyOnResolveCase = notifyOnResolveCaseDecoded
        let notifyOnCaseSeverityDecoded = try containerValues.decodeIfPresent(SupportAppClientTypes.NotificationSeverityLevel.self, forKey: .notifyOnCaseSeverity)
        notifyOnCaseSeverity = notifyOnCaseSeverityDecoded
        let channelRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelRoleArn)
        channelRoleArn = channelRoleArnDecoded
    }
}

extension UpdateSlackChannelConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSlackChannelConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSlackChannelConfigurationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSlackChannelConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSlackChannelConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.channelId = output.channelId
            self.channelName = output.channelName
            self.channelRoleArn = output.channelRoleArn
            self.notifyOnAddCorrespondenceToCase = output.notifyOnAddCorrespondenceToCase
            self.notifyOnCaseSeverity = output.notifyOnCaseSeverity
            self.notifyOnCreateOrReopenCase = output.notifyOnCreateOrReopenCase
            self.notifyOnResolveCase = output.notifyOnResolveCase
            self.teamId = output.teamId
        } else {
            self.channelId = nil
            self.channelName = nil
            self.channelRoleArn = nil
            self.notifyOnAddCorrespondenceToCase = nil
            self.notifyOnCaseSeverity = nil
            self.notifyOnCreateOrReopenCase = nil
            self.notifyOnResolveCase = nil
            self.teamId = nil
        }
    }
}

public struct UpdateSlackChannelConfigurationOutputResponse: Swift.Equatable {
    /// The channel ID in Slack. This ID identifies a channel within a Slack workspace.
    public var channelId: Swift.String?
    /// The name of the Slack channel that you configure for the Amazon Web Services Support App.
    public var channelName: Swift.String?
    /// The Amazon Resource Name (ARN) of an IAM role that you want to use to perform operations on Amazon Web Services. For more information, see [Managing access to the Amazon Web Services Support App](https://docs.aws.amazon.com/awssupport/latest/user/support-app-permissions.html) in the Amazon Web Services Support User Guide.
    public var channelRoleArn: Swift.String?
    /// Whether you want to get notified when a support case has a new correspondence.
    public var notifyOnAddCorrespondenceToCase: Swift.Bool?
    /// The case severity for a support case that you want to receive notifications.
    public var notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel?
    /// Whether you want to get notified when a support case is created or reopened.
    public var notifyOnCreateOrReopenCase: Swift.Bool?
    /// Whether you want to get notified when a support case is resolved.
    public var notifyOnResolveCase: Swift.Bool?
    /// The team ID in Slack. This ID uniquely identifies a Slack workspace, such as T012ABCDEFG.
    public var teamId: Swift.String?

    public init (
        channelId: Swift.String? = nil,
        channelName: Swift.String? = nil,
        channelRoleArn: Swift.String? = nil,
        notifyOnAddCorrespondenceToCase: Swift.Bool? = nil,
        notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel? = nil,
        notifyOnCreateOrReopenCase: Swift.Bool? = nil,
        notifyOnResolveCase: Swift.Bool? = nil,
        teamId: Swift.String? = nil
    )
    {
        self.channelId = channelId
        self.channelName = channelName
        self.channelRoleArn = channelRoleArn
        self.notifyOnAddCorrespondenceToCase = notifyOnAddCorrespondenceToCase
        self.notifyOnCaseSeverity = notifyOnCaseSeverity
        self.notifyOnCreateOrReopenCase = notifyOnCreateOrReopenCase
        self.notifyOnResolveCase = notifyOnResolveCase
        self.teamId = teamId
    }
}

struct UpdateSlackChannelConfigurationOutputResponseBody: Swift.Equatable {
    let teamId: Swift.String?
    let channelId: Swift.String?
    let channelName: Swift.String?
    let notifyOnCreateOrReopenCase: Swift.Bool?
    let notifyOnAddCorrespondenceToCase: Swift.Bool?
    let notifyOnResolveCase: Swift.Bool?
    let notifyOnCaseSeverity: SupportAppClientTypes.NotificationSeverityLevel?
    let channelRoleArn: Swift.String?
}

extension UpdateSlackChannelConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelId
        case channelName
        case channelRoleArn
        case notifyOnAddCorrespondenceToCase
        case notifyOnCaseSeverity
        case notifyOnCreateOrReopenCase
        case notifyOnResolveCase
        case teamId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let teamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .teamId)
        teamId = teamIdDecoded
        let channelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelId)
        channelId = channelIdDecoded
        let channelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelName)
        channelName = channelNameDecoded
        let notifyOnCreateOrReopenCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnCreateOrReopenCase)
        notifyOnCreateOrReopenCase = notifyOnCreateOrReopenCaseDecoded
        let notifyOnAddCorrespondenceToCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnAddCorrespondenceToCase)
        notifyOnAddCorrespondenceToCase = notifyOnAddCorrespondenceToCaseDecoded
        let notifyOnResolveCaseDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .notifyOnResolveCase)
        notifyOnResolveCase = notifyOnResolveCaseDecoded
        let notifyOnCaseSeverityDecoded = try containerValues.decodeIfPresent(SupportAppClientTypes.NotificationSeverityLevel.self, forKey: .notifyOnCaseSeverity)
        notifyOnCaseSeverity = notifyOnCaseSeverityDecoded
        let channelRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .channelRoleArn)
        channelRoleArn = channelRoleArnDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Your request input doesn't meet the constraints that the Amazon Web Services Support App specifies.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
