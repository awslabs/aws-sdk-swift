// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Caller does not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// A reason code for the exception.
        public internal(set) var reason: CleanRoomsClientTypes.AccessDeniedExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: CleanRoomsClientTypes.AccessDeniedExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: CleanRoomsClientTypes.AccessDeniedExceptionReason?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AccessDeniedExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension CleanRoomsClientTypes {
    public enum AccessDeniedExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case insufficientPermissions
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessDeniedExceptionReason] {
            return [
                .insufficientPermissions,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .insufficientPermissions: return "INSUFFICIENT_PERMISSIONS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AccessDeniedExceptionReason(rawValue: rawValue) ?? AccessDeniedExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes.AggregateColumn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnNames
        case function
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnNames = columnNames {
            var columnNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnNames)
            for analysisrulecolumnname0 in columnNames {
                try columnNamesContainer.encode(analysisrulecolumnname0)
            }
        }
        if let function = self.function {
            try encodeContainer.encode(function.rawValue, forKey: .function)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .columnNames)
        var columnNamesDecoded0:[Swift.String]? = nil
        if let columnNamesContainer = columnNamesContainer {
            columnNamesDecoded0 = [Swift.String]()
            for string0 in columnNamesContainer {
                if let string0 = string0 {
                    columnNamesDecoded0?.append(string0)
                }
            }
        }
        columnNames = columnNamesDecoded0
        let functionDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AggregateFunctionName.self, forKey: .function)
        function = functionDecoded
    }
}

extension CleanRoomsClientTypes {
    /// Column in configured table that can be used in aggregate function in query.
    public struct AggregateColumn: Swift.Equatable {
        /// Column names in configured table of aggregate columns.
        /// This member is required.
        public var columnNames: [Swift.String]?
        /// Aggregation function that can be applied to aggregate column in query.
        /// This member is required.
        public var function: CleanRoomsClientTypes.AggregateFunctionName?

        public init(
            columnNames: [Swift.String]? = nil,
            function: CleanRoomsClientTypes.AggregateFunctionName? = nil
        )
        {
            self.columnNames = columnNames
            self.function = function
        }
    }

}

extension CleanRoomsClientTypes {
    public enum AggregateFunctionName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case avg
        case count
        case countDistinct
        case sum
        case sumDistinct
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregateFunctionName] {
            return [
                .avg,
                .count,
                .countDistinct,
                .sum,
                .sumDistinct,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .avg: return "AVG"
            case .count: return "COUNT"
            case .countDistinct: return "COUNT_DISTINCT"
            case .sum: return "SUM"
            case .sumDistinct: return "SUM_DISTINCT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregateFunctionName(rawValue: rawValue) ?? AggregateFunctionName.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes.AggregationConstraint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnName
        case minimum
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnName = self.columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let minimum = self.minimum {
            try encodeContainer.encode(minimum, forKey: .minimum)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let minimumDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .minimum)
        minimum = minimumDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AggregationType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CleanRoomsClientTypes {
    /// Constraint on query output removing output rows that do not meet a minimum number of distinct values of a specified column.
    public struct AggregationConstraint: Swift.Equatable {
        /// Column in aggregation constraint for which there must be a minimum number of distinct values in an output row for it to be in the query output.
        /// This member is required.
        public var columnName: Swift.String?
        /// The minimum number of distinct values that an output row must be an aggregation of. Minimum threshold of distinct values for a specified column that must exist in an output row for it to be in the query output.
        /// This member is required.
        public var minimum: Swift.Int?
        /// The type of aggregation the constraint allows. The only valid value is currently `COUNT_DISTINCT`.
        /// This member is required.
        public var type: CleanRoomsClientTypes.AggregationType?

        public init(
            columnName: Swift.String? = nil,
            minimum: Swift.Int? = nil,
            type: CleanRoomsClientTypes.AggregationType? = nil
        )
        {
            self.columnName = columnName
            self.minimum = minimum
            self.type = type
        }
    }

}

extension CleanRoomsClientTypes {
    public enum AggregationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case countDistinct
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationType] {
            return [
                .countDistinct,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .countDistinct: return "COUNT_DISTINCT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregationType(rawValue: rawValue) ?? AggregationType.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes {
    public enum AnalysisFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sql
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisFormat] {
            return [
                .sql,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sql: return "SQL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalysisFormat(rawValue: rawValue) ?? AnalysisFormat.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes {
    public enum AnalysisMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case directQuery
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisMethod] {
            return [
                .directQuery,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .directQuery: return "DIRECT_QUERY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalysisMethod(rawValue: rawValue) ?? AnalysisMethod.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes.AnalysisParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ParameterType.self, forKey: .type)
        type = typeDecoded
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension CleanRoomsClientTypes.AnalysisParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CleanRoomsClientTypes {
    /// Optional. The member who can query can provide this placeholder for a literal data value in an analysis template.
    public struct AnalysisParameter: Swift.Equatable {
        /// Optional. The default value that is applied in the analysis template. The member who can query can override this value in the query editor.
        public var defaultValue: Swift.String?
        /// The name of the parameter. The name must use only alphanumeric, underscore (_), or hyphen (-) characters but cannot start or end with a hyphen.
        /// This member is required.
        public var name: Swift.String?
        /// The type of parameter.
        /// This member is required.
        public var type: CleanRoomsClientTypes.ParameterType?

        public init(
            defaultValue: Swift.String? = nil,
            name: Swift.String? = nil,
            type: CleanRoomsClientTypes.ParameterType? = nil
        )
        {
            self.defaultValue = defaultValue
            self.name = name
            self.type = type
        }
    }

}

extension CleanRoomsClientTypes.AnalysisRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collaborationId
        case createTime
        case name
        case policy
        case type
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AnalysisRuleType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let policyDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AnalysisRulePolicy.self, forKey: .policy)
        policy = policyDecoded
    }
}

extension CleanRoomsClientTypes {
    /// A specification about how data from the configured table can be used in a query.
    public struct AnalysisRule: Swift.Equatable {
        /// The unique ID for the associated collaboration.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time the analysis rule was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The name for the analysis rule.
        /// This member is required.
        public var name: Swift.String?
        /// A policy that describes the associated data usage limitations.
        /// This member is required.
        public var policy: CleanRoomsClientTypes.AnalysisRulePolicy?
        /// The type of analysis rule.
        /// This member is required.
        public var type: CleanRoomsClientTypes.AnalysisRuleType?
        /// The time the analysis rule was last updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            collaborationId: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            policy: CleanRoomsClientTypes.AnalysisRulePolicy? = nil,
            type: CleanRoomsClientTypes.AnalysisRuleType? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.name = name
            self.policy = policy
            self.type = type
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.AnalysisRuleAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregateColumns
        case allowedJoinOperators
        case dimensionColumns
        case joinColumns
        case joinRequired
        case outputConstraints
        case scalarFunctions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregateColumns = aggregateColumns {
            var aggregateColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregateColumns)
            for aggregatecolumn0 in aggregateColumns {
                try aggregateColumnsContainer.encode(aggregatecolumn0)
            }
        }
        if let allowedJoinOperators = allowedJoinOperators {
            var allowedJoinOperatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedJoinOperators)
            for joinoperator0 in allowedJoinOperators {
                try allowedJoinOperatorsContainer.encode(joinoperator0.rawValue)
            }
        }
        if let dimensionColumns = dimensionColumns {
            var dimensionColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dimensionColumns)
            for analysisrulecolumnname0 in dimensionColumns {
                try dimensionColumnsContainer.encode(analysisrulecolumnname0)
            }
        }
        if let joinColumns = joinColumns {
            var joinColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .joinColumns)
            for analysisrulecolumnname0 in joinColumns {
                try joinColumnsContainer.encode(analysisrulecolumnname0)
            }
        }
        if let joinRequired = self.joinRequired {
            try encodeContainer.encode(joinRequired.rawValue, forKey: .joinRequired)
        }
        if let outputConstraints = outputConstraints {
            var outputConstraintsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .outputConstraints)
            for aggregationconstraint0 in outputConstraints {
                try outputConstraintsContainer.encode(aggregationconstraint0)
            }
        }
        if let scalarFunctions = scalarFunctions {
            var scalarFunctionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scalarFunctions)
            for scalarfunctions0 in scalarFunctions {
                try scalarFunctionsContainer.encode(scalarfunctions0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregateColumnsContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.AggregateColumn?].self, forKey: .aggregateColumns)
        var aggregateColumnsDecoded0:[CleanRoomsClientTypes.AggregateColumn]? = nil
        if let aggregateColumnsContainer = aggregateColumnsContainer {
            aggregateColumnsDecoded0 = [CleanRoomsClientTypes.AggregateColumn]()
            for structure0 in aggregateColumnsContainer {
                if let structure0 = structure0 {
                    aggregateColumnsDecoded0?.append(structure0)
                }
            }
        }
        aggregateColumns = aggregateColumnsDecoded0
        let joinColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .joinColumns)
        var joinColumnsDecoded0:[Swift.String]? = nil
        if let joinColumnsContainer = joinColumnsContainer {
            joinColumnsDecoded0 = [Swift.String]()
            for string0 in joinColumnsContainer {
                if let string0 = string0 {
                    joinColumnsDecoded0?.append(string0)
                }
            }
        }
        joinColumns = joinColumnsDecoded0
        let joinRequiredDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.JoinRequiredOption.self, forKey: .joinRequired)
        joinRequired = joinRequiredDecoded
        let allowedJoinOperatorsContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.JoinOperator?].self, forKey: .allowedJoinOperators)
        var allowedJoinOperatorsDecoded0:[CleanRoomsClientTypes.JoinOperator]? = nil
        if let allowedJoinOperatorsContainer = allowedJoinOperatorsContainer {
            allowedJoinOperatorsDecoded0 = [CleanRoomsClientTypes.JoinOperator]()
            for string0 in allowedJoinOperatorsContainer {
                if let string0 = string0 {
                    allowedJoinOperatorsDecoded0?.append(string0)
                }
            }
        }
        allowedJoinOperators = allowedJoinOperatorsDecoded0
        let dimensionColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .dimensionColumns)
        var dimensionColumnsDecoded0:[Swift.String]? = nil
        if let dimensionColumnsContainer = dimensionColumnsContainer {
            dimensionColumnsDecoded0 = [Swift.String]()
            for string0 in dimensionColumnsContainer {
                if let string0 = string0 {
                    dimensionColumnsDecoded0?.append(string0)
                }
            }
        }
        dimensionColumns = dimensionColumnsDecoded0
        let scalarFunctionsContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.ScalarFunctions?].self, forKey: .scalarFunctions)
        var scalarFunctionsDecoded0:[CleanRoomsClientTypes.ScalarFunctions]? = nil
        if let scalarFunctionsContainer = scalarFunctionsContainer {
            scalarFunctionsDecoded0 = [CleanRoomsClientTypes.ScalarFunctions]()
            for string0 in scalarFunctionsContainer {
                if let string0 = string0 {
                    scalarFunctionsDecoded0?.append(string0)
                }
            }
        }
        scalarFunctions = scalarFunctionsDecoded0
        let outputConstraintsContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.AggregationConstraint?].self, forKey: .outputConstraints)
        var outputConstraintsDecoded0:[CleanRoomsClientTypes.AggregationConstraint]? = nil
        if let outputConstraintsContainer = outputConstraintsContainer {
            outputConstraintsDecoded0 = [CleanRoomsClientTypes.AggregationConstraint]()
            for structure0 in outputConstraintsContainer {
                if let structure0 = structure0 {
                    outputConstraintsDecoded0?.append(structure0)
                }
            }
        }
        outputConstraints = outputConstraintsDecoded0
    }
}

extension CleanRoomsClientTypes {
    /// A type of analysis rule that enables query structure and specified queries that produce aggregate statistics.
    public struct AnalysisRuleAggregation: Swift.Equatable {
        /// The columns that query runners are allowed to use in aggregation queries.
        /// This member is required.
        public var aggregateColumns: [CleanRoomsClientTypes.AggregateColumn]?
        /// Which logical operators (if any) are to be used in an INNER JOIN match condition. Default is AND.
        public var allowedJoinOperators: [CleanRoomsClientTypes.JoinOperator]?
        /// The columns that query runners are allowed to select, group by, or filter by.
        /// This member is required.
        public var dimensionColumns: [Swift.String]?
        /// Columns in configured table that can be used in join statements and/or as aggregate columns. They can never be outputted directly.
        /// This member is required.
        public var joinColumns: [Swift.String]?
        /// Control that requires member who runs query to do a join with their configured table and/or other configured table in query.
        public var joinRequired: CleanRoomsClientTypes.JoinRequiredOption?
        /// Columns that must meet a specific threshold value (after an aggregation function is applied to it) for each output row to be returned.
        /// This member is required.
        public var outputConstraints: [CleanRoomsClientTypes.AggregationConstraint]?
        /// Set of scalar functions that are allowed to be used on dimension columns and the output of aggregation of metrics.
        /// This member is required.
        public var scalarFunctions: [CleanRoomsClientTypes.ScalarFunctions]?

        public init(
            aggregateColumns: [CleanRoomsClientTypes.AggregateColumn]? = nil,
            allowedJoinOperators: [CleanRoomsClientTypes.JoinOperator]? = nil,
            dimensionColumns: [Swift.String]? = nil,
            joinColumns: [Swift.String]? = nil,
            joinRequired: CleanRoomsClientTypes.JoinRequiredOption? = nil,
            outputConstraints: [CleanRoomsClientTypes.AggregationConstraint]? = nil,
            scalarFunctions: [CleanRoomsClientTypes.ScalarFunctions]? = nil
        )
        {
            self.aggregateColumns = aggregateColumns
            self.allowedJoinOperators = allowedJoinOperators
            self.dimensionColumns = dimensionColumns
            self.joinColumns = joinColumns
            self.joinRequired = joinRequired
            self.outputConstraints = outputConstraints
            self.scalarFunctions = scalarFunctions
        }
    }

}

extension CleanRoomsClientTypes.AnalysisRuleCustom: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedAnalyses
        case allowedAnalysisProviders
        case differentialPrivacy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedAnalyses = allowedAnalyses {
            var allowedAnalysesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedAnalyses)
            for analysistemplatearnorquerywildcard0 in allowedAnalyses {
                try allowedAnalysesContainer.encode(analysistemplatearnorquerywildcard0)
            }
        }
        if let allowedAnalysisProviders = allowedAnalysisProviders {
            var allowedAnalysisProvidersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedAnalysisProviders)
            for accountid0 in allowedAnalysisProviders {
                try allowedAnalysisProvidersContainer.encode(accountid0)
            }
        }
        if let differentialPrivacy = self.differentialPrivacy {
            try encodeContainer.encode(differentialPrivacy, forKey: .differentialPrivacy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowedAnalysesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedAnalyses)
        var allowedAnalysesDecoded0:[Swift.String]? = nil
        if let allowedAnalysesContainer = allowedAnalysesContainer {
            allowedAnalysesDecoded0 = [Swift.String]()
            for string0 in allowedAnalysesContainer {
                if let string0 = string0 {
                    allowedAnalysesDecoded0?.append(string0)
                }
            }
        }
        allowedAnalyses = allowedAnalysesDecoded0
        let allowedAnalysisProvidersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedAnalysisProviders)
        var allowedAnalysisProvidersDecoded0:[Swift.String]? = nil
        if let allowedAnalysisProvidersContainer = allowedAnalysisProvidersContainer {
            allowedAnalysisProvidersDecoded0 = [Swift.String]()
            for string0 in allowedAnalysisProvidersContainer {
                if let string0 = string0 {
                    allowedAnalysisProvidersDecoded0?.append(string0)
                }
            }
        }
        allowedAnalysisProviders = allowedAnalysisProvidersDecoded0
        let differentialPrivacyDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.DifferentialPrivacyConfiguration.self, forKey: .differentialPrivacy)
        differentialPrivacy = differentialPrivacyDecoded
    }
}

extension CleanRoomsClientTypes {
    /// A type of analysis rule that enables the table owner to approve custom SQL queries on their configured tables. It supports differential privacy.
    public struct AnalysisRuleCustom: Swift.Equatable {
        /// The analysis templates that are allowed by the custom analysis rule.
        /// This member is required.
        public var allowedAnalyses: [Swift.String]?
        /// The Amazon Web Services accounts that are allowed to query by the custom analysis rule. Required when allowedAnalyses is ANY_QUERY.
        public var allowedAnalysisProviders: [Swift.String]?
        /// The differential privacy configuration.
        public var differentialPrivacy: CleanRoomsClientTypes.DifferentialPrivacyConfiguration?

        public init(
            allowedAnalyses: [Swift.String]? = nil,
            allowedAnalysisProviders: [Swift.String]? = nil,
            differentialPrivacy: CleanRoomsClientTypes.DifferentialPrivacyConfiguration? = nil
        )
        {
            self.allowedAnalyses = allowedAnalyses
            self.allowedAnalysisProviders = allowedAnalysisProviders
            self.differentialPrivacy = differentialPrivacy
        }
    }

}

extension CleanRoomsClientTypes.AnalysisRuleList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedJoinOperators
        case joinColumns
        case listColumns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedJoinOperators = allowedJoinOperators {
            var allowedJoinOperatorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedJoinOperators)
            for joinoperator0 in allowedJoinOperators {
                try allowedJoinOperatorsContainer.encode(joinoperator0.rawValue)
            }
        }
        if let joinColumns = joinColumns {
            var joinColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .joinColumns)
            for analysisrulecolumnname0 in joinColumns {
                try joinColumnsContainer.encode(analysisrulecolumnname0)
            }
        }
        if let listColumns = listColumns {
            var listColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listColumns)
            for analysisrulecolumnname0 in listColumns {
                try listColumnsContainer.encode(analysisrulecolumnname0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let joinColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .joinColumns)
        var joinColumnsDecoded0:[Swift.String]? = nil
        if let joinColumnsContainer = joinColumnsContainer {
            joinColumnsDecoded0 = [Swift.String]()
            for string0 in joinColumnsContainer {
                if let string0 = string0 {
                    joinColumnsDecoded0?.append(string0)
                }
            }
        }
        joinColumns = joinColumnsDecoded0
        let allowedJoinOperatorsContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.JoinOperator?].self, forKey: .allowedJoinOperators)
        var allowedJoinOperatorsDecoded0:[CleanRoomsClientTypes.JoinOperator]? = nil
        if let allowedJoinOperatorsContainer = allowedJoinOperatorsContainer {
            allowedJoinOperatorsDecoded0 = [CleanRoomsClientTypes.JoinOperator]()
            for string0 in allowedJoinOperatorsContainer {
                if let string0 = string0 {
                    allowedJoinOperatorsDecoded0?.append(string0)
                }
            }
        }
        allowedJoinOperators = allowedJoinOperatorsDecoded0
        let listColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .listColumns)
        var listColumnsDecoded0:[Swift.String]? = nil
        if let listColumnsContainer = listColumnsContainer {
            listColumnsDecoded0 = [Swift.String]()
            for string0 in listColumnsContainer {
                if let string0 = string0 {
                    listColumnsDecoded0?.append(string0)
                }
            }
        }
        listColumns = listColumnsDecoded0
    }
}

extension CleanRoomsClientTypes {
    /// A type of analysis rule that enables row-level analysis.
    public struct AnalysisRuleList: Swift.Equatable {
        /// The logical operators (if any) that are to be used in an INNER JOIN match condition. Default is AND.
        public var allowedJoinOperators: [CleanRoomsClientTypes.JoinOperator]?
        /// Columns that can be used to join a configured table with the table of the member who can query and other members' configured tables.
        /// This member is required.
        public var joinColumns: [Swift.String]?
        /// Columns that can be listed in the output.
        /// This member is required.
        public var listColumns: [Swift.String]?

        public init(
            allowedJoinOperators: [CleanRoomsClientTypes.JoinOperator]? = nil,
            joinColumns: [Swift.String]? = nil,
            listColumns: [Swift.String]? = nil
        )
        {
            self.allowedJoinOperators = allowedJoinOperators
            self.joinColumns = joinColumns
            self.listColumns = listColumns
        }
    }

}

extension CleanRoomsClientTypes.AnalysisRulePolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case v1
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .v1(v1):
                try container.encode(v1, forKey: .v1)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let v1Decoded = try values.decodeIfPresent(CleanRoomsClientTypes.AnalysisRulePolicyV1.self, forKey: .v1)
        if let v1 = v1Decoded {
            self = .v1(v1)
            return
        }
        self = .sdkUnknown("")
    }
}

extension CleanRoomsClientTypes {
    /// Controls on the query specifications that can be run on configured table.
    public enum AnalysisRulePolicy: Swift.Equatable {
        /// Controls on the query specifications that can be run on configured table.
        case v1(CleanRoomsClientTypes.AnalysisRulePolicyV1)
        case sdkUnknown(Swift.String)
    }

}

extension CleanRoomsClientTypes.AnalysisRulePolicyV1: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregation
        case custom
        case list
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .aggregation(aggregation):
                try container.encode(aggregation, forKey: .aggregation)
            case let .custom(custom):
                try container.encode(custom, forKey: .custom)
            case let .list(list):
                try container.encode(list, forKey: .list)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let listDecoded = try values.decodeIfPresent(CleanRoomsClientTypes.AnalysisRuleList.self, forKey: .list)
        if let list = listDecoded {
            self = .list(list)
            return
        }
        let aggregationDecoded = try values.decodeIfPresent(CleanRoomsClientTypes.AnalysisRuleAggregation.self, forKey: .aggregation)
        if let aggregation = aggregationDecoded {
            self = .aggregation(aggregation)
            return
        }
        let customDecoded = try values.decodeIfPresent(CleanRoomsClientTypes.AnalysisRuleCustom.self, forKey: .custom)
        if let custom = customDecoded {
            self = .custom(custom)
            return
        }
        self = .sdkUnknown("")
    }
}

extension CleanRoomsClientTypes {
    /// Controls on the query specifications that can be run on configured table.
    public enum AnalysisRulePolicyV1: Swift.Equatable {
        /// Analysis rule type that enables only list queries on a configured table.
        case list(CleanRoomsClientTypes.AnalysisRuleList)
        /// Analysis rule type that enables only aggregation queries on a configured table.
        case aggregation(CleanRoomsClientTypes.AnalysisRuleAggregation)
        /// Analysis rule type that enables custom SQL queries on a configured table.
        case custom(CleanRoomsClientTypes.AnalysisRuleCustom)
        case sdkUnknown(Swift.String)
    }

}

extension CleanRoomsClientTypes {
    public enum AnalysisRuleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aggregation
        case custom
        case list
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisRuleType] {
            return [
                .aggregation,
                .custom,
                .list,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aggregation: return "AGGREGATION"
            case .custom: return "CUSTOM"
            case .list: return "LIST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalysisRuleType(rawValue: rawValue) ?? AnalysisRuleType.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes.AnalysisSchema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case referencedTables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let referencedTables = referencedTables {
            var referencedTablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referencedTables)
            for tablealias0 in referencedTables {
                try referencedTablesContainer.encode(tablealias0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let referencedTablesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .referencedTables)
        var referencedTablesDecoded0:[Swift.String]? = nil
        if let referencedTablesContainer = referencedTablesContainer {
            referencedTablesDecoded0 = [Swift.String]()
            for string0 in referencedTablesContainer {
                if let string0 = string0 {
                    referencedTablesDecoded0?.append(string0)
                }
            }
        }
        referencedTables = referencedTablesDecoded0
    }
}

extension CleanRoomsClientTypes {
    /// A relation within an analysis.
    public struct AnalysisSchema: Swift.Equatable {
        /// The tables referenced in the analysis schema.
        public var referencedTables: [Swift.String]?

        public init(
            referencedTables: [Swift.String]? = nil
        )
        {
            self.referencedTables = referencedTables
        }
    }

}

extension CleanRoomsClientTypes.AnalysisSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case text
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .text(text):
                try container.encode(text, forKey: .text)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let textDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .text)
        if let text = textDecoded {
            self = .text(text)
            return
        }
        self = .sdkUnknown("")
    }
}

extension CleanRoomsClientTypes {
    /// The structure that defines the body of the analysis template.
    public enum AnalysisSource: Swift.Equatable {
        /// The query text.
        case text(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension CleanRoomsClientTypes.AnalysisTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisParameters
        case arn
        case collaborationArn
        case collaborationId
        case createTime
        case description
        case format
        case id
        case membershipArn
        case membershipId
        case name
        case schema
        case source
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisParameters = analysisParameters {
            var analysisParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .analysisParameters)
            for analysisparameter0 in analysisParameters {
                try analysisParametersContainer.encode(analysisparameter0)
            }
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let collaborationArn = self.collaborationArn {
            try encodeContainer.encode(collaborationArn, forKey: .collaborationArn)
        }
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let membershipArn = self.membershipArn {
            try encodeContainer.encode(membershipArn, forKey: .membershipArn)
        }
        if let membershipId = self.membershipId {
            try encodeContainer.encode(membershipId, forKey: .membershipId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let collaborationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationArn)
        collaborationArn = collaborationArnDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let membershipArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipArn)
        membershipArn = membershipArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AnalysisSchema.self, forKey: .schema)
        schema = schemaDecoded
        let formatDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AnalysisFormat.self, forKey: .format)
        format = formatDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AnalysisSource.self, forKey: .source)
        source = sourceDecoded
        let analysisParametersContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.AnalysisParameter?].self, forKey: .analysisParameters)
        var analysisParametersDecoded0:[CleanRoomsClientTypes.AnalysisParameter]? = nil
        if let analysisParametersContainer = analysisParametersContainer {
            analysisParametersDecoded0 = [CleanRoomsClientTypes.AnalysisParameter]()
            for structure0 in analysisParametersContainer {
                if let structure0 = structure0 {
                    analysisParametersDecoded0?.append(structure0)
                }
            }
        }
        analysisParameters = analysisParametersDecoded0
    }
}

extension CleanRoomsClientTypes.AnalysisTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AnalysisTemplate(analysisParameters: \(Swift.String(describing: analysisParameters)), arn: \(Swift.String(describing: arn)), collaborationArn: \(Swift.String(describing: collaborationArn)), collaborationId: \(Swift.String(describing: collaborationId)), createTime: \(Swift.String(describing: createTime)), description: \(Swift.String(describing: description)), format: \(Swift.String(describing: format)), id: \(Swift.String(describing: id)), membershipArn: \(Swift.String(describing: membershipArn)), membershipId: \(Swift.String(describing: membershipId)), name: \(Swift.String(describing: name)), schema: \(Swift.String(describing: schema)), updateTime: \(Swift.String(describing: updateTime)), source: \"CONTENT_REDACTED\")"}
}

extension CleanRoomsClientTypes {
    /// The analysis template.
    public struct AnalysisTemplate: Swift.Equatable {
        /// The parameters of the analysis template.
        public var analysisParameters: [CleanRoomsClientTypes.AnalysisParameter]?
        /// The Amazon Resource Name (ARN) of the analysis template.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique ARN for the analysis template’s associated collaboration.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique ID for the associated collaboration of the analysis template.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time that the analysis template was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description of the analysis template.
        public var description: Swift.String?
        /// The format of the analysis template.
        /// This member is required.
        public var format: CleanRoomsClientTypes.AnalysisFormat?
        /// The identifier for the analysis template.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the member who created the analysis template.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The identifier of a member who created the analysis template.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The name of the analysis template.
        /// This member is required.
        public var name: Swift.String?
        /// The entire schema object.
        /// This member is required.
        public var schema: CleanRoomsClientTypes.AnalysisSchema?
        /// The source of the analysis template.
        /// This member is required.
        public var source: CleanRoomsClientTypes.AnalysisSource?
        /// The time that the analysis template was last updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            analysisParameters: [CleanRoomsClientTypes.AnalysisParameter]? = nil,
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            format: CleanRoomsClientTypes.AnalysisFormat? = nil,
            id: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            name: Swift.String? = nil,
            schema: CleanRoomsClientTypes.AnalysisSchema? = nil,
            source: CleanRoomsClientTypes.AnalysisSource? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.analysisParameters = analysisParameters
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.description = description
            self.format = format
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.schema = schema
            self.source = source
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.AnalysisTemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case collaborationArn
        case collaborationId
        case createTime
        case description
        case id
        case membershipArn
        case membershipId
        case name
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let collaborationArn = self.collaborationArn {
            try encodeContainer.encode(collaborationArn, forKey: .collaborationArn)
        }
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let membershipArn = self.membershipArn {
            try encodeContainer.encode(membershipArn, forKey: .membershipArn)
        }
        if let membershipId = self.membershipId {
            try encodeContainer.encode(membershipId, forKey: .membershipId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let membershipArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipArn)
        membershipArn = membershipArnDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let collaborationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationArn)
        collaborationArn = collaborationArnDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CleanRoomsClientTypes {
    /// The metadata of the analysis template.
    public struct AnalysisTemplateSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the analysis template.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique ARN for the analysis template summary’s associated collaboration.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// A unique identifier for the collaboration that the analysis template summary belongs to. Currently accepts collaboration ID.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time that the analysis template summary was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description of the analysis template.
        public var description: Swift.String?
        /// The identifier of the analysis template.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the member who created the analysis template.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The identifier for a membership resource.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The name of the analysis template.
        /// This member is required.
        public var name: Swift.String?
        /// The time that the analysis template summary was last updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.description = description
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.BatchGetCollaborationAnalysisTemplateError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CleanRoomsClientTypes {
    /// Details of errors thrown by the call to retrieve multiple analysis templates within a collaboration by their identifiers.
    public struct BatchGetCollaborationAnalysisTemplateError: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the analysis template.
        /// This member is required.
        public var arn: Swift.String?
        /// An error code for the error.
        /// This member is required.
        public var code: Swift.String?
        /// A description of why the call failed.
        /// This member is required.
        public var message: Swift.String?

        public init(
            arn: Swift.String? = nil,
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.arn = arn
            self.code = code
            self.message = message
        }
    }

}

extension BatchGetCollaborationAnalysisTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisTemplateArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisTemplateArns = analysisTemplateArns {
            var analysisTemplateArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .analysisTemplateArns)
            for analysistemplatearn0 in analysisTemplateArns {
                try analysisTemplateArnsContainer.encode(analysistemplatearn0)
            }
        }
    }
}

extension BatchGetCollaborationAnalysisTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collaborationIdentifier = collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/batch-analysistemplates"
    }
}

public struct BatchGetCollaborationAnalysisTemplateInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the analysis template within a collaboration.
    /// This member is required.
    public var analysisTemplateArns: [Swift.String]?
    /// A unique identifier for the collaboration that the analysis templates belong to. Currently accepts collaboration ID.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?

    public init(
        analysisTemplateArns: [Swift.String]? = nil,
        collaborationIdentifier: Swift.String? = nil
    )
    {
        self.analysisTemplateArns = analysisTemplateArns
        self.collaborationIdentifier = collaborationIdentifier
    }
}

struct BatchGetCollaborationAnalysisTemplateInputBody: Swift.Equatable {
    let analysisTemplateArns: [Swift.String]?
}

extension BatchGetCollaborationAnalysisTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisTemplateArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisTemplateArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .analysisTemplateArns)
        var analysisTemplateArnsDecoded0:[Swift.String]? = nil
        if let analysisTemplateArnsContainer = analysisTemplateArnsContainer {
            analysisTemplateArnsDecoded0 = [Swift.String]()
            for string0 in analysisTemplateArnsContainer {
                if let string0 = string0 {
                    analysisTemplateArnsDecoded0?.append(string0)
                }
            }
        }
        analysisTemplateArns = analysisTemplateArnsDecoded0
    }
}

extension BatchGetCollaborationAnalysisTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetCollaborationAnalysisTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.collaborationAnalysisTemplates = output.collaborationAnalysisTemplates
            self.errors = output.errors
        } else {
            self.collaborationAnalysisTemplates = nil
            self.errors = nil
        }
    }
}

public struct BatchGetCollaborationAnalysisTemplateOutput: Swift.Equatable {
    /// The retrieved list of analysis templates within a collaboration.
    /// This member is required.
    public var collaborationAnalysisTemplates: [CleanRoomsClientTypes.CollaborationAnalysisTemplate]?
    /// Error reasons for collaboration analysis templates that could not be retrieved. One error is returned for every collaboration analysis template that could not be retrieved.
    /// This member is required.
    public var errors: [CleanRoomsClientTypes.BatchGetCollaborationAnalysisTemplateError]?

    public init(
        collaborationAnalysisTemplates: [CleanRoomsClientTypes.CollaborationAnalysisTemplate]? = nil,
        errors: [CleanRoomsClientTypes.BatchGetCollaborationAnalysisTemplateError]? = nil
    )
    {
        self.collaborationAnalysisTemplates = collaborationAnalysisTemplates
        self.errors = errors
    }
}

struct BatchGetCollaborationAnalysisTemplateOutputBody: Swift.Equatable {
    let collaborationAnalysisTemplates: [CleanRoomsClientTypes.CollaborationAnalysisTemplate]?
    let errors: [CleanRoomsClientTypes.BatchGetCollaborationAnalysisTemplateError]?
}

extension BatchGetCollaborationAnalysisTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collaborationAnalysisTemplates
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collaborationAnalysisTemplatesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.CollaborationAnalysisTemplate?].self, forKey: .collaborationAnalysisTemplates)
        var collaborationAnalysisTemplatesDecoded0:[CleanRoomsClientTypes.CollaborationAnalysisTemplate]? = nil
        if let collaborationAnalysisTemplatesContainer = collaborationAnalysisTemplatesContainer {
            collaborationAnalysisTemplatesDecoded0 = [CleanRoomsClientTypes.CollaborationAnalysisTemplate]()
            for structure0 in collaborationAnalysisTemplatesContainer {
                if let structure0 = structure0 {
                    collaborationAnalysisTemplatesDecoded0?.append(structure0)
                }
            }
        }
        collaborationAnalysisTemplates = collaborationAnalysisTemplatesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.BatchGetCollaborationAnalysisTemplateError?].self, forKey: .errors)
        var errorsDecoded0:[CleanRoomsClientTypes.BatchGetCollaborationAnalysisTemplateError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [CleanRoomsClientTypes.BatchGetCollaborationAnalysisTemplateError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchGetCollaborationAnalysisTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CleanRoomsClientTypes.BatchGetSchemaError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CleanRoomsClientTypes {
    /// An error describing why a schema could not be fetched.
    public struct BatchGetSchemaError: Swift.Equatable {
        /// An error code for the error.
        /// This member is required.
        public var code: Swift.String?
        /// An error message for the error.
        /// This member is required.
        public var message: Swift.String?
        /// An error name for the error.
        /// This member is required.
        public var name: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.name = name
        }
    }

}

extension BatchGetSchemaInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let names = names {
            var namesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .names)
            for tablealias0 in names {
                try namesContainer.encode(tablealias0)
            }
        }
    }
}

extension BatchGetSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collaborationIdentifier = collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/batch-schema"
    }
}

public struct BatchGetSchemaInput: Swift.Equatable {
    /// A unique identifier for the collaboration that the schemas belong to. Currently accepts collaboration ID.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The names for the schema objects to retrieve.>
    /// This member is required.
    public var names: [Swift.String]?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        names: [Swift.String]? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.names = names
    }
}

struct BatchGetSchemaInputBody: Swift.Equatable {
    let names: [Swift.String]?
}

extension BatchGetSchemaInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case names
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let namesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .names)
        var namesDecoded0:[Swift.String]? = nil
        if let namesContainer = namesContainer {
            namesDecoded0 = [Swift.String]()
            for string0 in namesContainer {
                if let string0 = string0 {
                    namesDecoded0?.append(string0)
                }
            }
        }
        names = namesDecoded0
    }
}

extension BatchGetSchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetSchemaOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.schemas = output.schemas
        } else {
            self.errors = nil
            self.schemas = nil
        }
    }
}

public struct BatchGetSchemaOutput: Swift.Equatable {
    /// Error reasons for schemas that could not be retrieved. One error is returned for every schema that could not be retrieved.
    /// This member is required.
    public var errors: [CleanRoomsClientTypes.BatchGetSchemaError]?
    /// The retrieved list of schemas.
    /// This member is required.
    public var schemas: [CleanRoomsClientTypes.Schema]?

    public init(
        errors: [CleanRoomsClientTypes.BatchGetSchemaError]? = nil,
        schemas: [CleanRoomsClientTypes.Schema]? = nil
    )
    {
        self.errors = errors
        self.schemas = schemas
    }
}

struct BatchGetSchemaOutputBody: Swift.Equatable {
    let schemas: [CleanRoomsClientTypes.Schema]?
    let errors: [CleanRoomsClientTypes.BatchGetSchemaError]?
}

extension BatchGetSchemaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case schemas
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemasContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.Schema?].self, forKey: .schemas)
        var schemasDecoded0:[CleanRoomsClientTypes.Schema]? = nil
        if let schemasContainer = schemasContainer {
            schemasDecoded0 = [CleanRoomsClientTypes.Schema]()
            for structure0 in schemasContainer {
                if let structure0 = structure0 {
                    schemasDecoded0?.append(structure0)
                }
            }
        }
        schemas = schemasDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.BatchGetSchemaError?].self, forKey: .errors)
        var errorsDecoded0:[CleanRoomsClientTypes.BatchGetSchemaError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [CleanRoomsClientTypes.BatchGetSchemaError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchGetSchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CleanRoomsClientTypes.Collaboration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case creatorAccountId
        case creatorDisplayName
        case dataEncryptionMetadata
        case description
        case id
        case memberStatus
        case membershipArn
        case membershipId
        case name
        case queryLogStatus
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let creatorAccountId = self.creatorAccountId {
            try encodeContainer.encode(creatorAccountId, forKey: .creatorAccountId)
        }
        if let creatorDisplayName = self.creatorDisplayName {
            try encodeContainer.encode(creatorDisplayName, forKey: .creatorDisplayName)
        }
        if let dataEncryptionMetadata = self.dataEncryptionMetadata {
            try encodeContainer.encode(dataEncryptionMetadata, forKey: .dataEncryptionMetadata)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let memberStatus = self.memberStatus {
            try encodeContainer.encode(memberStatus.rawValue, forKey: .memberStatus)
        }
        if let membershipArn = self.membershipArn {
            try encodeContainer.encode(membershipArn, forKey: .membershipArn)
        }
        if let membershipId = self.membershipId {
            try encodeContainer.encode(membershipId, forKey: .membershipId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queryLogStatus = self.queryLogStatus {
            try encodeContainer.encode(queryLogStatus.rawValue, forKey: .queryLogStatus)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creatorAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorAccountId)
        creatorAccountId = creatorAccountIdDecoded
        let creatorDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorDisplayName)
        creatorDisplayName = creatorDisplayNameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let memberStatusDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.MemberStatus.self, forKey: .memberStatus)
        memberStatus = memberStatusDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let membershipArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipArn)
        membershipArn = membershipArnDecoded
        let dataEncryptionMetadataDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.DataEncryptionMetadata.self, forKey: .dataEncryptionMetadata)
        dataEncryptionMetadata = dataEncryptionMetadataDecoded
        let queryLogStatusDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.CollaborationQueryLogStatus.self, forKey: .queryLogStatus)
        queryLogStatus = queryLogStatusDecoded
    }
}

extension CleanRoomsClientTypes {
    /// The multi-party data share environment. The collaboration contains metadata about its purpose and participants.
    public struct Collaboration: Swift.Equatable {
        /// The unique ARN for the collaboration.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the collaboration was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// A display name of the collaboration creator.
        /// This member is required.
        public var creatorDisplayName: Swift.String?
        /// The settings for client-side encryption for cryptographic computing.
        public var dataEncryptionMetadata: CleanRoomsClientTypes.DataEncryptionMetadata?
        /// A description of the collaboration provided by the collaboration owner.
        public var description: Swift.String?
        /// The unique ID for the collaboration.
        /// This member is required.
        public var id: Swift.String?
        /// The status of a member in a collaboration.
        /// This member is required.
        public var memberStatus: CleanRoomsClientTypes.MemberStatus?
        /// The unique ARN for your membership within the collaboration.
        public var membershipArn: Swift.String?
        /// The unique ID for your membership within the collaboration.
        public var membershipId: Swift.String?
        /// A human-readable identifier provided by the collaboration owner. Display names are not unique.
        /// This member is required.
        public var name: Swift.String?
        /// An indicator as to whether query logging has been enabled or disabled for the collaboration.
        /// This member is required.
        public var queryLogStatus: CleanRoomsClientTypes.CollaborationQueryLogStatus?
        /// The time the collaboration metadata was last updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            creatorDisplayName: Swift.String? = nil,
            dataEncryptionMetadata: CleanRoomsClientTypes.DataEncryptionMetadata? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            memberStatus: CleanRoomsClientTypes.MemberStatus? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            name: Swift.String? = nil,
            queryLogStatus: CleanRoomsClientTypes.CollaborationQueryLogStatus? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.creatorDisplayName = creatorDisplayName
            self.dataEncryptionMetadata = dataEncryptionMetadata
            self.description = description
            self.id = id
            self.memberStatus = memberStatus
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.queryLogStatus = queryLogStatus
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.CollaborationAnalysisTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisParameters
        case arn
        case collaborationArn
        case collaborationId
        case createTime
        case creatorAccountId
        case description
        case format
        case id
        case name
        case schema
        case source
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisParameters = analysisParameters {
            var analysisParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .analysisParameters)
            for analysisparameter0 in analysisParameters {
                try analysisParametersContainer.encode(analysisparameter0)
            }
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let collaborationArn = self.collaborationArn {
            try encodeContainer.encode(collaborationArn, forKey: .collaborationArn)
        }
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let creatorAccountId = self.creatorAccountId {
            try encodeContainer.encode(creatorAccountId, forKey: .creatorAccountId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let schema = self.schema {
            try encodeContainer.encode(schema, forKey: .schema)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let collaborationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationArn)
        collaborationArn = collaborationArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creatorAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorAccountId)
        creatorAccountId = creatorAccountIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let schemaDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AnalysisSchema.self, forKey: .schema)
        schema = schemaDecoded
        let formatDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AnalysisFormat.self, forKey: .format)
        format = formatDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AnalysisSource.self, forKey: .source)
        source = sourceDecoded
        let analysisParametersContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.AnalysisParameter?].self, forKey: .analysisParameters)
        var analysisParametersDecoded0:[CleanRoomsClientTypes.AnalysisParameter]? = nil
        if let analysisParametersContainer = analysisParametersContainer {
            analysisParametersDecoded0 = [CleanRoomsClientTypes.AnalysisParameter]()
            for structure0 in analysisParametersContainer {
                if let structure0 = structure0 {
                    analysisParametersDecoded0?.append(structure0)
                }
            }
        }
        analysisParameters = analysisParametersDecoded0
    }
}

extension CleanRoomsClientTypes.CollaborationAnalysisTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CollaborationAnalysisTemplate(analysisParameters: \(Swift.String(describing: analysisParameters)), arn: \(Swift.String(describing: arn)), collaborationArn: \(Swift.String(describing: collaborationArn)), collaborationId: \(Swift.String(describing: collaborationId)), createTime: \(Swift.String(describing: createTime)), creatorAccountId: \(Swift.String(describing: creatorAccountId)), description: \(Swift.String(describing: description)), format: \(Swift.String(describing: format)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), schema: \(Swift.String(describing: schema)), updateTime: \(Swift.String(describing: updateTime)), source: \"CONTENT_REDACTED\")"}
}

extension CleanRoomsClientTypes {
    /// The analysis template within a collaboration.
    public struct CollaborationAnalysisTemplate: Swift.Equatable {
        /// The analysis parameters that have been specified in the analysis template.
        public var analysisParameters: [CleanRoomsClientTypes.AnalysisParameter]?
        /// The Amazon Resource Name (ARN) of the analysis template.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique ARN for the analysis template’s associated collaboration.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// A unique identifier for the collaboration that the analysis templates belong to. Currently accepts collaboration ID.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time that the analysis template within a collaboration was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// The description of the analysis template.
        public var description: Swift.String?
        /// The format of the analysis template in the collaboration.
        /// This member is required.
        public var format: CleanRoomsClientTypes.AnalysisFormat?
        /// The identifier of the analysis template.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the analysis template.
        /// This member is required.
        public var name: Swift.String?
        /// The entire schema object.
        /// This member is required.
        public var schema: CleanRoomsClientTypes.AnalysisSchema?
        /// The source of the analysis template within a collaboration.
        /// This member is required.
        public var source: CleanRoomsClientTypes.AnalysisSource?
        /// The time that the analysis template in the collaboration was last updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            analysisParameters: [CleanRoomsClientTypes.AnalysisParameter]? = nil,
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            format: CleanRoomsClientTypes.AnalysisFormat? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            schema: CleanRoomsClientTypes.AnalysisSchema? = nil,
            source: CleanRoomsClientTypes.AnalysisSource? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.analysisParameters = analysisParameters
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.format = format
            self.id = id
            self.name = name
            self.schema = schema
            self.source = source
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.CollaborationAnalysisTemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case collaborationArn
        case collaborationId
        case createTime
        case creatorAccountId
        case description
        case id
        case name
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let collaborationArn = self.collaborationArn {
            try encodeContainer.encode(collaborationArn, forKey: .collaborationArn)
        }
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let creatorAccountId = self.creatorAccountId {
            try encodeContainer.encode(creatorAccountId, forKey: .creatorAccountId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let collaborationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationArn)
        collaborationArn = collaborationArnDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let creatorAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorAccountId)
        creatorAccountId = creatorAccountIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CleanRoomsClientTypes {
    /// The metadata of the analysis template within a collaboration.
    public struct CollaborationAnalysisTemplateSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the analysis template.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique ARN for the analysis template’s associated collaboration.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// A unique identifier for the collaboration that the analysis templates belong to. Currently accepts collaboration ID.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time that the summary of the analysis template in a collaboration was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// The description of the analysis template.
        public var description: Swift.String?
        /// The identifier of the analysis template.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the analysis template.
        /// This member is required.
        public var name: Swift.String?
        /// The time that the summary of the analysis template in the collaboration was last updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.id = id
            self.name = name
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case collaborationArn
        case collaborationId
        case configuredAudienceModelArn
        case createTime
        case creatorAccountId
        case description
        case id
        case name
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let collaborationArn = self.collaborationArn {
            try encodeContainer.encode(collaborationArn, forKey: .collaborationArn)
        }
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let configuredAudienceModelArn = self.configuredAudienceModelArn {
            try encodeContainer.encode(configuredAudienceModelArn, forKey: .configuredAudienceModelArn)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let creatorAccountId = self.creatorAccountId {
            try encodeContainer.encode(creatorAccountId, forKey: .creatorAccountId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let collaborationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationArn)
        collaborationArn = collaborationArnDecoded
        let configuredAudienceModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredAudienceModelArn)
        configuredAudienceModelArn = configuredAudienceModelArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creatorAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorAccountId)
        creatorAccountId = creatorAccountIdDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension CleanRoomsClientTypes {
    /// The configured audience model association within a collaboration.
    public struct CollaborationConfiguredAudienceModelAssociation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the configured audience model association.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique ARN for the configured audience model's associated collaboration.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// A unique identifier for the collaboration that the configured audience model associations belong to. Accepts collaboration ID.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the configure audience model.
        /// This member is required.
        public var configuredAudienceModelArn: Swift.String?
        /// The time at which the configured audience model association was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The identifier used to reference members of the collaboration. Only supports AWS account ID.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// The description of the configured audience model association.
        public var description: Swift.String?
        /// The identifier of the configured audience model association.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the configured audience model association.
        /// This member is required.
        public var name: Swift.String?
        /// The most recent time at which the configured audience model association was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            configuredAudienceModelArn: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.id = id
            self.name = name
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case collaborationArn
        case collaborationId
        case createTime
        case creatorAccountId
        case description
        case id
        case name
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let collaborationArn = self.collaborationArn {
            try encodeContainer.encode(collaborationArn, forKey: .collaborationArn)
        }
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let creatorAccountId = self.creatorAccountId {
            try encodeContainer.encode(creatorAccountId, forKey: .creatorAccountId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let collaborationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationArn)
        collaborationArn = collaborationArnDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let creatorAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorAccountId)
        creatorAccountId = creatorAccountIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CleanRoomsClientTypes {
    /// A summary of the configured audience model association in the collaboration.
    public struct CollaborationConfiguredAudienceModelAssociationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the configured audience model association.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique ARN for the configured audience model's associated collaboration.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// A unique identifier for the collaboration that the configured audience model associations belong to. Accepts collaboration ID.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time at which the configured audience model association was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The identifier used to reference members of the collaboration. Only supports AWS account ID.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// The description of the configured audience model association.
        public var description: Swift.String?
        /// The identifier of the configured audience model association.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the configured audience model association.
        /// This member is required.
        public var name: Swift.String?
        /// The most recent time at which the configured audience model association was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.id = id
            self.name = name
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.CollaborationPrivacyBudgetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budget
        case collaborationArn
        case collaborationId
        case createTime
        case creatorAccountId
        case id
        case privacyBudgetTemplateArn
        case privacyBudgetTemplateId
        case type
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budget = self.budget {
            try encodeContainer.encode(budget, forKey: .budget)
        }
        if let collaborationArn = self.collaborationArn {
            try encodeContainer.encode(collaborationArn, forKey: .collaborationArn)
        }
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let creatorAccountId = self.creatorAccountId {
            try encodeContainer.encode(creatorAccountId, forKey: .creatorAccountId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let privacyBudgetTemplateArn = self.privacyBudgetTemplateArn {
            try encodeContainer.encode(privacyBudgetTemplateArn, forKey: .privacyBudgetTemplateArn)
        }
        if let privacyBudgetTemplateId = self.privacyBudgetTemplateId {
            try encodeContainer.encode(privacyBudgetTemplateId, forKey: .privacyBudgetTemplateId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let privacyBudgetTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privacyBudgetTemplateId)
        privacyBudgetTemplateId = privacyBudgetTemplateIdDecoded
        let privacyBudgetTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privacyBudgetTemplateArn)
        privacyBudgetTemplateArn = privacyBudgetTemplateArnDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let collaborationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationArn)
        collaborationArn = collaborationArnDecoded
        let creatorAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorAccountId)
        creatorAccountId = creatorAccountIdDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyBudgetType.self, forKey: .type)
        type = typeDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let budgetDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyBudget.self, forKey: .budget)
        budget = budgetDecoded
    }
}

extension CleanRoomsClientTypes {
    /// A summary of the collaboration privacy budgets. This summary includes the collaboration information, creation information, epsilon provided, and utility in terms of aggregations.
    public struct CollaborationPrivacyBudgetSummary: Swift.Equatable {
        /// The includes epsilon provided and utility in terms of aggregations.
        /// This member is required.
        public var budget: CleanRoomsClientTypes.PrivacyBudget?
        /// The ARN of the collaboration that includes this privacy budget.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique identifier of the collaboration that includes this privacy budget.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time at which the privacy budget was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The unique identifier of the account that created this privacy budget.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// The unique identifier of the collaboration privacy budget.
        /// This member is required.
        public var id: Swift.String?
        /// The ARN of the collaboration privacy budget template.
        /// This member is required.
        public var privacyBudgetTemplateArn: Swift.String?
        /// The unique identifier of the collaboration privacy budget template.
        /// This member is required.
        public var privacyBudgetTemplateId: Swift.String?
        /// The type of privacy budget template.
        /// This member is required.
        public var type: CleanRoomsClientTypes.PrivacyBudgetType?
        /// The most recent time at which the privacy budget was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            budget: CleanRoomsClientTypes.PrivacyBudget? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            id: Swift.String? = nil,
            privacyBudgetTemplateArn: Swift.String? = nil,
            privacyBudgetTemplateId: Swift.String? = nil,
            type: CleanRoomsClientTypes.PrivacyBudgetType? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.budget = budget
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.id = id
            self.privacyBudgetTemplateArn = privacyBudgetTemplateArn
            self.privacyBudgetTemplateId = privacyBudgetTemplateId
            self.type = type
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case autoRefresh
        case collaborationArn
        case collaborationId
        case createTime
        case creatorAccountId
        case id
        case parameters
        case privacyBudgetType
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let autoRefresh = self.autoRefresh {
            try encodeContainer.encode(autoRefresh.rawValue, forKey: .autoRefresh)
        }
        if let collaborationArn = self.collaborationArn {
            try encodeContainer.encode(collaborationArn, forKey: .collaborationArn)
        }
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let creatorAccountId = self.creatorAccountId {
            try encodeContainer.encode(creatorAccountId, forKey: .creatorAccountId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let privacyBudgetType = self.privacyBudgetType {
            try encodeContainer.encode(privacyBudgetType.rawValue, forKey: .privacyBudgetType)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let collaborationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationArn)
        collaborationArn = collaborationArnDecoded
        let creatorAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorAccountId)
        creatorAccountId = creatorAccountIdDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let privacyBudgetTypeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyBudgetType.self, forKey: .privacyBudgetType)
        privacyBudgetType = privacyBudgetTypeDecoded
        let autoRefreshDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyBudgetTemplateAutoRefresh.self, forKey: .autoRefresh)
        autoRefresh = autoRefreshDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyBudgetTemplateParametersOutput.self, forKey: .parameters)
        parameters = parametersDecoded
    }
}

extension CleanRoomsClientTypes {
    /// An array that specifies the information for a collaboration's privacy budget template.
    public struct CollaborationPrivacyBudgetTemplate: Swift.Equatable {
        /// The ARN of the collaboration privacy budget template.
        /// This member is required.
        public var arn: Swift.String?
        /// How often the privacy budget refreshes. If you plan to regularly bring new data into the collaboration, use CALENDAR_MONTH to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queried across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.
        /// This member is required.
        public var autoRefresh: CleanRoomsClientTypes.PrivacyBudgetTemplateAutoRefresh?
        /// The ARN of the collaboration that includes this collaboration privacy budget template.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique identifier of the collaboration that includes this collaboration privacy budget template.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time at which the collaboration privacy budget template was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The unique identifier of the account that created this collaboration privacy budget template.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// The unique identifier of the collaboration privacy budget template.
        /// This member is required.
        public var id: Swift.String?
        /// Specifies the epsilon and noise parameters for the privacy budget template.
        /// This member is required.
        public var parameters: CleanRoomsClientTypes.PrivacyBudgetTemplateParametersOutput?
        /// The type of privacy budget template.
        /// This member is required.
        public var privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType?
        /// The most recent time at which the collaboration privacy budget template was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            autoRefresh: CleanRoomsClientTypes.PrivacyBudgetTemplateAutoRefresh? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            id: Swift.String? = nil,
            parameters: CleanRoomsClientTypes.PrivacyBudgetTemplateParametersOutput? = nil,
            privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.autoRefresh = autoRefresh
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.id = id
            self.parameters = parameters
            self.privacyBudgetType = privacyBudgetType
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case collaborationArn
        case collaborationId
        case createTime
        case creatorAccountId
        case id
        case privacyBudgetType
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let collaborationArn = self.collaborationArn {
            try encodeContainer.encode(collaborationArn, forKey: .collaborationArn)
        }
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let creatorAccountId = self.creatorAccountId {
            try encodeContainer.encode(creatorAccountId, forKey: .creatorAccountId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let privacyBudgetType = self.privacyBudgetType {
            try encodeContainer.encode(privacyBudgetType.rawValue, forKey: .privacyBudgetType)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let collaborationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationArn)
        collaborationArn = collaborationArnDecoded
        let creatorAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorAccountId)
        creatorAccountId = creatorAccountIdDecoded
        let privacyBudgetTypeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyBudgetType.self, forKey: .privacyBudgetType)
        privacyBudgetType = privacyBudgetTypeDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension CleanRoomsClientTypes {
    /// A summary of the collaboration's privacy budget template. This summary includes information about who created the privacy budget template and what collaborations it belongs to.
    public struct CollaborationPrivacyBudgetTemplateSummary: Swift.Equatable {
        /// The ARN of the collaboration privacy budget template.
        /// This member is required.
        public var arn: Swift.String?
        /// The ARN of the collaboration that contains this collaboration privacy budget template.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique identifier of the collaboration that contains this collaboration privacy budget template.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time at which the collaboration privacy budget template was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The unique identifier of the account that created this collaboration privacy budget template.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// The unique identifier of the collaboration privacy budget template.
        /// This member is required.
        public var id: Swift.String?
        /// The type of the privacy budget template.
        /// This member is required.
        public var privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType?
        /// The most recent time at which the collaboration privacy budget template was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            id: Swift.String? = nil,
            privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.id = id
            self.privacyBudgetType = privacyBudgetType
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes {
    public enum CollaborationQueryLogStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [CollaborationQueryLogStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CollaborationQueryLogStatus(rawValue: rawValue) ?? CollaborationQueryLogStatus.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes.CollaborationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createTime
        case creatorAccountId
        case creatorDisplayName
        case id
        case memberStatus
        case membershipArn
        case membershipId
        case name
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let creatorAccountId = self.creatorAccountId {
            try encodeContainer.encode(creatorAccountId, forKey: .creatorAccountId)
        }
        if let creatorDisplayName = self.creatorDisplayName {
            try encodeContainer.encode(creatorDisplayName, forKey: .creatorDisplayName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let memberStatus = self.memberStatus {
            try encodeContainer.encode(memberStatus.rawValue, forKey: .memberStatus)
        }
        if let membershipArn = self.membershipArn {
            try encodeContainer.encode(membershipArn, forKey: .membershipArn)
        }
        if let membershipId = self.membershipId {
            try encodeContainer.encode(membershipId, forKey: .membershipId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let creatorAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorAccountId)
        creatorAccountId = creatorAccountIdDecoded
        let creatorDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorDisplayName)
        creatorDisplayName = creatorDisplayNameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let memberStatusDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.MemberStatus.self, forKey: .memberStatus)
        memberStatus = memberStatusDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let membershipArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipArn)
        membershipArn = membershipArnDecoded
    }
}

extension CleanRoomsClientTypes {
    /// The metadata of the collaboration.
    public struct CollaborationSummary: Swift.Equatable {
        /// The ARN of the collaboration.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the collaboration was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// The display name of the collaboration creator.
        /// This member is required.
        public var creatorDisplayName: Swift.String?
        /// The identifier for the collaboration.
        /// This member is required.
        public var id: Swift.String?
        /// The status of a member in a collaboration.
        /// This member is required.
        public var memberStatus: CleanRoomsClientTypes.MemberStatus?
        /// The ARN of a member in a collaboration.
        public var membershipArn: Swift.String?
        /// The identifier of a member in a collaboration.
        public var membershipId: Swift.String?
        /// A human-readable identifier provided by the collaboration owner. Display names are not unique.
        /// This member is required.
        public var name: Swift.String?
        /// The time the collaboration metadata was last updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            creatorDisplayName: Swift.String? = nil,
            id: Swift.String? = nil,
            memberStatus: CleanRoomsClientTypes.MemberStatus? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.creatorDisplayName = creatorDisplayName
            self.id = id
            self.memberStatus = memberStatus
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.Column: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension CleanRoomsClientTypes {
    /// A column within a schema relation, derived from the underlying Glue table.
    public struct Column: Swift.Equatable {
        /// The name of the column.
        /// This member is required.
        public var name: Swift.String?
        /// The type of the column.
        /// This member is required.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }

}

extension CleanRoomsClientTypes.ConfiguredAudienceModelAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case collaborationArn
        case collaborationId
        case configuredAudienceModelArn
        case createTime
        case description
        case id
        case manageResourcePolicies
        case membershipArn
        case membershipId
        case name
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let collaborationArn = self.collaborationArn {
            try encodeContainer.encode(collaborationArn, forKey: .collaborationArn)
        }
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let configuredAudienceModelArn = self.configuredAudienceModelArn {
            try encodeContainer.encode(configuredAudienceModelArn, forKey: .configuredAudienceModelArn)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let manageResourcePolicies = self.manageResourcePolicies {
            try encodeContainer.encode(manageResourcePolicies, forKey: .manageResourcePolicies)
        }
        if let membershipArn = self.membershipArn {
            try encodeContainer.encode(membershipArn, forKey: .membershipArn)
        }
        if let membershipId = self.membershipId {
            try encodeContainer.encode(membershipId, forKey: .membershipId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let configuredAudienceModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredAudienceModelArn)
        configuredAudienceModelArn = configuredAudienceModelArnDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let membershipArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipArn)
        membershipArn = membershipArnDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let collaborationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationArn)
        collaborationArn = collaborationArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let manageResourcePoliciesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .manageResourcePolicies)
        manageResourcePolicies = manageResourcePoliciesDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension CleanRoomsClientTypes {
    /// Details about the configured audience model association.
    public struct ConfiguredAudienceModelAssociation: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the configured audience model association.
        /// This member is required.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the collaboration that contains this configured audience model association.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// A unique identifier of the collaboration that contains this configured audience model association.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the configured audience model that was used for this configured audience model association.
        /// This member is required.
        public var configuredAudienceModelArn: Swift.String?
        /// The time at which the configured audience model association was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description of the configured audience model association.
        public var description: Swift.String?
        /// A unique identifier of the configured audience model association.
        /// This member is required.
        public var id: Swift.String?
        /// When TRUE, indicates that the resource policy for the configured audience model resource being associated is configured for Clean Rooms to manage permissions related to the given collaboration. When FALSE, indicates that the configured audience model resource owner will manage permissions related to the given collaboration.
        /// This member is required.
        public var manageResourcePolicies: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the membership that contains this configured audience model association.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// A unique identifier for the membership that contains this configured audience model association.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The name of the configured audience model association.
        /// This member is required.
        public var name: Swift.String?
        /// The most recent time at which the configured audience model association was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            configuredAudienceModelArn: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            manageResourcePolicies: Swift.Bool? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.createTime = createTime
            self.description = description
            self.id = id
            self.manageResourcePolicies = manageResourcePolicies
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.ConfiguredAudienceModelAssociationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case collaborationArn
        case collaborationId
        case configuredAudienceModelArn
        case createTime
        case description
        case id
        case membershipArn
        case membershipId
        case name
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let collaborationArn = self.collaborationArn {
            try encodeContainer.encode(collaborationArn, forKey: .collaborationArn)
        }
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let configuredAudienceModelArn = self.configuredAudienceModelArn {
            try encodeContainer.encode(configuredAudienceModelArn, forKey: .configuredAudienceModelArn)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let membershipArn = self.membershipArn {
            try encodeContainer.encode(membershipArn, forKey: .membershipArn)
        }
        if let membershipId = self.membershipId {
            try encodeContainer.encode(membershipId, forKey: .membershipId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let membershipArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipArn)
        membershipArn = membershipArnDecoded
        let collaborationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationArn)
        collaborationArn = collaborationArnDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configuredAudienceModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredAudienceModelArn)
        configuredAudienceModelArn = configuredAudienceModelArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CleanRoomsClientTypes {
    /// A summary of the configured audience model association.
    public struct ConfiguredAudienceModelAssociationSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the configured audience model association.
        /// This member is required.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the collaboration that contains the configured audience model association.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// A unique identifier of the collaboration that configured audience model is associated with.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the configured audience model that was used for this configured audience model association.
        /// This member is required.
        public var configuredAudienceModelArn: Swift.String?
        /// The time at which the configured audience model association was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The description of the configured audience model association.
        public var description: Swift.String?
        /// A unique identifier of the configured audience model association.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the membership that contains the configured audience model association.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// A unique identifier of the membership that contains the configured audience model association.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The name of the configured audience model association.
        /// This member is required.
        public var name: Swift.String?
        /// The most recent time at which the configured audience model association was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            configuredAudienceModelArn: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.createTime = createTime
            self.description = description
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.ConfiguredTable: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedColumns
        case analysisMethod
        case analysisRuleTypes
        case arn
        case createTime
        case description
        case id
        case name
        case tableReference
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedColumns = allowedColumns {
            var allowedColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedColumns)
            for columnname0 in allowedColumns {
                try allowedColumnsContainer.encode(columnname0)
            }
        }
        if let analysisMethod = self.analysisMethod {
            try encodeContainer.encode(analysisMethod.rawValue, forKey: .analysisMethod)
        }
        if let analysisRuleTypes = analysisRuleTypes {
            var analysisRuleTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .analysisRuleTypes)
            for configuredtableanalysisruletype0 in analysisRuleTypes {
                try analysisRuleTypesContainer.encode(configuredtableanalysisruletype0.rawValue)
            }
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tableReference = self.tableReference {
            try encodeContainer.encode(tableReference, forKey: .tableReference)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tableReferenceDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.TableReference.self, forKey: .tableReference)
        tableReference = tableReferenceDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let analysisRuleTypesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType?].self, forKey: .analysisRuleTypes)
        var analysisRuleTypesDecoded0:[CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType]? = nil
        if let analysisRuleTypesContainer = analysisRuleTypesContainer {
            analysisRuleTypesDecoded0 = [CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType]()
            for enum0 in analysisRuleTypesContainer {
                if let enum0 = enum0 {
                    analysisRuleTypesDecoded0?.append(enum0)
                }
            }
        }
        analysisRuleTypes = analysisRuleTypesDecoded0
        let analysisMethodDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AnalysisMethod.self, forKey: .analysisMethod)
        analysisMethod = analysisMethodDecoded
        let allowedColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedColumns)
        var allowedColumnsDecoded0:[Swift.String]? = nil
        if let allowedColumnsContainer = allowedColumnsContainer {
            allowedColumnsDecoded0 = [Swift.String]()
            for string0 in allowedColumnsContainer {
                if let string0 = string0 {
                    allowedColumnsDecoded0?.append(string0)
                }
            }
        }
        allowedColumns = allowedColumnsDecoded0
    }
}

extension CleanRoomsClientTypes {
    /// A table that has been configured for use in a collaboration.
    public struct ConfiguredTable: Swift.Equatable {
        /// The columns within the underlying Glue table that can be utilized within collaborations.
        /// This member is required.
        public var allowedColumns: [Swift.String]?
        /// The analysis method for the configured table. The only valid value is currently `DIRECT_QUERY`.
        /// This member is required.
        public var analysisMethod: CleanRoomsClientTypes.AnalysisMethod?
        /// The types of analysis rules associated with this configured table. Currently, only one analysis rule may be associated with a configured table.
        /// This member is required.
        public var analysisRuleTypes: [CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType]?
        /// The unique ARN for the configured table.
        /// This member is required.
        public var arn: Swift.String?
        /// The time the configured table was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// A description for the configured table.
        public var description: Swift.String?
        /// The unique ID for the configured table.
        /// This member is required.
        public var id: Swift.String?
        /// A name for the configured table.
        /// This member is required.
        public var name: Swift.String?
        /// The Glue table that this configured table represents.
        /// This member is required.
        public var tableReference: CleanRoomsClientTypes.TableReference?
        /// The time the configured table was last updated
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            allowedColumns: [Swift.String]? = nil,
            analysisMethod: CleanRoomsClientTypes.AnalysisMethod? = nil,
            analysisRuleTypes: [CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType]? = nil,
            arn: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            tableReference: CleanRoomsClientTypes.TableReference? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.allowedColumns = allowedColumns
            self.analysisMethod = analysisMethod
            self.analysisRuleTypes = analysisRuleTypes
            self.arn = arn
            self.createTime = createTime
            self.description = description
            self.id = id
            self.name = name
            self.tableReference = tableReference
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.ConfiguredTableAnalysisRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredTableArn
        case configuredTableId
        case createTime
        case policy
        case type
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuredTableArn = self.configuredTableArn {
            try encodeContainer.encode(configuredTableArn, forKey: .configuredTableArn)
        }
        if let configuredTableId = self.configuredTableId {
            try encodeContainer.encode(configuredTableId, forKey: .configuredTableId)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let policy = self.policy {
            try encodeContainer.encode(policy, forKey: .policy)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredTableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredTableId)
        configuredTableId = configuredTableIdDecoded
        let configuredTableArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredTableArn)
        configuredTableArn = configuredTableArnDecoded
        let policyDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy.self, forKey: .policy)
        policy = policyDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType.self, forKey: .type)
        type = typeDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension CleanRoomsClientTypes {
    /// A configured table analysis rule, which limits how data for this table can be used.
    public struct ConfiguredTableAnalysisRule: Swift.Equatable {
        /// The unique ARN for the configured table.
        /// This member is required.
        public var configuredTableArn: Swift.String?
        /// The unique ID for the configured table.
        /// This member is required.
        public var configuredTableId: Swift.String?
        /// The time the configured table analysis rule was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The policy that controls SQL query rules.
        /// This member is required.
        public var policy: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy?
        /// The type of configured table analysis rule.
        /// This member is required.
        public var type: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType?
        /// The time the configured table analysis rule was last updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            configuredTableArn: Swift.String? = nil,
            configuredTableId: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            policy: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy? = nil,
            type: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.configuredTableArn = configuredTableArn
            self.configuredTableId = configuredTableId
            self.createTime = createTime
            self.policy = policy
            self.type = type
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case v1
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .v1(v1):
                try container.encode(v1, forKey: .v1)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let v1Decoded = try values.decodeIfPresent(CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicyV1.self, forKey: .v1)
        if let v1 = v1Decoded {
            self = .v1(v1)
            return
        }
        self = .sdkUnknown("")
    }
}

extension CleanRoomsClientTypes {
    /// Controls on the query specifications that can be run on a configured table.
    public enum ConfiguredTableAnalysisRulePolicy: Swift.Equatable {
        /// Controls on the query specifications that can be run on a configured table.
        case v1(CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicyV1)
        case sdkUnknown(Swift.String)
    }

}

extension CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicyV1: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregation
        case custom
        case list
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .aggregation(aggregation):
                try container.encode(aggregation, forKey: .aggregation)
            case let .custom(custom):
                try container.encode(custom, forKey: .custom)
            case let .list(list):
                try container.encode(list, forKey: .list)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let listDecoded = try values.decodeIfPresent(CleanRoomsClientTypes.AnalysisRuleList.self, forKey: .list)
        if let list = listDecoded {
            self = .list(list)
            return
        }
        let aggregationDecoded = try values.decodeIfPresent(CleanRoomsClientTypes.AnalysisRuleAggregation.self, forKey: .aggregation)
        if let aggregation = aggregationDecoded {
            self = .aggregation(aggregation)
            return
        }
        let customDecoded = try values.decodeIfPresent(CleanRoomsClientTypes.AnalysisRuleCustom.self, forKey: .custom)
        if let custom = customDecoded {
            self = .custom(custom)
            return
        }
        self = .sdkUnknown("")
    }
}

extension CleanRoomsClientTypes {
    /// Controls on the query specifications that can be run on a configured table.
    public enum ConfiguredTableAnalysisRulePolicyV1: Swift.Equatable {
        /// Analysis rule type that enables only list queries on a configured table.
        case list(CleanRoomsClientTypes.AnalysisRuleList)
        /// Analysis rule type that enables only aggregation queries on a configured table.
        case aggregation(CleanRoomsClientTypes.AnalysisRuleAggregation)
        /// A type of analysis rule that enables the table owner to approve custom SQL queries on their configured tables. It supports differential privacy.
        case custom(CleanRoomsClientTypes.AnalysisRuleCustom)
        case sdkUnknown(Swift.String)
    }

}

extension CleanRoomsClientTypes {
    public enum ConfiguredTableAnalysisRuleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aggregation
        case custom
        case list
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfiguredTableAnalysisRuleType] {
            return [
                .aggregation,
                .custom,
                .list,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aggregation: return "AGGREGATION"
            case .custom: return "CUSTOM"
            case .list: return "LIST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfiguredTableAnalysisRuleType(rawValue: rawValue) ?? ConfiguredTableAnalysisRuleType.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes.ConfiguredTableAssociation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case configuredTableArn
        case configuredTableId
        case createTime
        case description
        case id
        case membershipArn
        case membershipId
        case name
        case roleArn
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let configuredTableArn = self.configuredTableArn {
            try encodeContainer.encode(configuredTableArn, forKey: .configuredTableArn)
        }
        if let configuredTableId = self.configuredTableId {
            try encodeContainer.encode(configuredTableId, forKey: .configuredTableId)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let membershipArn = self.membershipArn {
            try encodeContainer.encode(membershipArn, forKey: .membershipArn)
        }
        if let membershipId = self.membershipId {
            try encodeContainer.encode(membershipId, forKey: .membershipId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let configuredTableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredTableId)
        configuredTableId = configuredTableIdDecoded
        let configuredTableArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredTableArn)
        configuredTableArn = configuredTableArnDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let membershipArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipArn)
        membershipArn = membershipArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension CleanRoomsClientTypes {
    /// A configured table association links a configured table to a collaboration.
    public struct ConfiguredTableAssociation: Swift.Equatable {
        /// The unique ARN for the configured table association.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique ARN for the configured table that the association refers to.
        /// This member is required.
        public var configuredTableArn: Swift.String?
        /// The unique ID for the configured table that the association refers to.
        /// This member is required.
        public var configuredTableId: Swift.String?
        /// The time the configured table association was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// A description of the configured table association.
        public var description: Swift.String?
        /// The unique ID for the configured table association.
        /// This member is required.
        public var id: Swift.String?
        /// The unique ARN for the membership this configured table association belongs to.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The unique ID for the membership this configured table association belongs to.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The name of the configured table association, in lowercase. The table is identified by this name when running protected queries against the underlying data.
        /// This member is required.
        public var name: Swift.String?
        /// The service will assume this role to access catalog metadata and query the table.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The time the configured table association was last updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            configuredTableArn: Swift.String? = nil,
            configuredTableId: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.configuredTableArn = configuredTableArn
            self.configuredTableId = configuredTableId
            self.createTime = createTime
            self.description = description
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.roleArn = roleArn
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.ConfiguredTableAssociationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case configuredTableId
        case createTime
        case id
        case membershipArn
        case membershipId
        case name
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let configuredTableId = self.configuredTableId {
            try encodeContainer.encode(configuredTableId, forKey: .configuredTableId)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let membershipArn = self.membershipArn {
            try encodeContainer.encode(membershipArn, forKey: .membershipArn)
        }
        if let membershipId = self.membershipId {
            try encodeContainer.encode(membershipId, forKey: .membershipId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredTableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredTableId)
        configuredTableId = configuredTableIdDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let membershipArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipArn)
        membershipArn = membershipArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension CleanRoomsClientTypes {
    /// The configured table association summary for the objects listed by the request.
    public struct ConfiguredTableAssociationSummary: Swift.Equatable {
        /// The unique ARN for the configured table association.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique configured table ID that this configured table association refers to.
        /// This member is required.
        public var configuredTableId: Swift.String?
        /// The time the configured table association was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The unique ID for the configured table association.
        /// This member is required.
        public var id: Swift.String?
        /// The unique ARN for the membership that the configured table association belongs to.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The unique ID for the membership that the configured table association belongs to.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The name of the configured table association. The table is identified by this name when running Protected Queries against the underlying data.
        /// This member is required.
        public var name: Swift.String?
        /// The time the configured table association was last updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            configuredTableId: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.configuredTableId = configuredTableId
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.ConfiguredTableSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisMethod
        case analysisRuleTypes
        case arn
        case createTime
        case id
        case name
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisMethod = self.analysisMethod {
            try encodeContainer.encode(analysisMethod.rawValue, forKey: .analysisMethod)
        }
        if let analysisRuleTypes = analysisRuleTypes {
            var analysisRuleTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .analysisRuleTypes)
            for configuredtableanalysisruletype0 in analysisRuleTypes {
                try analysisRuleTypesContainer.encode(configuredtableanalysisruletype0.rawValue)
            }
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let analysisRuleTypesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType?].self, forKey: .analysisRuleTypes)
        var analysisRuleTypesDecoded0:[CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType]? = nil
        if let analysisRuleTypesContainer = analysisRuleTypesContainer {
            analysisRuleTypesDecoded0 = [CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType]()
            for enum0 in analysisRuleTypesContainer {
                if let enum0 = enum0 {
                    analysisRuleTypesDecoded0?.append(enum0)
                }
            }
        }
        analysisRuleTypes = analysisRuleTypesDecoded0
        let analysisMethodDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AnalysisMethod.self, forKey: .analysisMethod)
        analysisMethod = analysisMethodDecoded
    }
}

extension CleanRoomsClientTypes {
    /// The configured table summary for the objects listed by the request.
    public struct ConfiguredTableSummary: Swift.Equatable {
        /// The analysis method for the configured tables. The only valid value is currently `DIRECT_QUERY`.
        /// This member is required.
        public var analysisMethod: CleanRoomsClientTypes.AnalysisMethod?
        /// The types of analysis rules associated with this configured table.
        /// This member is required.
        public var analysisRuleTypes: [CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType]?
        /// The unique ARN of the configured table.
        /// This member is required.
        public var arn: Swift.String?
        /// The time the configured table was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The unique ID of the configured table.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the configured table.
        /// This member is required.
        public var name: Swift.String?
        /// The time the configured table was last updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            analysisMethod: CleanRoomsClientTypes.AnalysisMethod? = nil,
            analysisRuleTypes: [CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType]? = nil,
            arn: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.analysisMethod = analysisMethod
            self.analysisRuleTypes = analysisRuleTypes
            self.arn = arn
            self.createTime = createTime
            self.id = id
            self.name = name
            self.updateTime = updateTime
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.reason = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// A reason code for the exception.
        public internal(set) var reason: CleanRoomsClientTypes.ConflictExceptionReason? = nil
        /// The ID of the conflicting resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the conflicting resource.
        public internal(set) var resourceType: CleanRoomsClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: CleanRoomsClientTypes.ConflictExceptionReason? = nil,
        resourceId: Swift.String? = nil,
        resourceType: CleanRoomsClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: CleanRoomsClientTypes.ResourceType?
    let reason: CleanRoomsClientTypes.ConflictExceptionReason?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ConflictExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension CleanRoomsClientTypes {
    public enum ConflictExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alreadyExists
        case invalidState
        case subresourcesExist
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .alreadyExists,
                .invalidState,
                .subresourcesExist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alreadyExists: return "ALREADY_EXISTS"
            case .invalidState: return "INVALID_STATE"
            case .subresourcesExist: return "SUBRESOURCES_EXIST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConflictExceptionReason(rawValue: rawValue) ?? ConflictExceptionReason.sdkUnknown(rawValue)
        }
    }
}

extension CreateAnalysisTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAnalysisTemplateInput(analysisParameters: \(Swift.String(describing: analysisParameters)), description: \(Swift.String(describing: description)), format: \(Swift.String(describing: format)), membershipIdentifier: \(Swift.String(describing: membershipIdentifier)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), source: \"CONTENT_REDACTED\")"}
}

extension CreateAnalysisTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisParameters
        case description
        case format
        case name
        case source
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisParameters = analysisParameters {
            var analysisParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .analysisParameters)
            for analysisparameter0 in analysisParameters {
                try analysisParametersContainer.encode(analysisparameter0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAnalysisTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/analysistemplates"
    }
}

public struct CreateAnalysisTemplateInput: Swift.Equatable {
    /// The parameters of the analysis template.
    public var analysisParameters: [CleanRoomsClientTypes.AnalysisParameter]?
    /// The description of the analysis template.
    public var description: Swift.String?
    /// The format of the analysis template.
    /// This member is required.
    public var format: CleanRoomsClientTypes.AnalysisFormat?
    /// The identifier for a membership resource.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The name of the analysis template.
    /// This member is required.
    public var name: Swift.String?
    /// The information in the analysis template. Currently supports text, the query text for the analysis template.
    /// This member is required.
    public var source: CleanRoomsClientTypes.AnalysisSource?
    /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        analysisParameters: [CleanRoomsClientTypes.AnalysisParameter]? = nil,
        description: Swift.String? = nil,
        format: CleanRoomsClientTypes.AnalysisFormat? = nil,
        membershipIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        source: CleanRoomsClientTypes.AnalysisSource? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.analysisParameters = analysisParameters
        self.description = description
        self.format = format
        self.membershipIdentifier = membershipIdentifier
        self.name = name
        self.source = source
        self.tags = tags
    }
}

struct CreateAnalysisTemplateInputBody: Swift.Equatable {
    let description: Swift.String?
    let name: Swift.String?
    let format: CleanRoomsClientTypes.AnalysisFormat?
    let source: CleanRoomsClientTypes.AnalysisSource?
    let tags: [Swift.String:Swift.String]?
    let analysisParameters: [CleanRoomsClientTypes.AnalysisParameter]?
}

extension CreateAnalysisTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisParameters
        case description
        case format
        case name
        case source
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AnalysisFormat.self, forKey: .format)
        format = formatDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AnalysisSource.self, forKey: .source)
        source = sourceDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let analysisParametersContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.AnalysisParameter?].self, forKey: .analysisParameters)
        var analysisParametersDecoded0:[CleanRoomsClientTypes.AnalysisParameter]? = nil
        if let analysisParametersContainer = analysisParametersContainer {
            analysisParametersDecoded0 = [CleanRoomsClientTypes.AnalysisParameter]()
            for structure0 in analysisParametersContainer {
                if let structure0 = structure0 {
                    analysisParametersDecoded0?.append(structure0)
                }
            }
        }
        analysisParameters = analysisParametersDecoded0
    }
}

extension CreateAnalysisTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAnalysisTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.analysisTemplate = output.analysisTemplate
        } else {
            self.analysisTemplate = nil
        }
    }
}

public struct CreateAnalysisTemplateOutput: Swift.Equatable {
    /// The analysis template.
    /// This member is required.
    public var analysisTemplate: CleanRoomsClientTypes.AnalysisTemplate?

    public init(
        analysisTemplate: CleanRoomsClientTypes.AnalysisTemplate? = nil
    )
    {
        self.analysisTemplate = analysisTemplate
    }
}

struct CreateAnalysisTemplateOutputBody: Swift.Equatable {
    let analysisTemplate: CleanRoomsClientTypes.AnalysisTemplate?
}

extension CreateAnalysisTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisTemplateDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AnalysisTemplate.self, forKey: .analysisTemplate)
        analysisTemplate = analysisTemplateDecoded
    }
}

enum CreateAnalysisTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateCollaborationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorDisplayName
        case creatorMemberAbilities
        case creatorPaymentConfiguration
        case dataEncryptionMetadata
        case description
        case members
        case name
        case queryLogStatus
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creatorDisplayName = self.creatorDisplayName {
            try encodeContainer.encode(creatorDisplayName, forKey: .creatorDisplayName)
        }
        if let creatorMemberAbilities = creatorMemberAbilities {
            var creatorMemberAbilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .creatorMemberAbilities)
            for memberability0 in creatorMemberAbilities {
                try creatorMemberAbilitiesContainer.encode(memberability0.rawValue)
            }
        }
        if let creatorPaymentConfiguration = self.creatorPaymentConfiguration {
            try encodeContainer.encode(creatorPaymentConfiguration, forKey: .creatorPaymentConfiguration)
        }
        if let dataEncryptionMetadata = self.dataEncryptionMetadata {
            try encodeContainer.encode(dataEncryptionMetadata, forKey: .dataEncryptionMetadata)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let members = members {
            var membersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .members)
            for memberspecification0 in members {
                try membersContainer.encode(memberspecification0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let queryLogStatus = self.queryLogStatus {
            try encodeContainer.encode(queryLogStatus.rawValue, forKey: .queryLogStatus)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateCollaborationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/collaborations"
    }
}

public struct CreateCollaborationInput: Swift.Equatable {
    /// The display name of the collaboration creator.
    /// This member is required.
    public var creatorDisplayName: Swift.String?
    /// The abilities granted to the collaboration creator.
    /// This member is required.
    public var creatorMemberAbilities: [CleanRoomsClientTypes.MemberAbility]?
    /// The collaboration creator's payment responsibilities set by the collaboration creator. If the collaboration creator hasn't specified anyone as the member paying for query compute costs, then the member who can query is the default payer.
    public var creatorPaymentConfiguration: CleanRoomsClientTypes.PaymentConfiguration?
    /// The settings for client-side encryption with Cryptographic Computing for Clean Rooms.
    public var dataEncryptionMetadata: CleanRoomsClientTypes.DataEncryptionMetadata?
    /// A description of the collaboration provided by the collaboration owner.
    /// This member is required.
    public var description: Swift.String?
    /// A list of initial members, not including the creator. This list is immutable.
    /// This member is required.
    public var members: [CleanRoomsClientTypes.MemberSpecification]?
    /// The display name for a collaboration.
    /// This member is required.
    public var name: Swift.String?
    /// An indicator as to whether query logging has been enabled or disabled for the collaboration.
    /// This member is required.
    public var queryLogStatus: CleanRoomsClientTypes.CollaborationQueryLogStatus?
    /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        creatorDisplayName: Swift.String? = nil,
        creatorMemberAbilities: [CleanRoomsClientTypes.MemberAbility]? = nil,
        creatorPaymentConfiguration: CleanRoomsClientTypes.PaymentConfiguration? = nil,
        dataEncryptionMetadata: CleanRoomsClientTypes.DataEncryptionMetadata? = nil,
        description: Swift.String? = nil,
        members: [CleanRoomsClientTypes.MemberSpecification]? = nil,
        name: Swift.String? = nil,
        queryLogStatus: CleanRoomsClientTypes.CollaborationQueryLogStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.creatorDisplayName = creatorDisplayName
        self.creatorMemberAbilities = creatorMemberAbilities
        self.creatorPaymentConfiguration = creatorPaymentConfiguration
        self.dataEncryptionMetadata = dataEncryptionMetadata
        self.description = description
        self.members = members
        self.name = name
        self.queryLogStatus = queryLogStatus
        self.tags = tags
    }
}

struct CreateCollaborationInputBody: Swift.Equatable {
    let members: [CleanRoomsClientTypes.MemberSpecification]?
    let name: Swift.String?
    let description: Swift.String?
    let creatorMemberAbilities: [CleanRoomsClientTypes.MemberAbility]?
    let creatorDisplayName: Swift.String?
    let dataEncryptionMetadata: CleanRoomsClientTypes.DataEncryptionMetadata?
    let queryLogStatus: CleanRoomsClientTypes.CollaborationQueryLogStatus?
    let tags: [Swift.String:Swift.String]?
    let creatorPaymentConfiguration: CleanRoomsClientTypes.PaymentConfiguration?
}

extension CreateCollaborationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creatorDisplayName
        case creatorMemberAbilities
        case creatorPaymentConfiguration
        case dataEncryptionMetadata
        case description
        case members
        case name
        case queryLogStatus
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.MemberSpecification?].self, forKey: .members)
        var membersDecoded0:[CleanRoomsClientTypes.MemberSpecification]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [CleanRoomsClientTypes.MemberSpecification]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creatorMemberAbilitiesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.MemberAbility?].self, forKey: .creatorMemberAbilities)
        var creatorMemberAbilitiesDecoded0:[CleanRoomsClientTypes.MemberAbility]? = nil
        if let creatorMemberAbilitiesContainer = creatorMemberAbilitiesContainer {
            creatorMemberAbilitiesDecoded0 = [CleanRoomsClientTypes.MemberAbility]()
            for string0 in creatorMemberAbilitiesContainer {
                if let string0 = string0 {
                    creatorMemberAbilitiesDecoded0?.append(string0)
                }
            }
        }
        creatorMemberAbilities = creatorMemberAbilitiesDecoded0
        let creatorDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorDisplayName)
        creatorDisplayName = creatorDisplayNameDecoded
        let dataEncryptionMetadataDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.DataEncryptionMetadata.self, forKey: .dataEncryptionMetadata)
        dataEncryptionMetadata = dataEncryptionMetadataDecoded
        let queryLogStatusDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.CollaborationQueryLogStatus.self, forKey: .queryLogStatus)
        queryLogStatus = queryLogStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let creatorPaymentConfigurationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PaymentConfiguration.self, forKey: .creatorPaymentConfiguration)
        creatorPaymentConfiguration = creatorPaymentConfigurationDecoded
    }
}

extension CreateCollaborationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateCollaborationOutputBody = try responseDecoder.decode(responseBody: data)
            self.collaboration = output.collaboration
        } else {
            self.collaboration = nil
        }
    }
}

public struct CreateCollaborationOutput: Swift.Equatable {
    /// The entire created collaboration object.
    /// This member is required.
    public var collaboration: CleanRoomsClientTypes.Collaboration?

    public init(
        collaboration: CleanRoomsClientTypes.Collaboration? = nil
    )
    {
        self.collaboration = collaboration
    }
}

struct CreateCollaborationOutputBody: Swift.Equatable {
    let collaboration: CleanRoomsClientTypes.Collaboration?
}

extension CreateCollaborationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collaboration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collaborationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.Collaboration.self, forKey: .collaboration)
        collaboration = collaborationDecoded
    }
}

enum CreateCollaborationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateConfiguredAudienceModelAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredAudienceModelArn
        case configuredAudienceModelAssociationName
        case description
        case manageResourcePolicies
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuredAudienceModelArn = self.configuredAudienceModelArn {
            try encodeContainer.encode(configuredAudienceModelArn, forKey: .configuredAudienceModelArn)
        }
        if let configuredAudienceModelAssociationName = self.configuredAudienceModelAssociationName {
            try encodeContainer.encode(configuredAudienceModelAssociationName, forKey: .configuredAudienceModelAssociationName)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let manageResourcePolicies = self.manageResourcePolicies {
            try encodeContainer.encode(manageResourcePolicies, forKey: .manageResourcePolicies)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateConfiguredAudienceModelAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredaudiencemodelassociations"
    }
}

public struct CreateConfiguredAudienceModelAssociationInput: Swift.Equatable {
    /// A unique identifier for the configured audience model that you want to associate.
    /// This member is required.
    public var configuredAudienceModelArn: Swift.String?
    /// The name of the configured audience model association.
    /// This member is required.
    public var configuredAudienceModelAssociationName: Swift.String?
    /// A description of the configured audience model association.
    public var description: Swift.String?
    /// When TRUE, indicates that the resource policy for the configured audience model resource being associated is configured for Clean Rooms to manage permissions related to the given collaboration. When FALSE, indicates that the configured audience model resource owner will manage permissions related to the given collaboration. Setting this to TRUE requires you to have permissions to create, update, and delete the resource policy for the cleanrooms-ml resource when you call the [DeleteConfiguredAudienceModelAssociation] resource. In addition, if you are the collaboration creator and specify TRUE, you must have the same permissions when you call the [DeleteMember] and [DeleteCollaboration] APIs.
    /// This member is required.
    public var manageResourcePolicies: Swift.Bool?
    /// A unique identifier for one of your memberships for a collaboration. The configured audience model is associated to the collaboration that this membership belongs to. Accepts a membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        configuredAudienceModelArn: Swift.String? = nil,
        configuredAudienceModelAssociationName: Swift.String? = nil,
        description: Swift.String? = nil,
        manageResourcePolicies: Swift.Bool? = nil,
        membershipIdentifier: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.configuredAudienceModelArn = configuredAudienceModelArn
        self.configuredAudienceModelAssociationName = configuredAudienceModelAssociationName
        self.description = description
        self.manageResourcePolicies = manageResourcePolicies
        self.membershipIdentifier = membershipIdentifier
        self.tags = tags
    }
}

struct CreateConfiguredAudienceModelAssociationInputBody: Swift.Equatable {
    let configuredAudienceModelArn: Swift.String?
    let configuredAudienceModelAssociationName: Swift.String?
    let manageResourcePolicies: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
    let description: Swift.String?
}

extension CreateConfiguredAudienceModelAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredAudienceModelArn
        case configuredAudienceModelAssociationName
        case description
        case manageResourcePolicies
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredAudienceModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredAudienceModelArn)
        configuredAudienceModelArn = configuredAudienceModelArnDecoded
        let configuredAudienceModelAssociationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredAudienceModelAssociationName)
        configuredAudienceModelAssociationName = configuredAudienceModelAssociationNameDecoded
        let manageResourcePoliciesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .manageResourcePolicies)
        manageResourcePolicies = manageResourcePoliciesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension CreateConfiguredAudienceModelAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateConfiguredAudienceModelAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuredAudienceModelAssociation = output.configuredAudienceModelAssociation
        } else {
            self.configuredAudienceModelAssociation = nil
        }
    }
}

public struct CreateConfiguredAudienceModelAssociationOutput: Swift.Equatable {
    /// Information about the configured audience model association.
    /// This member is required.
    public var configuredAudienceModelAssociation: CleanRoomsClientTypes.ConfiguredAudienceModelAssociation?

    public init(
        configuredAudienceModelAssociation: CleanRoomsClientTypes.ConfiguredAudienceModelAssociation? = nil
    )
    {
        self.configuredAudienceModelAssociation = configuredAudienceModelAssociation
    }
}

struct CreateConfiguredAudienceModelAssociationOutputBody: Swift.Equatable {
    let configuredAudienceModelAssociation: CleanRoomsClientTypes.ConfiguredAudienceModelAssociation?
}

extension CreateConfiguredAudienceModelAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredAudienceModelAssociation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredAudienceModelAssociationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ConfiguredAudienceModelAssociation.self, forKey: .configuredAudienceModelAssociation)
        configuredAudienceModelAssociation = configuredAudienceModelAssociationDecoded
    }
}

enum CreateConfiguredAudienceModelAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateConfiguredTableAnalysisRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisRulePolicy
        case analysisRuleType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisRulePolicy = self.analysisRulePolicy {
            try encodeContainer.encode(analysisRulePolicy, forKey: .analysisRulePolicy)
        }
        if let analysisRuleType = self.analysisRuleType {
            try encodeContainer.encode(analysisRuleType.rawValue, forKey: .analysisRuleType)
        }
    }
}

extension CreateConfiguredTableAnalysisRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configuredTableIdentifier = configuredTableIdentifier else {
            return nil
        }
        return "/configuredTables/\(configuredTableIdentifier.urlPercentEncoding())/analysisRule"
    }
}

public struct CreateConfiguredTableAnalysisRuleInput: Swift.Equatable {
    /// The entire created configured table analysis rule object.
    /// This member is required.
    public var analysisRulePolicy: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy?
    /// The type of analysis rule.
    /// This member is required.
    public var analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType?
    /// The identifier for the configured table to create the analysis rule for. Currently accepts the configured table ID.
    /// This member is required.
    public var configuredTableIdentifier: Swift.String?

    public init(
        analysisRulePolicy: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy? = nil,
        analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType? = nil,
        configuredTableIdentifier: Swift.String? = nil
    )
    {
        self.analysisRulePolicy = analysisRulePolicy
        self.analysisRuleType = analysisRuleType
        self.configuredTableIdentifier = configuredTableIdentifier
    }
}

struct CreateConfiguredTableAnalysisRuleInputBody: Swift.Equatable {
    let analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType?
    let analysisRulePolicy: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy?
}

extension CreateConfiguredTableAnalysisRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisRulePolicy
        case analysisRuleType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisRuleTypeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType.self, forKey: .analysisRuleType)
        analysisRuleType = analysisRuleTypeDecoded
        let analysisRulePolicyDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy.self, forKey: .analysisRulePolicy)
        analysisRulePolicy = analysisRulePolicyDecoded
    }
}

extension CreateConfiguredTableAnalysisRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateConfiguredTableAnalysisRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.analysisRule = output.analysisRule
        } else {
            self.analysisRule = nil
        }
    }
}

public struct CreateConfiguredTableAnalysisRuleOutput: Swift.Equatable {
    /// The entire created analysis rule.
    /// This member is required.
    public var analysisRule: CleanRoomsClientTypes.ConfiguredTableAnalysisRule?

    public init(
        analysisRule: CleanRoomsClientTypes.ConfiguredTableAnalysisRule? = nil
    )
    {
        self.analysisRule = analysisRule
    }
}

struct CreateConfiguredTableAnalysisRuleOutputBody: Swift.Equatable {
    let analysisRule: CleanRoomsClientTypes.ConfiguredTableAnalysisRule?
}

extension CreateConfiguredTableAnalysisRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisRule
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisRuleDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ConfiguredTableAnalysisRule.self, forKey: .analysisRule)
        analysisRule = analysisRuleDecoded
    }
}

enum CreateConfiguredTableAnalysisRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateConfiguredTableAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredTableIdentifier
        case description
        case name
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuredTableIdentifier = self.configuredTableIdentifier {
            try encodeContainer.encode(configuredTableIdentifier, forKey: .configuredTableIdentifier)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateConfiguredTableAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredTableAssociations"
    }
}

public struct CreateConfiguredTableAssociationInput: Swift.Equatable {
    /// A unique identifier for the configured table to be associated to. Currently accepts a configured table ID.
    /// This member is required.
    public var configuredTableIdentifier: Swift.String?
    /// A description for the configured table association.
    public var description: Swift.String?
    /// A unique identifier for one of your memberships for a collaboration. The configured table is associated to the collaboration that this membership belongs to. Currently accepts a membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The name of the configured table association. This name is used to query the underlying configured table.
    /// This member is required.
    public var name: Swift.String?
    /// The service will assume this role to access catalog metadata and query the table.
    /// This member is required.
    public var roleArn: Swift.String?
    /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        configuredTableIdentifier: Swift.String? = nil,
        description: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.configuredTableIdentifier = configuredTableIdentifier
        self.description = description
        self.membershipIdentifier = membershipIdentifier
        self.name = name
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreateConfiguredTableAssociationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let configuredTableIdentifier: Swift.String?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateConfiguredTableAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredTableIdentifier
        case description
        case name
        case roleArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let configuredTableIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .configuredTableIdentifier)
        configuredTableIdentifier = configuredTableIdentifierDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConfiguredTableAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateConfiguredTableAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuredTableAssociation = output.configuredTableAssociation
        } else {
            self.configuredTableAssociation = nil
        }
    }
}

public struct CreateConfiguredTableAssociationOutput: Swift.Equatable {
    /// The entire configured table association object.
    /// This member is required.
    public var configuredTableAssociation: CleanRoomsClientTypes.ConfiguredTableAssociation?

    public init(
        configuredTableAssociation: CleanRoomsClientTypes.ConfiguredTableAssociation? = nil
    )
    {
        self.configuredTableAssociation = configuredTableAssociation
    }
}

struct CreateConfiguredTableAssociationOutputBody: Swift.Equatable {
    let configuredTableAssociation: CleanRoomsClientTypes.ConfiguredTableAssociation?
}

extension CreateConfiguredTableAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredTableAssociation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredTableAssociationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ConfiguredTableAssociation.self, forKey: .configuredTableAssociation)
        configuredTableAssociation = configuredTableAssociationDecoded
    }
}

enum CreateConfiguredTableAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateConfiguredTableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedColumns
        case analysisMethod
        case description
        case name
        case tableReference
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowedColumns = allowedColumns {
            var allowedColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .allowedColumns)
            for columnname0 in allowedColumns {
                try allowedColumnsContainer.encode(columnname0)
            }
        }
        if let analysisMethod = self.analysisMethod {
            try encodeContainer.encode(analysisMethod.rawValue, forKey: .analysisMethod)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tableReference = self.tableReference {
            try encodeContainer.encode(tableReference, forKey: .tableReference)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateConfiguredTableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/configuredTables"
    }
}

public struct CreateConfiguredTableInput: Swift.Equatable {
    /// The columns of the underlying table that can be used by collaborations or analysis rules.
    /// This member is required.
    public var allowedColumns: [Swift.String]?
    /// The analysis method for the configured tables. The only valid value is currently `DIRECT_QUERY`.
    /// This member is required.
    public var analysisMethod: CleanRoomsClientTypes.AnalysisMethod?
    /// A description for the configured table.
    public var description: Swift.String?
    /// The name of the configured table.
    /// This member is required.
    public var name: Swift.String?
    /// A reference to the Glue table being configured.
    /// This member is required.
    public var tableReference: CleanRoomsClientTypes.TableReference?
    /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        allowedColumns: [Swift.String]? = nil,
        analysisMethod: CleanRoomsClientTypes.AnalysisMethod? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tableReference: CleanRoomsClientTypes.TableReference? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.allowedColumns = allowedColumns
        self.analysisMethod = analysisMethod
        self.description = description
        self.name = name
        self.tableReference = tableReference
        self.tags = tags
    }
}

struct CreateConfiguredTableInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let tableReference: CleanRoomsClientTypes.TableReference?
    let allowedColumns: [Swift.String]?
    let analysisMethod: CleanRoomsClientTypes.AnalysisMethod?
    let tags: [Swift.String:Swift.String]?
}

extension CreateConfiguredTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowedColumns
        case analysisMethod
        case description
        case name
        case tableReference
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tableReferenceDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.TableReference.self, forKey: .tableReference)
        tableReference = tableReferenceDecoded
        let allowedColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .allowedColumns)
        var allowedColumnsDecoded0:[Swift.String]? = nil
        if let allowedColumnsContainer = allowedColumnsContainer {
            allowedColumnsDecoded0 = [Swift.String]()
            for string0 in allowedColumnsContainer {
                if let string0 = string0 {
                    allowedColumnsDecoded0?.append(string0)
                }
            }
        }
        allowedColumns = allowedColumnsDecoded0
        let analysisMethodDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AnalysisMethod.self, forKey: .analysisMethod)
        analysisMethod = analysisMethodDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateConfiguredTableOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateConfiguredTableOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuredTable = output.configuredTable
        } else {
            self.configuredTable = nil
        }
    }
}

public struct CreateConfiguredTableOutput: Swift.Equatable {
    /// The created configured table.
    /// This member is required.
    public var configuredTable: CleanRoomsClientTypes.ConfiguredTable?

    public init(
        configuredTable: CleanRoomsClientTypes.ConfiguredTable? = nil
    )
    {
        self.configuredTable = configuredTable
    }
}

struct CreateConfiguredTableOutputBody: Swift.Equatable {
    let configuredTable: CleanRoomsClientTypes.ConfiguredTable?
}

extension CreateConfiguredTableOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredTable
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredTableDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ConfiguredTable.self, forKey: .configuredTable)
        configuredTable = configuredTableDecoded
    }
}

enum CreateConfiguredTableOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collaborationIdentifier
        case defaultResultConfiguration
        case paymentConfiguration
        case queryLogStatus
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collaborationIdentifier = self.collaborationIdentifier {
            try encodeContainer.encode(collaborationIdentifier, forKey: .collaborationIdentifier)
        }
        if let defaultResultConfiguration = self.defaultResultConfiguration {
            try encodeContainer.encode(defaultResultConfiguration, forKey: .defaultResultConfiguration)
        }
        if let paymentConfiguration = self.paymentConfiguration {
            try encodeContainer.encode(paymentConfiguration, forKey: .paymentConfiguration)
        }
        if let queryLogStatus = self.queryLogStatus {
            try encodeContainer.encode(queryLogStatus.rawValue, forKey: .queryLogStatus)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/memberships"
    }
}

public struct CreateMembershipInput: Swift.Equatable {
    /// The unique ID for the associated collaboration.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The default protected query result configuration as specified by the member who can receive results.
    public var defaultResultConfiguration: CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration?
    /// The payment responsibilities accepted by the collaboration member. Not required if the collaboration member has the member ability to run queries. Required if the collaboration member doesn't have the member ability to run queries but is configured as a payer by the collaboration creator.
    public var paymentConfiguration: CleanRoomsClientTypes.MembershipPaymentConfiguration?
    /// An indicator as to whether query logging has been enabled or disabled for the membership.
    /// This member is required.
    public var queryLogStatus: CleanRoomsClientTypes.MembershipQueryLogStatus?
    /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        defaultResultConfiguration: CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration? = nil,
        paymentConfiguration: CleanRoomsClientTypes.MembershipPaymentConfiguration? = nil,
        queryLogStatus: CleanRoomsClientTypes.MembershipQueryLogStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.defaultResultConfiguration = defaultResultConfiguration
        self.paymentConfiguration = paymentConfiguration
        self.queryLogStatus = queryLogStatus
        self.tags = tags
    }
}

struct CreateMembershipInputBody: Swift.Equatable {
    let collaborationIdentifier: Swift.String?
    let queryLogStatus: CleanRoomsClientTypes.MembershipQueryLogStatus?
    let tags: [Swift.String:Swift.String]?
    let defaultResultConfiguration: CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration?
    let paymentConfiguration: CleanRoomsClientTypes.MembershipPaymentConfiguration?
}

extension CreateMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collaborationIdentifier
        case defaultResultConfiguration
        case paymentConfiguration
        case queryLogStatus
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collaborationIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationIdentifier)
        collaborationIdentifier = collaborationIdentifierDecoded
        let queryLogStatusDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.MembershipQueryLogStatus.self, forKey: .queryLogStatus)
        queryLogStatus = queryLogStatusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let defaultResultConfigurationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration.self, forKey: .defaultResultConfiguration)
        defaultResultConfiguration = defaultResultConfigurationDecoded
        let paymentConfigurationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.MembershipPaymentConfiguration.self, forKey: .paymentConfiguration)
        paymentConfiguration = paymentConfigurationDecoded
    }
}

extension CreateMembershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMembershipOutputBody = try responseDecoder.decode(responseBody: data)
            self.membership = output.membership
        } else {
            self.membership = nil
        }
    }
}

public struct CreateMembershipOutput: Swift.Equatable {
    /// The membership that was created.
    /// This member is required.
    public var membership: CleanRoomsClientTypes.Membership?

    public init(
        membership: CleanRoomsClientTypes.Membership? = nil
    )
    {
        self.membership = membership
    }
}

struct CreateMembershipOutputBody: Swift.Equatable {
    let membership: CleanRoomsClientTypes.Membership?
}

extension CreateMembershipOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case membership
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membershipDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.Membership.self, forKey: .membership)
        membership = membershipDecoded
    }
}

enum CreateMembershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePrivacyBudgetTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoRefresh
        case parameters
        case privacyBudgetType
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoRefresh = self.autoRefresh {
            try encodeContainer.encode(autoRefresh.rawValue, forKey: .autoRefresh)
        }
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let privacyBudgetType = self.privacyBudgetType {
            try encodeContainer.encode(privacyBudgetType.rawValue, forKey: .privacyBudgetType)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreatePrivacyBudgetTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/privacybudgettemplates"
    }
}

public struct CreatePrivacyBudgetTemplateInput: Swift.Equatable {
    /// How often the privacy budget refreshes. If you plan to regularly bring new data into the collaboration, you can use CALENDAR_MONTH to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queries across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.
    /// This member is required.
    public var autoRefresh: CleanRoomsClientTypes.PrivacyBudgetTemplateAutoRefresh?
    /// A unique identifier for one of your memberships for a collaboration. The privacy budget template is created in the collaboration that this membership belongs to. Accepts a membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// Specifies your parameters for the privacy budget template.
    /// This member is required.
    public var parameters: CleanRoomsClientTypes.PrivacyBudgetTemplateParametersInput?
    /// Specifies the type of the privacy budget template.
    /// This member is required.
    public var privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType?
    /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        autoRefresh: CleanRoomsClientTypes.PrivacyBudgetTemplateAutoRefresh? = nil,
        membershipIdentifier: Swift.String? = nil,
        parameters: CleanRoomsClientTypes.PrivacyBudgetTemplateParametersInput? = nil,
        privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.autoRefresh = autoRefresh
        self.membershipIdentifier = membershipIdentifier
        self.parameters = parameters
        self.privacyBudgetType = privacyBudgetType
        self.tags = tags
    }
}

struct CreatePrivacyBudgetTemplateInputBody: Swift.Equatable {
    let autoRefresh: CleanRoomsClientTypes.PrivacyBudgetTemplateAutoRefresh?
    let privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType?
    let parameters: CleanRoomsClientTypes.PrivacyBudgetTemplateParametersInput?
    let tags: [Swift.String:Swift.String]?
}

extension CreatePrivacyBudgetTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoRefresh
        case parameters
        case privacyBudgetType
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoRefreshDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyBudgetTemplateAutoRefresh.self, forKey: .autoRefresh)
        autoRefresh = autoRefreshDecoded
        let privacyBudgetTypeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyBudgetType.self, forKey: .privacyBudgetType)
        privacyBudgetType = privacyBudgetTypeDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyBudgetTemplateParametersInput.self, forKey: .parameters)
        parameters = parametersDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreatePrivacyBudgetTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePrivacyBudgetTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.privacyBudgetTemplate = output.privacyBudgetTemplate
        } else {
            self.privacyBudgetTemplate = nil
        }
    }
}

public struct CreatePrivacyBudgetTemplateOutput: Swift.Equatable {
    /// A summary of the elements in the privacy budget template.
    /// This member is required.
    public var privacyBudgetTemplate: CleanRoomsClientTypes.PrivacyBudgetTemplate?

    public init(
        privacyBudgetTemplate: CleanRoomsClientTypes.PrivacyBudgetTemplate? = nil
    )
    {
        self.privacyBudgetTemplate = privacyBudgetTemplate
    }
}

struct CreatePrivacyBudgetTemplateOutputBody: Swift.Equatable {
    let privacyBudgetTemplate: CleanRoomsClientTypes.PrivacyBudgetTemplate?
}

extension CreatePrivacyBudgetTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case privacyBudgetTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privacyBudgetTemplateDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyBudgetTemplate.self, forKey: .privacyBudgetTemplate)
        privacyBudgetTemplate = privacyBudgetTemplateDecoded
    }
}

enum CreatePrivacyBudgetTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CleanRoomsClientTypes.DataEncryptionMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowCleartext
        case allowDuplicates
        case allowJoinsOnColumnsWithDifferentNames
        case preserveNulls
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowCleartext = self.allowCleartext {
            try encodeContainer.encode(allowCleartext, forKey: .allowCleartext)
        }
        if let allowDuplicates = self.allowDuplicates {
            try encodeContainer.encode(allowDuplicates, forKey: .allowDuplicates)
        }
        if let allowJoinsOnColumnsWithDifferentNames = self.allowJoinsOnColumnsWithDifferentNames {
            try encodeContainer.encode(allowJoinsOnColumnsWithDifferentNames, forKey: .allowJoinsOnColumnsWithDifferentNames)
        }
        if let preserveNulls = self.preserveNulls {
            try encodeContainer.encode(preserveNulls, forKey: .preserveNulls)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowCleartextDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowCleartext)
        allowCleartext = allowCleartextDecoded
        let allowDuplicatesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowDuplicates)
        allowDuplicates = allowDuplicatesDecoded
        let allowJoinsOnColumnsWithDifferentNamesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowJoinsOnColumnsWithDifferentNames)
        allowJoinsOnColumnsWithDifferentNames = allowJoinsOnColumnsWithDifferentNamesDecoded
        let preserveNullsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .preserveNulls)
        preserveNulls = preserveNullsDecoded
    }
}

extension CleanRoomsClientTypes {
    /// The settings for client-side encryption for cryptographic computing.
    public struct DataEncryptionMetadata: Swift.Equatable {
        /// Indicates whether encrypted tables can contain cleartext data (TRUE) or are to cryptographically process every column (FALSE).
        /// This member is required.
        public var allowCleartext: Swift.Bool?
        /// Indicates whether Fingerprint columns can contain duplicate entries (TRUE) or are to contain only non-repeated values (FALSE).
        /// This member is required.
        public var allowDuplicates: Swift.Bool?
        /// Indicates whether Fingerprint columns can be joined on any other Fingerprint column with a different name (TRUE) or can only be joined on Fingerprint columns of the same name (FALSE).
        /// This member is required.
        public var allowJoinsOnColumnsWithDifferentNames: Swift.Bool?
        /// Indicates whether NULL values are to be copied as NULL to encrypted tables (TRUE) or cryptographically processed (FALSE).
        /// This member is required.
        public var preserveNulls: Swift.Bool?

        public init(
            allowCleartext: Swift.Bool? = nil,
            allowDuplicates: Swift.Bool? = nil,
            allowJoinsOnColumnsWithDifferentNames: Swift.Bool? = nil,
            preserveNulls: Swift.Bool? = nil
        )
        {
            self.allowCleartext = allowCleartext
            self.allowDuplicates = allowDuplicates
            self.allowJoinsOnColumnsWithDifferentNames = allowJoinsOnColumnsWithDifferentNames
            self.preserveNulls = preserveNulls
        }
    }

}

extension DeleteAnalysisTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        guard let analysisTemplateIdentifier = analysisTemplateIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/analysistemplates/\(analysisTemplateIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteAnalysisTemplateInput: Swift.Equatable {
    /// The identifier for the analysis template resource.
    /// This member is required.
    public var analysisTemplateIdentifier: Swift.String?
    /// The identifier for a membership resource.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        analysisTemplateIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.analysisTemplateIdentifier = analysisTemplateIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

struct DeleteAnalysisTemplateInputBody: Swift.Equatable {
}

extension DeleteAnalysisTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAnalysisTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAnalysisTemplateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAnalysisTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteCollaborationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collaborationIdentifier = collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteCollaborationInput: Swift.Equatable {
    /// The identifier for the collaboration.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
    }
}

struct DeleteCollaborationInputBody: Swift.Equatable {
}

extension DeleteCollaborationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteCollaborationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteCollaborationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteCollaborationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConfiguredAudienceModelAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        guard let configuredAudienceModelAssociationIdentifier = configuredAudienceModelAssociationIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredaudiencemodelassociations/\(configuredAudienceModelAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteConfiguredAudienceModelAssociationInput: Swift.Equatable {
    /// A unique identifier of the configured audience model association that you want to delete.
    /// This member is required.
    public var configuredAudienceModelAssociationIdentifier: Swift.String?
    /// A unique identifier of the membership that contains the audience model association that you want to delete.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        configuredAudienceModelAssociationIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.configuredAudienceModelAssociationIdentifier = configuredAudienceModelAssociationIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

struct DeleteConfiguredAudienceModelAssociationInputBody: Swift.Equatable {
}

extension DeleteConfiguredAudienceModelAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfiguredAudienceModelAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteConfiguredAudienceModelAssociationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteConfiguredAudienceModelAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConfiguredTableAnalysisRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configuredTableIdentifier = configuredTableIdentifier else {
            return nil
        }
        guard let analysisRuleType = analysisRuleType else {
            return nil
        }
        return "/configuredTables/\(configuredTableIdentifier.urlPercentEncoding())/analysisRule/\(analysisRuleType.rawValue.urlPercentEncoding())"
    }
}

public struct DeleteConfiguredTableAnalysisRuleInput: Swift.Equatable {
    /// The analysis rule type to be deleted. Configured table analysis rules are uniquely identified by their configured table identifier and analysis rule type.
    /// This member is required.
    public var analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType?
    /// The unique identifier for the configured table that the analysis rule applies to. Currently accepts the configured table ID.
    /// This member is required.
    public var configuredTableIdentifier: Swift.String?

    public init(
        analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType? = nil,
        configuredTableIdentifier: Swift.String? = nil
    )
    {
        self.analysisRuleType = analysisRuleType
        self.configuredTableIdentifier = configuredTableIdentifier
    }
}

struct DeleteConfiguredTableAnalysisRuleInputBody: Swift.Equatable {
}

extension DeleteConfiguredTableAnalysisRuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfiguredTableAnalysisRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// An empty response that indicates a successful delete.
public struct DeleteConfiguredTableAnalysisRuleOutput: Swift.Equatable {

    public init() { }
}

enum DeleteConfiguredTableAnalysisRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConfiguredTableAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        guard let configuredTableAssociationIdentifier = configuredTableAssociationIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredTableAssociations/\(configuredTableAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteConfiguredTableAssociationInput: Swift.Equatable {
    /// The unique ID for the configured table association to be deleted. Currently accepts the configured table ID.
    /// This member is required.
    public var configuredTableAssociationIdentifier: Swift.String?
    /// A unique identifier for the membership that the configured table association belongs to. Currently accepts the membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        configuredTableAssociationIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

struct DeleteConfiguredTableAssociationInputBody: Swift.Equatable {
}

extension DeleteConfiguredTableAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfiguredTableAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteConfiguredTableAssociationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteConfiguredTableAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteConfiguredTableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configuredTableIdentifier = configuredTableIdentifier else {
            return nil
        }
        return "/configuredTables/\(configuredTableIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteConfiguredTableInput: Swift.Equatable {
    /// The unique ID for the configured table to delete.
    /// This member is required.
    public var configuredTableIdentifier: Swift.String?

    public init(
        configuredTableIdentifier: Swift.String? = nil
    )
    {
        self.configuredTableIdentifier = configuredTableIdentifier
    }
}

struct DeleteConfiguredTableInputBody: Swift.Equatable {
}

extension DeleteConfiguredTableInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteConfiguredTableOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// The empty output for a successful deletion.
public struct DeleteConfiguredTableOutput: Swift.Equatable {

    public init() { }
}

enum DeleteConfiguredTableOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMemberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collaborationIdentifier = collaborationIdentifier else {
            return nil
        }
        guard let accountId = accountId else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/member/\(accountId.urlPercentEncoding())"
    }
}

public struct DeleteMemberInput: Swift.Equatable {
    /// The account ID of the member to remove.
    /// This member is required.
    public var accountId: Swift.String?
    /// The unique identifier for the associated collaboration.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        collaborationIdentifier: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.collaborationIdentifier = collaborationIdentifier
    }
}

struct DeleteMemberInputBody: Swift.Equatable {
}

extension DeleteMemberInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMemberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMemberOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMemberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())"
    }
}

public struct DeleteMembershipInput: Swift.Equatable {
    /// The identifier for a membership resource.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.membershipIdentifier = membershipIdentifier
    }
}

struct DeleteMembershipInputBody: Swift.Equatable {
}

extension DeleteMembershipInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteMembershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteMembershipOutput: Swift.Equatable {

    public init() { }
}

enum DeleteMembershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePrivacyBudgetTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        guard let privacyBudgetTemplateIdentifier = privacyBudgetTemplateIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/privacybudgettemplates/\(privacyBudgetTemplateIdentifier.urlPercentEncoding())"
    }
}

public struct DeletePrivacyBudgetTemplateInput: Swift.Equatable {
    /// A unique identifier for one of your memberships for a collaboration. The privacy budget template is deleted from the collaboration that this membership belongs to. Accepts a membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// A unique identifier for your privacy budget template.
    /// This member is required.
    public var privacyBudgetTemplateIdentifier: Swift.String?

    public init(
        membershipIdentifier: Swift.String? = nil,
        privacyBudgetTemplateIdentifier: Swift.String? = nil
    )
    {
        self.membershipIdentifier = membershipIdentifier
        self.privacyBudgetTemplateIdentifier = privacyBudgetTemplateIdentifier
    }
}

struct DeletePrivacyBudgetTemplateInputBody: Swift.Equatable {
}

extension DeletePrivacyBudgetTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePrivacyBudgetTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePrivacyBudgetTemplateOutput: Swift.Equatable {

    public init() { }
}

enum DeletePrivacyBudgetTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CleanRoomsClientTypes {
    public enum DifferentialPrivacyAggregationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case avg
        case count
        case countDistinct
        case stddev
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [DifferentialPrivacyAggregationType] {
            return [
                .avg,
                .count,
                .countDistinct,
                .stddev,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .avg: return "AVG"
            case .count: return "COUNT"
            case .countDistinct: return "COUNT_DISTINCT"
            case .stddev: return "STDDEV"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DifferentialPrivacyAggregationType(rawValue: rawValue) ?? DifferentialPrivacyAggregationType.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes.DifferentialPrivacyColumn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CleanRoomsClientTypes {
    /// Specifies the name of the column that contains the unique identifier of your users, whose privacy you want to protect.
    public struct DifferentialPrivacyColumn: Swift.Equatable {
        /// The name of the column, such as user_id, that contains the unique identifier of your users, whose privacy you want to protect. If you want to turn on differential privacy for two or more tables in a collaboration, you must configure the same column as the user identifier column in both analysis rules.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }

}

extension CleanRoomsClientTypes.DifferentialPrivacyConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for differentialprivacycolumn0 in columns {
                try columnsContainer.encode(differentialprivacycolumn0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnsContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.DifferentialPrivacyColumn?].self, forKey: .columns)
        var columnsDecoded0:[CleanRoomsClientTypes.DifferentialPrivacyColumn]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [CleanRoomsClientTypes.DifferentialPrivacyColumn]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
    }
}

extension CleanRoomsClientTypes {
    /// Specifies the unique identifier for your users.
    public struct DifferentialPrivacyConfiguration: Swift.Equatable {
        /// The name of the column (such as user_id) that contains the unique identifier of your users whose privacy you want to protect. If you want to turn on diﬀerential privacy for two or more tables in a collaboration, you must conﬁgure the same column as the user identiﬁer column in both analysis rules.
        /// This member is required.
        public var columns: [CleanRoomsClientTypes.DifferentialPrivacyColumn]?

        public init(
            columns: [CleanRoomsClientTypes.DifferentialPrivacyColumn]? = nil
        )
        {
            self.columns = columns
        }
    }

}

extension CleanRoomsClientTypes.DifferentialPrivacyParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sensitivityParameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sensitivityParameters = sensitivityParameters {
            var sensitivityParametersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sensitivityParameters)
            for differentialprivacysensitivityparameters0 in sensitivityParameters {
                try sensitivityParametersContainer.encode(differentialprivacysensitivityparameters0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sensitivityParametersContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.DifferentialPrivacySensitivityParameters?].self, forKey: .sensitivityParameters)
        var sensitivityParametersDecoded0:[CleanRoomsClientTypes.DifferentialPrivacySensitivityParameters]? = nil
        if let sensitivityParametersContainer = sensitivityParametersContainer {
            sensitivityParametersDecoded0 = [CleanRoomsClientTypes.DifferentialPrivacySensitivityParameters]()
            for structure0 in sensitivityParametersContainer {
                if let structure0 = structure0 {
                    sensitivityParametersDecoded0?.append(structure0)
                }
            }
        }
        sensitivityParameters = sensitivityParametersDecoded0
    }
}

extension CleanRoomsClientTypes {
    /// An array that contains the sensitivity parameters.
    public struct DifferentialPrivacyParameters: Swift.Equatable {
        /// Provides the sensitivity parameters that you can use to better understand the total amount of noise in query results.
        /// This member is required.
        public var sensitivityParameters: [CleanRoomsClientTypes.DifferentialPrivacySensitivityParameters]?

        public init(
            sensitivityParameters: [CleanRoomsClientTypes.DifferentialPrivacySensitivityParameters]? = nil
        )
        {
            self.sensitivityParameters = sensitivityParameters
        }
    }

}

extension CleanRoomsClientTypes.DifferentialPrivacyPreviewAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxCount
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxCount = self.maxCount {
            try encodeContainer.encode(maxCount, forKey: .maxCount)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.DifferentialPrivacyAggregationType.self, forKey: .type)
        type = typeDecoded
        let maxCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCount)
        maxCount = maxCountDecoded
    }
}

extension CleanRoomsClientTypes {
    /// Provides an estimate of the number of aggregation functions that the member who can query can run given the epsilon and noise parameters.
    public struct DifferentialPrivacyPreviewAggregation: Swift.Equatable {
        /// The maximum number of aggregations that the member who can query can run given the epsilon and noise parameters.
        /// This member is required.
        public var maxCount: Swift.Int?
        /// The type of aggregation function.
        /// This member is required.
        public var type: CleanRoomsClientTypes.DifferentialPrivacyAggregationType?

        public init(
            maxCount: Swift.Int? = nil,
            type: CleanRoomsClientTypes.DifferentialPrivacyAggregationType? = nil
        )
        {
            self.maxCount = maxCount
            self.type = type
        }
    }

}

extension CleanRoomsClientTypes.DifferentialPrivacyPreviewParametersInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case epsilon
        case usersNoisePerQuery
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let epsilon = self.epsilon {
            try encodeContainer.encode(epsilon, forKey: .epsilon)
        }
        if let usersNoisePerQuery = self.usersNoisePerQuery {
            try encodeContainer.encode(usersNoisePerQuery, forKey: .usersNoisePerQuery)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let epsilonDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .epsilon)
        epsilon = epsilonDecoded
        let usersNoisePerQueryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .usersNoisePerQuery)
        usersNoisePerQuery = usersNoisePerQueryDecoded
    }
}

extension CleanRoomsClientTypes {
    /// The epsilon and noise parameters that you want to preview.
    public struct DifferentialPrivacyPreviewParametersInput: Swift.Equatable {
        /// The epsilon value that you want to preview.
        /// This member is required.
        public var epsilon: Swift.Int?
        /// Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        /// This member is required.
        public var usersNoisePerQuery: Swift.Int?

        public init(
            epsilon: Swift.Int? = nil,
            usersNoisePerQuery: Swift.Int? = nil
        )
        {
            self.epsilon = epsilon
            self.usersNoisePerQuery = usersNoisePerQuery
        }
    }

}

extension CleanRoomsClientTypes.DifferentialPrivacyPrivacyBudget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregations
        case epsilon
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregations = aggregations {
            var aggregationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregations)
            for differentialprivacyprivacybudgetaggregation0 in aggregations {
                try aggregationsContainer.encode(differentialprivacyprivacybudgetaggregation0)
            }
        }
        if let epsilon = self.epsilon {
            try encodeContainer.encode(epsilon, forKey: .epsilon)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregationsContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.DifferentialPrivacyPrivacyBudgetAggregation?].self, forKey: .aggregations)
        var aggregationsDecoded0:[CleanRoomsClientTypes.DifferentialPrivacyPrivacyBudgetAggregation]? = nil
        if let aggregationsContainer = aggregationsContainer {
            aggregationsDecoded0 = [CleanRoomsClientTypes.DifferentialPrivacyPrivacyBudgetAggregation]()
            for structure0 in aggregationsContainer {
                if let structure0 = structure0 {
                    aggregationsDecoded0?.append(structure0)
                }
            }
        }
        aggregations = aggregationsDecoded0
        let epsilonDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .epsilon)
        epsilon = epsilonDecoded
    }
}

extension CleanRoomsClientTypes {
    /// Specifies the configured epsilon value and the utility in terms of total aggregations, as well as the remaining aggregations available.
    public struct DifferentialPrivacyPrivacyBudget: Swift.Equatable {
        /// This information includes the configured epsilon value and the utility in terms of total aggregations, as well as the remaining aggregations.
        /// This member is required.
        public var aggregations: [CleanRoomsClientTypes.DifferentialPrivacyPrivacyBudgetAggregation]?
        /// The epsilon value that you configured.
        /// This member is required.
        public var epsilon: Swift.Int?

        public init(
            aggregations: [CleanRoomsClientTypes.DifferentialPrivacyPrivacyBudgetAggregation]? = nil,
            epsilon: Swift.Int? = nil
        )
        {
            self.aggregations = aggregations
            self.epsilon = epsilon
        }
    }

}

extension CleanRoomsClientTypes.DifferentialPrivacyPrivacyBudgetAggregation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxCount
        case remainingCount
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxCount = self.maxCount {
            try encodeContainer.encode(maxCount, forKey: .maxCount)
        }
        if let remainingCount = self.remainingCount {
            try encodeContainer.encode(remainingCount, forKey: .remainingCount)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.DifferentialPrivacyAggregationType.self, forKey: .type)
        type = typeDecoded
        let maxCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxCount)
        maxCount = maxCountDecoded
        let remainingCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .remainingCount)
        remainingCount = remainingCountDecoded
    }
}

extension CleanRoomsClientTypes {
    /// Information about the total number of aggregations, as well as the remaining aggregations.
    public struct DifferentialPrivacyPrivacyBudgetAggregation: Swift.Equatable {
        /// The maximum number of aggregation functions that you can perform with the given privacy budget.
        /// This member is required.
        public var maxCount: Swift.Int?
        /// The remaining number of aggregation functions that can be run with the available privacy budget.
        /// This member is required.
        public var remainingCount: Swift.Int?
        /// The different types of aggregation functions that you can perform.
        /// This member is required.
        public var type: CleanRoomsClientTypes.DifferentialPrivacyAggregationType?

        public init(
            maxCount: Swift.Int? = nil,
            remainingCount: Swift.Int? = nil,
            type: CleanRoomsClientTypes.DifferentialPrivacyAggregationType? = nil
        )
        {
            self.maxCount = maxCount
            self.remainingCount = remainingCount
            self.type = type
        }
    }

}

extension CleanRoomsClientTypes.DifferentialPrivacyPrivacyImpact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregations
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregations = aggregations {
            var aggregationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregations)
            for differentialprivacypreviewaggregation0 in aggregations {
                try aggregationsContainer.encode(differentialprivacypreviewaggregation0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregationsContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.DifferentialPrivacyPreviewAggregation?].self, forKey: .aggregations)
        var aggregationsDecoded0:[CleanRoomsClientTypes.DifferentialPrivacyPreviewAggregation]? = nil
        if let aggregationsContainer = aggregationsContainer {
            aggregationsDecoded0 = [CleanRoomsClientTypes.DifferentialPrivacyPreviewAggregation]()
            for structure0 in aggregationsContainer {
                if let structure0 = structure0 {
                    aggregationsDecoded0?.append(structure0)
                }
            }
        }
        aggregations = aggregationsDecoded0
    }
}

extension CleanRoomsClientTypes {
    /// Information about the number of aggregation functions that the member who can query can run given the epsilon and noise parameters.
    public struct DifferentialPrivacyPrivacyImpact: Swift.Equatable {
        /// The number of aggregation functions that you can perform.
        /// This member is required.
        public var aggregations: [CleanRoomsClientTypes.DifferentialPrivacyPreviewAggregation]?

        public init(
            aggregations: [CleanRoomsClientTypes.DifferentialPrivacyPreviewAggregation]? = nil
        )
        {
            self.aggregations = aggregations
        }
    }

}

extension CleanRoomsClientTypes.DifferentialPrivacySensitivityParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationExpression
        case aggregationType
        case maxColumnValue
        case minColumnValue
        case userContributionLimit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationExpression = self.aggregationExpression {
            try encodeContainer.encode(aggregationExpression, forKey: .aggregationExpression)
        }
        if let aggregationType = self.aggregationType {
            try encodeContainer.encode(aggregationType.rawValue, forKey: .aggregationType)
        }
        if let maxColumnValue = self.maxColumnValue {
            try encodeContainer.encode(maxColumnValue, forKey: .maxColumnValue)
        }
        if let minColumnValue = self.minColumnValue {
            try encodeContainer.encode(minColumnValue, forKey: .minColumnValue)
        }
        if let userContributionLimit = self.userContributionLimit {
            try encodeContainer.encode(userContributionLimit, forKey: .userContributionLimit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregationTypeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.DifferentialPrivacyAggregationType.self, forKey: .aggregationType)
        aggregationType = aggregationTypeDecoded
        let aggregationExpressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aggregationExpression)
        aggregationExpression = aggregationExpressionDecoded
        let userContributionLimitDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .userContributionLimit)
        userContributionLimit = userContributionLimitDecoded
        let minColumnValueDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .minColumnValue)
        minColumnValue = minColumnValueDecoded
        let maxColumnValueDecoded = try containerValues.decodeIfPresent(Swift.Float.self, forKey: .maxColumnValue)
        maxColumnValue = maxColumnValueDecoded
    }
}

extension CleanRoomsClientTypes {
    /// Provides the sensitivity parameters.
    public struct DifferentialPrivacySensitivityParameters: Swift.Equatable {
        /// The aggregation expression that was run.
        /// This member is required.
        public var aggregationExpression: Swift.String?
        /// The type of aggregation function that was run.
        /// This member is required.
        public var aggregationType: CleanRoomsClientTypes.DifferentialPrivacyAggregationType?
        /// The upper bound of the aggregation expression.
        public var maxColumnValue: Swift.Float?
        /// The lower bound of the aggregation expression.
        public var minColumnValue: Swift.Float?
        /// The maximum number of rows contributed by a user in a SQL query.
        /// This member is required.
        public var userContributionLimit: Swift.Int?

        public init(
            aggregationExpression: Swift.String? = nil,
            aggregationType: CleanRoomsClientTypes.DifferentialPrivacyAggregationType? = nil,
            maxColumnValue: Swift.Float? = nil,
            minColumnValue: Swift.Float? = nil,
            userContributionLimit: Swift.Int? = nil
        )
        {
            self.aggregationExpression = aggregationExpression
            self.aggregationType = aggregationType
            self.maxColumnValue = maxColumnValue
            self.minColumnValue = minColumnValue
            self.userContributionLimit = userContributionLimit
        }
    }

}

extension CleanRoomsClientTypes.DifferentialPrivacyTemplateParametersInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case epsilon
        case usersNoisePerQuery
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let epsilon = self.epsilon {
            try encodeContainer.encode(epsilon, forKey: .epsilon)
        }
        if let usersNoisePerQuery = self.usersNoisePerQuery {
            try encodeContainer.encode(usersNoisePerQuery, forKey: .usersNoisePerQuery)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let epsilonDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .epsilon)
        epsilon = epsilonDecoded
        let usersNoisePerQueryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .usersNoisePerQuery)
        usersNoisePerQuery = usersNoisePerQueryDecoded
    }
}

extension CleanRoomsClientTypes {
    /// The epsilon and noise parameter values that you want to use for the differential privacy template.
    public struct DifferentialPrivacyTemplateParametersInput: Swift.Equatable {
        /// The epsilon value that you want to use.
        /// This member is required.
        public var epsilon: Swift.Int?
        /// Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        /// This member is required.
        public var usersNoisePerQuery: Swift.Int?

        public init(
            epsilon: Swift.Int? = nil,
            usersNoisePerQuery: Swift.Int? = nil
        )
        {
            self.epsilon = epsilon
            self.usersNoisePerQuery = usersNoisePerQuery
        }
    }

}

extension CleanRoomsClientTypes.DifferentialPrivacyTemplateParametersOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case epsilon
        case usersNoisePerQuery
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let epsilon = self.epsilon {
            try encodeContainer.encode(epsilon, forKey: .epsilon)
        }
        if let usersNoisePerQuery = self.usersNoisePerQuery {
            try encodeContainer.encode(usersNoisePerQuery, forKey: .usersNoisePerQuery)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let epsilonDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .epsilon)
        epsilon = epsilonDecoded
        let usersNoisePerQueryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .usersNoisePerQuery)
        usersNoisePerQuery = usersNoisePerQueryDecoded
    }
}

extension CleanRoomsClientTypes {
    /// The epsilon and noise parameter values that were used for the differential privacy template.
    public struct DifferentialPrivacyTemplateParametersOutput: Swift.Equatable {
        /// The epsilon value that you specified.
        /// This member is required.
        public var epsilon: Swift.Int?
        /// Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        /// This member is required.
        public var usersNoisePerQuery: Swift.Int?

        public init(
            epsilon: Swift.Int? = nil,
            usersNoisePerQuery: Swift.Int? = nil
        )
        {
            self.epsilon = epsilon
            self.usersNoisePerQuery = usersNoisePerQuery
        }
    }

}

extension CleanRoomsClientTypes.DifferentialPrivacyTemplateUpdateParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case epsilon
        case usersNoisePerQuery
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let epsilon = self.epsilon {
            try encodeContainer.encode(epsilon, forKey: .epsilon)
        }
        if let usersNoisePerQuery = self.usersNoisePerQuery {
            try encodeContainer.encode(usersNoisePerQuery, forKey: .usersNoisePerQuery)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let epsilonDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .epsilon)
        epsilon = epsilonDecoded
        let usersNoisePerQueryDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .usersNoisePerQuery)
        usersNoisePerQuery = usersNoisePerQueryDecoded
    }
}

extension CleanRoomsClientTypes {
    /// The epsilon and noise parameter values that you want to update in the differential privacy template.
    public struct DifferentialPrivacyTemplateUpdateParameters: Swift.Equatable {
        /// The updated epsilon value that you want to use.
        public var epsilon: Swift.Int?
        /// The updated value of noise added per query. It is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        public var usersNoisePerQuery: Swift.Int?

        public init(
            epsilon: Swift.Int? = nil,
            usersNoisePerQuery: Swift.Int? = nil
        )
        {
            self.epsilon = epsilon
            self.usersNoisePerQuery = usersNoisePerQuery
        }
    }

}

extension CleanRoomsClientTypes {
    public enum FilterableMemberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case invited
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterableMemberStatus] {
            return [
                .active,
                .invited,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .invited: return "INVITED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterableMemberStatus(rawValue: rawValue) ?? FilterableMemberStatus.sdkUnknown(rawValue)
        }
    }
}

extension GetAnalysisTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        guard let analysisTemplateIdentifier = analysisTemplateIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/analysistemplates/\(analysisTemplateIdentifier.urlPercentEncoding())"
    }
}

public struct GetAnalysisTemplateInput: Swift.Equatable {
    /// The identifier for the analysis template resource.
    /// This member is required.
    public var analysisTemplateIdentifier: Swift.String?
    /// The identifier for a membership resource.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        analysisTemplateIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.analysisTemplateIdentifier = analysisTemplateIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

struct GetAnalysisTemplateInputBody: Swift.Equatable {
}

extension GetAnalysisTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAnalysisTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAnalysisTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.analysisTemplate = output.analysisTemplate
        } else {
            self.analysisTemplate = nil
        }
    }
}

public struct GetAnalysisTemplateOutput: Swift.Equatable {
    /// The analysis template.
    /// This member is required.
    public var analysisTemplate: CleanRoomsClientTypes.AnalysisTemplate?

    public init(
        analysisTemplate: CleanRoomsClientTypes.AnalysisTemplate? = nil
    )
    {
        self.analysisTemplate = analysisTemplate
    }
}

struct GetAnalysisTemplateOutputBody: Swift.Equatable {
    let analysisTemplate: CleanRoomsClientTypes.AnalysisTemplate?
}

extension GetAnalysisTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisTemplateDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AnalysisTemplate.self, forKey: .analysisTemplate)
        analysisTemplate = analysisTemplateDecoded
    }
}

enum GetAnalysisTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCollaborationAnalysisTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collaborationIdentifier = collaborationIdentifier else {
            return nil
        }
        guard let analysisTemplateArn = analysisTemplateArn else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/analysistemplates/\(analysisTemplateArn.urlPercentEncoding())"
    }
}

public struct GetCollaborationAnalysisTemplateInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the analysis template within a collaboration.
    /// This member is required.
    public var analysisTemplateArn: Swift.String?
    /// A unique identifier for the collaboration that the analysis templates belong to. Currently accepts collaboration ID.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?

    public init(
        analysisTemplateArn: Swift.String? = nil,
        collaborationIdentifier: Swift.String? = nil
    )
    {
        self.analysisTemplateArn = analysisTemplateArn
        self.collaborationIdentifier = collaborationIdentifier
    }
}

struct GetCollaborationAnalysisTemplateInputBody: Swift.Equatable {
}

extension GetCollaborationAnalysisTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCollaborationAnalysisTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCollaborationAnalysisTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.collaborationAnalysisTemplate = output.collaborationAnalysisTemplate
        } else {
            self.collaborationAnalysisTemplate = nil
        }
    }
}

public struct GetCollaborationAnalysisTemplateOutput: Swift.Equatable {
    /// The analysis template within a collaboration.
    /// This member is required.
    public var collaborationAnalysisTemplate: CleanRoomsClientTypes.CollaborationAnalysisTemplate?

    public init(
        collaborationAnalysisTemplate: CleanRoomsClientTypes.CollaborationAnalysisTemplate? = nil
    )
    {
        self.collaborationAnalysisTemplate = collaborationAnalysisTemplate
    }
}

struct GetCollaborationAnalysisTemplateOutputBody: Swift.Equatable {
    let collaborationAnalysisTemplate: CleanRoomsClientTypes.CollaborationAnalysisTemplate?
}

extension GetCollaborationAnalysisTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collaborationAnalysisTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collaborationAnalysisTemplateDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.CollaborationAnalysisTemplate.self, forKey: .collaborationAnalysisTemplate)
        collaborationAnalysisTemplate = collaborationAnalysisTemplateDecoded
    }
}

enum GetCollaborationAnalysisTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCollaborationConfiguredAudienceModelAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collaborationIdentifier = collaborationIdentifier else {
            return nil
        }
        guard let configuredAudienceModelAssociationIdentifier = configuredAudienceModelAssociationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/configuredaudiencemodelassociations/\(configuredAudienceModelAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct GetCollaborationConfiguredAudienceModelAssociationInput: Swift.Equatable {
    /// A unique identifier for the collaboration that the configured audience model association belongs to. Accepts a collaboration ID.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// A unique identifier for the configured audience model association that you want to retrieve.
    /// This member is required.
    public var configuredAudienceModelAssociationIdentifier: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        configuredAudienceModelAssociationIdentifier: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.configuredAudienceModelAssociationIdentifier = configuredAudienceModelAssociationIdentifier
    }
}

struct GetCollaborationConfiguredAudienceModelAssociationInputBody: Swift.Equatable {
}

extension GetCollaborationConfiguredAudienceModelAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCollaborationConfiguredAudienceModelAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCollaborationConfiguredAudienceModelAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.collaborationConfiguredAudienceModelAssociation = output.collaborationConfiguredAudienceModelAssociation
        } else {
            self.collaborationConfiguredAudienceModelAssociation = nil
        }
    }
}

public struct GetCollaborationConfiguredAudienceModelAssociationOutput: Swift.Equatable {
    /// The metadata of the configured audience model association.
    /// This member is required.
    public var collaborationConfiguredAudienceModelAssociation: CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociation?

    public init(
        collaborationConfiguredAudienceModelAssociation: CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociation? = nil
    )
    {
        self.collaborationConfiguredAudienceModelAssociation = collaborationConfiguredAudienceModelAssociation
    }
}

struct GetCollaborationConfiguredAudienceModelAssociationOutputBody: Swift.Equatable {
    let collaborationConfiguredAudienceModelAssociation: CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociation?
}

extension GetCollaborationConfiguredAudienceModelAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collaborationConfiguredAudienceModelAssociation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collaborationConfiguredAudienceModelAssociationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociation.self, forKey: .collaborationConfiguredAudienceModelAssociation)
        collaborationConfiguredAudienceModelAssociation = collaborationConfiguredAudienceModelAssociationDecoded
    }
}

enum GetCollaborationConfiguredAudienceModelAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCollaborationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collaborationIdentifier = collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())"
    }
}

public struct GetCollaborationInput: Swift.Equatable {
    /// The identifier for the collaboration.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
    }
}

struct GetCollaborationInputBody: Swift.Equatable {
}

extension GetCollaborationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCollaborationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCollaborationOutputBody = try responseDecoder.decode(responseBody: data)
            self.collaboration = output.collaboration
        } else {
            self.collaboration = nil
        }
    }
}

public struct GetCollaborationOutput: Swift.Equatable {
    /// The entire collaboration for this identifier.
    /// This member is required.
    public var collaboration: CleanRoomsClientTypes.Collaboration?

    public init(
        collaboration: CleanRoomsClientTypes.Collaboration? = nil
    )
    {
        self.collaboration = collaboration
    }
}

struct GetCollaborationOutputBody: Swift.Equatable {
    let collaboration: CleanRoomsClientTypes.Collaboration?
}

extension GetCollaborationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collaboration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collaborationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.Collaboration.self, forKey: .collaboration)
        collaboration = collaborationDecoded
    }
}

enum GetCollaborationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCollaborationPrivacyBudgetTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collaborationIdentifier = collaborationIdentifier else {
            return nil
        }
        guard let privacyBudgetTemplateIdentifier = privacyBudgetTemplateIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/privacybudgettemplates/\(privacyBudgetTemplateIdentifier.urlPercentEncoding())"
    }
}

public struct GetCollaborationPrivacyBudgetTemplateInput: Swift.Equatable {
    /// A unique identifier for one of your collaborations.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// A unique identifier for one of your privacy budget templates.
    /// This member is required.
    public var privacyBudgetTemplateIdentifier: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        privacyBudgetTemplateIdentifier: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.privacyBudgetTemplateIdentifier = privacyBudgetTemplateIdentifier
    }
}

struct GetCollaborationPrivacyBudgetTemplateInputBody: Swift.Equatable {
}

extension GetCollaborationPrivacyBudgetTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetCollaborationPrivacyBudgetTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCollaborationPrivacyBudgetTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.collaborationPrivacyBudgetTemplate = output.collaborationPrivacyBudgetTemplate
        } else {
            self.collaborationPrivacyBudgetTemplate = nil
        }
    }
}

public struct GetCollaborationPrivacyBudgetTemplateOutput: Swift.Equatable {
    /// Returns the details of the privacy budget template that you requested.
    /// This member is required.
    public var collaborationPrivacyBudgetTemplate: CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplate?

    public init(
        collaborationPrivacyBudgetTemplate: CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplate? = nil
    )
    {
        self.collaborationPrivacyBudgetTemplate = collaborationPrivacyBudgetTemplate
    }
}

struct GetCollaborationPrivacyBudgetTemplateOutputBody: Swift.Equatable {
    let collaborationPrivacyBudgetTemplate: CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplate?
}

extension GetCollaborationPrivacyBudgetTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collaborationPrivacyBudgetTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collaborationPrivacyBudgetTemplateDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplate.self, forKey: .collaborationPrivacyBudgetTemplate)
        collaborationPrivacyBudgetTemplate = collaborationPrivacyBudgetTemplateDecoded
    }
}

enum GetCollaborationPrivacyBudgetTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetConfiguredAudienceModelAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        guard let configuredAudienceModelAssociationIdentifier = configuredAudienceModelAssociationIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredaudiencemodelassociations/\(configuredAudienceModelAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct GetConfiguredAudienceModelAssociationInput: Swift.Equatable {
    /// A unique identifier for the configured audience model association that you want to retrieve.
    /// This member is required.
    public var configuredAudienceModelAssociationIdentifier: Swift.String?
    /// A unique identifier for the membership that contains the configured audience model association that you want to retrieve.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        configuredAudienceModelAssociationIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.configuredAudienceModelAssociationIdentifier = configuredAudienceModelAssociationIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

struct GetConfiguredAudienceModelAssociationInputBody: Swift.Equatable {
}

extension GetConfiguredAudienceModelAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetConfiguredAudienceModelAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConfiguredAudienceModelAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuredAudienceModelAssociation = output.configuredAudienceModelAssociation
        } else {
            self.configuredAudienceModelAssociation = nil
        }
    }
}

public struct GetConfiguredAudienceModelAssociationOutput: Swift.Equatable {
    /// Information about the configured audience model association that you requested.
    /// This member is required.
    public var configuredAudienceModelAssociation: CleanRoomsClientTypes.ConfiguredAudienceModelAssociation?

    public init(
        configuredAudienceModelAssociation: CleanRoomsClientTypes.ConfiguredAudienceModelAssociation? = nil
    )
    {
        self.configuredAudienceModelAssociation = configuredAudienceModelAssociation
    }
}

struct GetConfiguredAudienceModelAssociationOutputBody: Swift.Equatable {
    let configuredAudienceModelAssociation: CleanRoomsClientTypes.ConfiguredAudienceModelAssociation?
}

extension GetConfiguredAudienceModelAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredAudienceModelAssociation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredAudienceModelAssociationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ConfiguredAudienceModelAssociation.self, forKey: .configuredAudienceModelAssociation)
        configuredAudienceModelAssociation = configuredAudienceModelAssociationDecoded
    }
}

enum GetConfiguredAudienceModelAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetConfiguredTableAnalysisRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configuredTableIdentifier = configuredTableIdentifier else {
            return nil
        }
        guard let analysisRuleType = analysisRuleType else {
            return nil
        }
        return "/configuredTables/\(configuredTableIdentifier.urlPercentEncoding())/analysisRule/\(analysisRuleType.rawValue.urlPercentEncoding())"
    }
}

public struct GetConfiguredTableAnalysisRuleInput: Swift.Equatable {
    /// The analysis rule to be retrieved. Configured table analysis rules are uniquely identified by their configured table identifier and analysis rule type.
    /// This member is required.
    public var analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType?
    /// The unique identifier for the configured table to retrieve. Currently accepts the configured table ID.
    /// This member is required.
    public var configuredTableIdentifier: Swift.String?

    public init(
        analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType? = nil,
        configuredTableIdentifier: Swift.String? = nil
    )
    {
        self.analysisRuleType = analysisRuleType
        self.configuredTableIdentifier = configuredTableIdentifier
    }
}

struct GetConfiguredTableAnalysisRuleInputBody: Swift.Equatable {
}

extension GetConfiguredTableAnalysisRuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetConfiguredTableAnalysisRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConfiguredTableAnalysisRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.analysisRule = output.analysisRule
        } else {
            self.analysisRule = nil
        }
    }
}

public struct GetConfiguredTableAnalysisRuleOutput: Swift.Equatable {
    /// The entire analysis rule output.
    /// This member is required.
    public var analysisRule: CleanRoomsClientTypes.ConfiguredTableAnalysisRule?

    public init(
        analysisRule: CleanRoomsClientTypes.ConfiguredTableAnalysisRule? = nil
    )
    {
        self.analysisRule = analysisRule
    }
}

struct GetConfiguredTableAnalysisRuleOutputBody: Swift.Equatable {
    let analysisRule: CleanRoomsClientTypes.ConfiguredTableAnalysisRule?
}

extension GetConfiguredTableAnalysisRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisRule
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisRuleDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ConfiguredTableAnalysisRule.self, forKey: .analysisRule)
        analysisRule = analysisRuleDecoded
    }
}

enum GetConfiguredTableAnalysisRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetConfiguredTableAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        guard let configuredTableAssociationIdentifier = configuredTableAssociationIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredTableAssociations/\(configuredTableAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct GetConfiguredTableAssociationInput: Swift.Equatable {
    /// The unique ID for the configured table association to retrieve. Currently accepts the configured table ID.
    /// This member is required.
    public var configuredTableAssociationIdentifier: Swift.String?
    /// A unique identifier for the membership that the configured table association belongs to. Currently accepts the membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        configuredTableAssociationIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

struct GetConfiguredTableAssociationInputBody: Swift.Equatable {
}

extension GetConfiguredTableAssociationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetConfiguredTableAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConfiguredTableAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuredTableAssociation = output.configuredTableAssociation
        } else {
            self.configuredTableAssociation = nil
        }
    }
}

public struct GetConfiguredTableAssociationOutput: Swift.Equatable {
    /// The entire configured table association object.
    /// This member is required.
    public var configuredTableAssociation: CleanRoomsClientTypes.ConfiguredTableAssociation?

    public init(
        configuredTableAssociation: CleanRoomsClientTypes.ConfiguredTableAssociation? = nil
    )
    {
        self.configuredTableAssociation = configuredTableAssociation
    }
}

struct GetConfiguredTableAssociationOutputBody: Swift.Equatable {
    let configuredTableAssociation: CleanRoomsClientTypes.ConfiguredTableAssociation?
}

extension GetConfiguredTableAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredTableAssociation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredTableAssociationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ConfiguredTableAssociation.self, forKey: .configuredTableAssociation)
        configuredTableAssociation = configuredTableAssociationDecoded
    }
}

enum GetConfiguredTableAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetConfiguredTableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configuredTableIdentifier = configuredTableIdentifier else {
            return nil
        }
        return "/configuredTables/\(configuredTableIdentifier.urlPercentEncoding())"
    }
}

public struct GetConfiguredTableInput: Swift.Equatable {
    /// The unique ID for the configured table to retrieve.
    /// This member is required.
    public var configuredTableIdentifier: Swift.String?

    public init(
        configuredTableIdentifier: Swift.String? = nil
    )
    {
        self.configuredTableIdentifier = configuredTableIdentifier
    }
}

struct GetConfiguredTableInputBody: Swift.Equatable {
}

extension GetConfiguredTableInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetConfiguredTableOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetConfiguredTableOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuredTable = output.configuredTable
        } else {
            self.configuredTable = nil
        }
    }
}

public struct GetConfiguredTableOutput: Swift.Equatable {
    /// The retrieved configured table.
    /// This member is required.
    public var configuredTable: CleanRoomsClientTypes.ConfiguredTable?

    public init(
        configuredTable: CleanRoomsClientTypes.ConfiguredTable? = nil
    )
    {
        self.configuredTable = configuredTable
    }
}

struct GetConfiguredTableOutputBody: Swift.Equatable {
    let configuredTable: CleanRoomsClientTypes.ConfiguredTable?
}

extension GetConfiguredTableOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredTable
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredTableDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ConfiguredTable.self, forKey: .configuredTable)
        configuredTable = configuredTableDecoded
    }
}

enum GetConfiguredTableOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())"
    }
}

public struct GetMembershipInput: Swift.Equatable {
    /// The identifier for a membership resource.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.membershipIdentifier = membershipIdentifier
    }
}

struct GetMembershipInputBody: Swift.Equatable {
}

extension GetMembershipInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMembershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMembershipOutputBody = try responseDecoder.decode(responseBody: data)
            self.membership = output.membership
        } else {
            self.membership = nil
        }
    }
}

public struct GetMembershipOutput: Swift.Equatable {
    /// The membership retrieved for the provided identifier.
    /// This member is required.
    public var membership: CleanRoomsClientTypes.Membership?

    public init(
        membership: CleanRoomsClientTypes.Membership? = nil
    )
    {
        self.membership = membership
    }
}

struct GetMembershipOutputBody: Swift.Equatable {
    let membership: CleanRoomsClientTypes.Membership?
}

extension GetMembershipOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case membership
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membershipDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.Membership.self, forKey: .membership)
        membership = membershipDecoded
    }
}

enum GetMembershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPrivacyBudgetTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        guard let privacyBudgetTemplateIdentifier = privacyBudgetTemplateIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/privacybudgettemplates/\(privacyBudgetTemplateIdentifier.urlPercentEncoding())"
    }
}

public struct GetPrivacyBudgetTemplateInput: Swift.Equatable {
    /// A unique identifier for one of your memberships for a collaboration. The privacy budget template is retrieved from the collaboration that this membership belongs to. Accepts a membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// A unique identifier for your privacy budget template.
    /// This member is required.
    public var privacyBudgetTemplateIdentifier: Swift.String?

    public init(
        membershipIdentifier: Swift.String? = nil,
        privacyBudgetTemplateIdentifier: Swift.String? = nil
    )
    {
        self.membershipIdentifier = membershipIdentifier
        self.privacyBudgetTemplateIdentifier = privacyBudgetTemplateIdentifier
    }
}

struct GetPrivacyBudgetTemplateInputBody: Swift.Equatable {
}

extension GetPrivacyBudgetTemplateInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPrivacyBudgetTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPrivacyBudgetTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.privacyBudgetTemplate = output.privacyBudgetTemplate
        } else {
            self.privacyBudgetTemplate = nil
        }
    }
}

public struct GetPrivacyBudgetTemplateOutput: Swift.Equatable {
    /// Returns the details of the privacy budget template that you requested.
    /// This member is required.
    public var privacyBudgetTemplate: CleanRoomsClientTypes.PrivacyBudgetTemplate?

    public init(
        privacyBudgetTemplate: CleanRoomsClientTypes.PrivacyBudgetTemplate? = nil
    )
    {
        self.privacyBudgetTemplate = privacyBudgetTemplate
    }
}

struct GetPrivacyBudgetTemplateOutputBody: Swift.Equatable {
    let privacyBudgetTemplate: CleanRoomsClientTypes.PrivacyBudgetTemplate?
}

extension GetPrivacyBudgetTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case privacyBudgetTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privacyBudgetTemplateDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyBudgetTemplate.self, forKey: .privacyBudgetTemplate)
        privacyBudgetTemplate = privacyBudgetTemplateDecoded
    }
}

enum GetPrivacyBudgetTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProtectedQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        guard let protectedQueryIdentifier = protectedQueryIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/protectedQueries/\(protectedQueryIdentifier.urlPercentEncoding())"
    }
}

public struct GetProtectedQueryInput: Swift.Equatable {
    /// The identifier for a membership in a protected query instance.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The identifier for a protected query instance.
    /// This member is required.
    public var protectedQueryIdentifier: Swift.String?

    public init(
        membershipIdentifier: Swift.String? = nil,
        protectedQueryIdentifier: Swift.String? = nil
    )
    {
        self.membershipIdentifier = membershipIdentifier
        self.protectedQueryIdentifier = protectedQueryIdentifier
    }
}

struct GetProtectedQueryInputBody: Swift.Equatable {
}

extension GetProtectedQueryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetProtectedQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProtectedQueryOutputBody = try responseDecoder.decode(responseBody: data)
            self.protectedQuery = output.protectedQuery
        } else {
            self.protectedQuery = nil
        }
    }
}

public struct GetProtectedQueryOutput: Swift.Equatable {
    /// The query processing metadata.
    /// This member is required.
    public var protectedQuery: CleanRoomsClientTypes.ProtectedQuery?

    public init(
        protectedQuery: CleanRoomsClientTypes.ProtectedQuery? = nil
    )
    {
        self.protectedQuery = protectedQuery
    }
}

struct GetProtectedQueryOutputBody: Swift.Equatable {
    let protectedQuery: CleanRoomsClientTypes.ProtectedQuery?
}

extension GetProtectedQueryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectedQuery
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectedQueryDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ProtectedQuery.self, forKey: .protectedQuery)
        protectedQuery = protectedQueryDecoded
    }
}

enum GetProtectedQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSchemaAnalysisRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collaborationIdentifier = collaborationIdentifier else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        guard let type = type else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/schemas/\(name.urlPercentEncoding())/analysisRule/\(type.rawValue.urlPercentEncoding())"
    }
}

public struct GetSchemaAnalysisRuleInput: Swift.Equatable {
    /// A unique identifier for the collaboration that the schema belongs to. Currently accepts a collaboration ID.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The name of the schema to retrieve the analysis rule for.
    /// This member is required.
    public var name: Swift.String?
    /// The type of the schema analysis rule to retrieve. Schema analysis rules are uniquely identified by a combination of the collaboration, the schema name, and their type.
    /// This member is required.
    public var type: CleanRoomsClientTypes.AnalysisRuleType?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        type: CleanRoomsClientTypes.AnalysisRuleType? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.name = name
        self.type = type
    }
}

struct GetSchemaAnalysisRuleInputBody: Swift.Equatable {
}

extension GetSchemaAnalysisRuleInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSchemaAnalysisRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSchemaAnalysisRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.analysisRule = output.analysisRule
        } else {
            self.analysisRule = nil
        }
    }
}

public struct GetSchemaAnalysisRuleOutput: Swift.Equatable {
    /// A specification about how data from the configured table can be used.
    /// This member is required.
    public var analysisRule: CleanRoomsClientTypes.AnalysisRule?

    public init(
        analysisRule: CleanRoomsClientTypes.AnalysisRule? = nil
    )
    {
        self.analysisRule = analysisRule
    }
}

struct GetSchemaAnalysisRuleOutputBody: Swift.Equatable {
    let analysisRule: CleanRoomsClientTypes.AnalysisRule?
}

extension GetSchemaAnalysisRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisRule
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisRuleDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AnalysisRule.self, forKey: .analysisRule)
        analysisRule = analysisRuleDecoded
    }
}

enum GetSchemaAnalysisRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSchemaInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collaborationIdentifier = collaborationIdentifier else {
            return nil
        }
        guard let name = name else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/schemas/\(name.urlPercentEncoding())"
    }
}

public struct GetSchemaInput: Swift.Equatable {
    /// A unique identifier for the collaboration that the schema belongs to. Currently accepts a collaboration ID.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The name of the relation to retrieve the schema for.
    /// This member is required.
    public var name: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.name = name
    }
}

struct GetSchemaInputBody: Swift.Equatable {
}

extension GetSchemaInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSchemaOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSchemaOutputBody = try responseDecoder.decode(responseBody: data)
            self.schema = output.schema
        } else {
            self.schema = nil
        }
    }
}

public struct GetSchemaOutput: Swift.Equatable {
    /// The entire schema object.
    /// This member is required.
    public var schema: CleanRoomsClientTypes.Schema?

    public init(
        schema: CleanRoomsClientTypes.Schema? = nil
    )
    {
        self.schema = schema
    }
}

struct GetSchemaOutputBody: Swift.Equatable {
    let schema: CleanRoomsClientTypes.Schema?
}

extension GetSchemaOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case schema
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.Schema.self, forKey: .schema)
        schema = schemaDecoded
    }
}

enum GetSchemaOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CleanRoomsClientTypes.GlueTableReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseName
        case tableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseName = self.databaseName {
            try encodeContainer.encode(databaseName, forKey: .databaseName)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
        let databaseNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .databaseName)
        databaseName = databaseNameDecoded
    }
}

extension CleanRoomsClientTypes {
    /// A reference to a table within an Glue data catalog.
    public struct GlueTableReference: Swift.Equatable {
        /// The name of the database the Glue table belongs to.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The name of the Glue table.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            databaseName: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.tableName = tableName
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Unexpected error during processing of request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CleanRoomsClientTypes {
    public enum JoinOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case and
        case or
        case sdkUnknown(Swift.String)

        public static var allCases: [JoinOperator] {
            return [
                .and,
                .or,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .and: return "AND"
            case .or: return "OR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JoinOperator(rawValue: rawValue) ?? JoinOperator.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes {
    public enum JoinRequiredOption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case queryRunner
        case sdkUnknown(Swift.String)

        public static var allCases: [JoinRequiredOption] {
            return [
                .queryRunner,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .queryRunner: return "QUERY_RUNNER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JoinRequiredOption(rawValue: rawValue) ?? JoinRequiredOption.sdkUnknown(rawValue)
        }
    }
}

extension ListAnalysisTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAnalysisTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/analysistemplates"
    }
}

public struct ListAnalysisTemplatesInput: Swift.Equatable {
    /// The maximum size of the results that is returned per call.
    public var maxResults: Swift.Int?
    /// The identifier for a membership resource.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        membershipIdentifier: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.membershipIdentifier = membershipIdentifier
        self.nextToken = nextToken
    }
}

struct ListAnalysisTemplatesInputBody: Swift.Equatable {
}

extension ListAnalysisTemplatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAnalysisTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAnalysisTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.analysisTemplateSummaries = output.analysisTemplateSummaries
            self.nextToken = output.nextToken
        } else {
            self.analysisTemplateSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAnalysisTemplatesOutput: Swift.Equatable {
    /// Lists analysis template metadata.
    /// This member is required.
    public var analysisTemplateSummaries: [CleanRoomsClientTypes.AnalysisTemplateSummary]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        analysisTemplateSummaries: [CleanRoomsClientTypes.AnalysisTemplateSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analysisTemplateSummaries = analysisTemplateSummaries
        self.nextToken = nextToken
    }
}

struct ListAnalysisTemplatesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let analysisTemplateSummaries: [CleanRoomsClientTypes.AnalysisTemplateSummary]?
}

extension ListAnalysisTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisTemplateSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let analysisTemplateSummariesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.AnalysisTemplateSummary?].self, forKey: .analysisTemplateSummaries)
        var analysisTemplateSummariesDecoded0:[CleanRoomsClientTypes.AnalysisTemplateSummary]? = nil
        if let analysisTemplateSummariesContainer = analysisTemplateSummariesContainer {
            analysisTemplateSummariesDecoded0 = [CleanRoomsClientTypes.AnalysisTemplateSummary]()
            for structure0 in analysisTemplateSummariesContainer {
                if let structure0 = structure0 {
                    analysisTemplateSummariesDecoded0?.append(structure0)
                }
            }
        }
        analysisTemplateSummaries = analysisTemplateSummariesDecoded0
    }
}

enum ListAnalysisTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCollaborationAnalysisTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListCollaborationAnalysisTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collaborationIdentifier = collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/analysistemplates"
    }
}

public struct ListCollaborationAnalysisTemplatesInput: Swift.Equatable {
    /// A unique identifier for the collaboration that the analysis templates belong to. Currently accepts collaboration ID.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The maximum size of the results that is returned per call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCollaborationAnalysisTemplatesInputBody: Swift.Equatable {
}

extension ListCollaborationAnalysisTemplatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCollaborationAnalysisTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCollaborationAnalysisTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.collaborationAnalysisTemplateSummaries = output.collaborationAnalysisTemplateSummaries
            self.nextToken = output.nextToken
        } else {
            self.collaborationAnalysisTemplateSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListCollaborationAnalysisTemplatesOutput: Swift.Equatable {
    /// The metadata of the analysis template within a collaboration.
    /// This member is required.
    public var collaborationAnalysisTemplateSummaries: [CleanRoomsClientTypes.CollaborationAnalysisTemplateSummary]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        collaborationAnalysisTemplateSummaries: [CleanRoomsClientTypes.CollaborationAnalysisTemplateSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationAnalysisTemplateSummaries = collaborationAnalysisTemplateSummaries
        self.nextToken = nextToken
    }
}

struct ListCollaborationAnalysisTemplatesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let collaborationAnalysisTemplateSummaries: [CleanRoomsClientTypes.CollaborationAnalysisTemplateSummary]?
}

extension ListCollaborationAnalysisTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collaborationAnalysisTemplateSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let collaborationAnalysisTemplateSummariesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.CollaborationAnalysisTemplateSummary?].self, forKey: .collaborationAnalysisTemplateSummaries)
        var collaborationAnalysisTemplateSummariesDecoded0:[CleanRoomsClientTypes.CollaborationAnalysisTemplateSummary]? = nil
        if let collaborationAnalysisTemplateSummariesContainer = collaborationAnalysisTemplateSummariesContainer {
            collaborationAnalysisTemplateSummariesDecoded0 = [CleanRoomsClientTypes.CollaborationAnalysisTemplateSummary]()
            for structure0 in collaborationAnalysisTemplateSummariesContainer {
                if let structure0 = structure0 {
                    collaborationAnalysisTemplateSummariesDecoded0?.append(structure0)
                }
            }
        }
        collaborationAnalysisTemplateSummaries = collaborationAnalysisTemplateSummariesDecoded0
    }
}

enum ListCollaborationAnalysisTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCollaborationConfiguredAudienceModelAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListCollaborationConfiguredAudienceModelAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collaborationIdentifier = collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/configuredaudiencemodelassociations"
    }
}

public struct ListCollaborationConfiguredAudienceModelAssociationsInput: Swift.Equatable {
    /// A unique identifier for the collaboration that the configured audience model association belongs to. Accepts a collaboration ID.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The maximum size of the results that is returned per call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCollaborationConfiguredAudienceModelAssociationsInputBody: Swift.Equatable {
}

extension ListCollaborationConfiguredAudienceModelAssociationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCollaborationConfiguredAudienceModelAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCollaborationConfiguredAudienceModelAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.collaborationConfiguredAudienceModelAssociationSummaries = output.collaborationConfiguredAudienceModelAssociationSummaries
            self.nextToken = output.nextToken
        } else {
            self.collaborationConfiguredAudienceModelAssociationSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListCollaborationConfiguredAudienceModelAssociationsOutput: Swift.Equatable {
    /// The metadata of the configured audience model association within a collaboration.
    /// This member is required.
    public var collaborationConfiguredAudienceModelAssociationSummaries: [CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociationSummary]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        collaborationConfiguredAudienceModelAssociationSummaries: [CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationConfiguredAudienceModelAssociationSummaries = collaborationConfiguredAudienceModelAssociationSummaries
        self.nextToken = nextToken
    }
}

struct ListCollaborationConfiguredAudienceModelAssociationsOutputBody: Swift.Equatable {
    let collaborationConfiguredAudienceModelAssociationSummaries: [CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociationSummary]?
    let nextToken: Swift.String?
}

extension ListCollaborationConfiguredAudienceModelAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collaborationConfiguredAudienceModelAssociationSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collaborationConfiguredAudienceModelAssociationSummariesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociationSummary?].self, forKey: .collaborationConfiguredAudienceModelAssociationSummaries)
        var collaborationConfiguredAudienceModelAssociationSummariesDecoded0:[CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociationSummary]? = nil
        if let collaborationConfiguredAudienceModelAssociationSummariesContainer = collaborationConfiguredAudienceModelAssociationSummariesContainer {
            collaborationConfiguredAudienceModelAssociationSummariesDecoded0 = [CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociationSummary]()
            for structure0 in collaborationConfiguredAudienceModelAssociationSummariesContainer {
                if let structure0 = structure0 {
                    collaborationConfiguredAudienceModelAssociationSummariesDecoded0?.append(structure0)
                }
            }
        }
        collaborationConfiguredAudienceModelAssociationSummaries = collaborationConfiguredAudienceModelAssociationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCollaborationConfiguredAudienceModelAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCollaborationPrivacyBudgetTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListCollaborationPrivacyBudgetTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collaborationIdentifier = collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/privacybudgettemplates"
    }
}

public struct ListCollaborationPrivacyBudgetTemplatesInput: Swift.Equatable {
    /// A unique identifier for one of your collaborations.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service may return a nextToken even if the maximum results has not been met.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCollaborationPrivacyBudgetTemplatesInputBody: Swift.Equatable {
}

extension ListCollaborationPrivacyBudgetTemplatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCollaborationPrivacyBudgetTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCollaborationPrivacyBudgetTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.collaborationPrivacyBudgetTemplateSummaries = output.collaborationPrivacyBudgetTemplateSummaries
            self.nextToken = output.nextToken
        } else {
            self.collaborationPrivacyBudgetTemplateSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListCollaborationPrivacyBudgetTemplatesOutput: Swift.Equatable {
    /// An array that summarizes the collaboration privacy budget templates. The summary includes collaboration information, creation information, the privacy budget type.
    /// This member is required.
    public var collaborationPrivacyBudgetTemplateSummaries: [CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplateSummary]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        collaborationPrivacyBudgetTemplateSummaries: [CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplateSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationPrivacyBudgetTemplateSummaries = collaborationPrivacyBudgetTemplateSummaries
        self.nextToken = nextToken
    }
}

struct ListCollaborationPrivacyBudgetTemplatesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let collaborationPrivacyBudgetTemplateSummaries: [CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplateSummary]?
}

extension ListCollaborationPrivacyBudgetTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collaborationPrivacyBudgetTemplateSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let collaborationPrivacyBudgetTemplateSummariesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplateSummary?].self, forKey: .collaborationPrivacyBudgetTemplateSummaries)
        var collaborationPrivacyBudgetTemplateSummariesDecoded0:[CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplateSummary]? = nil
        if let collaborationPrivacyBudgetTemplateSummariesContainer = collaborationPrivacyBudgetTemplateSummariesContainer {
            collaborationPrivacyBudgetTemplateSummariesDecoded0 = [CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplateSummary]()
            for structure0 in collaborationPrivacyBudgetTemplateSummariesContainer {
                if let structure0 = structure0 {
                    collaborationPrivacyBudgetTemplateSummariesDecoded0?.append(structure0)
                }
            }
        }
        collaborationPrivacyBudgetTemplateSummaries = collaborationPrivacyBudgetTemplateSummariesDecoded0
    }
}

enum ListCollaborationPrivacyBudgetTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCollaborationPrivacyBudgetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let privacyBudgetType = privacyBudgetType else {
                let message = "Creating a URL Query Item failed. privacyBudgetType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let privacyBudgetTypeQueryItem = ClientRuntime.URLQueryItem(name: "privacyBudgetType".urlPercentEncoding(), value: Swift.String(privacyBudgetType.rawValue).urlPercentEncoding())
            items.append(privacyBudgetTypeQueryItem)
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListCollaborationPrivacyBudgetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collaborationIdentifier = collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/privacybudgets"
    }
}

public struct ListCollaborationPrivacyBudgetsInput: Swift.Equatable {
    /// A unique identifier for one of your collaborations.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service may return a nextToken even if the maximum results has not been met.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// Specifies the type of the privacy budget.
    /// This member is required.
    public var privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.privacyBudgetType = privacyBudgetType
    }
}

struct ListCollaborationPrivacyBudgetsInputBody: Swift.Equatable {
}

extension ListCollaborationPrivacyBudgetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCollaborationPrivacyBudgetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCollaborationPrivacyBudgetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.collaborationPrivacyBudgetSummaries = output.collaborationPrivacyBudgetSummaries
            self.nextToken = output.nextToken
        } else {
            self.collaborationPrivacyBudgetSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListCollaborationPrivacyBudgetsOutput: Swift.Equatable {
    /// Summaries of the collaboration privacy budgets.
    /// This member is required.
    public var collaborationPrivacyBudgetSummaries: [CleanRoomsClientTypes.CollaborationPrivacyBudgetSummary]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        collaborationPrivacyBudgetSummaries: [CleanRoomsClientTypes.CollaborationPrivacyBudgetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationPrivacyBudgetSummaries = collaborationPrivacyBudgetSummaries
        self.nextToken = nextToken
    }
}

struct ListCollaborationPrivacyBudgetsOutputBody: Swift.Equatable {
    let collaborationPrivacyBudgetSummaries: [CleanRoomsClientTypes.CollaborationPrivacyBudgetSummary]?
    let nextToken: Swift.String?
}

extension ListCollaborationPrivacyBudgetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collaborationPrivacyBudgetSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collaborationPrivacyBudgetSummariesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.CollaborationPrivacyBudgetSummary?].self, forKey: .collaborationPrivacyBudgetSummaries)
        var collaborationPrivacyBudgetSummariesDecoded0:[CleanRoomsClientTypes.CollaborationPrivacyBudgetSummary]? = nil
        if let collaborationPrivacyBudgetSummariesContainer = collaborationPrivacyBudgetSummariesContainer {
            collaborationPrivacyBudgetSummariesDecoded0 = [CleanRoomsClientTypes.CollaborationPrivacyBudgetSummary]()
            for structure0 in collaborationPrivacyBudgetSummariesContainer {
                if let structure0 = structure0 {
                    collaborationPrivacyBudgetSummariesDecoded0?.append(structure0)
                }
            }
        }
        collaborationPrivacyBudgetSummaries = collaborationPrivacyBudgetSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCollaborationPrivacyBudgetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCollaborationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let memberStatus = memberStatus {
                let memberStatusQueryItem = ClientRuntime.URLQueryItem(name: "memberStatus".urlPercentEncoding(), value: Swift.String(memberStatus.rawValue).urlPercentEncoding())
                items.append(memberStatusQueryItem)
            }
            return items
        }
    }
}

extension ListCollaborationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/collaborations"
    }
}

public struct ListCollaborationsInput: Swift.Equatable {
    /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service may return a nextToken even if the maximum results has not been met.
    public var maxResults: Swift.Int?
    /// The caller's status in a collaboration.
    public var memberStatus: CleanRoomsClientTypes.FilterableMemberStatus?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        memberStatus: CleanRoomsClientTypes.FilterableMemberStatus? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.memberStatus = memberStatus
        self.nextToken = nextToken
    }
}

struct ListCollaborationsInputBody: Swift.Equatable {
}

extension ListCollaborationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCollaborationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCollaborationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.collaborationList = output.collaborationList
            self.nextToken = output.nextToken
        } else {
            self.collaborationList = nil
            self.nextToken = nil
        }
    }
}

public struct ListCollaborationsOutput: Swift.Equatable {
    /// The list of collaborations.
    /// This member is required.
    public var collaborationList: [CleanRoomsClientTypes.CollaborationSummary]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        collaborationList: [CleanRoomsClientTypes.CollaborationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationList = collaborationList
        self.nextToken = nextToken
    }
}

struct ListCollaborationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let collaborationList: [CleanRoomsClientTypes.CollaborationSummary]?
}

extension ListCollaborationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collaborationList
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let collaborationListContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.CollaborationSummary?].self, forKey: .collaborationList)
        var collaborationListDecoded0:[CleanRoomsClientTypes.CollaborationSummary]? = nil
        if let collaborationListContainer = collaborationListContainer {
            collaborationListDecoded0 = [CleanRoomsClientTypes.CollaborationSummary]()
            for structure0 in collaborationListContainer {
                if let structure0 = structure0 {
                    collaborationListDecoded0?.append(structure0)
                }
            }
        }
        collaborationList = collaborationListDecoded0
    }
}

enum ListCollaborationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListConfiguredAudienceModelAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListConfiguredAudienceModelAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredaudiencemodelassociations"
    }
}

public struct ListConfiguredAudienceModelAssociationsInput: Swift.Equatable {
    /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service may return a nextToken even if the maximum results has not been met.
    public var maxResults: Swift.Int?
    /// A unique identifier for a membership that contains the configured audience model associations that you want to retrieve.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        membershipIdentifier: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.membershipIdentifier = membershipIdentifier
        self.nextToken = nextToken
    }
}

struct ListConfiguredAudienceModelAssociationsInputBody: Swift.Equatable {
}

extension ListConfiguredAudienceModelAssociationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListConfiguredAudienceModelAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConfiguredAudienceModelAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuredAudienceModelAssociationSummaries = output.configuredAudienceModelAssociationSummaries
            self.nextToken = output.nextToken
        } else {
            self.configuredAudienceModelAssociationSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListConfiguredAudienceModelAssociationsOutput: Swift.Equatable {
    /// Summaries of the configured audience model associations that you requested.
    /// This member is required.
    public var configuredAudienceModelAssociationSummaries: [CleanRoomsClientTypes.ConfiguredAudienceModelAssociationSummary]?
    /// The token value provided to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        configuredAudienceModelAssociationSummaries: [CleanRoomsClientTypes.ConfiguredAudienceModelAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configuredAudienceModelAssociationSummaries = configuredAudienceModelAssociationSummaries
        self.nextToken = nextToken
    }
}

struct ListConfiguredAudienceModelAssociationsOutputBody: Swift.Equatable {
    let configuredAudienceModelAssociationSummaries: [CleanRoomsClientTypes.ConfiguredAudienceModelAssociationSummary]?
    let nextToken: Swift.String?
}

extension ListConfiguredAudienceModelAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredAudienceModelAssociationSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredAudienceModelAssociationSummariesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.ConfiguredAudienceModelAssociationSummary?].self, forKey: .configuredAudienceModelAssociationSummaries)
        var configuredAudienceModelAssociationSummariesDecoded0:[CleanRoomsClientTypes.ConfiguredAudienceModelAssociationSummary]? = nil
        if let configuredAudienceModelAssociationSummariesContainer = configuredAudienceModelAssociationSummariesContainer {
            configuredAudienceModelAssociationSummariesDecoded0 = [CleanRoomsClientTypes.ConfiguredAudienceModelAssociationSummary]()
            for structure0 in configuredAudienceModelAssociationSummariesContainer {
                if let structure0 = structure0 {
                    configuredAudienceModelAssociationSummariesDecoded0?.append(structure0)
                }
            }
        }
        configuredAudienceModelAssociationSummaries = configuredAudienceModelAssociationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListConfiguredAudienceModelAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListConfiguredTableAssociationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListConfiguredTableAssociationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredTableAssociations"
    }
}

public struct ListConfiguredTableAssociationsInput: Swift.Equatable {
    /// The maximum size of the results that is returned per call.
    public var maxResults: Swift.Int?
    /// A unique identifier for the membership to list configured table associations for. Currently accepts the membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        membershipIdentifier: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.membershipIdentifier = membershipIdentifier
        self.nextToken = nextToken
    }
}

struct ListConfiguredTableAssociationsInputBody: Swift.Equatable {
}

extension ListConfiguredTableAssociationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListConfiguredTableAssociationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConfiguredTableAssociationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuredTableAssociationSummaries = output.configuredTableAssociationSummaries
            self.nextToken = output.nextToken
        } else {
            self.configuredTableAssociationSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListConfiguredTableAssociationsOutput: Swift.Equatable {
    /// The retrieved list of configured table associations.
    /// This member is required.
    public var configuredTableAssociationSummaries: [CleanRoomsClientTypes.ConfiguredTableAssociationSummary]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        configuredTableAssociationSummaries: [CleanRoomsClientTypes.ConfiguredTableAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configuredTableAssociationSummaries = configuredTableAssociationSummaries
        self.nextToken = nextToken
    }
}

struct ListConfiguredTableAssociationsOutputBody: Swift.Equatable {
    let configuredTableAssociationSummaries: [CleanRoomsClientTypes.ConfiguredTableAssociationSummary]?
    let nextToken: Swift.String?
}

extension ListConfiguredTableAssociationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredTableAssociationSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredTableAssociationSummariesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.ConfiguredTableAssociationSummary?].self, forKey: .configuredTableAssociationSummaries)
        var configuredTableAssociationSummariesDecoded0:[CleanRoomsClientTypes.ConfiguredTableAssociationSummary]? = nil
        if let configuredTableAssociationSummariesContainer = configuredTableAssociationSummariesContainer {
            configuredTableAssociationSummariesDecoded0 = [CleanRoomsClientTypes.ConfiguredTableAssociationSummary]()
            for structure0 in configuredTableAssociationSummariesContainer {
                if let structure0 = structure0 {
                    configuredTableAssociationSummariesDecoded0?.append(structure0)
                }
            }
        }
        configuredTableAssociationSummaries = configuredTableAssociationSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListConfiguredTableAssociationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListConfiguredTablesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListConfiguredTablesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/configuredTables"
    }
}

public struct ListConfiguredTablesInput: Swift.Equatable {
    /// The maximum size of the results that is returned per call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListConfiguredTablesInputBody: Swift.Equatable {
}

extension ListConfiguredTablesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListConfiguredTablesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListConfiguredTablesOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuredTableSummaries = output.configuredTableSummaries
            self.nextToken = output.nextToken
        } else {
            self.configuredTableSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListConfiguredTablesOutput: Swift.Equatable {
    /// The configured tables listed by the request.
    /// This member is required.
    public var configuredTableSummaries: [CleanRoomsClientTypes.ConfiguredTableSummary]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        configuredTableSummaries: [CleanRoomsClientTypes.ConfiguredTableSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configuredTableSummaries = configuredTableSummaries
        self.nextToken = nextToken
    }
}

struct ListConfiguredTablesOutputBody: Swift.Equatable {
    let configuredTableSummaries: [CleanRoomsClientTypes.ConfiguredTableSummary]?
    let nextToken: Swift.String?
}

extension ListConfiguredTablesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredTableSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredTableSummariesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.ConfiguredTableSummary?].self, forKey: .configuredTableSummaries)
        var configuredTableSummariesDecoded0:[CleanRoomsClientTypes.ConfiguredTableSummary]? = nil
        if let configuredTableSummariesContainer = configuredTableSummariesContainer {
            configuredTableSummariesDecoded0 = [CleanRoomsClientTypes.ConfiguredTableSummary]()
            for structure0 in configuredTableSummariesContainer {
                if let structure0 = structure0 {
                    configuredTableSummariesDecoded0?.append(structure0)
                }
            }
        }
        configuredTableSummaries = configuredTableSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListConfiguredTablesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMembersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collaborationIdentifier = collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/members"
    }
}

public struct ListMembersInput: Swift.Equatable {
    /// The identifier of the collaboration in which the members are listed.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The maximum size of the results that is returned per call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListMembersInputBody: Swift.Equatable {
}

extension ListMembersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMembersOutputBody = try responseDecoder.decode(responseBody: data)
            self.memberSummaries = output.memberSummaries
            self.nextToken = output.nextToken
        } else {
            self.memberSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListMembersOutput: Swift.Equatable {
    /// The list of members returned by the ListMembers operation.
    /// This member is required.
    public var memberSummaries: [CleanRoomsClientTypes.MemberSummary]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        memberSummaries: [CleanRoomsClientTypes.MemberSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.memberSummaries = memberSummaries
        self.nextToken = nextToken
    }
}

struct ListMembersOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let memberSummaries: [CleanRoomsClientTypes.MemberSummary]?
}

extension ListMembersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let memberSummariesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.MemberSummary?].self, forKey: .memberSummaries)
        var memberSummariesDecoded0:[CleanRoomsClientTypes.MemberSummary]? = nil
        if let memberSummariesContainer = memberSummariesContainer {
            memberSummariesDecoded0 = [CleanRoomsClientTypes.MemberSummary]()
            for structure0 in memberSummariesContainer {
                if let structure0 = structure0 {
                    memberSummariesDecoded0?.append(structure0)
                }
            }
        }
        memberSummaries = memberSummariesDecoded0
    }
}

enum ListMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMembershipsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListMembershipsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/memberships"
    }
}

public struct ListMembershipsInput: Swift.Equatable {
    /// The maximum size of the results that is returned per call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// A filter which will return only memberships in the specified status.
    public var status: CleanRoomsClientTypes.MembershipStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: CleanRoomsClientTypes.MembershipStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListMembershipsInputBody: Swift.Equatable {
}

extension ListMembershipsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMembershipsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMembershipsOutputBody = try responseDecoder.decode(responseBody: data)
            self.membershipSummaries = output.membershipSummaries
            self.nextToken = output.nextToken
        } else {
            self.membershipSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListMembershipsOutput: Swift.Equatable {
    /// The list of memberships returned from the ListMemberships operation.
    /// This member is required.
    public var membershipSummaries: [CleanRoomsClientTypes.MembershipSummary]?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        membershipSummaries: [CleanRoomsClientTypes.MembershipSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.membershipSummaries = membershipSummaries
        self.nextToken = nextToken
    }
}

struct ListMembershipsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let membershipSummaries: [CleanRoomsClientTypes.MembershipSummary]?
}

extension ListMembershipsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case membershipSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let membershipSummariesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.MembershipSummary?].self, forKey: .membershipSummaries)
        var membershipSummariesDecoded0:[CleanRoomsClientTypes.MembershipSummary]? = nil
        if let membershipSummariesContainer = membershipSummariesContainer {
            membershipSummariesDecoded0 = [CleanRoomsClientTypes.MembershipSummary]()
            for structure0 in membershipSummariesContainer {
                if let structure0 = structure0 {
                    membershipSummariesDecoded0?.append(structure0)
                }
            }
        }
        membershipSummaries = membershipSummariesDecoded0
    }
}

enum ListMembershipsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPrivacyBudgetTemplatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPrivacyBudgetTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/privacybudgettemplates"
    }
}

public struct ListPrivacyBudgetTemplatesInput: Swift.Equatable {
    /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service may return a nextToken even if the maximum results has not been met.
    public var maxResults: Swift.Int?
    /// A unique identifier for one of your memberships for a collaboration. The privacy budget templates are retrieved from the collaboration that this membership belongs to. Accepts a membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        membershipIdentifier: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.membershipIdentifier = membershipIdentifier
        self.nextToken = nextToken
    }
}

struct ListPrivacyBudgetTemplatesInputBody: Swift.Equatable {
}

extension ListPrivacyBudgetTemplatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPrivacyBudgetTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPrivacyBudgetTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.privacyBudgetTemplateSummaries = output.privacyBudgetTemplateSummaries
        } else {
            self.nextToken = nil
            self.privacyBudgetTemplateSummaries = nil
        }
    }
}

public struct ListPrivacyBudgetTemplatesOutput: Swift.Equatable {
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// An array that summarizes the privacy budget templates. The summary includes collaboration information, creation information, and privacy budget type.
    /// This member is required.
    public var privacyBudgetTemplateSummaries: [CleanRoomsClientTypes.PrivacyBudgetTemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        privacyBudgetTemplateSummaries: [CleanRoomsClientTypes.PrivacyBudgetTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.privacyBudgetTemplateSummaries = privacyBudgetTemplateSummaries
    }
}

struct ListPrivacyBudgetTemplatesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let privacyBudgetTemplateSummaries: [CleanRoomsClientTypes.PrivacyBudgetTemplateSummary]?
}

extension ListPrivacyBudgetTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case privacyBudgetTemplateSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let privacyBudgetTemplateSummariesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.PrivacyBudgetTemplateSummary?].self, forKey: .privacyBudgetTemplateSummaries)
        var privacyBudgetTemplateSummariesDecoded0:[CleanRoomsClientTypes.PrivacyBudgetTemplateSummary]? = nil
        if let privacyBudgetTemplateSummariesContainer = privacyBudgetTemplateSummariesContainer {
            privacyBudgetTemplateSummariesDecoded0 = [CleanRoomsClientTypes.PrivacyBudgetTemplateSummary]()
            for structure0 in privacyBudgetTemplateSummariesContainer {
                if let structure0 = structure0 {
                    privacyBudgetTemplateSummariesDecoded0?.append(structure0)
                }
            }
        }
        privacyBudgetTemplateSummaries = privacyBudgetTemplateSummariesDecoded0
    }
}

enum ListPrivacyBudgetTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPrivacyBudgetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let privacyBudgetType = privacyBudgetType else {
                let message = "Creating a URL Query Item failed. privacyBudgetType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let privacyBudgetTypeQueryItem = ClientRuntime.URLQueryItem(name: "privacyBudgetType".urlPercentEncoding(), value: Swift.String(privacyBudgetType.rawValue).urlPercentEncoding())
            items.append(privacyBudgetTypeQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPrivacyBudgetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/privacybudgets"
    }
}

public struct ListPrivacyBudgetsInput: Swift.Equatable {
    /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service may return a nextToken even if the maximum results has not been met.
    public var maxResults: Swift.Int?
    /// A unique identifier for one of your memberships for a collaboration. The privacy budget is retrieved from the collaboration that this membership belongs to. Accepts a membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// The privacy budget type.
    /// This member is required.
    public var privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType?

    public init(
        maxResults: Swift.Int? = nil,
        membershipIdentifier: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType? = nil
    )
    {
        self.maxResults = maxResults
        self.membershipIdentifier = membershipIdentifier
        self.nextToken = nextToken
        self.privacyBudgetType = privacyBudgetType
    }
}

struct ListPrivacyBudgetsInputBody: Swift.Equatable {
}

extension ListPrivacyBudgetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPrivacyBudgetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPrivacyBudgetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.privacyBudgetSummaries = output.privacyBudgetSummaries
        } else {
            self.nextToken = nil
            self.privacyBudgetSummaries = nil
        }
    }
}

public struct ListPrivacyBudgetsOutput: Swift.Equatable {
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// An array that summarizes the privacy budgets. The summary includes collaboration information, membership information, privacy budget template information, and privacy budget details.
    /// This member is required.
    public var privacyBudgetSummaries: [CleanRoomsClientTypes.PrivacyBudgetSummary]?

    public init(
        nextToken: Swift.String? = nil,
        privacyBudgetSummaries: [CleanRoomsClientTypes.PrivacyBudgetSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.privacyBudgetSummaries = privacyBudgetSummaries
    }
}

struct ListPrivacyBudgetsOutputBody: Swift.Equatable {
    let privacyBudgetSummaries: [CleanRoomsClientTypes.PrivacyBudgetSummary]?
    let nextToken: Swift.String?
}

extension ListPrivacyBudgetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case privacyBudgetSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privacyBudgetSummariesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.PrivacyBudgetSummary?].self, forKey: .privacyBudgetSummaries)
        var privacyBudgetSummariesDecoded0:[CleanRoomsClientTypes.PrivacyBudgetSummary]? = nil
        if let privacyBudgetSummariesContainer = privacyBudgetSummariesContainer {
            privacyBudgetSummariesDecoded0 = [CleanRoomsClientTypes.PrivacyBudgetSummary]()
            for structure0 in privacyBudgetSummariesContainer {
                if let structure0 = structure0 {
                    privacyBudgetSummariesDecoded0?.append(structure0)
                }
            }
        }
        privacyBudgetSummaries = privacyBudgetSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPrivacyBudgetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProtectedQueriesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListProtectedQueriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/protectedQueries"
    }
}

public struct ListProtectedQueriesInput: Swift.Equatable {
    /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service can return a nextToken even if the maximum results has not been met.
    public var maxResults: Swift.Int?
    /// The identifier for the membership in the collaboration.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// A filter on the status of the protected query.
    public var status: CleanRoomsClientTypes.ProtectedQueryStatus?

    public init(
        maxResults: Swift.Int? = nil,
        membershipIdentifier: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        status: CleanRoomsClientTypes.ProtectedQueryStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.membershipIdentifier = membershipIdentifier
        self.nextToken = nextToken
        self.status = status
    }
}

struct ListProtectedQueriesInputBody: Swift.Equatable {
}

extension ListProtectedQueriesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProtectedQueriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProtectedQueriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.protectedQueries = output.protectedQueries
        } else {
            self.nextToken = nil
            self.protectedQueries = nil
        }
    }
}

public struct ListProtectedQueriesOutput: Swift.Equatable {
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// A list of protected queries.
    /// This member is required.
    public var protectedQueries: [CleanRoomsClientTypes.ProtectedQuerySummary]?

    public init(
        nextToken: Swift.String? = nil,
        protectedQueries: [CleanRoomsClientTypes.ProtectedQuerySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.protectedQueries = protectedQueries
    }
}

struct ListProtectedQueriesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let protectedQueries: [CleanRoomsClientTypes.ProtectedQuerySummary]?
}

extension ListProtectedQueriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case protectedQueries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let protectedQueriesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.ProtectedQuerySummary?].self, forKey: .protectedQueries)
        var protectedQueriesDecoded0:[CleanRoomsClientTypes.ProtectedQuerySummary]? = nil
        if let protectedQueriesContainer = protectedQueriesContainer {
            protectedQueriesDecoded0 = [CleanRoomsClientTypes.ProtectedQuerySummary]()
            for structure0 in protectedQueriesContainer {
                if let structure0 = structure0 {
                    protectedQueriesDecoded0?.append(structure0)
                }
            }
        }
        protectedQueries = protectedQueriesDecoded0
    }
}

enum ListProtectedQueriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSchemasInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let schemaType = schemaType {
                let schemaTypeQueryItem = ClientRuntime.URLQueryItem(name: "schemaType".urlPercentEncoding(), value: Swift.String(schemaType.rawValue).urlPercentEncoding())
                items.append(schemaTypeQueryItem)
            }
            return items
        }
    }
}

extension ListSchemasInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collaborationIdentifier = collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/schemas"
    }
}

public struct ListSchemasInput: Swift.Equatable {
    /// A unique identifier for the collaboration that the schema belongs to. Currently accepts a collaboration ID.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The maximum size of the results that is returned per call.
    public var maxResults: Swift.Int?
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// If present, filter schemas by schema type. The only valid schema type is currently `TABLE`.
    public var schemaType: CleanRoomsClientTypes.SchemaType?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        schemaType: CleanRoomsClientTypes.SchemaType? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaType = schemaType
    }
}

struct ListSchemasInputBody: Swift.Equatable {
}

extension ListSchemasInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSchemasOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSchemasOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.schemaSummaries = output.schemaSummaries
        } else {
            self.nextToken = nil
            self.schemaSummaries = nil
        }
    }
}

public struct ListSchemasOutput: Swift.Equatable {
    /// The token value retrieved from a previous call to access the next page of results.
    public var nextToken: Swift.String?
    /// The retrieved list of schemas.
    /// This member is required.
    public var schemaSummaries: [CleanRoomsClientTypes.SchemaSummary]?

    public init(
        nextToken: Swift.String? = nil,
        schemaSummaries: [CleanRoomsClientTypes.SchemaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaSummaries = schemaSummaries
    }
}

struct ListSchemasOutputBody: Swift.Equatable {
    let schemaSummaries: [CleanRoomsClientTypes.SchemaSummary]?
    let nextToken: Swift.String?
}

extension ListSchemasOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case schemaSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let schemaSummariesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.SchemaSummary?].self, forKey: .schemaSummaries)
        var schemaSummariesDecoded0:[CleanRoomsClientTypes.SchemaSummary]? = nil
        if let schemaSummariesContainer = schemaSummariesContainer {
            schemaSummariesDecoded0 = [CleanRoomsClientTypes.SchemaSummary]()
            for structure0 in schemaSummariesContainer {
                if let structure0 = structure0 {
                    schemaSummariesDecoded0?.append(structure0)
                }
            }
        }
        schemaSummaries = schemaSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSchemasOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the resource you want to list tags on.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A map of objects specifying each key name and value.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CleanRoomsClientTypes {
    public enum MemberAbility: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canQuery
        case canReceiveResults
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberAbility] {
            return [
                .canQuery,
                .canReceiveResults,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canQuery: return "CAN_QUERY"
            case .canReceiveResults: return "CAN_RECEIVE_RESULTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MemberAbility(rawValue: rawValue) ?? MemberAbility.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes.MemberSpecification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case displayName
        case memberAbilities
        case paymentConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let memberAbilities = memberAbilities {
            var memberAbilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .memberAbilities)
            for memberability0 in memberAbilities {
                try memberAbilitiesContainer.encode(memberability0.rawValue)
            }
        }
        if let paymentConfiguration = self.paymentConfiguration {
            try encodeContainer.encode(paymentConfiguration, forKey: .paymentConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let memberAbilitiesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.MemberAbility?].self, forKey: .memberAbilities)
        var memberAbilitiesDecoded0:[CleanRoomsClientTypes.MemberAbility]? = nil
        if let memberAbilitiesContainer = memberAbilitiesContainer {
            memberAbilitiesDecoded0 = [CleanRoomsClientTypes.MemberAbility]()
            for string0 in memberAbilitiesContainer {
                if let string0 = string0 {
                    memberAbilitiesDecoded0?.append(string0)
                }
            }
        }
        memberAbilities = memberAbilitiesDecoded0
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let paymentConfigurationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PaymentConfiguration.self, forKey: .paymentConfiguration)
        paymentConfiguration = paymentConfigurationDecoded
    }
}

extension CleanRoomsClientTypes {
    /// Basic metadata used to construct a new member.
    public struct MemberSpecification: Swift.Equatable {
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        /// This member is required.
        public var accountId: Swift.String?
        /// The member's display name.
        /// This member is required.
        public var displayName: Swift.String?
        /// The abilities granted to the collaboration member.
        /// This member is required.
        public var memberAbilities: [CleanRoomsClientTypes.MemberAbility]?
        /// The collaboration member's payment responsibilities set by the collaboration creator. If the collaboration creator hasn't speciﬁed anyone as the member paying for query compute costs, then the member who can query is the default payer.
        public var paymentConfiguration: CleanRoomsClientTypes.PaymentConfiguration?

        public init(
            accountId: Swift.String? = nil,
            displayName: Swift.String? = nil,
            memberAbilities: [CleanRoomsClientTypes.MemberAbility]? = nil,
            paymentConfiguration: CleanRoomsClientTypes.PaymentConfiguration? = nil
        )
        {
            self.accountId = accountId
            self.displayName = displayName
            self.memberAbilities = memberAbilities
            self.paymentConfiguration = paymentConfiguration
        }
    }

}

extension CleanRoomsClientTypes {
    public enum MemberStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case invited
        case `left`
        case removed
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberStatus] {
            return [
                .active,
                .invited,
                .left,
                .removed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .invited: return "INVITED"
            case .left: return "LEFT"
            case .removed: return "REMOVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MemberStatus(rawValue: rawValue) ?? MemberStatus.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes.MemberSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case abilities
        case accountId
        case createTime
        case displayName
        case membershipArn
        case membershipId
        case paymentConfiguration
        case status
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let abilities = abilities {
            var abilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .abilities)
            for memberability0 in abilities {
                try abilitiesContainer.encode(memberability0.rawValue)
            }
        }
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let membershipArn = self.membershipArn {
            try encodeContainer.encode(membershipArn, forKey: .membershipArn)
        }
        if let membershipId = self.membershipId {
            try encodeContainer.encode(membershipId, forKey: .membershipId)
        }
        if let paymentConfiguration = self.paymentConfiguration {
            try encodeContainer.encode(paymentConfiguration, forKey: .paymentConfiguration)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.MemberStatus.self, forKey: .status)
        status = statusDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let abilitiesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.MemberAbility?].self, forKey: .abilities)
        var abilitiesDecoded0:[CleanRoomsClientTypes.MemberAbility]? = nil
        if let abilitiesContainer = abilitiesContainer {
            abilitiesDecoded0 = [CleanRoomsClientTypes.MemberAbility]()
            for string0 in abilitiesContainer {
                if let string0 = string0 {
                    abilitiesDecoded0?.append(string0)
                }
            }
        }
        abilities = abilitiesDecoded0
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let membershipArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipArn)
        membershipArn = membershipArnDecoded
        let paymentConfigurationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PaymentConfiguration.self, forKey: .paymentConfiguration)
        paymentConfiguration = paymentConfigurationDecoded
    }
}

extension CleanRoomsClientTypes {
    /// The member object listed by the request.
    public struct MemberSummary: Swift.Equatable {
        /// The abilities granted to the collaboration member.
        /// This member is required.
        public var abilities: [CleanRoomsClientTypes.MemberAbility]?
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        /// This member is required.
        public var accountId: Swift.String?
        /// The time when the member was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The member's display name.
        /// This member is required.
        public var displayName: Swift.String?
        /// The unique ARN for the member's associated membership, if present.
        public var membershipArn: Swift.String?
        /// The unique ID for the member's associated membership, if present.
        public var membershipId: Swift.String?
        /// The collaboration member's payment responsibilities set by the collaboration creator.
        /// This member is required.
        public var paymentConfiguration: CleanRoomsClientTypes.PaymentConfiguration?
        /// The status of the member.
        /// This member is required.
        public var status: CleanRoomsClientTypes.MemberStatus?
        /// The time the member metadata was last updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            abilities: [CleanRoomsClientTypes.MemberAbility]? = nil,
            accountId: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            displayName: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            paymentConfiguration: CleanRoomsClientTypes.PaymentConfiguration? = nil,
            status: CleanRoomsClientTypes.MemberStatus? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.abilities = abilities
            self.accountId = accountId
            self.createTime = createTime
            self.displayName = displayName
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.paymentConfiguration = paymentConfiguration
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.Membership: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case collaborationArn
        case collaborationCreatorAccountId
        case collaborationCreatorDisplayName
        case collaborationId
        case collaborationName
        case createTime
        case defaultResultConfiguration
        case id
        case memberAbilities
        case paymentConfiguration
        case queryLogStatus
        case status
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let collaborationArn = self.collaborationArn {
            try encodeContainer.encode(collaborationArn, forKey: .collaborationArn)
        }
        if let collaborationCreatorAccountId = self.collaborationCreatorAccountId {
            try encodeContainer.encode(collaborationCreatorAccountId, forKey: .collaborationCreatorAccountId)
        }
        if let collaborationCreatorDisplayName = self.collaborationCreatorDisplayName {
            try encodeContainer.encode(collaborationCreatorDisplayName, forKey: .collaborationCreatorDisplayName)
        }
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let collaborationName = self.collaborationName {
            try encodeContainer.encode(collaborationName, forKey: .collaborationName)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let defaultResultConfiguration = self.defaultResultConfiguration {
            try encodeContainer.encode(defaultResultConfiguration, forKey: .defaultResultConfiguration)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let memberAbilities = memberAbilities {
            var memberAbilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .memberAbilities)
            for memberability0 in memberAbilities {
                try memberAbilitiesContainer.encode(memberability0.rawValue)
            }
        }
        if let paymentConfiguration = self.paymentConfiguration {
            try encodeContainer.encode(paymentConfiguration, forKey: .paymentConfiguration)
        }
        if let queryLogStatus = self.queryLogStatus {
            try encodeContainer.encode(queryLogStatus.rawValue, forKey: .queryLogStatus)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let collaborationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationArn)
        collaborationArn = collaborationArnDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let collaborationCreatorAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationCreatorAccountId)
        collaborationCreatorAccountId = collaborationCreatorAccountIdDecoded
        let collaborationCreatorDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationCreatorDisplayName)
        collaborationCreatorDisplayName = collaborationCreatorDisplayNameDecoded
        let collaborationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationName)
        collaborationName = collaborationNameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.MembershipStatus.self, forKey: .status)
        status = statusDecoded
        let memberAbilitiesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.MemberAbility?].self, forKey: .memberAbilities)
        var memberAbilitiesDecoded0:[CleanRoomsClientTypes.MemberAbility]? = nil
        if let memberAbilitiesContainer = memberAbilitiesContainer {
            memberAbilitiesDecoded0 = [CleanRoomsClientTypes.MemberAbility]()
            for string0 in memberAbilitiesContainer {
                if let string0 = string0 {
                    memberAbilitiesDecoded0?.append(string0)
                }
            }
        }
        memberAbilities = memberAbilitiesDecoded0
        let queryLogStatusDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.MembershipQueryLogStatus.self, forKey: .queryLogStatus)
        queryLogStatus = queryLogStatusDecoded
        let defaultResultConfigurationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration.self, forKey: .defaultResultConfiguration)
        defaultResultConfiguration = defaultResultConfigurationDecoded
        let paymentConfigurationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.MembershipPaymentConfiguration.self, forKey: .paymentConfiguration)
        paymentConfiguration = paymentConfigurationDecoded
    }
}

extension CleanRoomsClientTypes {
    /// The membership object.
    public struct Membership: Swift.Equatable {
        /// The unique ARN for the membership.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique ARN for the membership's associated collaboration.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        /// This member is required.
        public var collaborationCreatorAccountId: Swift.String?
        /// The display name of the collaboration creator.
        /// This member is required.
        public var collaborationCreatorDisplayName: Swift.String?
        /// The unique ID for the membership's collaboration.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The name of the membership's collaboration.
        /// This member is required.
        public var collaborationName: Swift.String?
        /// The time when the membership was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The default protected query result configuration as specified by the member who can receive results.
        public var defaultResultConfiguration: CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration?
        /// The unique ID of the membership.
        /// This member is required.
        public var id: Swift.String?
        /// The abilities granted to the collaboration member.
        /// This member is required.
        public var memberAbilities: [CleanRoomsClientTypes.MemberAbility]?
        /// The payment responsibilities accepted by the collaboration member.
        /// This member is required.
        public var paymentConfiguration: CleanRoomsClientTypes.MembershipPaymentConfiguration?
        /// An indicator as to whether query logging has been enabled or disabled for the membership.
        /// This member is required.
        public var queryLogStatus: CleanRoomsClientTypes.MembershipQueryLogStatus?
        /// The status of the membership.
        /// This member is required.
        public var status: CleanRoomsClientTypes.MembershipStatus?
        /// The time the membership metadata was last updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationCreatorAccountId: Swift.String? = nil,
            collaborationCreatorDisplayName: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            collaborationName: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            defaultResultConfiguration: CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration? = nil,
            id: Swift.String? = nil,
            memberAbilities: [CleanRoomsClientTypes.MemberAbility]? = nil,
            paymentConfiguration: CleanRoomsClientTypes.MembershipPaymentConfiguration? = nil,
            queryLogStatus: CleanRoomsClientTypes.MembershipQueryLogStatus? = nil,
            status: CleanRoomsClientTypes.MembershipStatus? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationCreatorAccountId = collaborationCreatorAccountId
            self.collaborationCreatorDisplayName = collaborationCreatorDisplayName
            self.collaborationId = collaborationId
            self.collaborationName = collaborationName
            self.createTime = createTime
            self.defaultResultConfiguration = defaultResultConfiguration
            self.id = id
            self.memberAbilities = memberAbilities
            self.paymentConfiguration = paymentConfiguration
            self.queryLogStatus = queryLogStatus
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.MembershipPaymentConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryCompute
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryCompute = self.queryCompute {
            try encodeContainer.encode(queryCompute, forKey: .queryCompute)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryComputeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.MembershipQueryComputePaymentConfig.self, forKey: .queryCompute)
        queryCompute = queryComputeDecoded
    }
}

extension CleanRoomsClientTypes {
    /// An object representing the payment responsibilities accepted by the collaboration member.
    public struct MembershipPaymentConfiguration: Swift.Equatable {
        /// The payment responsibilities accepted by the collaboration member for query compute costs.
        /// This member is required.
        public var queryCompute: CleanRoomsClientTypes.MembershipQueryComputePaymentConfig?

        public init(
            queryCompute: CleanRoomsClientTypes.MembershipQueryComputePaymentConfig? = nil
        )
        {
            self.queryCompute = queryCompute
        }
    }

}

extension CleanRoomsClientTypes.MembershipProtectedQueryOutputConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .s3(s3):
                try container.encode(s3, forKey: .s3)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try values.decodeIfPresent(CleanRoomsClientTypes.ProtectedQueryS3OutputConfiguration.self, forKey: .s3)
        if let s3 = s3Decoded {
            self = .s3(s3)
            return
        }
        self = .sdkUnknown("")
    }
}

extension CleanRoomsClientTypes {
    /// Contains configurations for protected query results.
    public enum MembershipProtectedQueryOutputConfiguration: Swift.Equatable {
        /// Contains the configuration to write the query results to S3.
        case s3(CleanRoomsClientTypes.ProtectedQueryS3OutputConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputConfiguration
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputConfiguration = self.outputConfiguration {
            try encodeContainer.encode(outputConfiguration, forKey: .outputConfiguration)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputConfigurationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.MembershipProtectedQueryOutputConfiguration.self, forKey: .outputConfiguration)
        outputConfiguration = outputConfigurationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension CleanRoomsClientTypes {
    /// Contains configurations for protected query results.
    public struct MembershipProtectedQueryResultConfiguration: Swift.Equatable {
        /// Configuration for protected query results.
        /// This member is required.
        public var outputConfiguration: CleanRoomsClientTypes.MembershipProtectedQueryOutputConfiguration?
        /// The unique ARN for an IAM role that is used by Clean Rooms to write protected query results to the result location, given by the member who can receive results.
        public var roleArn: Swift.String?

        public init(
            outputConfiguration: CleanRoomsClientTypes.MembershipProtectedQueryOutputConfiguration? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.outputConfiguration = outputConfiguration
            self.roleArn = roleArn
        }
    }

}

extension CleanRoomsClientTypes.MembershipQueryComputePaymentConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isResponsible
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isResponsible = self.isResponsible {
            try encodeContainer.encode(isResponsible, forKey: .isResponsible)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isResponsibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isResponsible)
        isResponsible = isResponsibleDecoded
    }
}

extension CleanRoomsClientTypes {
    /// An object representing the payment responsibilities accepted by the collaboration member for query compute costs.
    public struct MembershipQueryComputePaymentConfig: Swift.Equatable {
        /// Indicates whether the collaboration member has accepted to pay for query compute costs (TRUE) or has not accepted to pay for query compute costs (FALSE). If the collaboration creator has not specified anyone to pay for query compute costs, then the member who can query is the default payer. An error message is returned for the following reasons:
        ///
        /// * If you set the value to FALSE but you are responsible to pay for query compute costs.
        ///
        /// * If you set the value to TRUE but you are not responsible to pay for query compute costs.
        /// This member is required.
        public var isResponsible: Swift.Bool?

        public init(
            isResponsible: Swift.Bool? = nil
        )
        {
            self.isResponsible = isResponsible
        }
    }

}

extension CleanRoomsClientTypes {
    public enum MembershipQueryLogStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MembershipQueryLogStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MembershipQueryLogStatus(rawValue: rawValue) ?? MembershipQueryLogStatus.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes {
    public enum MembershipStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case collaborationDeleted
        case removed
        case sdkUnknown(Swift.String)

        public static var allCases: [MembershipStatus] {
            return [
                .active,
                .collaborationDeleted,
                .removed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .collaborationDeleted: return "COLLABORATION_DELETED"
            case .removed: return "REMOVED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MembershipStatus(rawValue: rawValue) ?? MembershipStatus.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes.MembershipSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case collaborationArn
        case collaborationCreatorAccountId
        case collaborationCreatorDisplayName
        case collaborationId
        case collaborationName
        case createTime
        case id
        case memberAbilities
        case paymentConfiguration
        case status
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let collaborationArn = self.collaborationArn {
            try encodeContainer.encode(collaborationArn, forKey: .collaborationArn)
        }
        if let collaborationCreatorAccountId = self.collaborationCreatorAccountId {
            try encodeContainer.encode(collaborationCreatorAccountId, forKey: .collaborationCreatorAccountId)
        }
        if let collaborationCreatorDisplayName = self.collaborationCreatorDisplayName {
            try encodeContainer.encode(collaborationCreatorDisplayName, forKey: .collaborationCreatorDisplayName)
        }
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let collaborationName = self.collaborationName {
            try encodeContainer.encode(collaborationName, forKey: .collaborationName)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let memberAbilities = memberAbilities {
            var memberAbilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .memberAbilities)
            for memberability0 in memberAbilities {
                try memberAbilitiesContainer.encode(memberability0.rawValue)
            }
        }
        if let paymentConfiguration = self.paymentConfiguration {
            try encodeContainer.encode(paymentConfiguration, forKey: .paymentConfiguration)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let collaborationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationArn)
        collaborationArn = collaborationArnDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let collaborationCreatorAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationCreatorAccountId)
        collaborationCreatorAccountId = collaborationCreatorAccountIdDecoded
        let collaborationCreatorDisplayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationCreatorDisplayName)
        collaborationCreatorDisplayName = collaborationCreatorDisplayNameDecoded
        let collaborationNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationName)
        collaborationName = collaborationNameDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.MembershipStatus.self, forKey: .status)
        status = statusDecoded
        let memberAbilitiesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.MemberAbility?].self, forKey: .memberAbilities)
        var memberAbilitiesDecoded0:[CleanRoomsClientTypes.MemberAbility]? = nil
        if let memberAbilitiesContainer = memberAbilitiesContainer {
            memberAbilitiesDecoded0 = [CleanRoomsClientTypes.MemberAbility]()
            for string0 in memberAbilitiesContainer {
                if let string0 = string0 {
                    memberAbilitiesDecoded0?.append(string0)
                }
            }
        }
        memberAbilities = memberAbilitiesDecoded0
        let paymentConfigurationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.MembershipPaymentConfiguration.self, forKey: .paymentConfiguration)
        paymentConfiguration = paymentConfigurationDecoded
    }
}

extension CleanRoomsClientTypes {
    /// The membership object listed by the request.
    public struct MembershipSummary: Swift.Equatable {
        /// The unique ARN for the membership.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique ARN for the membership's associated collaboration.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The identifier of the Amazon Web Services principal that created the collaboration. Currently only supports Amazon Web Services account ID.
        /// This member is required.
        public var collaborationCreatorAccountId: Swift.String?
        /// The display name of the collaboration creator.
        /// This member is required.
        public var collaborationCreatorDisplayName: Swift.String?
        /// The unique ID for the membership's collaboration.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The name for the membership's collaboration.
        /// This member is required.
        public var collaborationName: Swift.String?
        /// The time when the membership was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The unique ID for the membership's collaboration.
        /// This member is required.
        public var id: Swift.String?
        /// The abilities granted to the collaboration member.
        /// This member is required.
        public var memberAbilities: [CleanRoomsClientTypes.MemberAbility]?
        /// The payment responsibilities accepted by the collaboration member.
        /// This member is required.
        public var paymentConfiguration: CleanRoomsClientTypes.MembershipPaymentConfiguration?
        /// The status of the membership.
        /// This member is required.
        public var status: CleanRoomsClientTypes.MembershipStatus?
        /// The time the membership metadata was last updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationCreatorAccountId: Swift.String? = nil,
            collaborationCreatorDisplayName: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            collaborationName: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            memberAbilities: [CleanRoomsClientTypes.MemberAbility]? = nil,
            paymentConfiguration: CleanRoomsClientTypes.MembershipPaymentConfiguration? = nil,
            status: CleanRoomsClientTypes.MembershipStatus? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationCreatorAccountId = collaborationCreatorAccountId
            self.collaborationCreatorDisplayName = collaborationCreatorDisplayName
            self.collaborationId = collaborationId
            self.collaborationName = collaborationName
            self.createTime = createTime
            self.id = id
            self.memberAbilities = memberAbilities
            self.paymentConfiguration = paymentConfiguration
            self.status = status
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes {
    public enum ParameterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bigint
        case boolean
        case char
        case date
        case decimal
        case doublePrecision
        case integer
        case real
        case smallint
        case time
        case timestamp
        case timestamptz
        case timetz
        case varbyte
        case varchar
        case sdkUnknown(Swift.String)

        public static var allCases: [ParameterType] {
            return [
                .bigint,
                .boolean,
                .char,
                .date,
                .decimal,
                .doublePrecision,
                .integer,
                .real,
                .smallint,
                .time,
                .timestamp,
                .timestamptz,
                .timetz,
                .varbyte,
                .varchar,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bigint: return "BIGINT"
            case .boolean: return "BOOLEAN"
            case .char: return "CHAR"
            case .date: return "DATE"
            case .decimal: return "DECIMAL"
            case .doublePrecision: return "DOUBLE_PRECISION"
            case .integer: return "INTEGER"
            case .real: return "REAL"
            case .smallint: return "SMALLINT"
            case .time: return "TIME"
            case .timestamp: return "TIMESTAMP"
            case .timestamptz: return "TIMESTAMPTZ"
            case .timetz: return "TIMETZ"
            case .varbyte: return "VARBYTE"
            case .varchar: return "VARCHAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParameterType(rawValue: rawValue) ?? ParameterType.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes.PaymentConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case queryCompute
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let queryCompute = self.queryCompute {
            try encodeContainer.encode(queryCompute, forKey: .queryCompute)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryComputeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.QueryComputePaymentConfig.self, forKey: .queryCompute)
        queryCompute = queryComputeDecoded
    }
}

extension CleanRoomsClientTypes {
    /// An object representing the collaboration member's payment responsibilities set by the collaboration creator.
    public struct PaymentConfiguration: Swift.Equatable {
        /// The collaboration member's payment responsibilities set by the collaboration creator for query compute costs.
        /// This member is required.
        public var queryCompute: CleanRoomsClientTypes.QueryComputePaymentConfig?

        public init(
            queryCompute: CleanRoomsClientTypes.QueryComputePaymentConfig? = nil
        )
        {
            self.queryCompute = queryCompute
        }
    }

}

extension PreviewPrivacyImpactInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
    }
}

extension PreviewPrivacyImpactInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/previewprivacyimpact"
    }
}

public struct PreviewPrivacyImpactInput: Swift.Equatable {
    /// A unique identifier for one of your memberships for a collaboration. Accepts a membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// Specifies the desired epsilon and noise parameters to preview.
    /// This member is required.
    public var parameters: CleanRoomsClientTypes.PreviewPrivacyImpactParametersInput?

    public init(
        membershipIdentifier: Swift.String? = nil,
        parameters: CleanRoomsClientTypes.PreviewPrivacyImpactParametersInput? = nil
    )
    {
        self.membershipIdentifier = membershipIdentifier
        self.parameters = parameters
    }
}

struct PreviewPrivacyImpactInputBody: Swift.Equatable {
    let parameters: CleanRoomsClientTypes.PreviewPrivacyImpactParametersInput?
}

extension PreviewPrivacyImpactInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parametersDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PreviewPrivacyImpactParametersInput.self, forKey: .parameters)
        parameters = parametersDecoded
    }
}

extension PreviewPrivacyImpactOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PreviewPrivacyImpactOutputBody = try responseDecoder.decode(responseBody: data)
            self.privacyImpact = output.privacyImpact
        } else {
            self.privacyImpact = nil
        }
    }
}

public struct PreviewPrivacyImpactOutput: Swift.Equatable {
    /// An estimate of the number of aggregation functions that the member who can query can run given the epsilon and noise parameters. This does not change the privacy budget.
    /// This member is required.
    public var privacyImpact: CleanRoomsClientTypes.PrivacyImpact?

    public init(
        privacyImpact: CleanRoomsClientTypes.PrivacyImpact? = nil
    )
    {
        self.privacyImpact = privacyImpact
    }
}

struct PreviewPrivacyImpactOutputBody: Swift.Equatable {
    let privacyImpact: CleanRoomsClientTypes.PrivacyImpact?
}

extension PreviewPrivacyImpactOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case privacyImpact
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privacyImpactDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyImpact.self, forKey: .privacyImpact)
        privacyImpact = privacyImpactDecoded
    }
}

enum PreviewPrivacyImpactOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CleanRoomsClientTypes.PreviewPrivacyImpactParametersInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case differentialprivacy = "differentialPrivacy"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .differentialprivacy(differentialprivacy):
                try container.encode(differentialprivacy, forKey: .differentialprivacy)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let differentialprivacyDecoded = try values.decodeIfPresent(CleanRoomsClientTypes.DifferentialPrivacyPreviewParametersInput.self, forKey: .differentialprivacy)
        if let differentialprivacy = differentialprivacyDecoded {
            self = .differentialprivacy(differentialprivacy)
            return
        }
        self = .sdkUnknown("")
    }
}

extension CleanRoomsClientTypes {
    /// Specifies the updated epsilon and noise parameters to preview. The preview allows you to see how the maximum number of each type of aggregation function would change with the new parameters.
    public enum PreviewPrivacyImpactParametersInput: Swift.Equatable {
        /// An array that specifies the epsilon and noise parameters.
        case differentialprivacy(CleanRoomsClientTypes.DifferentialPrivacyPreviewParametersInput)
        case sdkUnknown(Swift.String)
    }

}

extension CleanRoomsClientTypes.PrivacyBudget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case differentialprivacy = "differentialPrivacy"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .differentialprivacy(differentialprivacy):
                try container.encode(differentialprivacy, forKey: .differentialprivacy)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let differentialprivacyDecoded = try values.decodeIfPresent(CleanRoomsClientTypes.DifferentialPrivacyPrivacyBudget.self, forKey: .differentialprivacy)
        if let differentialprivacy = differentialprivacyDecoded {
            self = .differentialprivacy(differentialprivacy)
            return
        }
        self = .sdkUnknown("")
    }
}

extension CleanRoomsClientTypes {
    /// The epsilon parameter value and number of each aggregation function that you can perform.
    public enum PrivacyBudget: Swift.Equatable {
        /// An object that specifies the epsilon parameter and the utility in terms of total aggregations, as well as the remaining aggregations available.
        case differentialprivacy(CleanRoomsClientTypes.DifferentialPrivacyPrivacyBudget)
        case sdkUnknown(Swift.String)
    }

}

extension CleanRoomsClientTypes.PrivacyBudgetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budget
        case collaborationArn
        case collaborationId
        case createTime
        case id
        case membershipArn
        case membershipId
        case privacyBudgetTemplateArn
        case privacyBudgetTemplateId
        case type
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budget = self.budget {
            try encodeContainer.encode(budget, forKey: .budget)
        }
        if let collaborationArn = self.collaborationArn {
            try encodeContainer.encode(collaborationArn, forKey: .collaborationArn)
        }
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let membershipArn = self.membershipArn {
            try encodeContainer.encode(membershipArn, forKey: .membershipArn)
        }
        if let membershipId = self.membershipId {
            try encodeContainer.encode(membershipId, forKey: .membershipId)
        }
        if let privacyBudgetTemplateArn = self.privacyBudgetTemplateArn {
            try encodeContainer.encode(privacyBudgetTemplateArn, forKey: .privacyBudgetTemplateArn)
        }
        if let privacyBudgetTemplateId = self.privacyBudgetTemplateId {
            try encodeContainer.encode(privacyBudgetTemplateId, forKey: .privacyBudgetTemplateId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let privacyBudgetTemplateIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privacyBudgetTemplateId)
        privacyBudgetTemplateId = privacyBudgetTemplateIdDecoded
        let privacyBudgetTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privacyBudgetTemplateArn)
        privacyBudgetTemplateArn = privacyBudgetTemplateArnDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let membershipArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipArn)
        membershipArn = membershipArnDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let collaborationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationArn)
        collaborationArn = collaborationArnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyBudgetType.self, forKey: .type)
        type = typeDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let budgetDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyBudget.self, forKey: .budget)
        budget = budgetDecoded
    }
}

extension CleanRoomsClientTypes {
    /// An array that summaries the specified privacy budget. This summary includes collaboration information, creation information, membership information, and privacy budget information.
    public struct PrivacyBudgetSummary: Swift.Equatable {
        /// The provided privacy budget.
        /// This member is required.
        public var budget: CleanRoomsClientTypes.PrivacyBudget?
        /// The ARN of the collaboration that contains this privacy budget.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique identifier of the collaboration that contains this privacy budget.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time at which the privacy budget was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The unique identifier of the privacy budget.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the member who created the privacy budget summary.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The identifier for a membership resource.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The ARN of the privacy budget template.
        /// This member is required.
        public var privacyBudgetTemplateArn: Swift.String?
        /// The unique identifier of the privacy budget template.
        /// This member is required.
        public var privacyBudgetTemplateId: Swift.String?
        /// Specifies the type of the privacy budget.
        /// This member is required.
        public var type: CleanRoomsClientTypes.PrivacyBudgetType?
        /// The most recent time at which the privacy budget was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            budget: CleanRoomsClientTypes.PrivacyBudget? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            privacyBudgetTemplateArn: Swift.String? = nil,
            privacyBudgetTemplateId: Swift.String? = nil,
            type: CleanRoomsClientTypes.PrivacyBudgetType? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.budget = budget
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.privacyBudgetTemplateArn = privacyBudgetTemplateArn
            self.privacyBudgetTemplateId = privacyBudgetTemplateId
            self.type = type
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.PrivacyBudgetTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case autoRefresh
        case collaborationArn
        case collaborationId
        case createTime
        case id
        case membershipArn
        case membershipId
        case parameters
        case privacyBudgetType
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let autoRefresh = self.autoRefresh {
            try encodeContainer.encode(autoRefresh.rawValue, forKey: .autoRefresh)
        }
        if let collaborationArn = self.collaborationArn {
            try encodeContainer.encode(collaborationArn, forKey: .collaborationArn)
        }
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let membershipArn = self.membershipArn {
            try encodeContainer.encode(membershipArn, forKey: .membershipArn)
        }
        if let membershipId = self.membershipId {
            try encodeContainer.encode(membershipId, forKey: .membershipId)
        }
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let privacyBudgetType = self.privacyBudgetType {
            try encodeContainer.encode(privacyBudgetType.rawValue, forKey: .privacyBudgetType)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let membershipArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipArn)
        membershipArn = membershipArnDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let collaborationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationArn)
        collaborationArn = collaborationArnDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let privacyBudgetTypeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyBudgetType.self, forKey: .privacyBudgetType)
        privacyBudgetType = privacyBudgetTypeDecoded
        let autoRefreshDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyBudgetTemplateAutoRefresh.self, forKey: .autoRefresh)
        autoRefresh = autoRefreshDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyBudgetTemplateParametersOutput.self, forKey: .parameters)
        parameters = parametersDecoded
    }
}

extension CleanRoomsClientTypes {
    /// An object that defines the privacy budget template.
    public struct PrivacyBudgetTemplate: Swift.Equatable {
        /// The ARN of the privacy budget template.
        /// This member is required.
        public var arn: Swift.String?
        /// How often the privacy budget refreshes. If you plan to regularly bring new data into the collaboration, use CALENDAR_MONTH to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queried across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.
        /// This member is required.
        public var autoRefresh: CleanRoomsClientTypes.PrivacyBudgetTemplateAutoRefresh?
        /// The ARN of the collaboration that contains this privacy budget template.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique ID of the collaboration that contains this privacy budget template.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time at which the privacy budget template was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The unique identifier of the privacy budget template.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the member who created the privacy budget template.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The identifier for a membership resource.
        /// This member is required.
        public var membershipId: Swift.String?
        /// Specifies the epislon and noise parameters for the privacy budget template.
        /// This member is required.
        public var parameters: CleanRoomsClientTypes.PrivacyBudgetTemplateParametersOutput?
        /// Specifies the type of the privacy budget template.
        /// This member is required.
        public var privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType?
        /// The most recent time at which the privacy budget template was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            autoRefresh: CleanRoomsClientTypes.PrivacyBudgetTemplateAutoRefresh? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            parameters: CleanRoomsClientTypes.PrivacyBudgetTemplateParametersOutput? = nil,
            privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.autoRefresh = autoRefresh
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.parameters = parameters
            self.privacyBudgetType = privacyBudgetType
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes {
    public enum PrivacyBudgetTemplateAutoRefresh: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case calendarMonth
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [PrivacyBudgetTemplateAutoRefresh] {
            return [
                .calendarMonth,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .calendarMonth: return "CALENDAR_MONTH"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrivacyBudgetTemplateAutoRefresh(rawValue: rawValue) ?? PrivacyBudgetTemplateAutoRefresh.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes.PrivacyBudgetTemplateParametersInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case differentialprivacy = "differentialPrivacy"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .differentialprivacy(differentialprivacy):
                try container.encode(differentialprivacy, forKey: .differentialprivacy)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let differentialprivacyDecoded = try values.decodeIfPresent(CleanRoomsClientTypes.DifferentialPrivacyTemplateParametersInput.self, forKey: .differentialprivacy)
        if let differentialprivacy = differentialprivacyDecoded {
            self = .differentialprivacy(differentialprivacy)
            return
        }
        self = .sdkUnknown("")
    }
}

extension CleanRoomsClientTypes {
    /// The epsilon and noise parameters that you want to use for the privacy budget template.
    public enum PrivacyBudgetTemplateParametersInput: Swift.Equatable {
        /// An object that specifies the epsilon and noise parameters.
        case differentialprivacy(CleanRoomsClientTypes.DifferentialPrivacyTemplateParametersInput)
        case sdkUnknown(Swift.String)
    }

}

extension CleanRoomsClientTypes.PrivacyBudgetTemplateParametersOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case differentialprivacy = "differentialPrivacy"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .differentialprivacy(differentialprivacy):
                try container.encode(differentialprivacy, forKey: .differentialprivacy)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let differentialprivacyDecoded = try values.decodeIfPresent(CleanRoomsClientTypes.DifferentialPrivacyTemplateParametersOutput.self, forKey: .differentialprivacy)
        if let differentialprivacy = differentialprivacyDecoded {
            self = .differentialprivacy(differentialprivacy)
            return
        }
        self = .sdkUnknown("")
    }
}

extension CleanRoomsClientTypes {
    /// The epsilon and noise parameters that were used in the privacy budget template.
    public enum PrivacyBudgetTemplateParametersOutput: Swift.Equatable {
        /// The epsilon and noise parameters.
        case differentialprivacy(CleanRoomsClientTypes.DifferentialPrivacyTemplateParametersOutput)
        case sdkUnknown(Swift.String)
    }

}

extension CleanRoomsClientTypes.PrivacyBudgetTemplateSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case collaborationArn
        case collaborationId
        case createTime
        case id
        case membershipArn
        case membershipId
        case privacyBudgetType
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let collaborationArn = self.collaborationArn {
            try encodeContainer.encode(collaborationArn, forKey: .collaborationArn)
        }
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let membershipArn = self.membershipArn {
            try encodeContainer.encode(membershipArn, forKey: .membershipArn)
        }
        if let membershipId = self.membershipId {
            try encodeContainer.encode(membershipId, forKey: .membershipId)
        }
        if let privacyBudgetType = self.privacyBudgetType {
            try encodeContainer.encode(privacyBudgetType.rawValue, forKey: .privacyBudgetType)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let membershipArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipArn)
        membershipArn = membershipArnDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let collaborationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationArn)
        collaborationArn = collaborationArnDecoded
        let privacyBudgetTypeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyBudgetType.self, forKey: .privacyBudgetType)
        privacyBudgetType = privacyBudgetTypeDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
    }
}

extension CleanRoomsClientTypes {
    /// A summary of the privacy budget template. The summary includes membership information, collaboration information, and creation information.
    public struct PrivacyBudgetTemplateSummary: Swift.Equatable {
        /// The ARN of the privacy budget template.
        /// This member is required.
        public var arn: Swift.String?
        /// The ARN of the collaboration that contains this privacy budget template.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique ID of the collaboration that contains this privacy budget template.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time at which the privacy budget template was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The unique identifier of the privacy budget template.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the member who created the privacy budget template.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The identifier for a membership resource.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The type of the privacy budget template.
        /// This member is required.
        public var privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType?
        /// The most recent time at which the privacy budget template was updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.privacyBudgetType = privacyBudgetType
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.PrivacyBudgetTemplateUpdateParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case differentialprivacy = "differentialPrivacy"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .differentialprivacy(differentialprivacy):
                try container.encode(differentialprivacy, forKey: .differentialprivacy)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let differentialprivacyDecoded = try values.decodeIfPresent(CleanRoomsClientTypes.DifferentialPrivacyTemplateUpdateParameters.self, forKey: .differentialprivacy)
        if let differentialprivacy = differentialprivacyDecoded {
            self = .differentialprivacy(differentialprivacy)
            return
        }
        self = .sdkUnknown("")
    }
}

extension CleanRoomsClientTypes {
    /// The epsilon and noise parameters that you want to update in the privacy budget template.
    public enum PrivacyBudgetTemplateUpdateParameters: Swift.Equatable {
        /// An object that specifies the new values for the epsilon and noise parameters.
        case differentialprivacy(CleanRoomsClientTypes.DifferentialPrivacyTemplateUpdateParameters)
        case sdkUnknown(Swift.String)
    }

}

extension CleanRoomsClientTypes {
    public enum PrivacyBudgetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case differentialPrivacy
        case sdkUnknown(Swift.String)

        public static var allCases: [PrivacyBudgetType] {
            return [
                .differentialPrivacy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .differentialPrivacy: return "DIFFERENTIAL_PRIVACY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PrivacyBudgetType(rawValue: rawValue) ?? PrivacyBudgetType.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes.PrivacyImpact: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case differentialprivacy = "differentialPrivacy"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .differentialprivacy(differentialprivacy):
                try container.encode(differentialprivacy, forKey: .differentialprivacy)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let differentialprivacyDecoded = try values.decodeIfPresent(CleanRoomsClientTypes.DifferentialPrivacyPrivacyImpact.self, forKey: .differentialprivacy)
        if let differentialprivacy = differentialprivacyDecoded {
            self = .differentialprivacy(differentialprivacy)
            return
        }
        self = .sdkUnknown("")
    }
}

extension CleanRoomsClientTypes {
    /// Provides an estimate of the number of aggregation functions that the member who can query can run given the epsilon and noise parameters.
    public enum PrivacyImpact: Swift.Equatable {
        /// An object that lists the number and type of aggregation functions you can perform.
        case differentialprivacy(CleanRoomsClientTypes.DifferentialPrivacyPrivacyImpact)
        case sdkUnknown(Swift.String)
    }

}

extension CleanRoomsClientTypes.ProtectedQuery: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime
        case differentialPrivacy
        case error
        case id
        case membershipArn
        case membershipId
        case result
        case resultConfiguration
        case sqlParameters
        case statistics
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let differentialPrivacy = self.differentialPrivacy {
            try encodeContainer.encode(differentialPrivacy, forKey: .differentialPrivacy)
        }
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let membershipArn = self.membershipArn {
            try encodeContainer.encode(membershipArn, forKey: .membershipArn)
        }
        if let membershipId = self.membershipId {
            try encodeContainer.encode(membershipId, forKey: .membershipId)
        }
        if let result = self.result {
            try encodeContainer.encode(result, forKey: .result)
        }
        if let resultConfiguration = self.resultConfiguration {
            try encodeContainer.encode(resultConfiguration, forKey: .resultConfiguration)
        }
        if let sqlParameters = self.sqlParameters {
            try encodeContainer.encode(sqlParameters, forKey: .sqlParameters)
        }
        if let statistics = self.statistics {
            try encodeContainer.encode(statistics, forKey: .statistics)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let membershipArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipArn)
        membershipArn = membershipArnDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let sqlParametersDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ProtectedQuerySQLParameters.self, forKey: .sqlParameters)
        sqlParameters = sqlParametersDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ProtectedQueryStatus.self, forKey: .status)
        status = statusDecoded
        let resultConfigurationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ProtectedQueryResultConfiguration.self, forKey: .resultConfiguration)
        resultConfiguration = resultConfigurationDecoded
        let statisticsDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ProtectedQueryStatistics.self, forKey: .statistics)
        statistics = statisticsDecoded
        let resultDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ProtectedQueryResult.self, forKey: .result)
        result = resultDecoded
        let errorDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ProtectedQueryError.self, forKey: .error)
        error = errorDecoded
        let differentialPrivacyDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.DifferentialPrivacyParameters.self, forKey: .differentialPrivacy)
        differentialPrivacy = differentialPrivacyDecoded
    }
}

extension CleanRoomsClientTypes.ProtectedQuery: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProtectedQuery(createTime: \(Swift.String(describing: createTime)), differentialPrivacy: \(Swift.String(describing: differentialPrivacy)), error: \(Swift.String(describing: error)), id: \(Swift.String(describing: id)), membershipArn: \(Swift.String(describing: membershipArn)), membershipId: \(Swift.String(describing: membershipId)), result: \(Swift.String(describing: result)), resultConfiguration: \(Swift.String(describing: resultConfiguration)), statistics: \(Swift.String(describing: statistics)), status: \(Swift.String(describing: status)), sqlParameters: \"CONTENT_REDACTED\")"}
}

extension CleanRoomsClientTypes {
    /// The parameters for an Clean Rooms protected query.
    public struct ProtectedQuery: Swift.Equatable {
        /// The time at which the protected query was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The sensitivity parameters of the differential privacy results of the protected query.
        public var differentialPrivacy: CleanRoomsClientTypes.DifferentialPrivacyParameters?
        /// An error thrown by the protected query.
        public var error: CleanRoomsClientTypes.ProtectedQueryError?
        /// The identifier for a protected query instance.
        /// This member is required.
        public var id: Swift.String?
        /// The ARN of the membership.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The identifier for the membership.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The result of the protected query.
        public var result: CleanRoomsClientTypes.ProtectedQueryResult?
        /// Contains any details needed to write the query results.
        public var resultConfiguration: CleanRoomsClientTypes.ProtectedQueryResultConfiguration?
        /// The protected query SQL parameters.
        public var sqlParameters: CleanRoomsClientTypes.ProtectedQuerySQLParameters?
        /// Statistics about protected query execution.
        public var statistics: CleanRoomsClientTypes.ProtectedQueryStatistics?
        /// The status of the query.
        /// This member is required.
        public var status: CleanRoomsClientTypes.ProtectedQueryStatus?

        public init(
            createTime: ClientRuntime.Date? = nil,
            differentialPrivacy: CleanRoomsClientTypes.DifferentialPrivacyParameters? = nil,
            error: CleanRoomsClientTypes.ProtectedQueryError? = nil,
            id: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            result: CleanRoomsClientTypes.ProtectedQueryResult? = nil,
            resultConfiguration: CleanRoomsClientTypes.ProtectedQueryResultConfiguration? = nil,
            sqlParameters: CleanRoomsClientTypes.ProtectedQuerySQLParameters? = nil,
            statistics: CleanRoomsClientTypes.ProtectedQueryStatistics? = nil,
            status: CleanRoomsClientTypes.ProtectedQueryStatus? = nil
        )
        {
            self.createTime = createTime
            self.differentialPrivacy = differentialPrivacy
            self.error = error
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.result = result
            self.resultConfiguration = resultConfiguration
            self.sqlParameters = sqlParameters
            self.statistics = statistics
            self.status = status
        }
    }

}

extension CleanRoomsClientTypes.ProtectedQueryError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension CleanRoomsClientTypes {
    /// Details of errors thrown by the protected query.
    public struct ProtectedQueryError: Swift.Equatable {
        /// An error code for the error.
        /// This member is required.
        public var code: Swift.String?
        /// A description of why the query failed.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension CleanRoomsClientTypes.ProtectedQueryOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberlist = "memberList"
        case s3
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .memberlist(memberlist):
                var memberlistContainer = container.nestedUnkeyedContainer(forKey: .memberlist)
                for protectedquerysinglememberoutput0 in memberlist {
                    try memberlistContainer.encode(protectedquerysinglememberoutput0)
                }
            case let .s3(s3):
                try container.encode(s3, forKey: .s3)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try values.decodeIfPresent(CleanRoomsClientTypes.ProtectedQueryS3Output.self, forKey: .s3)
        if let s3 = s3Decoded {
            self = .s3(s3)
            return
        }
        let memberlistContainer = try values.decodeIfPresent([CleanRoomsClientTypes.ProtectedQuerySingleMemberOutput?].self, forKey: .memberlist)
        var memberlistDecoded0:[CleanRoomsClientTypes.ProtectedQuerySingleMemberOutput]? = nil
        if let memberlistContainer = memberlistContainer {
            memberlistDecoded0 = [CleanRoomsClientTypes.ProtectedQuerySingleMemberOutput]()
            for structure0 in memberlistContainer {
                if let structure0 = structure0 {
                    memberlistDecoded0?.append(structure0)
                }
            }
        }
        if let memberlist = memberlistDecoded0 {
            self = .memberlist(memberlist)
            return
        }
        self = .sdkUnknown("")
    }
}

extension CleanRoomsClientTypes {
    /// Contains details about the protected query output.
    public enum ProtectedQueryOutput: Swift.Equatable {
        /// If present, the output for a protected query with an `S3` output type.
        case s3(CleanRoomsClientTypes.ProtectedQueryS3Output)
        /// The list of member Amazon Web Services account(s) that received the results of the query.
        case memberlist([CleanRoomsClientTypes.ProtectedQuerySingleMemberOutput])
        case sdkUnknown(Swift.String)
    }

}

extension CleanRoomsClientTypes.ProtectedQueryOutputConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .s3(s3):
                try container.encode(s3, forKey: .s3)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let s3Decoded = try values.decodeIfPresent(CleanRoomsClientTypes.ProtectedQueryS3OutputConfiguration.self, forKey: .s3)
        if let s3 = s3Decoded {
            self = .s3(s3)
            return
        }
        self = .sdkUnknown("")
    }
}

extension CleanRoomsClientTypes {
    /// Contains configuration details for protected query output.
    public enum ProtectedQueryOutputConfiguration: Swift.Equatable {
        /// Required configuration for a protected query with an `S3` output type.
        case s3(CleanRoomsClientTypes.ProtectedQueryS3OutputConfiguration)
        case sdkUnknown(Swift.String)
    }

}

extension CleanRoomsClientTypes.ProtectedQueryResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case output
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let output = self.output {
            try encodeContainer.encode(output, forKey: .output)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ProtectedQueryOutput.self, forKey: .output)
        output = outputDecoded
    }
}

extension CleanRoomsClientTypes {
    /// Details about the query results.
    public struct ProtectedQueryResult: Swift.Equatable {
        /// The output of the protected query.
        /// This member is required.
        public var output: CleanRoomsClientTypes.ProtectedQueryOutput?

        public init(
            output: CleanRoomsClientTypes.ProtectedQueryOutput? = nil
        )
        {
            self.output = output
        }
    }

}

extension CleanRoomsClientTypes.ProtectedQueryResultConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case outputConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let outputConfiguration = self.outputConfiguration {
            try encodeContainer.encode(outputConfiguration, forKey: .outputConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputConfigurationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ProtectedQueryOutputConfiguration.self, forKey: .outputConfiguration)
        outputConfiguration = outputConfigurationDecoded
    }
}

extension CleanRoomsClientTypes {
    /// Contains configurations for protected query results.
    public struct ProtectedQueryResultConfiguration: Swift.Equatable {
        /// Configuration for protected query results.
        /// This member is required.
        public var outputConfiguration: CleanRoomsClientTypes.ProtectedQueryOutputConfiguration?

        public init(
            outputConfiguration: CleanRoomsClientTypes.ProtectedQueryOutputConfiguration? = nil
        )
        {
            self.outputConfiguration = outputConfiguration
        }
    }

}

extension CleanRoomsClientTypes.ProtectedQueryS3Output: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case location
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
    }
}

extension CleanRoomsClientTypes {
    /// Contains output information for protected queries with an S3 output type.
    public struct ProtectedQueryS3Output: Swift.Equatable {
        /// The S3 location of the result.
        /// This member is required.
        public var location: Swift.String?

        public init(
            location: Swift.String? = nil
        )
        {
            self.location = location
        }
    }

}

extension CleanRoomsClientTypes.ProtectedQueryS3OutputConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case keyPrefix
        case resultFormat
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let keyPrefix = self.keyPrefix {
            try encodeContainer.encode(keyPrefix, forKey: .keyPrefix)
        }
        if let resultFormat = self.resultFormat {
            try encodeContainer.encode(resultFormat.rawValue, forKey: .resultFormat)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultFormatDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ResultFormat.self, forKey: .resultFormat)
        resultFormat = resultFormatDecoded
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .keyPrefix)
        keyPrefix = keyPrefixDecoded
    }
}

extension CleanRoomsClientTypes {
    /// Contains the configuration to write the query results to S3.
    public struct ProtectedQueryS3OutputConfiguration: Swift.Equatable {
        /// The S3 bucket to unload the protected query results.
        /// This member is required.
        public var bucket: Swift.String?
        /// The S3 prefix to unload the protected query results.
        public var keyPrefix: Swift.String?
        /// Intended file format of the result.
        /// This member is required.
        public var resultFormat: CleanRoomsClientTypes.ResultFormat?

        public init(
            bucket: Swift.String? = nil,
            keyPrefix: Swift.String? = nil,
            resultFormat: CleanRoomsClientTypes.ResultFormat? = nil
        )
        {
            self.bucket = bucket
            self.keyPrefix = keyPrefix
            self.resultFormat = resultFormat
        }
    }

}

extension CleanRoomsClientTypes.ProtectedQuerySQLParameters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisTemplateArn
        case parameters
        case queryString
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisTemplateArn = self.analysisTemplateArn {
            try encodeContainer.encode(analysisTemplateArn, forKey: .analysisTemplateArn)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, parameterMap0) in parameters {
                try parametersContainer.encode(parameterMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let queryString = self.queryString {
            try encodeContainer.encode(queryString, forKey: .queryString)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .queryString)
        queryString = queryStringDecoded
        let analysisTemplateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .analysisTemplateArn)
        analysisTemplateArn = analysisTemplateArnDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:Swift.String]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:Swift.String]()
            for (key0, parametervalue0) in parametersContainer {
                if let parametervalue0 = parametervalue0 {
                    parametersDecoded0?[key0] = parametervalue0
                }
            }
        }
        parameters = parametersDecoded0
    }
}

extension CleanRoomsClientTypes.ProtectedQuerySQLParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CleanRoomsClientTypes {
    /// The parameters for the SQL type Protected Query.
    public struct ProtectedQuerySQLParameters: Swift.Equatable {
        /// The Amazon Resource Name (ARN) associated with the analysis template within a collaboration.
        public var analysisTemplateArn: Swift.String?
        /// The protected query SQL parameters.
        public var parameters: [Swift.String:Swift.String]?
        /// The query string to be submitted.
        public var queryString: Swift.String?

        public init(
            analysisTemplateArn: Swift.String? = nil,
            parameters: [Swift.String:Swift.String]? = nil,
            queryString: Swift.String? = nil
        )
        {
            self.analysisTemplateArn = analysisTemplateArn
            self.parameters = parameters
            self.queryString = queryString
        }
    }

}

extension CleanRoomsClientTypes.ProtectedQuerySingleMemberOutput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
    }
}

extension CleanRoomsClientTypes {
    /// Details about the member who received the query result.
    public struct ProtectedQuerySingleMemberOutput: Swift.Equatable {
        /// The Amazon Web Services account ID of the member in the collaboration who can receive results for the query.
        /// This member is required.
        public var accountId: Swift.String?

        public init(
            accountId: Swift.String? = nil
        )
        {
            self.accountId = accountId
        }
    }

}

extension CleanRoomsClientTypes.ProtectedQueryStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case totalDurationInMillis
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let totalDurationInMillis = self.totalDurationInMillis {
            try encodeContainer.encode(totalDurationInMillis, forKey: .totalDurationInMillis)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalDurationInMillisDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalDurationInMillis)
        totalDurationInMillis = totalDurationInMillisDecoded
    }
}

extension CleanRoomsClientTypes {
    /// Contains statistics about the execution of the protected query.
    public struct ProtectedQueryStatistics: Swift.Equatable {
        /// The duration of the Protected Query, from creation until query completion.
        public var totalDurationInMillis: Swift.Int?

        public init(
            totalDurationInMillis: Swift.Int? = nil
        )
        {
            self.totalDurationInMillis = totalDurationInMillis
        }
    }

}

extension CleanRoomsClientTypes {
    public enum ProtectedQueryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case cancelling
        case failed
        case started
        case submitted
        case success
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtectedQueryStatus] {
            return [
                .cancelled,
                .cancelling,
                .failed,
                .started,
                .submitted,
                .success,
                .timedOut,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .failed: return "FAILED"
            case .started: return "STARTED"
            case .submitted: return "SUBMITTED"
            case .success: return "SUCCESS"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProtectedQueryStatus(rawValue: rawValue) ?? ProtectedQueryStatus.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes.ProtectedQuerySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createTime
        case id
        case membershipArn
        case membershipId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let membershipArn = self.membershipArn {
            try encodeContainer.encode(membershipArn, forKey: .membershipArn)
        }
        if let membershipId = self.membershipId {
            try encodeContainer.encode(membershipId, forKey: .membershipId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let membershipIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipId)
        membershipId = membershipIdDecoded
        let membershipArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .membershipArn)
        membershipArn = membershipArnDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ProtectedQueryStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension CleanRoomsClientTypes {
    /// The protected query summary for the objects listed by the request.
    public struct ProtectedQuerySummary: Swift.Equatable {
        /// The time the protected query was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The unique ID of the protected query.
        /// This member is required.
        public var id: Swift.String?
        /// The unique ARN for the membership that initiated the protected query.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The unique ID for the membership that initiated the protected query.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The status of the protected query. Value values are `SUBMITTED`, `STARTED`, `CANCELLED`, `CANCELLING`, `FAILED`, `SUCCESS`, `TIMED_OUT`.
        /// This member is required.
        public var status: CleanRoomsClientTypes.ProtectedQueryStatus?

        public init(
            createTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            status: CleanRoomsClientTypes.ProtectedQueryStatus? = nil
        )
        {
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.status = status
        }
    }

}

extension CleanRoomsClientTypes {
    public enum ProtectedQueryType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sql
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtectedQueryType] {
            return [
                .sql,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sql: return "SQL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ProtectedQueryType(rawValue: rawValue) ?? ProtectedQueryType.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes.QueryComputePaymentConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isResponsible
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isResponsible = self.isResponsible {
            try encodeContainer.encode(isResponsible, forKey: .isResponsible)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let isResponsibleDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isResponsible)
        isResponsible = isResponsibleDecoded
    }
}

extension CleanRoomsClientTypes {
    /// An object representing the collaboration member's payment responsibilities set by the collaboration creator for query compute costs.
    public struct QueryComputePaymentConfig: Swift.Equatable {
        /// Indicates whether the collaboration creator has configured the collaboration member to pay for query compute costs (TRUE) or has not configured the collaboration member to pay for query compute costs (FALSE). Exactly one member can be configured to pay for query compute costs. An error is returned if the collaboration creator sets a TRUE value for more than one member in the collaboration. If the collaboration creator hasn't specified anyone as the member paying for query compute costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a FALSE value for the member who can query.
        /// This member is required.
        public var isResponsible: Swift.Bool?

        public init(
            isResponsible: Swift.Bool? = nil
        )
        {
            self.isResponsible = isResponsible
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request references a resource which does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The Id of the missing resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the missing resource.
        /// This member is required.
        public internal(set) var resourceType: CleanRoomsClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: CleanRoomsClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: CleanRoomsClientTypes.ResourceType?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CleanRoomsClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case collaboration
        case configuredTable
        case configuredTableAssociation
        case membership
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .collaboration,
                .configuredTable,
                .configuredTableAssociation,
                .membership,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .collaboration: return "COLLABORATION"
            case .configuredTable: return "CONFIGURED_TABLE"
            case .configuredTableAssociation: return "CONFIGURED_TABLE_ASSOCIATION"
            case .membership: return "MEMBERSHIP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes {
    public enum ResultFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case csv
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [ResultFormat] {
            return [
                .csv,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .parquet: return "PARQUET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResultFormat(rawValue: rawValue) ?? ResultFormat.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes {
    public enum ScalarFunctions: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case abs
        case cast
        case ceiling
        case coalesce
        case floor
        case ln
        case log
        case lower
        case round
        case rtrim
        case sqrt
        case trunc
        case upper
        case sdkUnknown(Swift.String)

        public static var allCases: [ScalarFunctions] {
            return [
                .abs,
                .cast,
                .ceiling,
                .coalesce,
                .floor,
                .ln,
                .log,
                .lower,
                .round,
                .rtrim,
                .sqrt,
                .trunc,
                .upper,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .abs: return "ABS"
            case .cast: return "CAST"
            case .ceiling: return "CEILING"
            case .coalesce: return "COALESCE"
            case .floor: return "FLOOR"
            case .ln: return "LN"
            case .log: return "LOG"
            case .lower: return "LOWER"
            case .round: return "ROUND"
            case .rtrim: return "RTRIM"
            case .sqrt: return "SQRT"
            case .trunc: return "TRUNC"
            case .upper: return "UPPER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScalarFunctions(rawValue: rawValue) ?? ScalarFunctions.sdkUnknown(rawValue)
        }
    }
}

extension CleanRoomsClientTypes.Schema: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisMethod
        case analysisRuleTypes
        case collaborationArn
        case collaborationId
        case columns
        case createTime
        case creatorAccountId
        case description
        case name
        case partitionKeys
        case type
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisMethod = self.analysisMethod {
            try encodeContainer.encode(analysisMethod.rawValue, forKey: .analysisMethod)
        }
        if let analysisRuleTypes = analysisRuleTypes {
            var analysisRuleTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .analysisRuleTypes)
            for analysisruletype0 in analysisRuleTypes {
                try analysisRuleTypesContainer.encode(analysisruletype0.rawValue)
            }
        }
        if let collaborationArn = self.collaborationArn {
            try encodeContainer.encode(collaborationArn, forKey: .collaborationArn)
        }
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for column0 in columns {
                try columnsContainer.encode(column0)
            }
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let creatorAccountId = self.creatorAccountId {
            try encodeContainer.encode(creatorAccountId, forKey: .creatorAccountId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let partitionKeys = partitionKeys {
            var partitionKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionKeys)
            for column0 in partitionKeys {
                try partitionKeysContainer.encode(column0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnsContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.Column?].self, forKey: .columns)
        var columnsDecoded0:[CleanRoomsClientTypes.Column]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [CleanRoomsClientTypes.Column]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
        let partitionKeysContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.Column?].self, forKey: .partitionKeys)
        var partitionKeysDecoded0:[CleanRoomsClientTypes.Column]? = nil
        if let partitionKeysContainer = partitionKeysContainer {
            partitionKeysDecoded0 = [CleanRoomsClientTypes.Column]()
            for structure0 in partitionKeysContainer {
                if let structure0 = structure0 {
                    partitionKeysDecoded0?.append(structure0)
                }
            }
        }
        partitionKeys = partitionKeysDecoded0
        let analysisRuleTypesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.AnalysisRuleType?].self, forKey: .analysisRuleTypes)
        var analysisRuleTypesDecoded0:[CleanRoomsClientTypes.AnalysisRuleType]? = nil
        if let analysisRuleTypesContainer = analysisRuleTypesContainer {
            analysisRuleTypesDecoded0 = [CleanRoomsClientTypes.AnalysisRuleType]()
            for enum0 in analysisRuleTypesContainer {
                if let enum0 = enum0 {
                    analysisRuleTypesDecoded0?.append(enum0)
                }
            }
        }
        analysisRuleTypes = analysisRuleTypesDecoded0
        let analysisMethodDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AnalysisMethod.self, forKey: .analysisMethod)
        analysisMethod = analysisMethodDecoded
        let creatorAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorAccountId)
        creatorAccountId = creatorAccountIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let collaborationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationArn)
        collaborationArn = collaborationArnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.SchemaType.self, forKey: .type)
        type = typeDecoded
    }
}

extension CleanRoomsClientTypes {
    /// A schema is a relation within a collaboration.
    public struct Schema: Swift.Equatable {
        /// The analysis method for the schema. The only valid value is currently DIRECT_QUERY.
        public var analysisMethod: CleanRoomsClientTypes.AnalysisMethod?
        /// The analysis rule types associated with the schema. Currently, only one entry is present.
        /// This member is required.
        public var analysisRuleTypes: [CleanRoomsClientTypes.AnalysisRuleType]?
        /// The unique ARN for the collaboration that the schema belongs to.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique ID for the collaboration that the schema belongs to.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The columns for the relation this schema represents.
        /// This member is required.
        public var columns: [CleanRoomsClientTypes.Column]?
        /// The time the schema was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The unique account ID for the Amazon Web Services account that owns the schema.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// A description for the schema.
        /// This member is required.
        public var description: Swift.String?
        /// A name for the schema. The schema relation is referred to by this name when queried by a protected query.
        /// This member is required.
        public var name: Swift.String?
        /// The partition keys for the dataset underlying this schema.
        /// This member is required.
        public var partitionKeys: [CleanRoomsClientTypes.Column]?
        /// The type of schema. The only valid value is currently `TABLE`.
        /// This member is required.
        public var type: CleanRoomsClientTypes.SchemaType?
        /// The time the schema was last updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            analysisMethod: CleanRoomsClientTypes.AnalysisMethod? = nil,
            analysisRuleTypes: [CleanRoomsClientTypes.AnalysisRuleType]? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            columns: [CleanRoomsClientTypes.Column]? = nil,
            createTime: ClientRuntime.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            partitionKeys: [CleanRoomsClientTypes.Column]? = nil,
            type: CleanRoomsClientTypes.SchemaType? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.analysisMethod = analysisMethod
            self.analysisRuleTypes = analysisRuleTypes
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.columns = columns
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.name = name
            self.partitionKeys = partitionKeys
            self.type = type
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes.SchemaSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisMethod
        case analysisRuleTypes
        case collaborationArn
        case collaborationId
        case createTime
        case creatorAccountId
        case name
        case type
        case updateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisMethod = self.analysisMethod {
            try encodeContainer.encode(analysisMethod.rawValue, forKey: .analysisMethod)
        }
        if let analysisRuleTypes = analysisRuleTypes {
            var analysisRuleTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .analysisRuleTypes)
            for analysisruletype0 in analysisRuleTypes {
                try analysisRuleTypesContainer.encode(analysisruletype0.rawValue)
            }
        }
        if let collaborationArn = self.collaborationArn {
            try encodeContainer.encode(collaborationArn, forKey: .collaborationArn)
        }
        if let collaborationId = self.collaborationId {
            try encodeContainer.encode(collaborationId, forKey: .collaborationId)
        }
        if let createTime = self.createTime {
            try encodeContainer.encodeTimestamp(createTime, format: .epochSeconds, forKey: .createTime)
        }
        if let creatorAccountId = self.creatorAccountId {
            try encodeContainer.encode(creatorAccountId, forKey: .creatorAccountId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updateTime = self.updateTime {
            try encodeContainer.encodeTimestamp(updateTime, format: .epochSeconds, forKey: .updateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.SchemaType.self, forKey: .type)
        type = typeDecoded
        let creatorAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creatorAccountId)
        creatorAccountId = creatorAccountIdDecoded
        let createTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createTime)
        createTime = createTimeDecoded
        let updateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updateTime)
        updateTime = updateTimeDecoded
        let collaborationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationId)
        collaborationId = collaborationIdDecoded
        let collaborationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collaborationArn)
        collaborationArn = collaborationArnDecoded
        let analysisRuleTypesContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.AnalysisRuleType?].self, forKey: .analysisRuleTypes)
        var analysisRuleTypesDecoded0:[CleanRoomsClientTypes.AnalysisRuleType]? = nil
        if let analysisRuleTypesContainer = analysisRuleTypesContainer {
            analysisRuleTypesDecoded0 = [CleanRoomsClientTypes.AnalysisRuleType]()
            for enum0 in analysisRuleTypesContainer {
                if let enum0 = enum0 {
                    analysisRuleTypesDecoded0?.append(enum0)
                }
            }
        }
        analysisRuleTypes = analysisRuleTypesDecoded0
        let analysisMethodDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AnalysisMethod.self, forKey: .analysisMethod)
        analysisMethod = analysisMethodDecoded
    }
}

extension CleanRoomsClientTypes {
    /// The schema summary for the objects listed by the request.
    public struct SchemaSummary: Swift.Equatable {
        /// The analysis method for the associated schema. The only valid value is currently `DIRECT_QUERY`.
        public var analysisMethod: CleanRoomsClientTypes.AnalysisMethod?
        /// The types of analysis rules that are associated with this schema object.
        /// This member is required.
        public var analysisRuleTypes: [CleanRoomsClientTypes.AnalysisRuleType]?
        /// The unique ARN for the collaboration that the schema belongs to.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique ID for the collaboration that the schema belongs to.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time the schema object was created.
        /// This member is required.
        public var createTime: ClientRuntime.Date?
        /// The unique account ID for the Amazon Web Services account that owns the schema.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// The name for the schema object.
        /// This member is required.
        public var name: Swift.String?
        /// The type of schema object. The only valid schema type is currently `TABLE`.
        /// This member is required.
        public var type: CleanRoomsClientTypes.SchemaType?
        /// The time the schema object was last updated.
        /// This member is required.
        public var updateTime: ClientRuntime.Date?

        public init(
            analysisMethod: CleanRoomsClientTypes.AnalysisMethod? = nil,
            analysisRuleTypes: [CleanRoomsClientTypes.AnalysisRuleType]? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: ClientRuntime.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            name: Swift.String? = nil,
            type: CleanRoomsClientTypes.SchemaType? = nil,
            updateTime: ClientRuntime.Date? = nil
        )
        {
            self.analysisMethod = analysisMethod
            self.analysisRuleTypes = analysisRuleTypes
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.name = name
            self.type = type
            self.updateTime = updateTime
        }
    }

}

extension CleanRoomsClientTypes {
    public enum SchemaType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case table
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaType] {
            return [
                .table,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .table: return "TABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SchemaType(rawValue: rawValue) ?? SchemaType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaName = output.quotaName
            self.properties.quotaValue = output.quotaValue
        } else {
            self.properties.message = nil
            self.properties.quotaName = nil
            self.properties.quotaValue = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request denied because service quota has been exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The name of the quota.
        /// This member is required.
        public internal(set) var quotaName: Swift.String? = nil
        /// The value of the quota.
        /// This member is required.
        public internal(set) var quotaValue: Swift.Double? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaName: Swift.String? = nil,
        quotaValue: Swift.Double? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaName = quotaName
        self.properties.quotaValue = quotaValue
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let quotaName: Swift.String?
    let quotaValue: Swift.Double?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaName
        case quotaValue
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let quotaNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaName)
        quotaName = quotaNameDecoded
        let quotaValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .quotaValue)
        quotaValue = quotaValueDecoded
    }
}

extension StartProtectedQueryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartProtectedQueryInput(membershipIdentifier: \(Swift.String(describing: membershipIdentifier)), resultConfiguration: \(Swift.String(describing: resultConfiguration)), type: \(Swift.String(describing: type)), sqlParameters: \"CONTENT_REDACTED\")"}
}

extension StartProtectedQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resultConfiguration
        case sqlParameters
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resultConfiguration = self.resultConfiguration {
            try encodeContainer.encode(resultConfiguration, forKey: .resultConfiguration)
        }
        if let sqlParameters = self.sqlParameters {
            try encodeContainer.encode(sqlParameters, forKey: .sqlParameters)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension StartProtectedQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/protectedQueries"
    }
}

public struct StartProtectedQueryInput: Swift.Equatable {
    /// A unique identifier for the membership to run this query against. Currently accepts a membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The details needed to write the query results.
    public var resultConfiguration: CleanRoomsClientTypes.ProtectedQueryResultConfiguration?
    /// The protected SQL query parameters.
    /// This member is required.
    public var sqlParameters: CleanRoomsClientTypes.ProtectedQuerySQLParameters?
    /// The type of the protected query to be started.
    /// This member is required.
    public var type: CleanRoomsClientTypes.ProtectedQueryType?

    public init(
        membershipIdentifier: Swift.String? = nil,
        resultConfiguration: CleanRoomsClientTypes.ProtectedQueryResultConfiguration? = nil,
        sqlParameters: CleanRoomsClientTypes.ProtectedQuerySQLParameters? = nil,
        type: CleanRoomsClientTypes.ProtectedQueryType? = nil
    )
    {
        self.membershipIdentifier = membershipIdentifier
        self.resultConfiguration = resultConfiguration
        self.sqlParameters = sqlParameters
        self.type = type
    }
}

struct StartProtectedQueryInputBody: Swift.Equatable {
    let type: CleanRoomsClientTypes.ProtectedQueryType?
    let sqlParameters: CleanRoomsClientTypes.ProtectedQuerySQLParameters?
    let resultConfiguration: CleanRoomsClientTypes.ProtectedQueryResultConfiguration?
}

extension StartProtectedQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resultConfiguration
        case sqlParameters
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ProtectedQueryType.self, forKey: .type)
        type = typeDecoded
        let sqlParametersDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ProtectedQuerySQLParameters.self, forKey: .sqlParameters)
        sqlParameters = sqlParametersDecoded
        let resultConfigurationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ProtectedQueryResultConfiguration.self, forKey: .resultConfiguration)
        resultConfiguration = resultConfigurationDecoded
    }
}

extension StartProtectedQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartProtectedQueryOutputBody = try responseDecoder.decode(responseBody: data)
            self.protectedQuery = output.protectedQuery
        } else {
            self.protectedQuery = nil
        }
    }
}

public struct StartProtectedQueryOutput: Swift.Equatable {
    /// The protected query.
    /// This member is required.
    public var protectedQuery: CleanRoomsClientTypes.ProtectedQuery?

    public init(
        protectedQuery: CleanRoomsClientTypes.ProtectedQuery? = nil
    )
    {
        self.protectedQuery = protectedQuery
    }
}

struct StartProtectedQueryOutputBody: Swift.Equatable {
    let protectedQuery: CleanRoomsClientTypes.ProtectedQuery?
}

extension StartProtectedQueryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectedQuery
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectedQueryDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ProtectedQuery.self, forKey: .protectedQuery)
        protectedQuery = protectedQueryDecoded
    }
}

enum StartProtectedQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CleanRoomsClientTypes.TableReference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case glue
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .glue(glue):
                try container.encode(glue, forKey: .glue)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let glueDecoded = try values.decodeIfPresent(CleanRoomsClientTypes.GlueTableReference.self, forKey: .glue)
        if let glue = glueDecoded {
            self = .glue(glue)
            return
        }
        self = .sdkUnknown("")
    }
}

extension CleanRoomsClientTypes {
    /// A pointer to the dataset that underlies this table. Currently, this can only be an Glue table.
    public enum TableReference: Swift.Equatable {
        /// If present, a reference to the Glue table referred to by this table reference.
        case glue(CleanRoomsClientTypes.GlueTableReference)
        case sdkUnknown(Swift.String)
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the resource you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map of objects specifying each key name and value.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CleanRoomsClientTypes {
    public enum TargetProtectedQueryStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetProtectedQueryStatus] {
            return [
                .cancelled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetProtectedQueryStatus(rawValue: rawValue) ?? TargetProtectedQueryStatus.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) associated with the resource you want to remove the tag from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of key names of tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAnalysisTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
    }
}

extension UpdateAnalysisTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        guard let analysisTemplateIdentifier = analysisTemplateIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/analysistemplates/\(analysisTemplateIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateAnalysisTemplateInput: Swift.Equatable {
    /// The identifier for the analysis template resource.
    /// This member is required.
    public var analysisTemplateIdentifier: Swift.String?
    /// A new description for the analysis template.
    public var description: Swift.String?
    /// The identifier for a membership resource.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        analysisTemplateIdentifier: Swift.String? = nil,
        description: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.analysisTemplateIdentifier = analysisTemplateIdentifier
        self.description = description
        self.membershipIdentifier = membershipIdentifier
    }
}

struct UpdateAnalysisTemplateInputBody: Swift.Equatable {
    let description: Swift.String?
}

extension UpdateAnalysisTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateAnalysisTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAnalysisTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.analysisTemplate = output.analysisTemplate
        } else {
            self.analysisTemplate = nil
        }
    }
}

public struct UpdateAnalysisTemplateOutput: Swift.Equatable {
    /// The analysis template.
    /// This member is required.
    public var analysisTemplate: CleanRoomsClientTypes.AnalysisTemplate?

    public init(
        analysisTemplate: CleanRoomsClientTypes.AnalysisTemplate? = nil
    )
    {
        self.analysisTemplate = analysisTemplate
    }
}

struct UpdateAnalysisTemplateOutputBody: Swift.Equatable {
    let analysisTemplate: CleanRoomsClientTypes.AnalysisTemplate?
}

extension UpdateAnalysisTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisTemplateDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.AnalysisTemplate.self, forKey: .analysisTemplate)
        analysisTemplate = analysisTemplateDecoded
    }
}

enum UpdateAnalysisTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateCollaborationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateCollaborationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let collaborationIdentifier = collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateCollaborationInput: Swift.Equatable {
    /// The identifier for the collaboration.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// A description of the collaboration.
    public var description: Swift.String?
    /// A human-readable identifier provided by the collaboration owner. Display names are not unique.
    public var name: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.description = description
        self.name = name
    }
}

struct UpdateCollaborationInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateCollaborationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateCollaborationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateCollaborationOutputBody = try responseDecoder.decode(responseBody: data)
            self.collaboration = output.collaboration
        } else {
            self.collaboration = nil
        }
    }
}

public struct UpdateCollaborationOutput: Swift.Equatable {
    /// The entire collaboration that has been updated.
    /// This member is required.
    public var collaboration: CleanRoomsClientTypes.Collaboration?

    public init(
        collaboration: CleanRoomsClientTypes.Collaboration? = nil
    )
    {
        self.collaboration = collaboration
    }
}

struct UpdateCollaborationOutputBody: Swift.Equatable {
    let collaboration: CleanRoomsClientTypes.Collaboration?
}

extension UpdateCollaborationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collaboration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collaborationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.Collaboration.self, forKey: .collaboration)
        collaboration = collaborationDecoded
    }
}

enum UpdateCollaborationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateConfiguredAudienceModelAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateConfiguredAudienceModelAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        guard let configuredAudienceModelAssociationIdentifier = configuredAudienceModelAssociationIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredaudiencemodelassociations/\(configuredAudienceModelAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateConfiguredAudienceModelAssociationInput: Swift.Equatable {
    /// A unique identifier for the configured audience model association that you want to update.
    /// This member is required.
    public var configuredAudienceModelAssociationIdentifier: Swift.String?
    /// A new description for the configured audience model association.
    public var description: Swift.String?
    /// A unique identifier of the membership that contains the configured audience model association that you want to update.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// A new name for the configured audience model association.
    public var name: Swift.String?

    public init(
        configuredAudienceModelAssociationIdentifier: Swift.String? = nil,
        description: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.configuredAudienceModelAssociationIdentifier = configuredAudienceModelAssociationIdentifier
        self.description = description
        self.membershipIdentifier = membershipIdentifier
        self.name = name
    }
}

struct UpdateConfiguredAudienceModelAssociationInputBody: Swift.Equatable {
    let description: Swift.String?
    let name: Swift.String?
}

extension UpdateConfiguredAudienceModelAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateConfiguredAudienceModelAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateConfiguredAudienceModelAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuredAudienceModelAssociation = output.configuredAudienceModelAssociation
        } else {
            self.configuredAudienceModelAssociation = nil
        }
    }
}

public struct UpdateConfiguredAudienceModelAssociationOutput: Swift.Equatable {
    /// Details about the configured audience model association that you updated.
    /// This member is required.
    public var configuredAudienceModelAssociation: CleanRoomsClientTypes.ConfiguredAudienceModelAssociation?

    public init(
        configuredAudienceModelAssociation: CleanRoomsClientTypes.ConfiguredAudienceModelAssociation? = nil
    )
    {
        self.configuredAudienceModelAssociation = configuredAudienceModelAssociation
    }
}

struct UpdateConfiguredAudienceModelAssociationOutputBody: Swift.Equatable {
    let configuredAudienceModelAssociation: CleanRoomsClientTypes.ConfiguredAudienceModelAssociation?
}

extension UpdateConfiguredAudienceModelAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredAudienceModelAssociation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredAudienceModelAssociationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ConfiguredAudienceModelAssociation.self, forKey: .configuredAudienceModelAssociation)
        configuredAudienceModelAssociation = configuredAudienceModelAssociationDecoded
    }
}

enum UpdateConfiguredAudienceModelAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateConfiguredTableAnalysisRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisRulePolicy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisRulePolicy = self.analysisRulePolicy {
            try encodeContainer.encode(analysisRulePolicy, forKey: .analysisRulePolicy)
        }
    }
}

extension UpdateConfiguredTableAnalysisRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configuredTableIdentifier = configuredTableIdentifier else {
            return nil
        }
        guard let analysisRuleType = analysisRuleType else {
            return nil
        }
        return "/configuredTables/\(configuredTableIdentifier.urlPercentEncoding())/analysisRule/\(analysisRuleType.rawValue.urlPercentEncoding())"
    }
}

public struct UpdateConfiguredTableAnalysisRuleInput: Swift.Equatable {
    /// The new analysis rule policy for the configured table analysis rule.
    /// This member is required.
    public var analysisRulePolicy: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy?
    /// The analysis rule type to be updated. Configured table analysis rules are uniquely identified by their configured table identifier and analysis rule type.
    /// This member is required.
    public var analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType?
    /// The unique identifier for the configured table that the analysis rule applies to. Currently accepts the configured table ID.
    /// This member is required.
    public var configuredTableIdentifier: Swift.String?

    public init(
        analysisRulePolicy: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy? = nil,
        analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType? = nil,
        configuredTableIdentifier: Swift.String? = nil
    )
    {
        self.analysisRulePolicy = analysisRulePolicy
        self.analysisRuleType = analysisRuleType
        self.configuredTableIdentifier = configuredTableIdentifier
    }
}

struct UpdateConfiguredTableAnalysisRuleInputBody: Swift.Equatable {
    let analysisRulePolicy: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy?
}

extension UpdateConfiguredTableAnalysisRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisRulePolicy
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisRulePolicyDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy.self, forKey: .analysisRulePolicy)
        analysisRulePolicy = analysisRulePolicyDecoded
    }
}

extension UpdateConfiguredTableAnalysisRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateConfiguredTableAnalysisRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.analysisRule = output.analysisRule
        } else {
            self.analysisRule = nil
        }
    }
}

public struct UpdateConfiguredTableAnalysisRuleOutput: Swift.Equatable {
    /// The entire updated analysis rule.
    /// This member is required.
    public var analysisRule: CleanRoomsClientTypes.ConfiguredTableAnalysisRule?

    public init(
        analysisRule: CleanRoomsClientTypes.ConfiguredTableAnalysisRule? = nil
    )
    {
        self.analysisRule = analysisRule
    }
}

struct UpdateConfiguredTableAnalysisRuleOutputBody: Swift.Equatable {
    let analysisRule: CleanRoomsClientTypes.ConfiguredTableAnalysisRule?
}

extension UpdateConfiguredTableAnalysisRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisRule
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisRuleDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ConfiguredTableAnalysisRule.self, forKey: .analysisRule)
        analysisRule = analysisRuleDecoded
    }
}

enum UpdateConfiguredTableAnalysisRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateConfiguredTableAssociationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdateConfiguredTableAssociationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        guard let configuredTableAssociationIdentifier = configuredTableAssociationIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredTableAssociations/\(configuredTableAssociationIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateConfiguredTableAssociationInput: Swift.Equatable {
    /// The unique identifier for the configured table association to update. Currently accepts the configured table association ID.
    /// This member is required.
    public var configuredTableAssociationIdentifier: Swift.String?
    /// A new description for the configured table association.
    public var description: Swift.String?
    /// The unique ID for the membership that the configured table association belongs to.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The service will assume this role to access catalog metadata and query the table.
    public var roleArn: Swift.String?

    public init(
        configuredTableAssociationIdentifier: Swift.String? = nil,
        description: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
        self.description = description
        self.membershipIdentifier = membershipIdentifier
        self.roleArn = roleArn
    }
}

struct UpdateConfiguredTableAssociationInputBody: Swift.Equatable {
    let description: Swift.String?
    let roleArn: Swift.String?
}

extension UpdateConfiguredTableAssociationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension UpdateConfiguredTableAssociationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateConfiguredTableAssociationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuredTableAssociation = output.configuredTableAssociation
        } else {
            self.configuredTableAssociation = nil
        }
    }
}

public struct UpdateConfiguredTableAssociationOutput: Swift.Equatable {
    /// The entire updated configured table association.
    /// This member is required.
    public var configuredTableAssociation: CleanRoomsClientTypes.ConfiguredTableAssociation?

    public init(
        configuredTableAssociation: CleanRoomsClientTypes.ConfiguredTableAssociation? = nil
    )
    {
        self.configuredTableAssociation = configuredTableAssociation
    }
}

struct UpdateConfiguredTableAssociationOutputBody: Swift.Equatable {
    let configuredTableAssociation: CleanRoomsClientTypes.ConfiguredTableAssociation?
}

extension UpdateConfiguredTableAssociationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredTableAssociation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredTableAssociationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ConfiguredTableAssociation.self, forKey: .configuredTableAssociation)
        configuredTableAssociation = configuredTableAssociationDecoded
    }
}

enum UpdateConfiguredTableAssociationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateConfiguredTableInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateConfiguredTableInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let configuredTableIdentifier = configuredTableIdentifier else {
            return nil
        }
        return "/configuredTables/\(configuredTableIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateConfiguredTableInput: Swift.Equatable {
    /// The identifier for the configured table to update. Currently accepts the configured table ID.
    /// This member is required.
    public var configuredTableIdentifier: Swift.String?
    /// A new description for the configured table.
    public var description: Swift.String?
    /// A new name for the configured table.
    public var name: Swift.String?

    public init(
        configuredTableIdentifier: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.configuredTableIdentifier = configuredTableIdentifier
        self.description = description
        self.name = name
    }
}

struct UpdateConfiguredTableInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
}

extension UpdateConfiguredTableInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension UpdateConfiguredTableOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateConfiguredTableOutputBody = try responseDecoder.decode(responseBody: data)
            self.configuredTable = output.configuredTable
        } else {
            self.configuredTable = nil
        }
    }
}

public struct UpdateConfiguredTableOutput: Swift.Equatable {
    /// The updated configured table.
    /// This member is required.
    public var configuredTable: CleanRoomsClientTypes.ConfiguredTable?

    public init(
        configuredTable: CleanRoomsClientTypes.ConfiguredTable? = nil
    )
    {
        self.configuredTable = configuredTable
    }
}

struct UpdateConfiguredTableOutputBody: Swift.Equatable {
    let configuredTable: CleanRoomsClientTypes.ConfiguredTable?
}

extension UpdateConfiguredTableOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuredTable
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let configuredTableDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ConfiguredTable.self, forKey: .configuredTable)
        configuredTable = configuredTableDecoded
    }
}

enum UpdateConfiguredTableOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMembershipInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultResultConfiguration
        case queryLogStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultResultConfiguration = self.defaultResultConfiguration {
            try encodeContainer.encode(defaultResultConfiguration, forKey: .defaultResultConfiguration)
        }
        if let queryLogStatus = self.queryLogStatus {
            try encodeContainer.encode(queryLogStatus.rawValue, forKey: .queryLogStatus)
        }
    }
}

extension UpdateMembershipInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateMembershipInput: Swift.Equatable {
    /// The default protected query result configuration as specified by the member who can receive results.
    public var defaultResultConfiguration: CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration?
    /// The unique identifier of the membership.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// An indicator as to whether query logging has been enabled or disabled for the membership.
    public var queryLogStatus: CleanRoomsClientTypes.MembershipQueryLogStatus?

    public init(
        defaultResultConfiguration: CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration? = nil,
        membershipIdentifier: Swift.String? = nil,
        queryLogStatus: CleanRoomsClientTypes.MembershipQueryLogStatus? = nil
    )
    {
        self.defaultResultConfiguration = defaultResultConfiguration
        self.membershipIdentifier = membershipIdentifier
        self.queryLogStatus = queryLogStatus
    }
}

struct UpdateMembershipInputBody: Swift.Equatable {
    let queryLogStatus: CleanRoomsClientTypes.MembershipQueryLogStatus?
    let defaultResultConfiguration: CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration?
}

extension UpdateMembershipInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultResultConfiguration
        case queryLogStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let queryLogStatusDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.MembershipQueryLogStatus.self, forKey: .queryLogStatus)
        queryLogStatus = queryLogStatusDecoded
        let defaultResultConfigurationDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration.self, forKey: .defaultResultConfiguration)
        defaultResultConfiguration = defaultResultConfigurationDecoded
    }
}

extension UpdateMembershipOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateMembershipOutputBody = try responseDecoder.decode(responseBody: data)
            self.membership = output.membership
        } else {
            self.membership = nil
        }
    }
}

public struct UpdateMembershipOutput: Swift.Equatable {
    /// The membership object.
    /// This member is required.
    public var membership: CleanRoomsClientTypes.Membership?

    public init(
        membership: CleanRoomsClientTypes.Membership? = nil
    )
    {
        self.membership = membership
    }
}

struct UpdateMembershipOutputBody: Swift.Equatable {
    let membership: CleanRoomsClientTypes.Membership?
}

extension UpdateMembershipOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case membership
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membershipDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.Membership.self, forKey: .membership)
        membership = membershipDecoded
    }
}

enum UpdateMembershipOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePrivacyBudgetTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameters
        case privacyBudgetType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let privacyBudgetType = self.privacyBudgetType {
            try encodeContainer.encode(privacyBudgetType.rawValue, forKey: .privacyBudgetType)
        }
    }
}

extension UpdatePrivacyBudgetTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        guard let privacyBudgetTemplateIdentifier = privacyBudgetTemplateIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/privacybudgettemplates/\(privacyBudgetTemplateIdentifier.urlPercentEncoding())"
    }
}

public struct UpdatePrivacyBudgetTemplateInput: Swift.Equatable {
    /// A unique identifier for one of your memberships for a collaboration. The privacy budget template is updated in the collaboration that this membership belongs to. Accepts a membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// Specifies the epsilon and noise parameters for the privacy budget template.
    public var parameters: CleanRoomsClientTypes.PrivacyBudgetTemplateUpdateParameters?
    /// A unique identifier for your privacy budget template that you want to update.
    /// This member is required.
    public var privacyBudgetTemplateIdentifier: Swift.String?
    /// Specifies the type of the privacy budget template.
    /// This member is required.
    public var privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType?

    public init(
        membershipIdentifier: Swift.String? = nil,
        parameters: CleanRoomsClientTypes.PrivacyBudgetTemplateUpdateParameters? = nil,
        privacyBudgetTemplateIdentifier: Swift.String? = nil,
        privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType? = nil
    )
    {
        self.membershipIdentifier = membershipIdentifier
        self.parameters = parameters
        self.privacyBudgetTemplateIdentifier = privacyBudgetTemplateIdentifier
        self.privacyBudgetType = privacyBudgetType
    }
}

struct UpdatePrivacyBudgetTemplateInputBody: Swift.Equatable {
    let privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType?
    let parameters: CleanRoomsClientTypes.PrivacyBudgetTemplateUpdateParameters?
}

extension UpdatePrivacyBudgetTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameters
        case privacyBudgetType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privacyBudgetTypeDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyBudgetType.self, forKey: .privacyBudgetType)
        privacyBudgetType = privacyBudgetTypeDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyBudgetTemplateUpdateParameters.self, forKey: .parameters)
        parameters = parametersDecoded
    }
}

extension UpdatePrivacyBudgetTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePrivacyBudgetTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.privacyBudgetTemplate = output.privacyBudgetTemplate
        } else {
            self.privacyBudgetTemplate = nil
        }
    }
}

public struct UpdatePrivacyBudgetTemplateOutput: Swift.Equatable {
    /// Summary of the privacy budget template.
    /// This member is required.
    public var privacyBudgetTemplate: CleanRoomsClientTypes.PrivacyBudgetTemplate?

    public init(
        privacyBudgetTemplate: CleanRoomsClientTypes.PrivacyBudgetTemplate? = nil
    )
    {
        self.privacyBudgetTemplate = privacyBudgetTemplate
    }
}

struct UpdatePrivacyBudgetTemplateOutputBody: Swift.Equatable {
    let privacyBudgetTemplate: CleanRoomsClientTypes.PrivacyBudgetTemplate?
}

extension UpdatePrivacyBudgetTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case privacyBudgetTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privacyBudgetTemplateDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.PrivacyBudgetTemplate.self, forKey: .privacyBudgetTemplate)
        privacyBudgetTemplate = privacyBudgetTemplateDecoded
    }
}

enum UpdatePrivacyBudgetTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProtectedQueryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetStatus = self.targetStatus {
            try encodeContainer.encode(targetStatus.rawValue, forKey: .targetStatus)
        }
    }
}

extension UpdateProtectedQueryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let membershipIdentifier = membershipIdentifier else {
            return nil
        }
        guard let protectedQueryIdentifier = protectedQueryIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/protectedQueries/\(protectedQueryIdentifier.urlPercentEncoding())"
    }
}

public struct UpdateProtectedQueryInput: Swift.Equatable {
    /// The identifier for a member of a protected query instance.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The identifier for a protected query instance.
    /// This member is required.
    public var protectedQueryIdentifier: Swift.String?
    /// The target status of a query. Used to update the execution status of a currently running query.
    /// This member is required.
    public var targetStatus: CleanRoomsClientTypes.TargetProtectedQueryStatus?

    public init(
        membershipIdentifier: Swift.String? = nil,
        protectedQueryIdentifier: Swift.String? = nil,
        targetStatus: CleanRoomsClientTypes.TargetProtectedQueryStatus? = nil
    )
    {
        self.membershipIdentifier = membershipIdentifier
        self.protectedQueryIdentifier = protectedQueryIdentifier
        self.targetStatus = targetStatus
    }
}

struct UpdateProtectedQueryInputBody: Swift.Equatable {
    let targetStatus: CleanRoomsClientTypes.TargetProtectedQueryStatus?
}

extension UpdateProtectedQueryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetStatusDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.TargetProtectedQueryStatus.self, forKey: .targetStatus)
        targetStatus = targetStatusDecoded
    }
}

extension UpdateProtectedQueryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateProtectedQueryOutputBody = try responseDecoder.decode(responseBody: data)
            self.protectedQuery = output.protectedQuery
        } else {
            self.protectedQuery = nil
        }
    }
}

public struct UpdateProtectedQueryOutput: Swift.Equatable {
    /// The protected query output.
    /// This member is required.
    public var protectedQuery: CleanRoomsClientTypes.ProtectedQuery?

    public init(
        protectedQuery: CleanRoomsClientTypes.ProtectedQuery? = nil
    )
    {
        self.protectedQuery = protectedQuery
    }
}

struct UpdateProtectedQueryOutputBody: Swift.Equatable {
    let protectedQuery: CleanRoomsClientTypes.ProtectedQuery?
}

extension UpdateProtectedQueryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case protectedQuery
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let protectedQueryDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ProtectedQuery.self, forKey: .protectedQuery)
        protectedQuery = protectedQueryDecoded
    }
}

enum UpdateProtectedQueryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the specified constraints.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Validation errors for specific input parameters.
        public internal(set) var fieldList: [CleanRoomsClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// A reason code for the exception.
        public internal(set) var reason: CleanRoomsClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [CleanRoomsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: CleanRoomsClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: CleanRoomsClientTypes.ValidationExceptionReason?
    let fieldList: [CleanRoomsClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(CleanRoomsClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([CleanRoomsClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[CleanRoomsClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [CleanRoomsClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension CleanRoomsClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CleanRoomsClientTypes {
    /// Describes validation errors for specific input parameters.
    public struct ValidationExceptionField: Swift.Equatable {
        /// A message for the input validation error.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the input parameter.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension CleanRoomsClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fieldValidationFailed
        case iamSynchronizationDelay
        case invalidConfiguration
        case invalidQuery
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .fieldValidationFailed,
                .iamSynchronizationDelay,
                .invalidConfiguration,
                .invalidQuery,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .iamSynchronizationDelay: return "IAM_SYNCHRONIZATION_DELAY"
            case .invalidConfiguration: return "INVALID_CONFIGURATION"
            case .invalidQuery: return "INVALID_QUERY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
