//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.Document
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

extension CleanRoomsClientTypes {

    public enum AccessDeniedExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case insufficientPermissions
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessDeniedExceptionReason] {
            return [
                .insufficientPermissions
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .insufficientPermissions: return "INSUFFICIENT_PERMISSIONS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Caller does not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// A reason code for the exception.
        public internal(set) var reason: CleanRoomsClientTypes.AccessDeniedExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: CleanRoomsClientTypes.AccessDeniedExceptionReason? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension CleanRoomsClientTypes {

    public enum AdditionalAnalyses: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allowed
        case notAllowed
        case `required`
        case sdkUnknown(Swift.String)

        public static var allCases: [AdditionalAnalyses] {
            return [
                .allowed,
                .notAllowed,
                .required
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allowed: return "ALLOWED"
            case .notAllowed: return "NOT_ALLOWED"
            case .required: return "REQUIRED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    public enum AggregateFunctionName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case avg
        case count
        case countDistinct
        case sum
        case sumDistinct
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregateFunctionName] {
            return [
                .avg,
                .count,
                .countDistinct,
                .sum,
                .sumDistinct
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .avg: return "AVG"
            case .count: return "COUNT"
            case .countDistinct: return "COUNT_DISTINCT"
            case .sum: return "SUM"
            case .sumDistinct: return "SUM_DISTINCT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// Column in configured table that can be used in aggregate function in query.
    public struct AggregateColumn: Swift.Sendable {
        /// Column names in configured table of aggregate columns.
        /// This member is required.
        public var columnNames: [Swift.String]?
        /// Aggregation function that can be applied to aggregate column in query.
        /// This member is required.
        public var function: CleanRoomsClientTypes.AggregateFunctionName?

        public init(
            columnNames: [Swift.String]? = nil,
            function: CleanRoomsClientTypes.AggregateFunctionName? = nil
        )
        {
            self.columnNames = columnNames
            self.function = function
        }
    }
}

extension CleanRoomsClientTypes {

    public enum AggregationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case countDistinct
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregationType] {
            return [
                .countDistinct
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .countDistinct: return "COUNT_DISTINCT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// Constraint on query output removing output rows that do not meet a minimum number of distinct values of a specified column.
    public struct AggregationConstraint: Swift.Sendable {
        /// Column in aggregation constraint for which there must be a minimum number of distinct values in an output row for it to be in the query output.
        /// This member is required.
        public var columnName: Swift.String?
        /// The minimum number of distinct values that an output row must be an aggregation of. Minimum threshold of distinct values for a specified column that must exist in an output row for it to be in the query output.
        /// This member is required.
        public var minimum: Swift.Int?
        /// The type of aggregation the constraint allows. The only valid value is currently `COUNT_DISTINCT`.
        /// This member is required.
        public var type: CleanRoomsClientTypes.AggregationType?

        public init(
            columnName: Swift.String? = nil,
            minimum: Swift.Int? = nil,
            type: CleanRoomsClientTypes.AggregationType? = nil
        )
        {
            self.columnName = columnName
            self.minimum = minimum
            self.type = type
        }
    }
}

extension CleanRoomsClientTypes {

    public enum AnalysisFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sql
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisFormat] {
            return [
                .sql
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sql: return "SQL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    public enum AnalysisMethod: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case directQuery
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisMethod] {
            return [
                .directQuery
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .directQuery: return "DIRECT_QUERY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    public enum ParameterType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bigint
        case binary
        case boolean
        case byte
        case char
        case character
        case date
        case decimal
        case double
        case doublePrecision
        case float
        case int
        case integer
        case long
        case numeric
        case real
        case short
        case smallint
        case string
        case time
        case timestamp
        case timestamptz
        case timestampLtz
        case timestampNtz
        case timetz
        case tinyint
        case varbyte
        case varchar
        case sdkUnknown(Swift.String)

        public static var allCases: [ParameterType] {
            return [
                .bigint,
                .binary,
                .boolean,
                .byte,
                .char,
                .character,
                .date,
                .decimal,
                .double,
                .doublePrecision,
                .float,
                .int,
                .integer,
                .long,
                .numeric,
                .real,
                .short,
                .smallint,
                .string,
                .time,
                .timestamp,
                .timestamptz,
                .timestampLtz,
                .timestampNtz,
                .timetz,
                .tinyint,
                .varbyte,
                .varchar
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bigint: return "BIGINT"
            case .binary: return "BINARY"
            case .boolean: return "BOOLEAN"
            case .byte: return "BYTE"
            case .char: return "CHAR"
            case .character: return "CHARACTER"
            case .date: return "DATE"
            case .decimal: return "DECIMAL"
            case .double: return "DOUBLE"
            case .doublePrecision: return "DOUBLE_PRECISION"
            case .float: return "FLOAT"
            case .int: return "INT"
            case .integer: return "INTEGER"
            case .long: return "LONG"
            case .numeric: return "NUMERIC"
            case .real: return "REAL"
            case .short: return "SHORT"
            case .smallint: return "SMALLINT"
            case .string: return "STRING"
            case .time: return "TIME"
            case .timestamp: return "TIMESTAMP"
            case .timestamptz: return "TIMESTAMPTZ"
            case .timestampLtz: return "TIMESTAMP_LTZ"
            case .timestampNtz: return "TIMESTAMP_NTZ"
            case .timetz: return "TIMETZ"
            case .tinyint: return "TINYINT"
            case .varbyte: return "VARBYTE"
            case .varchar: return "VARCHAR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// Optional. The member who can query can provide this placeholder for a literal data value in an analysis template.
    public struct AnalysisParameter: Swift.Sendable {
        /// Optional. The default value that is applied in the analysis template. The member who can query can override this value in the query editor.
        public var defaultValue: Swift.String?
        /// The name of the parameter. The name must use only alphanumeric, underscore (_), or hyphen (-) characters but cannot start or end with a hyphen.
        /// This member is required.
        public var name: Swift.String?
        /// The type of parameter.
        /// This member is required.
        public var type: CleanRoomsClientTypes.ParameterType?

        public init(
            defaultValue: Swift.String? = nil,
            name: Swift.String? = nil,
            type: CleanRoomsClientTypes.ParameterType? = nil
        )
        {
            self.defaultValue = defaultValue
            self.name = name
            self.type = type
        }
    }
}

extension CleanRoomsClientTypes.AnalysisParameter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CleanRoomsClientTypes {

    public enum JoinOperator: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case and
        case or
        case sdkUnknown(Swift.String)

        public static var allCases: [JoinOperator] {
            return [
                .and,
                .or
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .and: return "AND"
            case .or: return "OR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    public enum JoinRequiredOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case queryRunner
        case sdkUnknown(Swift.String)

        public static var allCases: [JoinRequiredOption] {
            return [
                .queryRunner
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .queryRunner: return "QUERY_RUNNER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    public enum ScalarFunctions: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case abs
        case cast
        case ceiling
        case coalesce
        case convert
        case currentDate
        case dateadd
        case extract
        case floor
        case getdate
        case ln
        case log
        case lower
        case round
        case rtrim
        case sqrt
        case substring
        case toChar
        case toDate
        case toNumber
        case toTimestamp
        case trim
        case trunc
        case upper
        case sdkUnknown(Swift.String)

        public static var allCases: [ScalarFunctions] {
            return [
                .abs,
                .cast,
                .ceiling,
                .coalesce,
                .convert,
                .currentDate,
                .dateadd,
                .extract,
                .floor,
                .getdate,
                .ln,
                .log,
                .lower,
                .round,
                .rtrim,
                .sqrt,
                .substring,
                .toChar,
                .toDate,
                .toNumber,
                .toTimestamp,
                .trim,
                .trunc,
                .upper
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .abs: return "ABS"
            case .cast: return "CAST"
            case .ceiling: return "CEILING"
            case .coalesce: return "COALESCE"
            case .convert: return "CONVERT"
            case .currentDate: return "CURRENT_DATE"
            case .dateadd: return "DATEADD"
            case .extract: return "EXTRACT"
            case .floor: return "FLOOR"
            case .getdate: return "GETDATE"
            case .ln: return "LN"
            case .log: return "LOG"
            case .lower: return "LOWER"
            case .round: return "ROUND"
            case .rtrim: return "RTRIM"
            case .sqrt: return "SQRT"
            case .substring: return "SUBSTRING"
            case .toChar: return "TO_CHAR"
            case .toDate: return "TO_DATE"
            case .toNumber: return "TO_NUMBER"
            case .toTimestamp: return "TO_TIMESTAMP"
            case .trim: return "TRIM"
            case .trunc: return "TRUNC"
            case .upper: return "UPPER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// A type of analysis rule that enables query structure and specified queries that produce aggregate statistics.
    public struct AnalysisRuleAggregation: Swift.Sendable {
        /// An indicator as to whether additional analyses (such as Clean Rooms ML) can be applied to the output of the direct query. The additionalAnalyses parameter is currently supported for the list analysis rule (AnalysisRuleList) and the custom analysis rule (AnalysisRuleCustom).
        public var additionalAnalyses: CleanRoomsClientTypes.AdditionalAnalyses?
        /// The columns that query runners are allowed to use in aggregation queries.
        /// This member is required.
        public var aggregateColumns: [CleanRoomsClientTypes.AggregateColumn]?
        /// Which logical operators (if any) are to be used in an INNER JOIN match condition. Default is AND.
        public var allowedJoinOperators: [CleanRoomsClientTypes.JoinOperator]?
        /// The columns that query runners are allowed to select, group by, or filter by.
        /// This member is required.
        public var dimensionColumns: [Swift.String]?
        /// Columns in configured table that can be used in join statements and/or as aggregate columns. They can never be outputted directly.
        /// This member is required.
        public var joinColumns: [Swift.String]?
        /// Control that requires member who runs query to do a join with their configured table and/or other configured table in query.
        public var joinRequired: CleanRoomsClientTypes.JoinRequiredOption?
        /// Columns that must meet a specific threshold value (after an aggregation function is applied to it) for each output row to be returned.
        /// This member is required.
        public var outputConstraints: [CleanRoomsClientTypes.AggregationConstraint]?
        /// Set of scalar functions that are allowed to be used on dimension columns and the output of aggregation of metrics.
        /// This member is required.
        public var scalarFunctions: [CleanRoomsClientTypes.ScalarFunctions]?

        public init(
            additionalAnalyses: CleanRoomsClientTypes.AdditionalAnalyses? = nil,
            aggregateColumns: [CleanRoomsClientTypes.AggregateColumn]? = nil,
            allowedJoinOperators: [CleanRoomsClientTypes.JoinOperator]? = nil,
            dimensionColumns: [Swift.String]? = nil,
            joinColumns: [Swift.String]? = nil,
            joinRequired: CleanRoomsClientTypes.JoinRequiredOption? = nil,
            outputConstraints: [CleanRoomsClientTypes.AggregationConstraint]? = nil,
            scalarFunctions: [CleanRoomsClientTypes.ScalarFunctions]? = nil
        )
        {
            self.additionalAnalyses = additionalAnalyses
            self.aggregateColumns = aggregateColumns
            self.allowedJoinOperators = allowedJoinOperators
            self.dimensionColumns = dimensionColumns
            self.joinColumns = joinColumns
            self.joinRequired = joinRequired
            self.outputConstraints = outputConstraints
            self.scalarFunctions = scalarFunctions
        }
    }
}

extension CleanRoomsClientTypes {

    /// Specifies the name of the column that contains the unique identifier of your users, whose privacy you want to protect.
    public struct DifferentialPrivacyColumn: Swift.Sendable {
        /// The name of the column, such as user_id, that contains the unique identifier of your users, whose privacy you want to protect. If you want to turn on differential privacy for two or more tables in a collaboration, you must configure the same column as the user identifier column in both analysis rules.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        )
        {
            self.name = name
        }
    }
}

extension CleanRoomsClientTypes {

    /// Specifies the unique identifier for your users.
    public struct DifferentialPrivacyConfiguration: Swift.Sendable {
        /// The name of the column (such as user_id) that contains the unique identifier of your users whose privacy you want to protect. If you want to turn on diﬀerential privacy for two or more tables in a collaboration, you must conﬁgure the same column as the user identiﬁer column in both analysis rules.
        /// This member is required.
        public var columns: [CleanRoomsClientTypes.DifferentialPrivacyColumn]?

        public init(
            columns: [CleanRoomsClientTypes.DifferentialPrivacyColumn]? = nil
        )
        {
            self.columns = columns
        }
    }
}

extension CleanRoomsClientTypes {

    /// A type of analysis rule that enables the table owner to approve custom SQL queries on their configured tables. It supports differential privacy.
    public struct AnalysisRuleCustom: Swift.Sendable {
        /// An indicator as to whether additional analyses (such as Clean Rooms ML) can be applied to the output of the direct query.
        public var additionalAnalyses: CleanRoomsClientTypes.AdditionalAnalyses?
        /// The ARN of the analysis templates that are allowed by the custom analysis rule.
        /// This member is required.
        public var allowedAnalyses: [Swift.String]?
        /// The IDs of the Amazon Web Services accounts that are allowed to query by the custom analysis rule. Required when allowedAnalyses is ANY_QUERY.
        public var allowedAnalysisProviders: [Swift.String]?
        /// The differential privacy configuration.
        public var differentialPrivacy: CleanRoomsClientTypes.DifferentialPrivacyConfiguration?
        /// A list of columns that aren't allowed to be shown in the query output.
        public var disallowedOutputColumns: [Swift.String]?

        public init(
            additionalAnalyses: CleanRoomsClientTypes.AdditionalAnalyses? = nil,
            allowedAnalyses: [Swift.String]? = nil,
            allowedAnalysisProviders: [Swift.String]? = nil,
            differentialPrivacy: CleanRoomsClientTypes.DifferentialPrivacyConfiguration? = nil,
            disallowedOutputColumns: [Swift.String]? = nil
        )
        {
            self.additionalAnalyses = additionalAnalyses
            self.allowedAnalyses = allowedAnalyses
            self.allowedAnalysisProviders = allowedAnalysisProviders
            self.differentialPrivacy = differentialPrivacy
            self.disallowedOutputColumns = disallowedOutputColumns
        }
    }
}

extension CleanRoomsClientTypes {

    /// Provides the name of the columns that are required to overlap.
    public struct QueryConstraintRequireOverlap: Swift.Sendable {
        /// The columns that are required to overlap.
        public var columns: [Swift.String]?

        public init(
            columns: [Swift.String]? = nil
        )
        {
            self.columns = columns
        }
    }
}

extension CleanRoomsClientTypes {

    /// Provides any necessary query constraint information.
    public enum QueryConstraint: Swift.Sendable {
        /// An array of column names that specifies which columns are required in the JOIN statement.
        case requireoverlap(CleanRoomsClientTypes.QueryConstraintRequireOverlap)
        case sdkUnknown(Swift.String)
    }
}

extension CleanRoomsClientTypes {

    /// Defines details for the analysis rule ID mapping table.
    public struct AnalysisRuleIdMappingTable: Swift.Sendable {
        /// The columns that query runners are allowed to select, group by, or filter by.
        public var dimensionColumns: [Swift.String]?
        /// The columns that query runners are allowed to use in an INNER JOIN statement.
        /// This member is required.
        public var joinColumns: [Swift.String]?
        /// The query constraints of the analysis rule ID mapping table.
        /// This member is required.
        public var queryConstraints: [CleanRoomsClientTypes.QueryConstraint]?

        public init(
            dimensionColumns: [Swift.String]? = nil,
            joinColumns: [Swift.String]? = nil,
            queryConstraints: [CleanRoomsClientTypes.QueryConstraint]? = nil
        )
        {
            self.dimensionColumns = dimensionColumns
            self.joinColumns = joinColumns
            self.queryConstraints = queryConstraints
        }
    }
}

extension CleanRoomsClientTypes {

    /// A type of analysis rule that enables row-level analysis.
    public struct AnalysisRuleList: Swift.Sendable {
        /// An indicator as to whether additional analyses (such as Clean Rooms ML) can be applied to the output of the direct query.
        public var additionalAnalyses: CleanRoomsClientTypes.AdditionalAnalyses?
        /// The logical operators (if any) that are to be used in an INNER JOIN match condition. Default is AND.
        public var allowedJoinOperators: [CleanRoomsClientTypes.JoinOperator]?
        /// Columns that can be used to join a configured table with the table of the member who can query and other members' configured tables.
        /// This member is required.
        public var joinColumns: [Swift.String]?
        /// Columns that can be listed in the output.
        /// This member is required.
        public var listColumns: [Swift.String]?

        public init(
            additionalAnalyses: CleanRoomsClientTypes.AdditionalAnalyses? = nil,
            allowedJoinOperators: [CleanRoomsClientTypes.JoinOperator]? = nil,
            joinColumns: [Swift.String]? = nil,
            listColumns: [Swift.String]? = nil
        )
        {
            self.additionalAnalyses = additionalAnalyses
            self.allowedJoinOperators = allowedJoinOperators
            self.joinColumns = joinColumns
            self.listColumns = listColumns
        }
    }
}

extension CleanRoomsClientTypes {

    /// Controls on the query specifications that can be run on configured table.
    public enum AnalysisRulePolicyV1: Swift.Sendable {
        /// Analysis rule type that enables only list queries on a configured table.
        case list(CleanRoomsClientTypes.AnalysisRuleList)
        /// Analysis rule type that enables only aggregation queries on a configured table.
        case aggregation(CleanRoomsClientTypes.AnalysisRuleAggregation)
        /// Analysis rule type that enables custom SQL queries on a configured table.
        case custom(CleanRoomsClientTypes.AnalysisRuleCustom)
        /// The ID mapping table.
        case idmappingtable(CleanRoomsClientTypes.AnalysisRuleIdMappingTable)
        case sdkUnknown(Swift.String)
    }
}

extension CleanRoomsClientTypes {

    /// Controls on the query specifications that can be run on configured table.
    public enum AnalysisRulePolicy: Swift.Sendable {
        /// Controls on the query specifications that can be run on configured table.
        case v1(CleanRoomsClientTypes.AnalysisRulePolicyV1)
        case sdkUnknown(Swift.String)
    }
}

extension CleanRoomsClientTypes {

    public enum AnalysisRuleType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aggregation
        case custom
        case idMappingTable
        case list
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisRuleType] {
            return [
                .aggregation,
                .custom,
                .idMappingTable,
                .list
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aggregation: return "AGGREGATION"
            case .custom: return "CUSTOM"
            case .idMappingTable: return "ID_MAPPING_TABLE"
            case .list: return "LIST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// A specification about how data from the configured table can be used in a query.
    public struct AnalysisRule: Swift.Sendable {
        /// The unique ID for the associated collaboration.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time the analysis rule was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The name for the analysis rule.
        /// This member is required.
        public var name: Swift.String?
        /// A policy that describes the associated data usage limitations.
        /// This member is required.
        public var policy: CleanRoomsClientTypes.AnalysisRulePolicy?
        /// The type of analysis rule.
        /// This member is required.
        public var type: CleanRoomsClientTypes.AnalysisRuleType?
        /// The time the analysis rule was last updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            collaborationId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            policy: CleanRoomsClientTypes.AnalysisRulePolicy? = nil,
            type: CleanRoomsClientTypes.AnalysisRuleType? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.name = name
            self.policy = policy
            self.type = type
            self.updateTime = updateTime
        }
    }
}

extension CleanRoomsClientTypes {

    /// A relation within an analysis.
    public struct AnalysisSchema: Swift.Sendable {
        /// The tables referenced in the analysis schema.
        public var referencedTables: [Swift.String]?

        public init(
            referencedTables: [Swift.String]? = nil
        )
        {
            self.referencedTables = referencedTables
        }
    }
}

extension CleanRoomsClientTypes {

    /// The structure that defines the body of the analysis template.
    public enum AnalysisSource: Swift.Sendable {
        /// The query text.
        case text(Swift.String)
        case sdkUnknown(Swift.String)
    }
}

extension CleanRoomsClientTypes {

    /// The reasons for the validation results.
    public struct AnalysisTemplateValidationStatusReason: Swift.Sendable {
        /// The validation message.
        /// This member is required.
        public var message: Swift.String?

        public init(
            message: Swift.String? = nil
        )
        {
            self.message = message
        }
    }
}

extension CleanRoomsClientTypes {

    public enum AnalysisTemplateValidationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case invalid
        case unableToValidate
        case valid
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisTemplateValidationStatus] {
            return [
                .invalid,
                .unableToValidate,
                .valid
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .invalid: return "INVALID"
            case .unableToValidate: return "UNABLE_TO_VALIDATE"
            case .valid: return "VALID"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    public enum AnalysisTemplateValidationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case differentialPrivacy
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisTemplateValidationType] {
            return [
                .differentialPrivacy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .differentialPrivacy: return "DIFFERENTIAL_PRIVACY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// The status details of the analysis template validation. Clean Rooms Differential Privacy uses a general-purpose query structure to support complex SQL queries and validates whether an analysis template fits that general-purpose query structure. Validation is performed when analysis templates are created and fetched. Because analysis templates are immutable by design, we recommend that you create analysis templates after you associate the configured tables with their analysis rule to your collaboration. For more information, see [https://docs.aws.amazon.com/clean-rooms/latest/userguide/analysis-rules-custom.html#custom-diff-privacy](https://docs.aws.amazon.com/clean-rooms/latest/userguide/analysis-rules-custom.html#custom-diff-privacy).
    public struct AnalysisTemplateValidationStatusDetail: Swift.Sendable {
        /// The reasons for the validation results.
        public var reasons: [CleanRoomsClientTypes.AnalysisTemplateValidationStatusReason]?
        /// The status of the validation.
        /// This member is required.
        public var status: CleanRoomsClientTypes.AnalysisTemplateValidationStatus?
        /// The type of validation that was performed.
        /// This member is required.
        public var type: CleanRoomsClientTypes.AnalysisTemplateValidationType?

        public init(
            reasons: [CleanRoomsClientTypes.AnalysisTemplateValidationStatusReason]? = nil,
            status: CleanRoomsClientTypes.AnalysisTemplateValidationStatus? = nil,
            type: CleanRoomsClientTypes.AnalysisTemplateValidationType? = nil
        )
        {
            self.reasons = reasons
            self.status = status
            self.type = type
        }
    }
}

extension CleanRoomsClientTypes {

    /// The analysis template.
    public struct AnalysisTemplate: Swift.Sendable {
        /// The parameters of the analysis template.
        public var analysisParameters: [CleanRoomsClientTypes.AnalysisParameter]?
        /// The Amazon Resource Name (ARN) of the analysis template.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique ARN for the analysis template’s associated collaboration.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique ID for the associated collaboration of the analysis template.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time that the analysis template was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The description of the analysis template.
        public var description: Swift.String?
        /// The format of the analysis template.
        /// This member is required.
        public var format: CleanRoomsClientTypes.AnalysisFormat?
        /// The identifier for the analysis template.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the member who created the analysis template.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The identifier of a member who created the analysis template.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The name of the analysis template.
        /// This member is required.
        public var name: Swift.String?
        /// The entire schema object.
        /// This member is required.
        public var schema: CleanRoomsClientTypes.AnalysisSchema?
        /// The source of the analysis template.
        /// This member is required.
        public var source: CleanRoomsClientTypes.AnalysisSource?
        /// The time that the analysis template was last updated.
        /// This member is required.
        public var updateTime: Foundation.Date?
        /// Information about the validations performed on the analysis template.
        public var validations: [CleanRoomsClientTypes.AnalysisTemplateValidationStatusDetail]?

        public init(
            analysisParameters: [CleanRoomsClientTypes.AnalysisParameter]? = nil,
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            format: CleanRoomsClientTypes.AnalysisFormat? = nil,
            id: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            name: Swift.String? = nil,
            schema: CleanRoomsClientTypes.AnalysisSchema? = nil,
            source: CleanRoomsClientTypes.AnalysisSource? = nil,
            updateTime: Foundation.Date? = nil,
            validations: [CleanRoomsClientTypes.AnalysisTemplateValidationStatusDetail]? = nil
        )
        {
            self.analysisParameters = analysisParameters
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.description = description
            self.format = format
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.schema = schema
            self.source = source
            self.updateTime = updateTime
            self.validations = validations
        }
    }
}

extension CleanRoomsClientTypes.AnalysisTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AnalysisTemplate(arn: \(Swift.String(describing: arn)), collaborationArn: \(Swift.String(describing: collaborationArn)), collaborationId: \(Swift.String(describing: collaborationId)), createTime: \(Swift.String(describing: createTime)), description: \(Swift.String(describing: description)), format: \(Swift.String(describing: format)), id: \(Swift.String(describing: id)), membershipArn: \(Swift.String(describing: membershipArn)), membershipId: \(Swift.String(describing: membershipId)), name: \(Swift.String(describing: name)), schema: \(Swift.String(describing: schema)), updateTime: \(Swift.String(describing: updateTime)), validations: \(Swift.String(describing: validations)), analysisParameters: \"CONTENT_REDACTED\", source: \"CONTENT_REDACTED\")"}
}

extension CleanRoomsClientTypes {

    public enum ConflictExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case alreadyExists
        case invalidState
        case subresourcesExist
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .alreadyExists,
                .invalidState,
                .subresourcesExist
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .alreadyExists: return "ALREADY_EXISTS"
            case .invalidState: return "INVALID_STATE"
            case .subresourcesExist: return "SUBRESOURCES_EXIST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case collaboration
        case configuredTable
        case configuredTableAssociation
        case membership
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .collaboration,
                .configuredTable,
                .configuredTableAssociation,
                .membership
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .collaboration: return "COLLABORATION"
            case .configuredTable: return "CONFIGURED_TABLE"
            case .configuredTableAssociation: return "CONFIGURED_TABLE_ASSOCIATION"
            case .membership: return "MEMBERSHIP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Updating or deleting a resource can cause an inconsistent state.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// A reason code for the exception.
        public internal(set) var reason: CleanRoomsClientTypes.ConflictExceptionReason? = nil
        /// The ID of the conflicting resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the conflicting resource.
        public internal(set) var resourceType: CleanRoomsClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: CleanRoomsClientTypes.ConflictExceptionReason? = nil,
        resourceId: Swift.String? = nil,
        resourceType: CleanRoomsClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// Unexpected error during processing of request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Request references a resource which does not exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The Id of the missing resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the missing resource.
        /// This member is required.
        public internal(set) var resourceType: CleanRoomsClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: CleanRoomsClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// Request denied because service quota has been exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The name of the quota.
        /// This member is required.
        public internal(set) var quotaName: Swift.String? = nil
        /// The value of the quota.
        /// This member is required.
        public internal(set) var quotaValue: Swift.Double? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaName: Swift.String? = nil,
        quotaValue: Swift.Double? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaName = quotaName
        self.properties.quotaValue = quotaValue
    }
}

/// Request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension CleanRoomsClientTypes {

    /// Describes validation errors for specific input parameters.
    public struct ValidationExceptionField: Swift.Sendable {
        /// A message for the input validation error.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the input parameter.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension CleanRoomsClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case fieldValidationFailed
        case iamSynchronizationDelay
        case invalidConfiguration
        case invalidQuery
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .fieldValidationFailed,
                .iamSynchronizationDelay,
                .invalidConfiguration,
                .invalidQuery
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .iamSynchronizationDelay: return "IAM_SYNCHRONIZATION_DELAY"
            case .invalidConfiguration: return "INVALID_CONFIGURATION"
            case .invalidQuery: return "INVALID_QUERY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the specified constraints.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Validation errors for specific input parameters.
        public internal(set) var fieldList: [CleanRoomsClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// A reason code for the exception.
        public internal(set) var reason: CleanRoomsClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [CleanRoomsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: CleanRoomsClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct CreateAnalysisTemplateInput: Swift.Sendable {
    /// The parameters of the analysis template.
    public var analysisParameters: [CleanRoomsClientTypes.AnalysisParameter]?
    /// The description of the analysis template.
    public var description: Swift.String?
    /// The format of the analysis template.
    /// This member is required.
    public var format: CleanRoomsClientTypes.AnalysisFormat?
    /// The identifier for a membership resource.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The name of the analysis template.
    /// This member is required.
    public var name: Swift.String?
    /// The information in the analysis template. Currently supports text, the query text for the analysis template.
    /// This member is required.
    public var source: CleanRoomsClientTypes.AnalysisSource?
    /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        analysisParameters: [CleanRoomsClientTypes.AnalysisParameter]? = nil,
        description: Swift.String? = nil,
        format: CleanRoomsClientTypes.AnalysisFormat? = nil,
        membershipIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        source: CleanRoomsClientTypes.AnalysisSource? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.analysisParameters = analysisParameters
        self.description = description
        self.format = format
        self.membershipIdentifier = membershipIdentifier
        self.name = name
        self.source = source
        self.tags = tags
    }
}

extension CreateAnalysisTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAnalysisTemplateInput(description: \(Swift.String(describing: description)), format: \(Swift.String(describing: format)), membershipIdentifier: \(Swift.String(describing: membershipIdentifier)), name: \(Swift.String(describing: name)), tags: \(Swift.String(describing: tags)), analysisParameters: \"CONTENT_REDACTED\", source: \"CONTENT_REDACTED\")"}
}

public struct CreateAnalysisTemplateOutput: Swift.Sendable {
    /// The analysis template.
    /// This member is required.
    public var analysisTemplate: CleanRoomsClientTypes.AnalysisTemplate?

    public init(
        analysisTemplate: CleanRoomsClientTypes.AnalysisTemplate? = nil
    )
    {
        self.analysisTemplate = analysisTemplate
    }
}

public struct DeleteAnalysisTemplateInput: Swift.Sendable {
    /// The identifier for the analysis template resource.
    /// This member is required.
    public var analysisTemplateIdentifier: Swift.String?
    /// The identifier for a membership resource.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        analysisTemplateIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.analysisTemplateIdentifier = analysisTemplateIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

public struct DeleteAnalysisTemplateOutput: Swift.Sendable {

    public init() { }
}

public struct GetAnalysisTemplateInput: Swift.Sendable {
    /// The identifier for the analysis template resource.
    /// This member is required.
    public var analysisTemplateIdentifier: Swift.String?
    /// The identifier for a membership resource.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        analysisTemplateIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.analysisTemplateIdentifier = analysisTemplateIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

public struct GetAnalysisTemplateOutput: Swift.Sendable {
    /// The analysis template.
    /// This member is required.
    public var analysisTemplate: CleanRoomsClientTypes.AnalysisTemplate?

    public init(
        analysisTemplate: CleanRoomsClientTypes.AnalysisTemplate? = nil
    )
    {
        self.analysisTemplate = analysisTemplate
    }
}

public struct ListAnalysisTemplatesInput: Swift.Sendable {
    /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the `maxResults` value has not been met.
    public var maxResults: Swift.Int?
    /// The identifier for a membership resource.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        membershipIdentifier: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.membershipIdentifier = membershipIdentifier
        self.nextToken = nextToken
    }
}

extension CleanRoomsClientTypes {

    /// The metadata of the analysis template.
    public struct AnalysisTemplateSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the analysis template.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique ARN for the analysis template summary’s associated collaboration.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// A unique identifier for the collaboration that the analysis template summary belongs to. Currently accepts collaboration ID.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time that the analysis template summary was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The description of the analysis template.
        public var description: Swift.String?
        /// The identifier of the analysis template.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the member who created the analysis template.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The identifier for a membership resource.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The name of the analysis template.
        /// This member is required.
        public var name: Swift.String?
        /// The time that the analysis template summary was last updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.description = description
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }
    }
}

public struct ListAnalysisTemplatesOutput: Swift.Sendable {
    /// Lists analysis template metadata.
    /// This member is required.
    public var analysisTemplateSummaries: [CleanRoomsClientTypes.AnalysisTemplateSummary]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        analysisTemplateSummaries: [CleanRoomsClientTypes.AnalysisTemplateSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analysisTemplateSummaries = analysisTemplateSummaries
        self.nextToken = nextToken
    }
}

public struct UpdateAnalysisTemplateInput: Swift.Sendable {
    /// The identifier for the analysis template resource.
    /// This member is required.
    public var analysisTemplateIdentifier: Swift.String?
    /// A new description for the analysis template.
    public var description: Swift.String?
    /// The identifier for a membership resource.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        analysisTemplateIdentifier: Swift.String? = nil,
        description: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.analysisTemplateIdentifier = analysisTemplateIdentifier
        self.description = description
        self.membershipIdentifier = membershipIdentifier
    }
}

public struct UpdateAnalysisTemplateOutput: Swift.Sendable {
    /// The analysis template.
    /// This member is required.
    public var analysisTemplate: CleanRoomsClientTypes.AnalysisTemplate?

    public init(
        analysisTemplate: CleanRoomsClientTypes.AnalysisTemplate? = nil
    )
    {
        self.analysisTemplate = analysisTemplate
    }
}

extension CleanRoomsClientTypes {

    public enum AnalysisType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case additionalAnalysis
        case directAnalysis
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisType] {
            return [
                .additionalAnalysis,
                .directAnalysis
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .additionalAnalysis: return "ADDITIONAL_ANALYSIS"
            case .directAnalysis: return "DIRECT_ANALYSIS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    public enum AnalyticsEngine: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cleanRoomsSql
        case spark
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalyticsEngine] {
            return [
                .cleanRoomsSql,
                .spark
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cleanRoomsSql: return "CLEAN_ROOMS_SQL"
            case .spark: return "SPARK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct BatchGetCollaborationAnalysisTemplateInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) associated with the analysis template within a collaboration.
    /// This member is required.
    public var analysisTemplateArns: [Swift.String]?
    /// A unique identifier for the collaboration that the analysis templates belong to. Currently accepts collaboration ID.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?

    public init(
        analysisTemplateArns: [Swift.String]? = nil,
        collaborationIdentifier: Swift.String? = nil
    )
    {
        self.analysisTemplateArns = analysisTemplateArns
        self.collaborationIdentifier = collaborationIdentifier
    }
}

extension CleanRoomsClientTypes {

    /// The analysis template within a collaboration.
    public struct CollaborationAnalysisTemplate: Swift.Sendable {
        /// The analysis parameters that have been specified in the analysis template.
        public var analysisParameters: [CleanRoomsClientTypes.AnalysisParameter]?
        /// The Amazon Resource Name (ARN) of the analysis template.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique ARN for the analysis template’s associated collaboration.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// A unique identifier for the collaboration that the analysis templates belong to. Currently accepts collaboration ID.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time that the analysis template within a collaboration was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// The description of the analysis template.
        public var description: Swift.String?
        /// The format of the analysis template in the collaboration.
        /// This member is required.
        public var format: CleanRoomsClientTypes.AnalysisFormat?
        /// The identifier of the analysis template.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the analysis template.
        /// This member is required.
        public var name: Swift.String?
        /// The entire schema object.
        /// This member is required.
        public var schema: CleanRoomsClientTypes.AnalysisSchema?
        /// The source of the analysis template within a collaboration.
        /// This member is required.
        public var source: CleanRoomsClientTypes.AnalysisSource?
        /// The time that the analysis template in the collaboration was last updated.
        /// This member is required.
        public var updateTime: Foundation.Date?
        /// The validations that were performed.
        public var validations: [CleanRoomsClientTypes.AnalysisTemplateValidationStatusDetail]?

        public init(
            analysisParameters: [CleanRoomsClientTypes.AnalysisParameter]? = nil,
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            format: CleanRoomsClientTypes.AnalysisFormat? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            schema: CleanRoomsClientTypes.AnalysisSchema? = nil,
            source: CleanRoomsClientTypes.AnalysisSource? = nil,
            updateTime: Foundation.Date? = nil,
            validations: [CleanRoomsClientTypes.AnalysisTemplateValidationStatusDetail]? = nil
        )
        {
            self.analysisParameters = analysisParameters
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.format = format
            self.id = id
            self.name = name
            self.schema = schema
            self.source = source
            self.updateTime = updateTime
            self.validations = validations
        }
    }
}

extension CleanRoomsClientTypes.CollaborationAnalysisTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CollaborationAnalysisTemplate(arn: \(Swift.String(describing: arn)), collaborationArn: \(Swift.String(describing: collaborationArn)), collaborationId: \(Swift.String(describing: collaborationId)), createTime: \(Swift.String(describing: createTime)), creatorAccountId: \(Swift.String(describing: creatorAccountId)), description: \(Swift.String(describing: description)), format: \(Swift.String(describing: format)), id: \(Swift.String(describing: id)), name: \(Swift.String(describing: name)), schema: \(Swift.String(describing: schema)), updateTime: \(Swift.String(describing: updateTime)), validations: \(Swift.String(describing: validations)), analysisParameters: \"CONTENT_REDACTED\", source: \"CONTENT_REDACTED\")"}
}

extension CleanRoomsClientTypes {

    /// Details of errors thrown by the call to retrieve multiple analysis templates within a collaboration by their identifiers.
    public struct BatchGetCollaborationAnalysisTemplateError: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the analysis template.
        /// This member is required.
        public var arn: Swift.String?
        /// An error code for the error.
        /// This member is required.
        public var code: Swift.String?
        /// A description of why the call failed.
        /// This member is required.
        public var message: Swift.String?

        public init(
            arn: Swift.String? = nil,
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.arn = arn
            self.code = code
            self.message = message
        }
    }
}

public struct BatchGetCollaborationAnalysisTemplateOutput: Swift.Sendable {
    /// The retrieved list of analysis templates within a collaboration.
    /// This member is required.
    public var collaborationAnalysisTemplates: [CleanRoomsClientTypes.CollaborationAnalysisTemplate]?
    /// Error reasons for collaboration analysis templates that could not be retrieved. One error is returned for every collaboration analysis template that could not be retrieved.
    /// This member is required.
    public var errors: [CleanRoomsClientTypes.BatchGetCollaborationAnalysisTemplateError]?

    public init(
        collaborationAnalysisTemplates: [CleanRoomsClientTypes.CollaborationAnalysisTemplate]? = nil,
        errors: [CleanRoomsClientTypes.BatchGetCollaborationAnalysisTemplateError]? = nil
    )
    {
        self.collaborationAnalysisTemplates = collaborationAnalysisTemplates
        self.errors = errors
    }
}

public struct BatchGetSchemaInput: Swift.Sendable {
    /// A unique identifier for the collaboration that the schemas belong to. Currently accepts collaboration ID.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The names for the schema objects to retrieve.
    /// This member is required.
    public var names: [Swift.String]?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        names: [Swift.String]? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.names = names
    }
}

extension CleanRoomsClientTypes {

    /// An error describing why a schema could not be fetched.
    public struct BatchGetSchemaError: Swift.Sendable {
        /// An error code for the error.
        /// This member is required.
        public var code: Swift.String?
        /// An error message for the error.
        /// This member is required.
        public var message: Swift.String?
        /// An error name for the error.
        /// This member is required.
        public var name: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
            self.name = name
        }
    }
}

extension CleanRoomsClientTypes {

    /// A column within a schema relation, derived from the underlying Glue table.
    public struct Column: Swift.Sendable {
        /// The name of the column.
        /// This member is required.
        public var name: Swift.String?
        /// The type of the column.
        /// This member is required.
        public var type: Swift.String?

        public init(
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }
}

extension CleanRoomsClientTypes {

    public enum SchemaConfiguration: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case differentialPrivacy
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaConfiguration] {
            return [
                .differentialPrivacy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .differentialPrivacy: return "DIFFERENTIAL_PRIVACY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    public enum SchemaStatusReasonCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case additionalAnalysesNotAllowed
        case additionalAnalysesNotConfigured
        case analysisProvidersNotConfigured
        case analysisRuleMissing
        case analysisRuleTypesNotCompatible
        case analysisTemplatesNotConfigured
        case collaborationAnalysisRuleNotConfigured
        case differentialPrivacyPolicyNotConfigured
        case idMappingTableNotPopulated
        case resultReceiversNotAllowed
        case resultReceiversNotConfigured
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaStatusReasonCode] {
            return [
                .additionalAnalysesNotAllowed,
                .additionalAnalysesNotConfigured,
                .analysisProvidersNotConfigured,
                .analysisRuleMissing,
                .analysisRuleTypesNotCompatible,
                .analysisTemplatesNotConfigured,
                .collaborationAnalysisRuleNotConfigured,
                .differentialPrivacyPolicyNotConfigured,
                .idMappingTableNotPopulated,
                .resultReceiversNotAllowed,
                .resultReceiversNotConfigured
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .additionalAnalysesNotAllowed: return "ADDITIONAL_ANALYSES_NOT_ALLOWED"
            case .additionalAnalysesNotConfigured: return "ADDITIONAL_ANALYSES_NOT_CONFIGURED"
            case .analysisProvidersNotConfigured: return "ANALYSIS_PROVIDERS_NOT_CONFIGURED"
            case .analysisRuleMissing: return "ANALYSIS_RULE_MISSING"
            case .analysisRuleTypesNotCompatible: return "ANALYSIS_RULE_TYPES_NOT_COMPATIBLE"
            case .analysisTemplatesNotConfigured: return "ANALYSIS_TEMPLATES_NOT_CONFIGURED"
            case .collaborationAnalysisRuleNotConfigured: return "COLLABORATION_ANALYSIS_RULE_NOT_CONFIGURED"
            case .differentialPrivacyPolicyNotConfigured: return "DIFFERENTIAL_PRIVACY_POLICY_NOT_CONFIGURED"
            case .idMappingTableNotPopulated: return "ID_MAPPING_TABLE_NOT_POPULATED"
            case .resultReceiversNotAllowed: return "RESULT_RECEIVERS_NOT_ALLOWED"
            case .resultReceiversNotConfigured: return "RESULT_RECEIVERS_NOT_CONFIGURED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// A reason why the schema status is set to its current value.
    public struct SchemaStatusReason: Swift.Sendable {
        /// The schema status reason code.
        /// This member is required.
        public var code: CleanRoomsClientTypes.SchemaStatusReasonCode?
        /// An explanation of the schema status reason code.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: CleanRoomsClientTypes.SchemaStatusReasonCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }
}

extension CleanRoomsClientTypes {

    public enum SchemaStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case notReady
        case ready
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaStatus] {
            return [
                .notReady,
                .ready
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .notReady: return "NOT_READY"
            case .ready: return "READY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// Information about the schema status. A status of READY means that based on the schema analysis rule, queries of the given analysis rule type are properly configured to run queries on this schema.
    public struct SchemaStatusDetail: Swift.Sendable {
        /// The analysis rule type for which the schema status has been evaluated.
        public var analysisRuleType: CleanRoomsClientTypes.AnalysisRuleType?
        /// The type of analysis that can be performed on the schema. A schema can have an analysisType of DIRECT_ANALYSIS, ADDITIONAL_ANALYSIS_FOR_AUDIENCE_GENERATION, or both.
        /// This member is required.
        public var analysisType: CleanRoomsClientTypes.AnalysisType?
        /// The configuration details of the schema analysis rule for the given type.
        public var configurations: [CleanRoomsClientTypes.SchemaConfiguration]?
        /// The reasons why the schema status is set to its current state.
        public var reasons: [CleanRoomsClientTypes.SchemaStatusReason]?
        /// The status of the schema, indicating if it is ready to query.
        /// This member is required.
        public var status: CleanRoomsClientTypes.SchemaStatus?

        public init(
            analysisRuleType: CleanRoomsClientTypes.AnalysisRuleType? = nil,
            analysisType: CleanRoomsClientTypes.AnalysisType? = nil,
            configurations: [CleanRoomsClientTypes.SchemaConfiguration]? = nil,
            reasons: [CleanRoomsClientTypes.SchemaStatusReason]? = nil,
            status: CleanRoomsClientTypes.SchemaStatus? = nil
        )
        {
            self.analysisRuleType = analysisRuleType
            self.analysisType = analysisType
            self.configurations = configurations
            self.reasons = reasons
            self.status = status
        }
    }
}

extension CleanRoomsClientTypes {

    public enum IdNamespaceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case source
        case target
        case sdkUnknown(Swift.String)

        public static var allCases: [IdNamespaceType] {
            return [
                .source,
                .target
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .source: return "SOURCE"
            case .target: return "TARGET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// The input source of the ID mapping table.
    public struct IdMappingTableInputSource: Swift.Sendable {
        /// The unique identifier of the ID namespace association.
        /// This member is required.
        public var idNamespaceAssociationId: Swift.String?
        /// The type of the input source of the ID mapping table.
        /// This member is required.
        public var type: CleanRoomsClientTypes.IdNamespaceType?

        public init(
            idNamespaceAssociationId: Swift.String? = nil,
            type: CleanRoomsClientTypes.IdNamespaceType? = nil
        )
        {
            self.idNamespaceAssociationId = idNamespaceAssociationId
            self.type = type
        }
    }
}

extension CleanRoomsClientTypes {

    /// Additional properties that are specific to the type of the associated schema.
    public struct IdMappingTableSchemaTypeProperties: Swift.Sendable {
        /// Defines which ID namespace associations are used to create the ID mapping table.
        /// This member is required.
        public var idMappingTableInputSource: [CleanRoomsClientTypes.IdMappingTableInputSource]?

        public init(
            idMappingTableInputSource: [CleanRoomsClientTypes.IdMappingTableInputSource]? = nil
        )
        {
            self.idMappingTableInputSource = idMappingTableInputSource
        }
    }
}

extension CleanRoomsClientTypes {

    /// Information about the schema type properties.
    public enum SchemaTypeProperties: Swift.Sendable {
        /// The ID mapping table for the schema type properties.
        case idmappingtable(CleanRoomsClientTypes.IdMappingTableSchemaTypeProperties)
        case sdkUnknown(Swift.String)
    }
}

extension CleanRoomsClientTypes {

    public enum SchemaType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case idMappingTable
        case table
        case sdkUnknown(Swift.String)

        public static var allCases: [SchemaType] {
            return [
                .idMappingTable,
                .table
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .idMappingTable: return "ID_MAPPING_TABLE"
            case .table: return "TABLE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// A schema is a relation within a collaboration.
    public struct Schema: Swift.Sendable {
        /// The analysis method for the schema. The only valid value is currently DIRECT_QUERY.
        public var analysisMethod: CleanRoomsClientTypes.AnalysisMethod?
        /// The analysis rule types that are associated with the schema. Currently, only one entry is present.
        /// This member is required.
        public var analysisRuleTypes: [CleanRoomsClientTypes.AnalysisRuleType]?
        /// The unique Amazon Resource Name (ARN) for the collaboration that the schema belongs to.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique ID for the collaboration that the schema belongs to.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The columns for the relation that this schema represents.
        /// This member is required.
        public var columns: [CleanRoomsClientTypes.Column]?
        /// The time at which the schema was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The unique account ID for the Amazon Web Services account that owns the schema.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// A description for the schema.
        /// This member is required.
        public var description: Swift.String?
        /// A name for the schema. The schema relation is referred to by this name when queried by a protected query.
        /// This member is required.
        public var name: Swift.String?
        /// The partition keys for the dataset underlying this schema.
        /// This member is required.
        public var partitionKeys: [CleanRoomsClientTypes.Column]?
        /// Details about the status of the schema. Currently, only one entry is present.
        /// This member is required.
        public var schemaStatusDetails: [CleanRoomsClientTypes.SchemaStatusDetail]?
        /// The schema type properties.
        public var schemaTypeProperties: CleanRoomsClientTypes.SchemaTypeProperties?
        /// The type of schema.
        /// This member is required.
        public var type: CleanRoomsClientTypes.SchemaType?
        /// The most recent time at which the schema was updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            analysisMethod: CleanRoomsClientTypes.AnalysisMethod? = nil,
            analysisRuleTypes: [CleanRoomsClientTypes.AnalysisRuleType]? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            columns: [CleanRoomsClientTypes.Column]? = nil,
            createTime: Foundation.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            partitionKeys: [CleanRoomsClientTypes.Column]? = nil,
            schemaStatusDetails: [CleanRoomsClientTypes.SchemaStatusDetail]? = [],
            schemaTypeProperties: CleanRoomsClientTypes.SchemaTypeProperties? = nil,
            type: CleanRoomsClientTypes.SchemaType? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.analysisMethod = analysisMethod
            self.analysisRuleTypes = analysisRuleTypes
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.columns = columns
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.name = name
            self.partitionKeys = partitionKeys
            self.schemaStatusDetails = schemaStatusDetails
            self.schemaTypeProperties = schemaTypeProperties
            self.type = type
            self.updateTime = updateTime
        }
    }
}

public struct BatchGetSchemaOutput: Swift.Sendable {
    /// Error reasons for schemas that could not be retrieved. One error is returned for every schema that could not be retrieved.
    /// This member is required.
    public var errors: [CleanRoomsClientTypes.BatchGetSchemaError]?
    /// The retrieved list of schemas.
    /// This member is required.
    public var schemas: [CleanRoomsClientTypes.Schema]?

    public init(
        errors: [CleanRoomsClientTypes.BatchGetSchemaError]? = nil,
        schemas: [CleanRoomsClientTypes.Schema]? = nil
    )
    {
        self.errors = errors
        self.schemas = schemas
    }
}

extension CleanRoomsClientTypes {

    /// Defines the information that's necessary to retrieve an analysis rule schema. Schema analysis rules are uniquely identiﬁed by a combination of the schema name and the analysis rule type for a given collaboration.
    public struct SchemaAnalysisRuleRequest: Swift.Sendable {
        /// The name of the analysis rule schema that you are requesting.
        /// This member is required.
        public var name: Swift.String?
        /// The type of analysis rule schema that you are requesting.
        /// This member is required.
        public var type: CleanRoomsClientTypes.AnalysisRuleType?

        public init(
            name: Swift.String? = nil,
            type: CleanRoomsClientTypes.AnalysisRuleType? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }
}

public struct BatchGetSchemaAnalysisRuleInput: Swift.Sendable {
    /// The unique identifier of the collaboration that contains the schema analysis rule.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The information that's necessary to retrieve a schema analysis rule.
    /// This member is required.
    public var schemaAnalysisRuleRequests: [CleanRoomsClientTypes.SchemaAnalysisRuleRequest]?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        schemaAnalysisRuleRequests: [CleanRoomsClientTypes.SchemaAnalysisRuleRequest]? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.schemaAnalysisRuleRequests = schemaAnalysisRuleRequests
    }
}

extension CleanRoomsClientTypes {

    /// An error that describes why a schema could not be fetched.
    public struct BatchGetSchemaAnalysisRuleError: Swift.Sendable {
        /// An error code for the error.
        /// This member is required.
        public var code: Swift.String?
        /// A description of why the call failed.
        /// This member is required.
        public var message: Swift.String?
        /// An error name for the error.
        /// This member is required.
        public var name: Swift.String?
        /// The analysis rule type.
        /// This member is required.
        public var type: CleanRoomsClientTypes.AnalysisRuleType?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            type: CleanRoomsClientTypes.AnalysisRuleType? = nil
        )
        {
            self.code = code
            self.message = message
            self.name = name
            self.type = type
        }
    }
}

public struct BatchGetSchemaAnalysisRuleOutput: Swift.Sendable {
    /// The retrieved list of analysis rules.
    /// This member is required.
    public var analysisRules: [CleanRoomsClientTypes.AnalysisRule]?
    /// Error reasons for schemas that could not be retrieved. One error is returned for every schema that could not be retrieved.
    /// This member is required.
    public var errors: [CleanRoomsClientTypes.BatchGetSchemaAnalysisRuleError]?

    public init(
        analysisRules: [CleanRoomsClientTypes.AnalysisRule]? = nil,
        errors: [CleanRoomsClientTypes.BatchGetSchemaAnalysisRuleError]? = nil
    )
    {
        self.analysisRules = analysisRules
        self.errors = errors
    }
}

extension CleanRoomsClientTypes {

    public enum MemberAbility: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canQuery
        case canReceiveResults
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberAbility] {
            return [
                .canQuery,
                .canReceiveResults
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canQuery: return "CAN_QUERY"
            case .canReceiveResults: return "CAN_RECEIVE_RESULTS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// An object representing the collaboration member's payment responsibilities set by the collaboration creator for query compute costs.
    public struct QueryComputePaymentConfig: Swift.Sendable {
        /// Indicates whether the collaboration creator has configured the collaboration member to pay for query compute costs (TRUE) or has not configured the collaboration member to pay for query compute costs (FALSE). Exactly one member can be configured to pay for query compute costs. An error is returned if the collaboration creator sets a TRUE value for more than one member in the collaboration. If the collaboration creator hasn't specified anyone as the member paying for query compute costs, then the member who can query is the default payer. An error is returned if the collaboration creator sets a FALSE value for the member who can query.
        /// This member is required.
        public var isResponsible: Swift.Bool?

        public init(
            isResponsible: Swift.Bool? = nil
        )
        {
            self.isResponsible = isResponsible
        }
    }
}

extension CleanRoomsClientTypes {

    /// An object representing the collaboration member's payment responsibilities set by the collaboration creator.
    public struct PaymentConfiguration: Swift.Sendable {
        /// The collaboration member's payment responsibilities set by the collaboration creator for query compute costs.
        /// This member is required.
        public var queryCompute: CleanRoomsClientTypes.QueryComputePaymentConfig?

        public init(
            queryCompute: CleanRoomsClientTypes.QueryComputePaymentConfig? = nil
        )
        {
            self.queryCompute = queryCompute
        }
    }
}

extension CleanRoomsClientTypes {

    /// The settings for client-side encryption for cryptographic computing.
    public struct DataEncryptionMetadata: Swift.Sendable {
        /// Indicates whether encrypted tables can contain cleartext data (TRUE) or are to cryptographically process every column (FALSE).
        /// This member is required.
        public var allowCleartext: Swift.Bool?
        /// Indicates whether Fingerprint columns can contain duplicate entries (TRUE) or are to contain only non-repeated values (FALSE).
        /// This member is required.
        public var allowDuplicates: Swift.Bool?
        /// Indicates whether Fingerprint columns can be joined on any other Fingerprint column with a different name (TRUE) or can only be joined on Fingerprint columns of the same name (FALSE).
        /// This member is required.
        public var allowJoinsOnColumnsWithDifferentNames: Swift.Bool?
        /// Indicates whether NULL values are to be copied as NULL to encrypted tables (TRUE) or cryptographically processed (FALSE).
        /// This member is required.
        public var preserveNulls: Swift.Bool?

        public init(
            allowCleartext: Swift.Bool? = nil,
            allowDuplicates: Swift.Bool? = nil,
            allowJoinsOnColumnsWithDifferentNames: Swift.Bool? = nil,
            preserveNulls: Swift.Bool? = nil
        )
        {
            self.allowCleartext = allowCleartext
            self.allowDuplicates = allowDuplicates
            self.allowJoinsOnColumnsWithDifferentNames = allowJoinsOnColumnsWithDifferentNames
            self.preserveNulls = preserveNulls
        }
    }
}

extension CleanRoomsClientTypes {

    /// Basic metadata used to construct a new member.
    public struct MemberSpecification: Swift.Sendable {
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        /// This member is required.
        public var accountId: Swift.String?
        /// The member's display name.
        /// This member is required.
        public var displayName: Swift.String?
        /// The abilities granted to the collaboration member.
        /// This member is required.
        public var memberAbilities: [CleanRoomsClientTypes.MemberAbility]?
        /// The collaboration member's payment responsibilities set by the collaboration creator. If the collaboration creator hasn't speciﬁed anyone as the member paying for query compute costs, then the member who can query is the default payer.
        public var paymentConfiguration: CleanRoomsClientTypes.PaymentConfiguration?

        public init(
            accountId: Swift.String? = nil,
            displayName: Swift.String? = nil,
            memberAbilities: [CleanRoomsClientTypes.MemberAbility]? = nil,
            paymentConfiguration: CleanRoomsClientTypes.PaymentConfiguration? = nil
        )
        {
            self.accountId = accountId
            self.displayName = displayName
            self.memberAbilities = memberAbilities
            self.paymentConfiguration = paymentConfiguration
        }
    }
}

extension CleanRoomsClientTypes {

    public enum CollaborationQueryLogStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [CollaborationQueryLogStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateCollaborationInput: Swift.Sendable {
    /// The analytics engine.
    public var analyticsEngine: CleanRoomsClientTypes.AnalyticsEngine?
    /// The display name of the collaboration creator.
    /// This member is required.
    public var creatorDisplayName: Swift.String?
    /// The abilities granted to the collaboration creator.
    /// This member is required.
    public var creatorMemberAbilities: [CleanRoomsClientTypes.MemberAbility]?
    /// The collaboration creator's payment responsibilities set by the collaboration creator. If the collaboration creator hasn't specified anyone as the member paying for query compute costs, then the member who can query is the default payer.
    public var creatorPaymentConfiguration: CleanRoomsClientTypes.PaymentConfiguration?
    /// The settings for client-side encryption with Cryptographic Computing for Clean Rooms.
    public var dataEncryptionMetadata: CleanRoomsClientTypes.DataEncryptionMetadata?
    /// A description of the collaboration provided by the collaboration owner.
    /// This member is required.
    public var description: Swift.String?
    /// A list of initial members, not including the creator. This list is immutable.
    /// This member is required.
    public var members: [CleanRoomsClientTypes.MemberSpecification]?
    /// The display name for a collaboration.
    /// This member is required.
    public var name: Swift.String?
    /// An indicator as to whether query logging has been enabled or disabled for the collaboration.
    /// This member is required.
    public var queryLogStatus: CleanRoomsClientTypes.CollaborationQueryLogStatus?
    /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        analyticsEngine: CleanRoomsClientTypes.AnalyticsEngine? = nil,
        creatorDisplayName: Swift.String? = nil,
        creatorMemberAbilities: [CleanRoomsClientTypes.MemberAbility]? = nil,
        creatorPaymentConfiguration: CleanRoomsClientTypes.PaymentConfiguration? = nil,
        dataEncryptionMetadata: CleanRoomsClientTypes.DataEncryptionMetadata? = nil,
        description: Swift.String? = nil,
        members: [CleanRoomsClientTypes.MemberSpecification]? = nil,
        name: Swift.String? = nil,
        queryLogStatus: CleanRoomsClientTypes.CollaborationQueryLogStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.analyticsEngine = analyticsEngine
        self.creatorDisplayName = creatorDisplayName
        self.creatorMemberAbilities = creatorMemberAbilities
        self.creatorPaymentConfiguration = creatorPaymentConfiguration
        self.dataEncryptionMetadata = dataEncryptionMetadata
        self.description = description
        self.members = members
        self.name = name
        self.queryLogStatus = queryLogStatus
        self.tags = tags
    }
}

extension CleanRoomsClientTypes {

    public enum MemberStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case invited
        case `left`
        case removed
        case sdkUnknown(Swift.String)

        public static var allCases: [MemberStatus] {
            return [
                .active,
                .invited,
                .left,
                .removed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .invited: return "INVITED"
            case .left: return "LEFT"
            case .removed: return "REMOVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// The multi-party data share environment. The collaboration contains metadata about its purpose and participants.
    public struct Collaboration: Swift.Sendable {
        /// The analytics engine for the collaboration.
        public var analyticsEngine: CleanRoomsClientTypes.AnalyticsEngine?
        /// The unique ARN for the collaboration.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the collaboration was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// A display name of the collaboration creator.
        /// This member is required.
        public var creatorDisplayName: Swift.String?
        /// The settings for client-side encryption for cryptographic computing.
        public var dataEncryptionMetadata: CleanRoomsClientTypes.DataEncryptionMetadata?
        /// A description of the collaboration provided by the collaboration owner.
        public var description: Swift.String?
        /// The unique ID for the collaboration.
        /// This member is required.
        public var id: Swift.String?
        /// The status of a member in a collaboration.
        /// This member is required.
        public var memberStatus: CleanRoomsClientTypes.MemberStatus?
        /// The unique ARN for your membership within the collaboration.
        public var membershipArn: Swift.String?
        /// The unique ID for your membership within the collaboration.
        public var membershipId: Swift.String?
        /// A human-readable identifier provided by the collaboration owner. Display names are not unique.
        /// This member is required.
        public var name: Swift.String?
        /// An indicator as to whether query logging has been enabled or disabled for the collaboration.
        /// This member is required.
        public var queryLogStatus: CleanRoomsClientTypes.CollaborationQueryLogStatus?
        /// The time the collaboration metadata was last updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            analyticsEngine: CleanRoomsClientTypes.AnalyticsEngine? = nil,
            arn: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            creatorDisplayName: Swift.String? = nil,
            dataEncryptionMetadata: CleanRoomsClientTypes.DataEncryptionMetadata? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            memberStatus: CleanRoomsClientTypes.MemberStatus? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            name: Swift.String? = nil,
            queryLogStatus: CleanRoomsClientTypes.CollaborationQueryLogStatus? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.analyticsEngine = analyticsEngine
            self.arn = arn
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.creatorDisplayName = creatorDisplayName
            self.dataEncryptionMetadata = dataEncryptionMetadata
            self.description = description
            self.id = id
            self.memberStatus = memberStatus
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.queryLogStatus = queryLogStatus
            self.updateTime = updateTime
        }
    }
}

public struct CreateCollaborationOutput: Swift.Sendable {
    /// The collaboration.
    /// This member is required.
    public var collaboration: CleanRoomsClientTypes.Collaboration?

    public init(
        collaboration: CleanRoomsClientTypes.Collaboration? = nil
    )
    {
        self.collaboration = collaboration
    }
}

public struct DeleteCollaborationInput: Swift.Sendable {
    /// The identifier for the collaboration.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
    }
}

public struct DeleteCollaborationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteMemberInput: Swift.Sendable {
    /// The account ID of the member to remove.
    /// This member is required.
    public var accountId: Swift.String?
    /// The unique identifier for the associated collaboration.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        collaborationIdentifier: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.collaborationIdentifier = collaborationIdentifier
    }
}

public struct DeleteMemberOutput: Swift.Sendable {

    public init() { }
}

public struct GetCollaborationInput: Swift.Sendable {
    /// The identifier for the collaboration.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
    }
}

public struct GetCollaborationOutput: Swift.Sendable {
    /// The entire collaboration for this identifier.
    /// This member is required.
    public var collaboration: CleanRoomsClientTypes.Collaboration?

    public init(
        collaboration: CleanRoomsClientTypes.Collaboration? = nil
    )
    {
        self.collaboration = collaboration
    }
}

public struct GetCollaborationAnalysisTemplateInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) associated with the analysis template within a collaboration.
    /// This member is required.
    public var analysisTemplateArn: Swift.String?
    /// A unique identifier for the collaboration that the analysis templates belong to. Currently accepts collaboration ID.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?

    public init(
        analysisTemplateArn: Swift.String? = nil,
        collaborationIdentifier: Swift.String? = nil
    )
    {
        self.analysisTemplateArn = analysisTemplateArn
        self.collaborationIdentifier = collaborationIdentifier
    }
}

public struct GetCollaborationAnalysisTemplateOutput: Swift.Sendable {
    /// The analysis template within a collaboration.
    /// This member is required.
    public var collaborationAnalysisTemplate: CleanRoomsClientTypes.CollaborationAnalysisTemplate?

    public init(
        collaborationAnalysisTemplate: CleanRoomsClientTypes.CollaborationAnalysisTemplate? = nil
    )
    {
        self.collaborationAnalysisTemplate = collaborationAnalysisTemplate
    }
}

public struct GetCollaborationConfiguredAudienceModelAssociationInput: Swift.Sendable {
    /// A unique identifier for the collaboration that the configured audience model association belongs to. Accepts a collaboration ID.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// A unique identifier for the configured audience model association that you want to retrieve.
    /// This member is required.
    public var configuredAudienceModelAssociationIdentifier: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        configuredAudienceModelAssociationIdentifier: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.configuredAudienceModelAssociationIdentifier = configuredAudienceModelAssociationIdentifier
    }
}

extension CleanRoomsClientTypes {

    /// The configured audience model association within a collaboration.
    public struct CollaborationConfiguredAudienceModelAssociation: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the configured audience model association.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique ARN for the configured audience model's associated collaboration.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// A unique identifier for the collaboration that the configured audience model associations belong to. Accepts collaboration ID.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the configure audience model.
        /// This member is required.
        public var configuredAudienceModelArn: Swift.String?
        /// The time at which the configured audience model association was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The identifier used to reference members of the collaboration. Only supports Amazon Web Services account ID.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// The description of the configured audience model association.
        public var description: Swift.String?
        /// The identifier of the configured audience model association.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the configured audience model association.
        /// This member is required.
        public var name: Swift.String?
        /// The most recent time at which the configured audience model association was updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            configuredAudienceModelArn: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.id = id
            self.name = name
            self.updateTime = updateTime
        }
    }
}

public struct GetCollaborationConfiguredAudienceModelAssociationOutput: Swift.Sendable {
    /// The metadata of the configured audience model association.
    /// This member is required.
    public var collaborationConfiguredAudienceModelAssociation: CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociation?

    public init(
        collaborationConfiguredAudienceModelAssociation: CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociation? = nil
    )
    {
        self.collaborationConfiguredAudienceModelAssociation = collaborationConfiguredAudienceModelAssociation
    }
}

public struct GetCollaborationIdNamespaceAssociationInput: Swift.Sendable {
    /// The unique identifier of the collaboration that contains the ID namespace association that you want to retrieve.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The unique identifier of the ID namespace association that you want to retrieve.
    /// This member is required.
    public var idNamespaceAssociationIdentifier: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        idNamespaceAssociationIdentifier: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.idNamespaceAssociationIdentifier = idNamespaceAssociationIdentifier
    }
}

extension CleanRoomsClientTypes {

    /// The configuration settings for the ID mapping table.
    public struct IdMappingConfig: Swift.Sendable {
        /// An indicator as to whether you can use your column as a dimension column in the ID mapping table (TRUE) or not (FALSE). Default is FALSE.
        /// This member is required.
        public var allowUseAsDimensionColumn: Swift.Bool

        public init(
            allowUseAsDimensionColumn: Swift.Bool = false
        )
        {
            self.allowUseAsDimensionColumn = allowUseAsDimensionColumn
        }
    }
}

extension CleanRoomsClientTypes {

    /// Provides the information for the ID namespace association input reference configuration.
    public struct IdNamespaceAssociationInputReferenceConfig: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the Entity Resolution resource that is being associated to the collaboration. Valid resource ARNs are from the ID namespaces that you own.
        /// This member is required.
        public var inputReferenceArn: Swift.String?
        /// When TRUE, Clean Rooms manages permissions for the ID namespace association resource. When FALSE, the resource owner manages permissions for the ID namespace association resource.
        /// This member is required.
        public var manageResourcePolicies: Swift.Bool?

        public init(
            inputReferenceArn: Swift.String? = nil,
            manageResourcePolicies: Swift.Bool? = nil
        )
        {
            self.inputReferenceArn = inputReferenceArn
            self.manageResourcePolicies = manageResourcePolicies
        }
    }
}

extension CleanRoomsClientTypes {

    /// Provides the information for the ID namespace association input reference properties.
    public struct IdNamespaceAssociationInputReferenceProperties: Swift.Sendable {
        /// Defines how ID mapping workflows are supported for this ID namespace association.
        /// This member is required.
        public var idMappingWorkflowsSupported: [Smithy.Document]?
        /// The ID namespace type for this ID namespace association.
        /// This member is required.
        public var idNamespaceType: CleanRoomsClientTypes.IdNamespaceType?

        public init(
            idMappingWorkflowsSupported: [Smithy.Document]? = nil,
            idNamespaceType: CleanRoomsClientTypes.IdNamespaceType? = nil
        )
        {
            self.idMappingWorkflowsSupported = idMappingWorkflowsSupported
            self.idNamespaceType = idNamespaceType
        }
    }
}

extension CleanRoomsClientTypes {

    /// Defines details for the collaboration ID namespace association.
    public struct CollaborationIdNamespaceAssociation: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the collaboration ID namespace association.
        /// This member is required.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the collaboration that contains the collaboration ID namespace association.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique identifier of the collaboration that contains the collaboration ID namespace association.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time at which the collaboration ID namespace association was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The unique identifier of the Amazon Web Services account that created the collaboration ID namespace association.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// The description of the collaboration ID namespace association.
        public var description: Swift.String?
        /// The unique identifier of the collaboration ID namespace association.
        /// This member is required.
        public var id: Swift.String?
        /// The configuration settings for the ID mapping table.
        public var idMappingConfig: CleanRoomsClientTypes.IdMappingConfig?
        /// The input reference configuration that's necessary to create the collaboration ID namespace association.
        /// This member is required.
        public var inputReferenceConfig: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceConfig?
        /// The input reference properties that are needed to create the collaboration ID namespace association.
        /// This member is required.
        public var inputReferenceProperties: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceProperties?
        /// The name of the collaboration ID namespace association.
        /// This member is required.
        public var name: Swift.String?
        /// The most recent time at which the collaboration ID namespace was updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            idMappingConfig: CleanRoomsClientTypes.IdMappingConfig? = nil,
            inputReferenceConfig: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceConfig? = nil,
            inputReferenceProperties: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceProperties? = nil,
            name: Swift.String? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.id = id
            self.idMappingConfig = idMappingConfig
            self.inputReferenceConfig = inputReferenceConfig
            self.inputReferenceProperties = inputReferenceProperties
            self.name = name
            self.updateTime = updateTime
        }
    }
}

public struct GetCollaborationIdNamespaceAssociationOutput: Swift.Sendable {
    /// The ID namespace association that you requested.
    /// This member is required.
    public var collaborationIdNamespaceAssociation: CleanRoomsClientTypes.CollaborationIdNamespaceAssociation?

    public init(
        collaborationIdNamespaceAssociation: CleanRoomsClientTypes.CollaborationIdNamespaceAssociation? = nil
    )
    {
        self.collaborationIdNamespaceAssociation = collaborationIdNamespaceAssociation
    }
}

public struct GetCollaborationPrivacyBudgetTemplateInput: Swift.Sendable {
    /// A unique identifier for one of your collaborations.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// A unique identifier for one of your privacy budget templates.
    /// This member is required.
    public var privacyBudgetTemplateIdentifier: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        privacyBudgetTemplateIdentifier: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.privacyBudgetTemplateIdentifier = privacyBudgetTemplateIdentifier
    }
}

extension CleanRoomsClientTypes {

    public enum PrivacyBudgetTemplateAutoRefresh: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case calendarMonth
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [PrivacyBudgetTemplateAutoRefresh] {
            return [
                .calendarMonth,
                .none
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .calendarMonth: return "CALENDAR_MONTH"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// The epsilon and noise parameter values that were used for the differential privacy template.
    public struct DifferentialPrivacyTemplateParametersOutput: Swift.Sendable {
        /// The epsilon value that you specified.
        /// This member is required.
        public var epsilon: Swift.Int?
        /// Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        /// This member is required.
        public var usersNoisePerQuery: Swift.Int?

        public init(
            epsilon: Swift.Int? = nil,
            usersNoisePerQuery: Swift.Int? = nil
        )
        {
            self.epsilon = epsilon
            self.usersNoisePerQuery = usersNoisePerQuery
        }
    }
}

extension CleanRoomsClientTypes {

    /// The epsilon and noise parameters that were used in the privacy budget template.
    public enum PrivacyBudgetTemplateParametersOutput: Swift.Sendable {
        /// The epsilon and noise parameters.
        case differentialprivacy(CleanRoomsClientTypes.DifferentialPrivacyTemplateParametersOutput)
        case sdkUnknown(Swift.String)
    }
}

extension CleanRoomsClientTypes {

    public enum PrivacyBudgetType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case differentialPrivacy
        case sdkUnknown(Swift.String)

        public static var allCases: [PrivacyBudgetType] {
            return [
                .differentialPrivacy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .differentialPrivacy: return "DIFFERENTIAL_PRIVACY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// An array that specifies the information for a collaboration's privacy budget template.
    public struct CollaborationPrivacyBudgetTemplate: Swift.Sendable {
        /// The ARN of the collaboration privacy budget template.
        /// This member is required.
        public var arn: Swift.String?
        /// How often the privacy budget refreshes. If you plan to regularly bring new data into the collaboration, use CALENDAR_MONTH to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queried across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.
        /// This member is required.
        public var autoRefresh: CleanRoomsClientTypes.PrivacyBudgetTemplateAutoRefresh?
        /// The ARN of the collaboration that includes this collaboration privacy budget template.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique identifier of the collaboration that includes this collaboration privacy budget template.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time at which the collaboration privacy budget template was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The unique identifier of the account that created this collaboration privacy budget template.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// The unique identifier of the collaboration privacy budget template.
        /// This member is required.
        public var id: Swift.String?
        /// Specifies the epsilon and noise parameters for the privacy budget template.
        /// This member is required.
        public var parameters: CleanRoomsClientTypes.PrivacyBudgetTemplateParametersOutput?
        /// The type of privacy budget template.
        /// This member is required.
        public var privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType?
        /// The most recent time at which the collaboration privacy budget template was updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            autoRefresh: CleanRoomsClientTypes.PrivacyBudgetTemplateAutoRefresh? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            id: Swift.String? = nil,
            parameters: CleanRoomsClientTypes.PrivacyBudgetTemplateParametersOutput? = nil,
            privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.autoRefresh = autoRefresh
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.id = id
            self.parameters = parameters
            self.privacyBudgetType = privacyBudgetType
            self.updateTime = updateTime
        }
    }
}

public struct GetCollaborationPrivacyBudgetTemplateOutput: Swift.Sendable {
    /// Returns the details of the privacy budget template that you requested.
    /// This member is required.
    public var collaborationPrivacyBudgetTemplate: CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplate?

    public init(
        collaborationPrivacyBudgetTemplate: CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplate? = nil
    )
    {
        self.collaborationPrivacyBudgetTemplate = collaborationPrivacyBudgetTemplate
    }
}

public struct GetSchemaInput: Swift.Sendable {
    /// A unique identifier for the collaboration that the schema belongs to. Currently accepts a collaboration ID.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The name of the relation to retrieve the schema for.
    /// This member is required.
    public var name: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.name = name
    }
}

public struct GetSchemaOutput: Swift.Sendable {
    /// The entire schema object.
    /// This member is required.
    public var schema: CleanRoomsClientTypes.Schema?

    public init(
        schema: CleanRoomsClientTypes.Schema? = nil
    )
    {
        self.schema = schema
    }
}

public struct GetSchemaAnalysisRuleInput: Swift.Sendable {
    /// A unique identifier for the collaboration that the schema belongs to. Currently accepts a collaboration ID.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The name of the schema to retrieve the analysis rule for.
    /// This member is required.
    public var name: Swift.String?
    /// The type of the schema analysis rule to retrieve. Schema analysis rules are uniquely identified by a combination of the collaboration, the schema name, and their type.
    /// This member is required.
    public var type: CleanRoomsClientTypes.AnalysisRuleType?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        type: CleanRoomsClientTypes.AnalysisRuleType? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.name = name
        self.type = type
    }
}

public struct GetSchemaAnalysisRuleOutput: Swift.Sendable {
    /// A specification about how data from the configured table can be used.
    /// This member is required.
    public var analysisRule: CleanRoomsClientTypes.AnalysisRule?

    public init(
        analysisRule: CleanRoomsClientTypes.AnalysisRule? = nil
    )
    {
        self.analysisRule = analysisRule
    }
}

public struct ListCollaborationAnalysisTemplatesInput: Swift.Sendable {
    /// A unique identifier for the collaboration that the analysis templates belong to. Currently accepts collaboration ID.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the `maxResults` value has not been met.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CleanRoomsClientTypes {

    /// The metadata of the analysis template within a collaboration.
    public struct CollaborationAnalysisTemplateSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the analysis template.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique ARN for the analysis template’s associated collaboration.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// A unique identifier for the collaboration that the analysis templates belong to. Currently accepts collaboration ID.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time that the summary of the analysis template in a collaboration was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// The description of the analysis template.
        public var description: Swift.String?
        /// The identifier of the analysis template.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the analysis template.
        /// This member is required.
        public var name: Swift.String?
        /// The time that the summary of the analysis template in the collaboration was last updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.id = id
            self.name = name
            self.updateTime = updateTime
        }
    }
}

public struct ListCollaborationAnalysisTemplatesOutput: Swift.Sendable {
    /// The metadata of the analysis template within a collaboration.
    /// This member is required.
    public var collaborationAnalysisTemplateSummaries: [CleanRoomsClientTypes.CollaborationAnalysisTemplateSummary]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        collaborationAnalysisTemplateSummaries: [CleanRoomsClientTypes.CollaborationAnalysisTemplateSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationAnalysisTemplateSummaries = collaborationAnalysisTemplateSummaries
        self.nextToken = nextToken
    }
}

public struct ListCollaborationConfiguredAudienceModelAssociationsInput: Swift.Sendable {
    /// A unique identifier for the collaboration that the configured audience model association belongs to. Accepts a collaboration ID.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the `maxResults` value has not been met.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CleanRoomsClientTypes {

    /// A summary of the configured audience model association in the collaboration.
    public struct CollaborationConfiguredAudienceModelAssociationSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the configured audience model association.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique ARN for the configured audience model's associated collaboration.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// A unique identifier for the collaboration that the configured audience model associations belong to. Accepts collaboration ID.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time at which the configured audience model association was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The identifier used to reference members of the collaboration. Only supports Amazon Web Services account ID.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// The description of the configured audience model association.
        public var description: Swift.String?
        /// The identifier of the configured audience model association.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the configured audience model association.
        /// This member is required.
        public var name: Swift.String?
        /// The most recent time at which the configured audience model association was updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.id = id
            self.name = name
            self.updateTime = updateTime
        }
    }
}

public struct ListCollaborationConfiguredAudienceModelAssociationsOutput: Swift.Sendable {
    /// The metadata of the configured audience model association within a collaboration.
    /// This member is required.
    public var collaborationConfiguredAudienceModelAssociationSummaries: [CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociationSummary]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        collaborationConfiguredAudienceModelAssociationSummaries: [CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationConfiguredAudienceModelAssociationSummaries = collaborationConfiguredAudienceModelAssociationSummaries
        self.nextToken = nextToken
    }
}

public struct ListCollaborationIdNamespaceAssociationsInput: Swift.Sendable {
    /// The unique identifier of the collaboration that contains the ID namespace associations that you want to retrieve.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service may return a nextToken even if the maximum results has not been met.>
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CleanRoomsClientTypes {

    /// Detailed information about the ID namespace association input reference properties.
    public struct IdNamespaceAssociationInputReferencePropertiesSummary: Swift.Sendable {
        /// The ID namespace type for this ID namespace association.
        /// This member is required.
        public var idNamespaceType: CleanRoomsClientTypes.IdNamespaceType?

        public init(
            idNamespaceType: CleanRoomsClientTypes.IdNamespaceType? = nil
        )
        {
            self.idNamespaceType = idNamespaceType
        }
    }
}

extension CleanRoomsClientTypes {

    /// Provides summary information about the collaboration ID namespace association.
    public struct CollaborationIdNamespaceAssociationSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the collaboration ID namespace association.
        /// This member is required.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the collaboration that contains this collaboration ID namespace association.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique identifier of the collaboration that contains this collaboration ID namespace association.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time at which the collaboration ID namespace association was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The Amazon Web Services account that created this collaboration ID namespace association.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// The description of the collaboration ID namepsace association.
        public var description: Swift.String?
        /// The unique identifier of the collaboration ID namespace association.
        /// This member is required.
        public var id: Swift.String?
        /// The input reference configuration that's used to create the collaboration ID namespace association.
        /// This member is required.
        public var inputReferenceConfig: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceConfig?
        /// The input reference properties that are used to create the collaboration ID namespace association.
        /// This member is required.
        public var inputReferenceProperties: CleanRoomsClientTypes.IdNamespaceAssociationInputReferencePropertiesSummary?
        /// The name of the collaboration ID namespace association.
        /// This member is required.
        public var name: Swift.String?
        /// The most recent time at which the collaboration ID namespace association was updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            inputReferenceConfig: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceConfig? = nil,
            inputReferenceProperties: CleanRoomsClientTypes.IdNamespaceAssociationInputReferencePropertiesSummary? = nil,
            name: Swift.String? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.description = description
            self.id = id
            self.inputReferenceConfig = inputReferenceConfig
            self.inputReferenceProperties = inputReferenceProperties
            self.name = name
            self.updateTime = updateTime
        }
    }
}

public struct ListCollaborationIdNamespaceAssociationsOutput: Swift.Sendable {
    /// The summary information of the collaboration ID namespace associations that you requested.
    /// This member is required.
    public var collaborationIdNamespaceAssociationSummaries: [CleanRoomsClientTypes.CollaborationIdNamespaceAssociationSummary]?
    /// The token value provided to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        collaborationIdNamespaceAssociationSummaries: [CleanRoomsClientTypes.CollaborationIdNamespaceAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationIdNamespaceAssociationSummaries = collaborationIdNamespaceAssociationSummaries
        self.nextToken = nextToken
    }
}

public struct ListCollaborationPrivacyBudgetsInput: Swift.Sendable {
    /// A unique identifier for one of your collaborations.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the `maxResults` value has not been met.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// Specifies the type of the privacy budget.
    /// This member is required.
    public var privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.privacyBudgetType = privacyBudgetType
    }
}

extension CleanRoomsClientTypes {

    public enum DifferentialPrivacyAggregationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case avg
        case count
        case countDistinct
        case stddev
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [DifferentialPrivacyAggregationType] {
            return [
                .avg,
                .count,
                .countDistinct,
                .stddev,
                .sum
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .avg: return "AVG"
            case .count: return "COUNT"
            case .countDistinct: return "COUNT_DISTINCT"
            case .stddev: return "STDDEV"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// Information about the total number of aggregations, as well as the remaining aggregations.
    public struct DifferentialPrivacyPrivacyBudgetAggregation: Swift.Sendable {
        /// The maximum number of aggregation functions that you can perform with the given privacy budget.
        /// This member is required.
        public var maxCount: Swift.Int?
        /// The remaining number of aggregation functions that can be run with the available privacy budget.
        /// This member is required.
        public var remainingCount: Swift.Int?
        /// The different types of aggregation functions that you can perform.
        /// This member is required.
        public var type: CleanRoomsClientTypes.DifferentialPrivacyAggregationType?

        public init(
            maxCount: Swift.Int? = nil,
            remainingCount: Swift.Int? = nil,
            type: CleanRoomsClientTypes.DifferentialPrivacyAggregationType? = nil
        )
        {
            self.maxCount = maxCount
            self.remainingCount = remainingCount
            self.type = type
        }
    }
}

extension CleanRoomsClientTypes {

    /// Specifies the configured epsilon value and the utility in terms of total aggregations, as well as the remaining aggregations available.
    public struct DifferentialPrivacyPrivacyBudget: Swift.Sendable {
        /// This information includes the configured epsilon value and the utility in terms of total aggregations, as well as the remaining aggregations.
        /// This member is required.
        public var aggregations: [CleanRoomsClientTypes.DifferentialPrivacyPrivacyBudgetAggregation]?
        /// The epsilon value that you configured.
        /// This member is required.
        public var epsilon: Swift.Int?

        public init(
            aggregations: [CleanRoomsClientTypes.DifferentialPrivacyPrivacyBudgetAggregation]? = nil,
            epsilon: Swift.Int? = nil
        )
        {
            self.aggregations = aggregations
            self.epsilon = epsilon
        }
    }
}

extension CleanRoomsClientTypes {

    /// The epsilon parameter value and number of each aggregation function that you can perform.
    public enum PrivacyBudget: Swift.Sendable {
        /// An object that specifies the epsilon parameter and the utility in terms of total aggregations, as well as the remaining aggregations available.
        case differentialprivacy(CleanRoomsClientTypes.DifferentialPrivacyPrivacyBudget)
        case sdkUnknown(Swift.String)
    }
}

extension CleanRoomsClientTypes {

    /// A summary of the collaboration privacy budgets. This summary includes the collaboration information, creation information, epsilon provided, and utility in terms of aggregations.
    public struct CollaborationPrivacyBudgetSummary: Swift.Sendable {
        /// The includes epsilon provided and utility in terms of aggregations.
        /// This member is required.
        public var budget: CleanRoomsClientTypes.PrivacyBudget?
        /// The ARN of the collaboration that includes this privacy budget.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique identifier of the collaboration that includes this privacy budget.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time at which the privacy budget was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The unique identifier of the account that created this privacy budget.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// The unique identifier of the collaboration privacy budget.
        /// This member is required.
        public var id: Swift.String?
        /// The ARN of the collaboration privacy budget template.
        /// This member is required.
        public var privacyBudgetTemplateArn: Swift.String?
        /// The unique identifier of the collaboration privacy budget template.
        /// This member is required.
        public var privacyBudgetTemplateId: Swift.String?
        /// The type of privacy budget template.
        /// This member is required.
        public var type: CleanRoomsClientTypes.PrivacyBudgetType?
        /// The most recent time at which the privacy budget was updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            budget: CleanRoomsClientTypes.PrivacyBudget? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            id: Swift.String? = nil,
            privacyBudgetTemplateArn: Swift.String? = nil,
            privacyBudgetTemplateId: Swift.String? = nil,
            type: CleanRoomsClientTypes.PrivacyBudgetType? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.budget = budget
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.id = id
            self.privacyBudgetTemplateArn = privacyBudgetTemplateArn
            self.privacyBudgetTemplateId = privacyBudgetTemplateId
            self.type = type
            self.updateTime = updateTime
        }
    }
}

public struct ListCollaborationPrivacyBudgetsOutput: Swift.Sendable {
    /// Summaries of the collaboration privacy budgets.
    /// This member is required.
    public var collaborationPrivacyBudgetSummaries: [CleanRoomsClientTypes.CollaborationPrivacyBudgetSummary]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        collaborationPrivacyBudgetSummaries: [CleanRoomsClientTypes.CollaborationPrivacyBudgetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationPrivacyBudgetSummaries = collaborationPrivacyBudgetSummaries
        self.nextToken = nextToken
    }
}

public struct ListCollaborationPrivacyBudgetTemplatesInput: Swift.Sendable {
    /// A unique identifier for one of your collaborations.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the `maxResults` value has not been met.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CleanRoomsClientTypes {

    /// A summary of the collaboration's privacy budget template. This summary includes information about who created the privacy budget template and what collaborations it belongs to.
    public struct CollaborationPrivacyBudgetTemplateSummary: Swift.Sendable {
        /// The ARN of the collaboration privacy budget template.
        /// This member is required.
        public var arn: Swift.String?
        /// The ARN of the collaboration that contains this collaboration privacy budget template.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique identifier of the collaboration that contains this collaboration privacy budget template.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time at which the collaboration privacy budget template was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The unique identifier of the account that created this collaboration privacy budget template.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// The unique identifier of the collaboration privacy budget template.
        /// This member is required.
        public var id: Swift.String?
        /// The type of the privacy budget template.
        /// This member is required.
        public var privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType?
        /// The most recent time at which the collaboration privacy budget template was updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            id: Swift.String? = nil,
            privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.id = id
            self.privacyBudgetType = privacyBudgetType
            self.updateTime = updateTime
        }
    }
}

public struct ListCollaborationPrivacyBudgetTemplatesOutput: Swift.Sendable {
    /// An array that summarizes the collaboration privacy budget templates. The summary includes collaboration information, creation information, the privacy budget type.
    /// This member is required.
    public var collaborationPrivacyBudgetTemplateSummaries: [CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplateSummary]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        collaborationPrivacyBudgetTemplateSummaries: [CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplateSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationPrivacyBudgetTemplateSummaries = collaborationPrivacyBudgetTemplateSummaries
        self.nextToken = nextToken
    }
}

extension CleanRoomsClientTypes {

    public enum FilterableMemberStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case invited
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterableMemberStatus] {
            return [
                .active,
                .invited
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .invited: return "INVITED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListCollaborationsInput: Swift.Sendable {
    /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the `maxResults` value has not been met.
    public var maxResults: Swift.Int?
    /// The caller's status in a collaboration.
    public var memberStatus: CleanRoomsClientTypes.FilterableMemberStatus?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        memberStatus: CleanRoomsClientTypes.FilterableMemberStatus? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.memberStatus = memberStatus
        self.nextToken = nextToken
    }
}

extension CleanRoomsClientTypes {

    /// The metadata of the collaboration.
    public struct CollaborationSummary: Swift.Sendable {
        /// The analytics engine.
        public var analyticsEngine: CleanRoomsClientTypes.AnalyticsEngine?
        /// The ARN of the collaboration.
        /// This member is required.
        public var arn: Swift.String?
        /// The time when the collaboration was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// The display name of the collaboration creator.
        /// This member is required.
        public var creatorDisplayName: Swift.String?
        /// The identifier for the collaboration.
        /// This member is required.
        public var id: Swift.String?
        /// The status of a member in a collaboration.
        /// This member is required.
        public var memberStatus: CleanRoomsClientTypes.MemberStatus?
        /// The ARN of a member in a collaboration.
        public var membershipArn: Swift.String?
        /// The identifier of a member in a collaboration.
        public var membershipId: Swift.String?
        /// A human-readable identifier provided by the collaboration owner. Display names are not unique.
        /// This member is required.
        public var name: Swift.String?
        /// The time the collaboration metadata was last updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            analyticsEngine: CleanRoomsClientTypes.AnalyticsEngine? = nil,
            arn: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            creatorDisplayName: Swift.String? = nil,
            id: Swift.String? = nil,
            memberStatus: CleanRoomsClientTypes.MemberStatus? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.analyticsEngine = analyticsEngine
            self.arn = arn
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.creatorDisplayName = creatorDisplayName
            self.id = id
            self.memberStatus = memberStatus
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }
    }
}

public struct ListCollaborationsOutput: Swift.Sendable {
    /// The list of collaborations.
    /// This member is required.
    public var collaborationList: [CleanRoomsClientTypes.CollaborationSummary]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        collaborationList: [CleanRoomsClientTypes.CollaborationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationList = collaborationList
        self.nextToken = nextToken
    }
}

public struct ListMembersInput: Swift.Sendable {
    /// The identifier of the collaboration in which the members are listed.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the `maxResults` value has not been met.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CleanRoomsClientTypes {

    /// The member object listed by the request.
    public struct MemberSummary: Swift.Sendable {
        /// The abilities granted to the collaboration member.
        /// This member is required.
        public var abilities: [CleanRoomsClientTypes.MemberAbility]?
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        /// This member is required.
        public var accountId: Swift.String?
        /// The time when the member was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The member's display name.
        /// This member is required.
        public var displayName: Swift.String?
        /// The unique ARN for the member's associated membership, if present.
        public var membershipArn: Swift.String?
        /// The unique ID for the member's associated membership, if present.
        public var membershipId: Swift.String?
        /// The collaboration member's payment responsibilities set by the collaboration creator.
        /// This member is required.
        public var paymentConfiguration: CleanRoomsClientTypes.PaymentConfiguration?
        /// The status of the member.
        /// This member is required.
        public var status: CleanRoomsClientTypes.MemberStatus?
        /// The time the member metadata was last updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            abilities: [CleanRoomsClientTypes.MemberAbility]? = nil,
            accountId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            displayName: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            paymentConfiguration: CleanRoomsClientTypes.PaymentConfiguration? = nil,
            status: CleanRoomsClientTypes.MemberStatus? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.abilities = abilities
            self.accountId = accountId
            self.createTime = createTime
            self.displayName = displayName
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.paymentConfiguration = paymentConfiguration
            self.status = status
            self.updateTime = updateTime
        }
    }
}

public struct ListMembersOutput: Swift.Sendable {
    /// The list of members returned by the ListMembers operation.
    /// This member is required.
    public var memberSummaries: [CleanRoomsClientTypes.MemberSummary]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        memberSummaries: [CleanRoomsClientTypes.MemberSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.memberSummaries = memberSummaries
        self.nextToken = nextToken
    }
}

public struct ListSchemasInput: Swift.Sendable {
    /// A unique identifier for the collaboration that the schema belongs to. Currently accepts a collaboration ID.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the `maxResults` value has not been met.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// If present, filter schemas by schema type.
    public var schemaType: CleanRoomsClientTypes.SchemaType?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        schemaType: CleanRoomsClientTypes.SchemaType? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.schemaType = schemaType
    }
}

extension CleanRoomsClientTypes {

    /// The schema summary for the objects listed by the request.
    public struct SchemaSummary: Swift.Sendable {
        /// The analysis method for the associated schema. The only valid value is currently `DIRECT_QUERY`.
        public var analysisMethod: CleanRoomsClientTypes.AnalysisMethod?
        /// The types of analysis rules that are associated with this schema object.
        /// This member is required.
        public var analysisRuleTypes: [CleanRoomsClientTypes.AnalysisRuleType]?
        /// The unique ARN for the collaboration that the schema belongs to.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique ID for the collaboration that the schema belongs to.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time the schema object was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The unique account ID for the Amazon Web Services account that owns the schema.
        /// This member is required.
        public var creatorAccountId: Swift.String?
        /// The name for the schema object.
        /// This member is required.
        public var name: Swift.String?
        /// The type of schema object.
        /// This member is required.
        public var type: CleanRoomsClientTypes.SchemaType?
        /// The time the schema object was last updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            analysisMethod: CleanRoomsClientTypes.AnalysisMethod? = nil,
            analysisRuleTypes: [CleanRoomsClientTypes.AnalysisRuleType]? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            creatorAccountId: Swift.String? = nil,
            name: Swift.String? = nil,
            type: CleanRoomsClientTypes.SchemaType? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.analysisMethod = analysisMethod
            self.analysisRuleTypes = analysisRuleTypes
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.creatorAccountId = creatorAccountId
            self.name = name
            self.type = type
            self.updateTime = updateTime
        }
    }
}

public struct ListSchemasOutput: Swift.Sendable {
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// The retrieved list of schemas.
    /// This member is required.
    public var schemaSummaries: [CleanRoomsClientTypes.SchemaSummary]?

    public init(
        nextToken: Swift.String? = nil,
        schemaSummaries: [CleanRoomsClientTypes.SchemaSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.schemaSummaries = schemaSummaries
    }
}

public struct UpdateCollaborationInput: Swift.Sendable {
    /// The identifier for the collaboration.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// A description of the collaboration.
    public var description: Swift.String?
    /// A human-readable identifier provided by the collaboration owner. Display names are not unique.
    public var name: Swift.String?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.description = description
        self.name = name
    }
}

public struct UpdateCollaborationOutput: Swift.Sendable {
    /// The entire collaboration that has been updated.
    /// This member is required.
    public var collaboration: CleanRoomsClientTypes.Collaboration?

    public init(
        collaboration: CleanRoomsClientTypes.Collaboration? = nil
    )
    {
        self.collaboration = collaboration
    }
}

public struct CreateConfiguredAudienceModelAssociationInput: Swift.Sendable {
    /// A unique identifier for the configured audience model that you want to associate.
    /// This member is required.
    public var configuredAudienceModelArn: Swift.String?
    /// The name of the configured audience model association.
    /// This member is required.
    public var configuredAudienceModelAssociationName: Swift.String?
    /// A description of the configured audience model association.
    public var description: Swift.String?
    /// When TRUE, indicates that the resource policy for the configured audience model resource being associated is configured for Clean Rooms to manage permissions related to the given collaboration. When FALSE, indicates that the configured audience model resource owner will manage permissions related to the given collaboration. Setting this to TRUE requires you to have permissions to create, update, and delete the resource policy for the cleanrooms-ml resource when you call the [DeleteConfiguredAudienceModelAssociation] resource. In addition, if you are the collaboration creator and specify TRUE, you must have the same permissions when you call the [DeleteMember] and [DeleteCollaboration] APIs.
    /// This member is required.
    public var manageResourcePolicies: Swift.Bool?
    /// A unique identifier for one of your memberships for a collaboration. The configured audience model is associated to the collaboration that this membership belongs to. Accepts a membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        configuredAudienceModelArn: Swift.String? = nil,
        configuredAudienceModelAssociationName: Swift.String? = nil,
        description: Swift.String? = nil,
        manageResourcePolicies: Swift.Bool? = nil,
        membershipIdentifier: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.configuredAudienceModelArn = configuredAudienceModelArn
        self.configuredAudienceModelAssociationName = configuredAudienceModelAssociationName
        self.description = description
        self.manageResourcePolicies = manageResourcePolicies
        self.membershipIdentifier = membershipIdentifier
        self.tags = tags
    }
}

extension CleanRoomsClientTypes {

    /// Details about the configured audience model association.
    public struct ConfiguredAudienceModelAssociation: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the configured audience model association.
        /// This member is required.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the collaboration that contains this configured audience model association.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// A unique identifier of the collaboration that contains this configured audience model association.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the configured audience model that was used for this configured audience model association.
        /// This member is required.
        public var configuredAudienceModelArn: Swift.String?
        /// The time at which the configured audience model association was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The description of the configured audience model association.
        public var description: Swift.String?
        /// A unique identifier of the configured audience model association.
        /// This member is required.
        public var id: Swift.String?
        /// When TRUE, indicates that the resource policy for the configured audience model resource being associated is configured for Clean Rooms to manage permissions related to the given collaboration. When FALSE, indicates that the configured audience model resource owner will manage permissions related to the given collaboration.
        /// This member is required.
        public var manageResourcePolicies: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the membership that contains this configured audience model association.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// A unique identifier for the membership that contains this configured audience model association.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The name of the configured audience model association.
        /// This member is required.
        public var name: Swift.String?
        /// The most recent time at which the configured audience model association was updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            configuredAudienceModelArn: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            manageResourcePolicies: Swift.Bool? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.createTime = createTime
            self.description = description
            self.id = id
            self.manageResourcePolicies = manageResourcePolicies
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }
    }
}

public struct CreateConfiguredAudienceModelAssociationOutput: Swift.Sendable {
    /// Information about the configured audience model association.
    /// This member is required.
    public var configuredAudienceModelAssociation: CleanRoomsClientTypes.ConfiguredAudienceModelAssociation?

    public init(
        configuredAudienceModelAssociation: CleanRoomsClientTypes.ConfiguredAudienceModelAssociation? = nil
    )
    {
        self.configuredAudienceModelAssociation = configuredAudienceModelAssociation
    }
}

public struct DeleteConfiguredAudienceModelAssociationInput: Swift.Sendable {
    /// A unique identifier of the configured audience model association that you want to delete.
    /// This member is required.
    public var configuredAudienceModelAssociationIdentifier: Swift.String?
    /// A unique identifier of the membership that contains the audience model association that you want to delete.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        configuredAudienceModelAssociationIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.configuredAudienceModelAssociationIdentifier = configuredAudienceModelAssociationIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

public struct DeleteConfiguredAudienceModelAssociationOutput: Swift.Sendable {

    public init() { }
}

public struct GetConfiguredAudienceModelAssociationInput: Swift.Sendable {
    /// A unique identifier for the configured audience model association that you want to retrieve.
    /// This member is required.
    public var configuredAudienceModelAssociationIdentifier: Swift.String?
    /// A unique identifier for the membership that contains the configured audience model association that you want to retrieve.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        configuredAudienceModelAssociationIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.configuredAudienceModelAssociationIdentifier = configuredAudienceModelAssociationIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

public struct GetConfiguredAudienceModelAssociationOutput: Swift.Sendable {
    /// Information about the configured audience model association that you requested.
    /// This member is required.
    public var configuredAudienceModelAssociation: CleanRoomsClientTypes.ConfiguredAudienceModelAssociation?

    public init(
        configuredAudienceModelAssociation: CleanRoomsClientTypes.ConfiguredAudienceModelAssociation? = nil
    )
    {
        self.configuredAudienceModelAssociation = configuredAudienceModelAssociation
    }
}

public struct ListConfiguredAudienceModelAssociationsInput: Swift.Sendable {
    /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the `maxResults` value has not been met.
    public var maxResults: Swift.Int?
    /// A unique identifier for a membership that contains the configured audience model associations that you want to retrieve.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        membershipIdentifier: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.membershipIdentifier = membershipIdentifier
        self.nextToken = nextToken
    }
}

extension CleanRoomsClientTypes {

    /// A summary of the configured audience model association.
    public struct ConfiguredAudienceModelAssociationSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the configured audience model association.
        /// This member is required.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the collaboration that contains the configured audience model association.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// A unique identifier of the collaboration that configured audience model is associated with.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The Amazon Resource Name (ARN) of the configured audience model that was used for this configured audience model association.
        /// This member is required.
        public var configuredAudienceModelArn: Swift.String?
        /// The time at which the configured audience model association was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The description of the configured audience model association.
        public var description: Swift.String?
        /// A unique identifier of the configured audience model association.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the membership that contains the configured audience model association.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// A unique identifier of the membership that contains the configured audience model association.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The name of the configured audience model association.
        /// This member is required.
        public var name: Swift.String?
        /// The most recent time at which the configured audience model association was updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            configuredAudienceModelArn: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.configuredAudienceModelArn = configuredAudienceModelArn
            self.createTime = createTime
            self.description = description
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }
    }
}

public struct ListConfiguredAudienceModelAssociationsOutput: Swift.Sendable {
    /// Summaries of the configured audience model associations that you requested.
    /// This member is required.
    public var configuredAudienceModelAssociationSummaries: [CleanRoomsClientTypes.ConfiguredAudienceModelAssociationSummary]?
    /// The token value provided to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        configuredAudienceModelAssociationSummaries: [CleanRoomsClientTypes.ConfiguredAudienceModelAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configuredAudienceModelAssociationSummaries = configuredAudienceModelAssociationSummaries
        self.nextToken = nextToken
    }
}

public struct UpdateConfiguredAudienceModelAssociationInput: Swift.Sendable {
    /// A unique identifier for the configured audience model association that you want to update.
    /// This member is required.
    public var configuredAudienceModelAssociationIdentifier: Swift.String?
    /// A new description for the configured audience model association.
    public var description: Swift.String?
    /// A unique identifier of the membership that contains the configured audience model association that you want to update.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// A new name for the configured audience model association.
    public var name: Swift.String?

    public init(
        configuredAudienceModelAssociationIdentifier: Swift.String? = nil,
        description: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.configuredAudienceModelAssociationIdentifier = configuredAudienceModelAssociationIdentifier
        self.description = description
        self.membershipIdentifier = membershipIdentifier
        self.name = name
    }
}

public struct UpdateConfiguredAudienceModelAssociationOutput: Swift.Sendable {
    /// Details about the configured audience model association that you updated.
    /// This member is required.
    public var configuredAudienceModelAssociation: CleanRoomsClientTypes.ConfiguredAudienceModelAssociation?

    public init(
        configuredAudienceModelAssociation: CleanRoomsClientTypes.ConfiguredAudienceModelAssociation? = nil
    )
    {
        self.configuredAudienceModelAssociation = configuredAudienceModelAssociation
    }
}

public struct CreateConfiguredTableAssociationInput: Swift.Sendable {
    /// A unique identifier for the configured table to be associated to. Currently accepts a configured table ID.
    /// This member is required.
    public var configuredTableIdentifier: Swift.String?
    /// A description for the configured table association.
    public var description: Swift.String?
    /// A unique identifier for one of your memberships for a collaboration. The configured table is associated to the collaboration that this membership belongs to. Currently accepts a membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The name of the configured table association. This name is used to query the underlying configured table.
    /// This member is required.
    public var name: Swift.String?
    /// The service will assume this role to access catalog metadata and query the table.
    /// This member is required.
    public var roleArn: Swift.String?
    /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        configuredTableIdentifier: Swift.String? = nil,
        description: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.configuredTableIdentifier = configuredTableIdentifier
        self.description = description
        self.membershipIdentifier = membershipIdentifier
        self.name = name
        self.roleArn = roleArn
        self.tags = tags
    }
}

extension CleanRoomsClientTypes {

    public enum ConfiguredTableAssociationAnalysisRuleType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aggregation
        case custom
        case list
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfiguredTableAssociationAnalysisRuleType] {
            return [
                .aggregation,
                .custom,
                .list
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aggregation: return "AGGREGATION"
            case .custom: return "CUSTOM"
            case .list: return "LIST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// A configured table association links a configured table to a collaboration.
    public struct ConfiguredTableAssociation: Swift.Sendable {
        /// The analysis rule types for the configured table association.
        public var analysisRuleTypes: [CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleType]?
        /// The unique ARN for the configured table association.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique ARN for the configured table that the association refers to.
        /// This member is required.
        public var configuredTableArn: Swift.String?
        /// The unique ID for the configured table that the association refers to.
        /// This member is required.
        public var configuredTableId: Swift.String?
        /// The time the configured table association was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// A description of the configured table association.
        public var description: Swift.String?
        /// The unique ID for the configured table association.
        /// This member is required.
        public var id: Swift.String?
        /// The unique ARN for the membership this configured table association belongs to.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The unique ID for the membership this configured table association belongs to.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The name of the configured table association, in lowercase. The table is identified by this name when running protected queries against the underlying data.
        /// This member is required.
        public var name: Swift.String?
        /// The service will assume this role to access catalog metadata and query the table.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The time the configured table association was last updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            analysisRuleTypes: [CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleType]? = nil,
            arn: Swift.String? = nil,
            configuredTableArn: Swift.String? = nil,
            configuredTableId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.analysisRuleTypes = analysisRuleTypes
            self.arn = arn
            self.configuredTableArn = configuredTableArn
            self.configuredTableId = configuredTableId
            self.createTime = createTime
            self.description = description
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.roleArn = roleArn
            self.updateTime = updateTime
        }
    }
}

public struct CreateConfiguredTableAssociationOutput: Swift.Sendable {
    /// The configured table association.
    /// This member is required.
    public var configuredTableAssociation: CleanRoomsClientTypes.ConfiguredTableAssociation?

    public init(
        configuredTableAssociation: CleanRoomsClientTypes.ConfiguredTableAssociation? = nil
    )
    {
        self.configuredTableAssociation = configuredTableAssociation
    }
}

extension CleanRoomsClientTypes {

    /// The configured table association analysis rule applied to a configured table with the aggregation analysis rule.
    public struct ConfiguredTableAssociationAnalysisRuleAggregation: Swift.Sendable {
        /// The list of resources or wildcards (ARNs) that are allowed to perform additional analysis on query output. The allowedAdditionalAnalyses parameter is currently supported for the list analysis rule (AnalysisRuleList) and the custom analysis rule (AnalysisRuleCustom).
        public var allowedAdditionalAnalyses: [Swift.String]?
        /// The list of collaboration members who are allowed to receive results of queries run with this configured table.
        public var allowedResultReceivers: [Swift.String]?

        public init(
            allowedAdditionalAnalyses: [Swift.String]? = nil,
            allowedResultReceivers: [Swift.String]? = nil
        )
        {
            self.allowedAdditionalAnalyses = allowedAdditionalAnalyses
            self.allowedResultReceivers = allowedResultReceivers
        }
    }
}

extension CleanRoomsClientTypes {

    /// The configured table association analysis rule applied to a configured table with the custom analysis rule.
    public struct ConfiguredTableAssociationAnalysisRuleCustom: Swift.Sendable {
        /// The list of resources or wildcards (ARNs) that are allowed to perform additional analysis on query output.
        public var allowedAdditionalAnalyses: [Swift.String]?
        /// The list of collaboration members who are allowed to receive results of queries run with this configured table.
        public var allowedResultReceivers: [Swift.String]?

        public init(
            allowedAdditionalAnalyses: [Swift.String]? = nil,
            allowedResultReceivers: [Swift.String]? = nil
        )
        {
            self.allowedAdditionalAnalyses = allowedAdditionalAnalyses
            self.allowedResultReceivers = allowedResultReceivers
        }
    }
}

extension CleanRoomsClientTypes {

    /// The configured table association analysis rule applied to a configured table with the list analysis rule.
    public struct ConfiguredTableAssociationAnalysisRuleList: Swift.Sendable {
        /// The list of resources or wildcards (ARNs) that are allowed to perform additional analysis on query output.
        public var allowedAdditionalAnalyses: [Swift.String]?
        /// The list of collaboration members who are allowed to receive results of queries run with this configured table.
        public var allowedResultReceivers: [Swift.String]?

        public init(
            allowedAdditionalAnalyses: [Swift.String]? = nil,
            allowedResultReceivers: [Swift.String]? = nil
        )
        {
            self.allowedAdditionalAnalyses = allowedAdditionalAnalyses
            self.allowedResultReceivers = allowedResultReceivers
        }
    }
}

extension CleanRoomsClientTypes {

    /// Controls on the query specifications that can be run on an associated configured table.
    public enum ConfiguredTableAssociationAnalysisRulePolicyV1: Swift.Sendable {
        /// Analysis rule type that enables only list queries on a configured table.
        case list(CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleList)
        /// Analysis rule type that enables only aggregation queries on a configured table.
        case aggregation(CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleAggregation)
        /// Analysis rule type that enables the table owner to approve custom SQL queries on their configured tables. It supports differential privacy.
        case custom(CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleCustom)
        case sdkUnknown(Swift.String)
    }
}

extension CleanRoomsClientTypes {

    /// Controls on the query specifications that can be run on an associated configured table.
    public enum ConfiguredTableAssociationAnalysisRulePolicy: Swift.Sendable {
        /// The policy for the configured table association analysis rule.
        case v1(CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRulePolicyV1)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateConfiguredTableAssociationAnalysisRuleInput: Swift.Sendable {
    /// The analysis rule policy that was created for the configured table association.
    /// This member is required.
    public var analysisRulePolicy: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRulePolicy?
    /// The type of analysis rule.
    /// This member is required.
    public var analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleType?
    /// The unique ID for the configured table association. Currently accepts the configured table association ID.
    /// This member is required.
    public var configuredTableAssociationIdentifier: Swift.String?
    /// A unique identifier for the membership that the configured table association belongs to. Currently accepts the membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        analysisRulePolicy: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRulePolicy? = nil,
        analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleType? = nil,
        configuredTableAssociationIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.analysisRulePolicy = analysisRulePolicy
        self.analysisRuleType = analysisRuleType
        self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

extension CleanRoomsClientTypes {

    /// An analysis rule for a configured table association. This analysis rule specifies how data from the table can be used within its associated collaboration. In the console, the ConfiguredTableAssociationAnalysisRule is referred to as the collaboration analysis rule.
    public struct ConfiguredTableAssociationAnalysisRule: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the configured table association.
        /// This member is required.
        public var configuredTableAssociationArn: Swift.String?
        /// The unique identifier for the configured table association.
        /// This member is required.
        public var configuredTableAssociationId: Swift.String?
        /// The creation time of the configured table association analysis rule.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The membership identifier for the configured table association analysis rule.
        /// This member is required.
        public var membershipIdentifier: Swift.String?
        /// The policy of the configured table association analysis rule.
        /// This member is required.
        public var policy: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRulePolicy?
        /// The type of the configured table association analysis rule.
        /// This member is required.
        public var type: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleType?
        /// The update time of the configured table association analysis rule.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            configuredTableAssociationArn: Swift.String? = nil,
            configuredTableAssociationId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            membershipIdentifier: Swift.String? = nil,
            policy: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRulePolicy? = nil,
            type: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleType? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.configuredTableAssociationArn = configuredTableAssociationArn
            self.configuredTableAssociationId = configuredTableAssociationId
            self.createTime = createTime
            self.membershipIdentifier = membershipIdentifier
            self.policy = policy
            self.type = type
            self.updateTime = updateTime
        }
    }
}

public struct CreateConfiguredTableAssociationAnalysisRuleOutput: Swift.Sendable {
    /// The analysis rule for the conﬁgured table association. In the console, the ConfiguredTableAssociationAnalysisRule is referred to as the collaboration analysis rule.
    /// This member is required.
    public var analysisRule: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRule?

    public init(
        analysisRule: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRule? = nil
    )
    {
        self.analysisRule = analysisRule
    }
}

public struct DeleteConfiguredTableAssociationInput: Swift.Sendable {
    /// The unique ID for the configured table association to be deleted. Currently accepts the configured table ID.
    /// This member is required.
    public var configuredTableAssociationIdentifier: Swift.String?
    /// A unique identifier for the membership that the configured table association belongs to. Currently accepts the membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        configuredTableAssociationIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

public struct DeleteConfiguredTableAssociationOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteConfiguredTableAssociationAnalysisRuleInput: Swift.Sendable {
    /// The type of the analysis rule that you want to delete.
    /// This member is required.
    public var analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleType?
    /// The identiﬁer for the conﬁgured table association that's related to the analysis rule that you want to delete.
    /// This member is required.
    public var configuredTableAssociationIdentifier: Swift.String?
    /// A unique identifier for the membership that the configured table association belongs to. Currently accepts the membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleType? = nil,
        configuredTableAssociationIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.analysisRuleType = analysisRuleType
        self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

public struct DeleteConfiguredTableAssociationAnalysisRuleOutput: Swift.Sendable {

    public init() { }
}

public struct GetConfiguredTableAssociationInput: Swift.Sendable {
    /// The unique ID for the configured table association to retrieve. Currently accepts the configured table ID.
    /// This member is required.
    public var configuredTableAssociationIdentifier: Swift.String?
    /// A unique identifier for the membership that the configured table association belongs to. Currently accepts the membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        configuredTableAssociationIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

public struct GetConfiguredTableAssociationOutput: Swift.Sendable {
    /// The entire configured table association object.
    /// This member is required.
    public var configuredTableAssociation: CleanRoomsClientTypes.ConfiguredTableAssociation?

    public init(
        configuredTableAssociation: CleanRoomsClientTypes.ConfiguredTableAssociation? = nil
    )
    {
        self.configuredTableAssociation = configuredTableAssociation
    }
}

public struct GetConfiguredTableAssociationAnalysisRuleInput: Swift.Sendable {
    /// The type of analysis rule that you want to retrieve.
    /// This member is required.
    public var analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleType?
    /// The identiﬁer for the conﬁgured table association that's related to the analysis rule.
    /// This member is required.
    public var configuredTableAssociationIdentifier: Swift.String?
    /// A unique identifier for the membership that the configured table association belongs to. Currently accepts the membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleType? = nil,
        configuredTableAssociationIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.analysisRuleType = analysisRuleType
        self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

public struct GetConfiguredTableAssociationAnalysisRuleOutput: Swift.Sendable {
    /// The analysis rule for the conﬁgured table association. In the console, the ConfiguredTableAssociationAnalysisRule is referred to as the collaboration analysis rule.
    /// This member is required.
    public var analysisRule: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRule?

    public init(
        analysisRule: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRule? = nil
    )
    {
        self.analysisRule = analysisRule
    }
}

public struct ListConfiguredTableAssociationsInput: Swift.Sendable {
    /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the `maxResults` value has not been met.
    public var maxResults: Swift.Int?
    /// A unique identifier for the membership to list configured table associations for. Currently accepts the membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        membershipIdentifier: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.membershipIdentifier = membershipIdentifier
        self.nextToken = nextToken
    }
}

extension CleanRoomsClientTypes {

    /// The configured table association summary for the objects listed by the request.
    public struct ConfiguredTableAssociationSummary: Swift.Sendable {
        /// The unique ARN for the configured table association.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique configured table ID that this configured table association refers to.
        /// This member is required.
        public var configuredTableId: Swift.String?
        /// The time the configured table association was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The unique ID for the configured table association.
        /// This member is required.
        public var id: Swift.String?
        /// The unique ARN for the membership that the configured table association belongs to.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The unique ID for the membership that the configured table association belongs to.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The name of the configured table association. The table is identified by this name when running Protected Queries against the underlying data.
        /// This member is required.
        public var name: Swift.String?
        /// The time the configured table association was last updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            configuredTableId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.configuredTableId = configuredTableId
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }
    }
}

public struct ListConfiguredTableAssociationsOutput: Swift.Sendable {
    /// The retrieved list of configured table associations.
    /// This member is required.
    public var configuredTableAssociationSummaries: [CleanRoomsClientTypes.ConfiguredTableAssociationSummary]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        configuredTableAssociationSummaries: [CleanRoomsClientTypes.ConfiguredTableAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configuredTableAssociationSummaries = configuredTableAssociationSummaries
        self.nextToken = nextToken
    }
}

public struct UpdateConfiguredTableAssociationInput: Swift.Sendable {
    /// The unique identifier for the configured table association to update. Currently accepts the configured table association ID.
    /// This member is required.
    public var configuredTableAssociationIdentifier: Swift.String?
    /// A new description for the configured table association.
    public var description: Swift.String?
    /// The unique ID for the membership that the configured table association belongs to.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The service will assume this role to access catalog metadata and query the table.
    public var roleArn: Swift.String?

    public init(
        configuredTableAssociationIdentifier: Swift.String? = nil,
        description: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
        self.description = description
        self.membershipIdentifier = membershipIdentifier
        self.roleArn = roleArn
    }
}

public struct UpdateConfiguredTableAssociationOutput: Swift.Sendable {
    /// The entire updated configured table association.
    /// This member is required.
    public var configuredTableAssociation: CleanRoomsClientTypes.ConfiguredTableAssociation?

    public init(
        configuredTableAssociation: CleanRoomsClientTypes.ConfiguredTableAssociation? = nil
    )
    {
        self.configuredTableAssociation = configuredTableAssociation
    }
}

public struct UpdateConfiguredTableAssociationAnalysisRuleInput: Swift.Sendable {
    /// The updated analysis rule policy for the conﬁgured table association.
    /// This member is required.
    public var analysisRulePolicy: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRulePolicy?
    /// The analysis rule type that you want to update.
    /// This member is required.
    public var analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleType?
    /// The identifier for the configured table association to update.
    /// This member is required.
    public var configuredTableAssociationIdentifier: Swift.String?
    /// A unique identifier for the membership that the configured table association belongs to. Currently accepts the membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        analysisRulePolicy: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRulePolicy? = nil,
        analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleType? = nil,
        configuredTableAssociationIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.analysisRulePolicy = analysisRulePolicy
        self.analysisRuleType = analysisRuleType
        self.configuredTableAssociationIdentifier = configuredTableAssociationIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

public struct UpdateConfiguredTableAssociationAnalysisRuleOutput: Swift.Sendable {
    /// The updated analysis rule for the conﬁgured table association. In the console, the ConfiguredTableAssociationAnalysisRule is referred to as the collaboration analysis rule.
    /// This member is required.
    public var analysisRule: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRule?

    public init(
        analysisRule: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRule? = nil
    )
    {
        self.analysisRule = analysisRule
    }
}

extension CleanRoomsClientTypes {

    /// A reference to a table within an Glue data catalog.
    public struct GlueTableReference: Swift.Sendable {
        /// The name of the database the Glue table belongs to.
        /// This member is required.
        public var databaseName: Swift.String?
        /// The name of the Glue table.
        /// This member is required.
        public var tableName: Swift.String?

        public init(
            databaseName: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.databaseName = databaseName
            self.tableName = tableName
        }
    }
}

extension CleanRoomsClientTypes {

    /// A pointer to the dataset that underlies this table. Currently, this can only be an Glue table.
    public enum TableReference: Swift.Sendable {
        /// If present, a reference to the Glue table referred to by this table reference.
        case glue(CleanRoomsClientTypes.GlueTableReference)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateConfiguredTableInput: Swift.Sendable {
    /// The columns of the underlying table that can be used by collaborations or analysis rules.
    /// This member is required.
    public var allowedColumns: [Swift.String]?
    /// The analysis method for the configured tables. The only valid value is currently `DIRECT_QUERY`.
    /// This member is required.
    public var analysisMethod: CleanRoomsClientTypes.AnalysisMethod?
    /// A description for the configured table.
    public var description: Swift.String?
    /// The name of the configured table.
    /// This member is required.
    public var name: Swift.String?
    /// A reference to the Glue table being configured.
    /// This member is required.
    public var tableReference: CleanRoomsClientTypes.TableReference?
    /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        allowedColumns: [Swift.String]? = nil,
        analysisMethod: CleanRoomsClientTypes.AnalysisMethod? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        tableReference: CleanRoomsClientTypes.TableReference? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.allowedColumns = allowedColumns
        self.analysisMethod = analysisMethod
        self.description = description
        self.name = name
        self.tableReference = tableReference
        self.tags = tags
    }
}

extension CleanRoomsClientTypes {

    public enum ConfiguredTableAnalysisRuleType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case aggregation
        case custom
        case list
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfiguredTableAnalysisRuleType] {
            return [
                .aggregation,
                .custom,
                .list
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .aggregation: return "AGGREGATION"
            case .custom: return "CUSTOM"
            case .list: return "LIST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// A table that has been configured for use in a collaboration.
    public struct ConfiguredTable: Swift.Sendable {
        /// The columns within the underlying Glue table that can be utilized within collaborations.
        /// This member is required.
        public var allowedColumns: [Swift.String]?
        /// The analysis method for the configured table. The only valid value is currently `DIRECT_QUERY`.
        /// This member is required.
        public var analysisMethod: CleanRoomsClientTypes.AnalysisMethod?
        /// The types of analysis rules associated with this configured table. Currently, only one analysis rule may be associated with a configured table.
        /// This member is required.
        public var analysisRuleTypes: [CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType]?
        /// The unique ARN for the configured table.
        /// This member is required.
        public var arn: Swift.String?
        /// The time the configured table was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// A description for the configured table.
        public var description: Swift.String?
        /// The unique ID for the configured table.
        /// This member is required.
        public var id: Swift.String?
        /// A name for the configured table.
        /// This member is required.
        public var name: Swift.String?
        /// The Glue table that this configured table represents.
        /// This member is required.
        public var tableReference: CleanRoomsClientTypes.TableReference?
        /// The time the configured table was last updated
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            allowedColumns: [Swift.String]? = nil,
            analysisMethod: CleanRoomsClientTypes.AnalysisMethod? = nil,
            analysisRuleTypes: [CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType]? = nil,
            arn: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            tableReference: CleanRoomsClientTypes.TableReference? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.allowedColumns = allowedColumns
            self.analysisMethod = analysisMethod
            self.analysisRuleTypes = analysisRuleTypes
            self.arn = arn
            self.createTime = createTime
            self.description = description
            self.id = id
            self.name = name
            self.tableReference = tableReference
            self.updateTime = updateTime
        }
    }
}

public struct CreateConfiguredTableOutput: Swift.Sendable {
    /// The created configured table.
    /// This member is required.
    public var configuredTable: CleanRoomsClientTypes.ConfiguredTable?

    public init(
        configuredTable: CleanRoomsClientTypes.ConfiguredTable? = nil
    )
    {
        self.configuredTable = configuredTable
    }
}

extension CleanRoomsClientTypes {

    /// Controls on the query specifications that can be run on a configured table.
    public enum ConfiguredTableAnalysisRulePolicyV1: Swift.Sendable {
        /// Analysis rule type that enables only list queries on a configured table.
        case list(CleanRoomsClientTypes.AnalysisRuleList)
        /// Analysis rule type that enables only aggregation queries on a configured table.
        case aggregation(CleanRoomsClientTypes.AnalysisRuleAggregation)
        /// A type of analysis rule that enables the table owner to approve custom SQL queries on their configured tables. It supports differential privacy.
        case custom(CleanRoomsClientTypes.AnalysisRuleCustom)
        case sdkUnknown(Swift.String)
    }
}

extension CleanRoomsClientTypes {

    /// Controls on the query specifications that can be run on a configured table.
    public enum ConfiguredTableAnalysisRulePolicy: Swift.Sendable {
        /// Controls on the query specifications that can be run on a configured table.
        case v1(CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicyV1)
        case sdkUnknown(Swift.String)
    }
}

public struct CreateConfiguredTableAnalysisRuleInput: Swift.Sendable {
    /// The analysis rule policy that was created for the configured table.
    /// This member is required.
    public var analysisRulePolicy: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy?
    /// The type of analysis rule.
    /// This member is required.
    public var analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType?
    /// The identifier for the configured table to create the analysis rule for. Currently accepts the configured table ID.
    /// This member is required.
    public var configuredTableIdentifier: Swift.String?

    public init(
        analysisRulePolicy: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy? = nil,
        analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType? = nil,
        configuredTableIdentifier: Swift.String? = nil
    )
    {
        self.analysisRulePolicy = analysisRulePolicy
        self.analysisRuleType = analysisRuleType
        self.configuredTableIdentifier = configuredTableIdentifier
    }
}

extension CleanRoomsClientTypes {

    /// A configured table analysis rule, which limits how data for this table can be used.
    public struct ConfiguredTableAnalysisRule: Swift.Sendable {
        /// The unique ARN for the configured table.
        /// This member is required.
        public var configuredTableArn: Swift.String?
        /// The unique ID for the configured table.
        /// This member is required.
        public var configuredTableId: Swift.String?
        /// The time the configured table analysis rule was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The policy that controls SQL query rules.
        /// This member is required.
        public var policy: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy?
        /// The type of configured table analysis rule.
        /// This member is required.
        public var type: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType?
        /// The time the configured table analysis rule was last updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            configuredTableArn: Swift.String? = nil,
            configuredTableId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            policy: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy? = nil,
            type: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.configuredTableArn = configuredTableArn
            self.configuredTableId = configuredTableId
            self.createTime = createTime
            self.policy = policy
            self.type = type
            self.updateTime = updateTime
        }
    }
}

public struct CreateConfiguredTableAnalysisRuleOutput: Swift.Sendable {
    /// The analysis rule that was created for the configured table.
    /// This member is required.
    public var analysisRule: CleanRoomsClientTypes.ConfiguredTableAnalysisRule?

    public init(
        analysisRule: CleanRoomsClientTypes.ConfiguredTableAnalysisRule? = nil
    )
    {
        self.analysisRule = analysisRule
    }
}

public struct DeleteConfiguredTableInput: Swift.Sendable {
    /// The unique ID for the configured table to delete.
    /// This member is required.
    public var configuredTableIdentifier: Swift.String?

    public init(
        configuredTableIdentifier: Swift.String? = nil
    )
    {
        self.configuredTableIdentifier = configuredTableIdentifier
    }
}

/// The empty output for a successful deletion.
public struct DeleteConfiguredTableOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteConfiguredTableAnalysisRuleInput: Swift.Sendable {
    /// The analysis rule type to be deleted. Configured table analysis rules are uniquely identified by their configured table identifier and analysis rule type.
    /// This member is required.
    public var analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType?
    /// The unique identifier for the configured table that the analysis rule applies to. Currently accepts the configured table ID.
    /// This member is required.
    public var configuredTableIdentifier: Swift.String?

    public init(
        analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType? = nil,
        configuredTableIdentifier: Swift.String? = nil
    )
    {
        self.analysisRuleType = analysisRuleType
        self.configuredTableIdentifier = configuredTableIdentifier
    }
}

/// An empty response that indicates a successful delete.
public struct DeleteConfiguredTableAnalysisRuleOutput: Swift.Sendable {

    public init() { }
}

public struct GetConfiguredTableInput: Swift.Sendable {
    /// The unique ID for the configured table to retrieve.
    /// This member is required.
    public var configuredTableIdentifier: Swift.String?

    public init(
        configuredTableIdentifier: Swift.String? = nil
    )
    {
        self.configuredTableIdentifier = configuredTableIdentifier
    }
}

public struct GetConfiguredTableOutput: Swift.Sendable {
    /// The retrieved configured table.
    /// This member is required.
    public var configuredTable: CleanRoomsClientTypes.ConfiguredTable?

    public init(
        configuredTable: CleanRoomsClientTypes.ConfiguredTable? = nil
    )
    {
        self.configuredTable = configuredTable
    }
}

public struct GetConfiguredTableAnalysisRuleInput: Swift.Sendable {
    /// The analysis rule to be retrieved. Configured table analysis rules are uniquely identified by their configured table identifier and analysis rule type.
    /// This member is required.
    public var analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType?
    /// The unique identifier for the configured table to retrieve. Currently accepts the configured table ID.
    /// This member is required.
    public var configuredTableIdentifier: Swift.String?

    public init(
        analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType? = nil,
        configuredTableIdentifier: Swift.String? = nil
    )
    {
        self.analysisRuleType = analysisRuleType
        self.configuredTableIdentifier = configuredTableIdentifier
    }
}

public struct GetConfiguredTableAnalysisRuleOutput: Swift.Sendable {
    /// The entire analysis rule output.
    /// This member is required.
    public var analysisRule: CleanRoomsClientTypes.ConfiguredTableAnalysisRule?

    public init(
        analysisRule: CleanRoomsClientTypes.ConfiguredTableAnalysisRule? = nil
    )
    {
        self.analysisRule = analysisRule
    }
}

public struct ListConfiguredTablesInput: Swift.Sendable {
    /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the `maxResults` value has not been met.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension CleanRoomsClientTypes {

    /// The configured table summary for the objects listed by the request.
    public struct ConfiguredTableSummary: Swift.Sendable {
        /// The analysis method for the configured tables. The only valid value is currently `DIRECT_QUERY`.
        /// This member is required.
        public var analysisMethod: CleanRoomsClientTypes.AnalysisMethod?
        /// The types of analysis rules associated with this configured table.
        /// This member is required.
        public var analysisRuleTypes: [CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType]?
        /// The unique ARN of the configured table.
        /// This member is required.
        public var arn: Swift.String?
        /// The time the configured table was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The unique ID of the configured table.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the configured table.
        /// This member is required.
        public var name: Swift.String?
        /// The time the configured table was last updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            analysisMethod: CleanRoomsClientTypes.AnalysisMethod? = nil,
            analysisRuleTypes: [CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType]? = nil,
            arn: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.analysisMethod = analysisMethod
            self.analysisRuleTypes = analysisRuleTypes
            self.arn = arn
            self.createTime = createTime
            self.id = id
            self.name = name
            self.updateTime = updateTime
        }
    }
}

public struct ListConfiguredTablesOutput: Swift.Sendable {
    /// The configured tables listed by the request.
    /// This member is required.
    public var configuredTableSummaries: [CleanRoomsClientTypes.ConfiguredTableSummary]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        configuredTableSummaries: [CleanRoomsClientTypes.ConfiguredTableSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.configuredTableSummaries = configuredTableSummaries
        self.nextToken = nextToken
    }
}

public struct UpdateConfiguredTableInput: Swift.Sendable {
    /// The identifier for the configured table to update. Currently accepts the configured table ID.
    /// This member is required.
    public var configuredTableIdentifier: Swift.String?
    /// A new description for the configured table.
    public var description: Swift.String?
    /// A new name for the configured table.
    public var name: Swift.String?

    public init(
        configuredTableIdentifier: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.configuredTableIdentifier = configuredTableIdentifier
        self.description = description
        self.name = name
    }
}

public struct UpdateConfiguredTableOutput: Swift.Sendable {
    /// The updated configured table.
    /// This member is required.
    public var configuredTable: CleanRoomsClientTypes.ConfiguredTable?

    public init(
        configuredTable: CleanRoomsClientTypes.ConfiguredTable? = nil
    )
    {
        self.configuredTable = configuredTable
    }
}

public struct UpdateConfiguredTableAnalysisRuleInput: Swift.Sendable {
    /// The new analysis rule policy for the configured table analysis rule.
    /// This member is required.
    public var analysisRulePolicy: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy?
    /// The analysis rule type to be updated. Configured table analysis rules are uniquely identified by their configured table identifier and analysis rule type.
    /// This member is required.
    public var analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType?
    /// The unique identifier for the configured table that the analysis rule applies to. Currently accepts the configured table ID.
    /// This member is required.
    public var configuredTableIdentifier: Swift.String?

    public init(
        analysisRulePolicy: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy? = nil,
        analysisRuleType: CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType? = nil,
        configuredTableIdentifier: Swift.String? = nil
    )
    {
        self.analysisRulePolicy = analysisRulePolicy
        self.analysisRuleType = analysisRuleType
        self.configuredTableIdentifier = configuredTableIdentifier
    }
}

public struct UpdateConfiguredTableAnalysisRuleOutput: Swift.Sendable {
    /// The entire updated analysis rule.
    /// This member is required.
    public var analysisRule: CleanRoomsClientTypes.ConfiguredTableAnalysisRule?

    public init(
        analysisRule: CleanRoomsClientTypes.ConfiguredTableAnalysisRule? = nil
    )
    {
        self.analysisRule = analysisRule
    }
}

extension CleanRoomsClientTypes {

    /// Provides the input reference configuration for the ID mapping table.
    public struct IdMappingTableInputReferenceConfig: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the referenced resource in Entity Resolution. Valid values are ID mapping workflow ARNs.
        /// This member is required.
        public var inputReferenceArn: Swift.String?
        /// When TRUE, Clean Rooms manages permissions for the ID mapping table resource. When FALSE, the resource owner manages permissions for the ID mapping table resource.
        /// This member is required.
        public var manageResourcePolicies: Swift.Bool?

        public init(
            inputReferenceArn: Swift.String? = nil,
            manageResourcePolicies: Swift.Bool? = nil
        )
        {
            self.inputReferenceArn = inputReferenceArn
            self.manageResourcePolicies = manageResourcePolicies
        }
    }
}

public struct CreateIdMappingTableInput: Swift.Sendable {
    /// A description of the ID mapping table.
    public var description: Swift.String?
    /// The input reference configuration needed to create the ID mapping table.
    /// This member is required.
    public var inputReferenceConfig: CleanRoomsClientTypes.IdMappingTableInputReferenceConfig?
    /// The Amazon Resource Name (ARN) of the Amazon Web Services KMS key. This value is used to encrypt the mapping table data that is stored by Clean Rooms.
    public var kmsKeyArn: Swift.String?
    /// The unique identifier of the membership that contains the ID mapping table.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// A name for the ID mapping table.
    /// This member is required.
    public var name: Swift.String?
    /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        inputReferenceConfig: CleanRoomsClientTypes.IdMappingTableInputReferenceConfig? = nil,
        kmsKeyArn: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.inputReferenceConfig = inputReferenceConfig
        self.kmsKeyArn = kmsKeyArn
        self.membershipIdentifier = membershipIdentifier
        self.name = name
        self.tags = tags
    }
}

extension CleanRoomsClientTypes {

    /// The input reference properties for the ID mapping table.
    public struct IdMappingTableInputReferenceProperties: Swift.Sendable {
        /// The input source of the ID mapping table.
        /// This member is required.
        public var idMappingTableInputSource: [CleanRoomsClientTypes.IdMappingTableInputSource]?

        public init(
            idMappingTableInputSource: [CleanRoomsClientTypes.IdMappingTableInputSource]? = nil
        )
        {
            self.idMappingTableInputSource = idMappingTableInputSource
        }
    }
}

extension CleanRoomsClientTypes {

    /// Describes information about the ID mapping table.
    public struct IdMappingTable: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the ID mapping table.
        /// This member is required.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the collaboration that contains this ID mapping table.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique identifier of the collaboration that contains this ID mapping table.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time at which the ID mapping table was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The description of the ID mapping table.
        public var description: Swift.String?
        /// The unique identifier of the ID mapping table.
        /// This member is required.
        public var id: Swift.String?
        /// The input reference configuration for the ID mapping table.
        /// This member is required.
        public var inputReferenceConfig: CleanRoomsClientTypes.IdMappingTableInputReferenceConfig?
        /// The input reference properties for the ID mapping table.
        /// This member is required.
        public var inputReferenceProperties: CleanRoomsClientTypes.IdMappingTableInputReferenceProperties?
        /// The Amazon Resource Name (ARN) of the Amazon Web Services KMS key.
        public var kmsKeyArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the membership resource for the ID mapping table.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The unique identifier of the membership resource for the ID mapping table.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The name of the ID mapping table.
        /// This member is required.
        public var name: Swift.String?
        /// The most recent time at which the ID mapping table was updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            inputReferenceConfig: CleanRoomsClientTypes.IdMappingTableInputReferenceConfig? = nil,
            inputReferenceProperties: CleanRoomsClientTypes.IdMappingTableInputReferenceProperties? = nil,
            kmsKeyArn: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.description = description
            self.id = id
            self.inputReferenceConfig = inputReferenceConfig
            self.inputReferenceProperties = inputReferenceProperties
            self.kmsKeyArn = kmsKeyArn
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }
    }
}

public struct CreateIdMappingTableOutput: Swift.Sendable {
    /// The ID mapping table that was created.
    /// This member is required.
    public var idMappingTable: CleanRoomsClientTypes.IdMappingTable?

    public init(
        idMappingTable: CleanRoomsClientTypes.IdMappingTable? = nil
    )
    {
        self.idMappingTable = idMappingTable
    }
}

public struct DeleteIdMappingTableInput: Swift.Sendable {
    /// The unique identifier of the ID mapping table that you want to delete.
    /// This member is required.
    public var idMappingTableIdentifier: Swift.String?
    /// The unique identifier of the membership that contains the ID mapping table that you want to delete.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        idMappingTableIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.idMappingTableIdentifier = idMappingTableIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

public struct DeleteIdMappingTableOutput: Swift.Sendable {

    public init() { }
}

public struct GetIdMappingTableInput: Swift.Sendable {
    /// The unique identifier of the ID mapping table identifier that you want to retrieve.
    /// This member is required.
    public var idMappingTableIdentifier: Swift.String?
    /// The unique identifier of the membership that contains the ID mapping table that you want to retrieve.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        idMappingTableIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.idMappingTableIdentifier = idMappingTableIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

public struct GetIdMappingTableOutput: Swift.Sendable {
    /// The ID mapping table that you requested.
    /// This member is required.
    public var idMappingTable: CleanRoomsClientTypes.IdMappingTable?

    public init(
        idMappingTable: CleanRoomsClientTypes.IdMappingTable? = nil
    )
    {
        self.idMappingTable = idMappingTable
    }
}

public struct ListIdMappingTablesInput: Swift.Sendable {
    /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service may return a nextToken even if the maximum results has not been met.
    public var maxResults: Swift.Int?
    /// The unique identifier of the membership that contains the ID mapping tables that you want to view.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        membershipIdentifier: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.membershipIdentifier = membershipIdentifier
        self.nextToken = nextToken
    }
}

extension CleanRoomsClientTypes {

    /// Detailed information about the ID mapping table.
    public struct IdMappingTableSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of this ID mapping table.
        /// This member is required.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the collaboration that contains this ID mapping table.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique identifier of the collaboration that contains this ID mapping table.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time at which this ID mapping table was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The description of this ID mapping table.
        public var description: Swift.String?
        /// The unique identifier of this ID mapping table.
        /// This member is required.
        public var id: Swift.String?
        /// The input reference configuration for the ID mapping table.
        /// This member is required.
        public var inputReferenceConfig: CleanRoomsClientTypes.IdMappingTableInputReferenceConfig?
        /// The Amazon Resource Name (ARN) of the membership resource for this ID mapping table.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The unique identifier of the membership resource for this ID mapping table.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The name of this ID mapping table.
        /// This member is required.
        public var name: Swift.String?
        /// The most recent time at which this ID mapping table was updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            inputReferenceConfig: CleanRoomsClientTypes.IdMappingTableInputReferenceConfig? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.description = description
            self.id = id
            self.inputReferenceConfig = inputReferenceConfig
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }
    }
}

public struct ListIdMappingTablesOutput: Swift.Sendable {
    /// The summary information of the ID mapping tables that you requested.
    /// This member is required.
    public var idMappingTableSummaries: [CleanRoomsClientTypes.IdMappingTableSummary]?
    /// The token value provided to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        idMappingTableSummaries: [CleanRoomsClientTypes.IdMappingTableSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.idMappingTableSummaries = idMappingTableSummaries
        self.nextToken = nextToken
    }
}

public struct PopulateIdMappingTableInput: Swift.Sendable {
    /// The unique identifier of the ID mapping table that you want to populate.
    /// This member is required.
    public var idMappingTableIdentifier: Swift.String?
    /// The unique identifier of the membership that contains the ID mapping table that you want to populate.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        idMappingTableIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.idMappingTableIdentifier = idMappingTableIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

public struct PopulateIdMappingTableOutput: Swift.Sendable {
    /// The unique identifier of the mapping job that will populate the ID mapping table.
    /// This member is required.
    public var idMappingJobId: Swift.String?

    public init(
        idMappingJobId: Swift.String? = nil
    )
    {
        self.idMappingJobId = idMappingJobId
    }
}

public struct UpdateIdMappingTableInput: Swift.Sendable {
    /// A new description for the ID mapping table.
    public var description: Swift.String?
    /// The unique identifier of the ID mapping table that you want to update.
    /// This member is required.
    public var idMappingTableIdentifier: Swift.String?
    /// The Amazon Resource Name (ARN) of the Amazon Web Services KMS key.
    public var kmsKeyArn: Swift.String?
    /// The unique identifier of the membership that contains the ID mapping table that you want to update.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        description: Swift.String? = nil,
        idMappingTableIdentifier: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.description = description
        self.idMappingTableIdentifier = idMappingTableIdentifier
        self.kmsKeyArn = kmsKeyArn
        self.membershipIdentifier = membershipIdentifier
    }
}

public struct UpdateIdMappingTableOutput: Swift.Sendable {
    /// The updated ID mapping table.
    /// This member is required.
    public var idMappingTable: CleanRoomsClientTypes.IdMappingTable?

    public init(
        idMappingTable: CleanRoomsClientTypes.IdMappingTable? = nil
    )
    {
        self.idMappingTable = idMappingTable
    }
}

public struct CreateIdNamespaceAssociationInput: Swift.Sendable {
    /// The description of the ID namespace association.
    public var description: Swift.String?
    /// The configuration settings for the ID mapping table.
    public var idMappingConfig: CleanRoomsClientTypes.IdMappingConfig?
    /// The input reference configuration needed to create the ID namespace association.
    /// This member is required.
    public var inputReferenceConfig: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceConfig?
    /// The unique identifier of the membership that contains the ID namespace association.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The name for the ID namespace association.
    /// This member is required.
    public var name: Swift.String?
    /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        description: Swift.String? = nil,
        idMappingConfig: CleanRoomsClientTypes.IdMappingConfig? = nil,
        inputReferenceConfig: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceConfig? = nil,
        membershipIdentifier: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.description = description
        self.idMappingConfig = idMappingConfig
        self.inputReferenceConfig = inputReferenceConfig
        self.membershipIdentifier = membershipIdentifier
        self.name = name
        self.tags = tags
    }
}

extension CleanRoomsClientTypes {

    /// Provides information to create the ID namespace association.
    public struct IdNamespaceAssociation: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the ID namespace association.
        /// This member is required.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the collaboration that contains this ID namespace association.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique identifier of the collaboration that contains this ID namespace association.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time at which the ID namespace association was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The description of the ID namespace association.
        public var description: Swift.String?
        /// The unique identifier for this ID namespace association.
        /// This member is required.
        public var id: Swift.String?
        /// The configuration settings for the ID mapping table.
        public var idMappingConfig: CleanRoomsClientTypes.IdMappingConfig?
        /// The input reference configuration for the ID namespace association.
        /// This member is required.
        public var inputReferenceConfig: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceConfig?
        /// The input reference properties for the ID namespace association.
        /// This member is required.
        public var inputReferenceProperties: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceProperties?
        /// The Amazon Resource Name (ARN) of the membership resource for this ID namespace association.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The unique identifier of the membership resource for this ID namespace association.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The name of this ID namespace association.
        /// This member is required.
        public var name: Swift.String?
        /// The most recent time at which the ID namespace association was updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            idMappingConfig: CleanRoomsClientTypes.IdMappingConfig? = nil,
            inputReferenceConfig: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceConfig? = nil,
            inputReferenceProperties: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceProperties? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.description = description
            self.id = id
            self.idMappingConfig = idMappingConfig
            self.inputReferenceConfig = inputReferenceConfig
            self.inputReferenceProperties = inputReferenceProperties
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }
    }
}

public struct CreateIdNamespaceAssociationOutput: Swift.Sendable {
    /// The ID namespace association that was created.
    /// This member is required.
    public var idNamespaceAssociation: CleanRoomsClientTypes.IdNamespaceAssociation?

    public init(
        idNamespaceAssociation: CleanRoomsClientTypes.IdNamespaceAssociation? = nil
    )
    {
        self.idNamespaceAssociation = idNamespaceAssociation
    }
}

public struct DeleteIdNamespaceAssociationInput: Swift.Sendable {
    /// The unique identifier of the ID namespace association that you want to delete.
    /// This member is required.
    public var idNamespaceAssociationIdentifier: Swift.String?
    /// The unique identifier of the membership that contains the ID namespace association that you want to delete.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        idNamespaceAssociationIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.idNamespaceAssociationIdentifier = idNamespaceAssociationIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

public struct DeleteIdNamespaceAssociationOutput: Swift.Sendable {

    public init() { }
}

public struct GetIdNamespaceAssociationInput: Swift.Sendable {
    /// The unique identifier of the ID namespace association that you want to retrieve.
    /// This member is required.
    public var idNamespaceAssociationIdentifier: Swift.String?
    /// The unique identifier of the membership that contains the ID namespace association that you want to retrieve.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        idNamespaceAssociationIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.idNamespaceAssociationIdentifier = idNamespaceAssociationIdentifier
        self.membershipIdentifier = membershipIdentifier
    }
}

public struct GetIdNamespaceAssociationOutput: Swift.Sendable {
    /// The ID namespace association that you requested.
    /// This member is required.
    public var idNamespaceAssociation: CleanRoomsClientTypes.IdNamespaceAssociation?

    public init(
        idNamespaceAssociation: CleanRoomsClientTypes.IdNamespaceAssociation? = nil
    )
    {
        self.idNamespaceAssociation = idNamespaceAssociation
    }
}

public struct ListIdNamespaceAssociationsInput: Swift.Sendable {
    /// The maximum size of the results that is returned per call. Service chooses a default if it has not been set. Service may return a nextToken even if the maximum results has not been met.
    public var maxResults: Swift.Int?
    /// The unique identifier of the membership that contains the ID namespace association that you want to view.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        membershipIdentifier: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.membershipIdentifier = membershipIdentifier
        self.nextToken = nextToken
    }
}

extension CleanRoomsClientTypes {

    /// Detailed information about the ID namespace association.
    public struct IdNamespaceAssociationSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of this ID namespace association.
        /// This member is required.
        public var arn: Swift.String?
        /// The Amazon Resource Name (ARN) of the collaboration that contains this ID namespace association.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique identifier of the collaboration that contains this ID namespace association.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time at which this ID namespace association was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The description of the ID namespace association.
        public var description: Swift.String?
        /// The unique identifier of this ID namespace association.
        /// This member is required.
        public var id: Swift.String?
        /// The input reference configuration details for this ID namespace association.
        /// This member is required.
        public var inputReferenceConfig: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceConfig?
        /// The input reference properties for this ID namespace association.
        /// This member is required.
        public var inputReferenceProperties: CleanRoomsClientTypes.IdNamespaceAssociationInputReferencePropertiesSummary?
        /// The Amazon Resource Name (ARN) of the membership resource for this ID namespace association.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The unique identifier of the membership resource for this ID namespace association.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The name of the ID namespace association.
        /// This member is required.
        public var name: Swift.String?
        /// The most recent time at which this ID namespace association has been updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            inputReferenceConfig: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceConfig? = nil,
            inputReferenceProperties: CleanRoomsClientTypes.IdNamespaceAssociationInputReferencePropertiesSummary? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            name: Swift.String? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.description = description
            self.id = id
            self.inputReferenceConfig = inputReferenceConfig
            self.inputReferenceProperties = inputReferenceProperties
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.name = name
            self.updateTime = updateTime
        }
    }
}

public struct ListIdNamespaceAssociationsOutput: Swift.Sendable {
    /// The summary information of the ID namespace associations that you requested.
    /// This member is required.
    public var idNamespaceAssociationSummaries: [CleanRoomsClientTypes.IdNamespaceAssociationSummary]?
    /// The token value provided to access the next page of results.
    public var nextToken: Swift.String?

    public init(
        idNamespaceAssociationSummaries: [CleanRoomsClientTypes.IdNamespaceAssociationSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.idNamespaceAssociationSummaries = idNamespaceAssociationSummaries
        self.nextToken = nextToken
    }
}

public struct UpdateIdNamespaceAssociationInput: Swift.Sendable {
    /// A new description for the ID namespace association.
    public var description: Swift.String?
    /// The configuration settings for the ID mapping table.
    public var idMappingConfig: CleanRoomsClientTypes.IdMappingConfig?
    /// The unique identifier of the ID namespace association that you want to update.
    /// This member is required.
    public var idNamespaceAssociationIdentifier: Swift.String?
    /// The unique identifier of the membership that contains the ID namespace association that you want to update.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// A new name for the ID namespace association.
    public var name: Swift.String?

    public init(
        description: Swift.String? = nil,
        idMappingConfig: CleanRoomsClientTypes.IdMappingConfig? = nil,
        idNamespaceAssociationIdentifier: Swift.String? = nil,
        membershipIdentifier: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.description = description
        self.idMappingConfig = idMappingConfig
        self.idNamespaceAssociationIdentifier = idNamespaceAssociationIdentifier
        self.membershipIdentifier = membershipIdentifier
        self.name = name
    }
}

public struct UpdateIdNamespaceAssociationOutput: Swift.Sendable {
    /// The updated ID namespace association.
    /// This member is required.
    public var idNamespaceAssociation: CleanRoomsClientTypes.IdNamespaceAssociation?

    public init(
        idNamespaceAssociation: CleanRoomsClientTypes.IdNamespaceAssociation? = nil
    )
    {
        self.idNamespaceAssociation = idNamespaceAssociation
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) associated with the resource you want to list tags on.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A map of objects specifying each key name and value.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

extension CleanRoomsClientTypes {

    public enum ResultFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case csv
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [ResultFormat] {
            return [
                .csv,
                .parquet
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .csv: return "CSV"
            case .parquet: return "PARQUET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// Contains the configuration to write the query results to S3.
    public struct ProtectedQueryS3OutputConfiguration: Swift.Sendable {
        /// The S3 bucket to unload the protected query results.
        /// This member is required.
        public var bucket: Swift.String?
        /// The S3 prefix to unload the protected query results.
        public var keyPrefix: Swift.String?
        /// Intended file format of the result.
        /// This member is required.
        public var resultFormat: CleanRoomsClientTypes.ResultFormat?
        /// Indicates whether files should be output as a single file (TRUE) or output as multiple files (FALSE). This parameter is only supported for analyses with the Spark analytics engine.
        public var singleFileOutput: Swift.Bool?

        public init(
            bucket: Swift.String? = nil,
            keyPrefix: Swift.String? = nil,
            resultFormat: CleanRoomsClientTypes.ResultFormat? = nil,
            singleFileOutput: Swift.Bool? = nil
        )
        {
            self.bucket = bucket
            self.keyPrefix = keyPrefix
            self.resultFormat = resultFormat
            self.singleFileOutput = singleFileOutput
        }
    }
}

extension CleanRoomsClientTypes {

    /// Contains configurations for protected query results.
    public enum MembershipProtectedQueryOutputConfiguration: Swift.Sendable {
        /// Contains the configuration to write the query results to S3.
        case s3(CleanRoomsClientTypes.ProtectedQueryS3OutputConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension CleanRoomsClientTypes {

    /// Contains configurations for protected query results.
    public struct MembershipProtectedQueryResultConfiguration: Swift.Sendable {
        /// Configuration for protected query results.
        /// This member is required.
        public var outputConfiguration: CleanRoomsClientTypes.MembershipProtectedQueryOutputConfiguration?
        /// The unique ARN for an IAM role that is used by Clean Rooms to write protected query results to the result location, given by the member who can receive results.
        public var roleArn: Swift.String?

        public init(
            outputConfiguration: CleanRoomsClientTypes.MembershipProtectedQueryOutputConfiguration? = nil,
            roleArn: Swift.String? = nil
        )
        {
            self.outputConfiguration = outputConfiguration
            self.roleArn = roleArn
        }
    }
}

extension CleanRoomsClientTypes {

    /// An object representing the payment responsibilities accepted by the collaboration member for query compute costs.
    public struct MembershipQueryComputePaymentConfig: Swift.Sendable {
        /// Indicates whether the collaboration member has accepted to pay for query compute costs (TRUE) or has not accepted to pay for query compute costs (FALSE). If the collaboration creator has not specified anyone to pay for query compute costs, then the member who can query is the default payer. An error message is returned for the following reasons:
        ///
        /// * If you set the value to FALSE but you are responsible to pay for query compute costs.
        ///
        /// * If you set the value to TRUE but you are not responsible to pay for query compute costs.
        /// This member is required.
        public var isResponsible: Swift.Bool?

        public init(
            isResponsible: Swift.Bool? = nil
        )
        {
            self.isResponsible = isResponsible
        }
    }
}

extension CleanRoomsClientTypes {

    /// An object representing the payment responsibilities accepted by the collaboration member.
    public struct MembershipPaymentConfiguration: Swift.Sendable {
        /// The payment responsibilities accepted by the collaboration member for query compute costs.
        /// This member is required.
        public var queryCompute: CleanRoomsClientTypes.MembershipQueryComputePaymentConfig?

        public init(
            queryCompute: CleanRoomsClientTypes.MembershipQueryComputePaymentConfig? = nil
        )
        {
            self.queryCompute = queryCompute
        }
    }
}

extension CleanRoomsClientTypes {

    public enum MembershipQueryLogStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [MembershipQueryLogStatus] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateMembershipInput: Swift.Sendable {
    /// The unique ID for the associated collaboration.
    /// This member is required.
    public var collaborationIdentifier: Swift.String?
    /// The default protected query result configuration as specified by the member who can receive results.
    public var defaultResultConfiguration: CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration?
    /// The payment responsibilities accepted by the collaboration member. Not required if the collaboration member has the member ability to run queries. Required if the collaboration member doesn't have the member ability to run queries but is configured as a payer by the collaboration creator.
    public var paymentConfiguration: CleanRoomsClientTypes.MembershipPaymentConfiguration?
    /// An indicator as to whether query logging has been enabled or disabled for the membership.
    /// This member is required.
    public var queryLogStatus: CleanRoomsClientTypes.MembershipQueryLogStatus?
    /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        collaborationIdentifier: Swift.String? = nil,
        defaultResultConfiguration: CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration? = nil,
        paymentConfiguration: CleanRoomsClientTypes.MembershipPaymentConfiguration? = nil,
        queryLogStatus: CleanRoomsClientTypes.MembershipQueryLogStatus? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.collaborationIdentifier = collaborationIdentifier
        self.defaultResultConfiguration = defaultResultConfiguration
        self.paymentConfiguration = paymentConfiguration
        self.queryLogStatus = queryLogStatus
        self.tags = tags
    }
}

extension CleanRoomsClientTypes {

    public enum MembershipStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case collaborationDeleted
        case removed
        case sdkUnknown(Swift.String)

        public static var allCases: [MembershipStatus] {
            return [
                .active,
                .collaborationDeleted,
                .removed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .collaborationDeleted: return "COLLABORATION_DELETED"
            case .removed: return "REMOVED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// The membership object.
    public struct Membership: Swift.Sendable {
        /// The unique ARN for the membership.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique ARN for the membership's associated collaboration.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The identifier used to reference members of the collaboration. Currently only supports Amazon Web Services account ID.
        /// This member is required.
        public var collaborationCreatorAccountId: Swift.String?
        /// The display name of the collaboration creator.
        /// This member is required.
        public var collaborationCreatorDisplayName: Swift.String?
        /// The unique ID for the membership's collaboration.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The name of the membership's collaboration.
        /// This member is required.
        public var collaborationName: Swift.String?
        /// The time when the membership was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The default protected query result configuration as specified by the member who can receive results.
        public var defaultResultConfiguration: CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration?
        /// The unique ID of the membership.
        /// This member is required.
        public var id: Swift.String?
        /// The abilities granted to the collaboration member.
        /// This member is required.
        public var memberAbilities: [CleanRoomsClientTypes.MemberAbility]?
        /// The payment responsibilities accepted by the collaboration member.
        /// This member is required.
        public var paymentConfiguration: CleanRoomsClientTypes.MembershipPaymentConfiguration?
        /// An indicator as to whether query logging has been enabled or disabled for the membership.
        /// This member is required.
        public var queryLogStatus: CleanRoomsClientTypes.MembershipQueryLogStatus?
        /// The status of the membership.
        /// This member is required.
        public var status: CleanRoomsClientTypes.MembershipStatus?
        /// The time the membership metadata was last updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationCreatorAccountId: Swift.String? = nil,
            collaborationCreatorDisplayName: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            collaborationName: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            defaultResultConfiguration: CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration? = nil,
            id: Swift.String? = nil,
            memberAbilities: [CleanRoomsClientTypes.MemberAbility]? = nil,
            paymentConfiguration: CleanRoomsClientTypes.MembershipPaymentConfiguration? = nil,
            queryLogStatus: CleanRoomsClientTypes.MembershipQueryLogStatus? = nil,
            status: CleanRoomsClientTypes.MembershipStatus? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationCreatorAccountId = collaborationCreatorAccountId
            self.collaborationCreatorDisplayName = collaborationCreatorDisplayName
            self.collaborationId = collaborationId
            self.collaborationName = collaborationName
            self.createTime = createTime
            self.defaultResultConfiguration = defaultResultConfiguration
            self.id = id
            self.memberAbilities = memberAbilities
            self.paymentConfiguration = paymentConfiguration
            self.queryLogStatus = queryLogStatus
            self.status = status
            self.updateTime = updateTime
        }
    }
}

public struct CreateMembershipOutput: Swift.Sendable {
    /// The membership that was created.
    /// This member is required.
    public var membership: CleanRoomsClientTypes.Membership?

    public init(
        membership: CleanRoomsClientTypes.Membership? = nil
    )
    {
        self.membership = membership
    }
}

public struct DeleteMembershipInput: Swift.Sendable {
    /// The identifier for a membership resource.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.membershipIdentifier = membershipIdentifier
    }
}

public struct DeleteMembershipOutput: Swift.Sendable {

    public init() { }
}

public struct GetMembershipInput: Swift.Sendable {
    /// The identifier for a membership resource.
    /// This member is required.
    public var membershipIdentifier: Swift.String?

    public init(
        membershipIdentifier: Swift.String? = nil
    )
    {
        self.membershipIdentifier = membershipIdentifier
    }
}

public struct GetMembershipOutput: Swift.Sendable {
    /// The membership retrieved for the provided identifier.
    /// This member is required.
    public var membership: CleanRoomsClientTypes.Membership?

    public init(
        membership: CleanRoomsClientTypes.Membership? = nil
    )
    {
        self.membership = membership
    }
}

public struct GetProtectedQueryInput: Swift.Sendable {
    /// The identifier for a membership in a protected query instance.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The identifier for a protected query instance.
    /// This member is required.
    public var protectedQueryIdentifier: Swift.String?

    public init(
        membershipIdentifier: Swift.String? = nil,
        protectedQueryIdentifier: Swift.String? = nil
    )
    {
        self.membershipIdentifier = membershipIdentifier
        self.protectedQueryIdentifier = protectedQueryIdentifier
    }
}

extension CleanRoomsClientTypes {

    public enum WorkerComputeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cr1x
        case cr4x
        case sdkUnknown(Swift.String)

        public static var allCases: [WorkerComputeType] {
            return [
                .cr1x,
                .cr4x
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cr1x: return "CR.1X"
            case .cr4x: return "CR.4X"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// The configuration of the compute resources for workers running an analysis with the Clean Rooms SQL analytics engine.
    public struct WorkerComputeConfiguration: Swift.Sendable {
        /// The number of workers.
        public var number: Swift.Int?
        /// The worker compute configuration type.
        public var type: CleanRoomsClientTypes.WorkerComputeType?

        public init(
            number: Swift.Int? = nil,
            type: CleanRoomsClientTypes.WorkerComputeType? = nil
        )
        {
            self.number = number
            self.type = type
        }
    }
}

extension CleanRoomsClientTypes {

    /// The configuration of the compute resources for an analysis with the Spark analytics engine.
    public enum ComputeConfiguration: Swift.Sendable {
        /// The worker configuration for the compute environment.
        case worker(CleanRoomsClientTypes.WorkerComputeConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension CleanRoomsClientTypes {

    /// Provides the sensitivity parameters.
    public struct DifferentialPrivacySensitivityParameters: Swift.Sendable {
        /// The aggregation expression that was run.
        /// This member is required.
        public var aggregationExpression: Swift.String?
        /// The type of aggregation function that was run.
        /// This member is required.
        public var aggregationType: CleanRoomsClientTypes.DifferentialPrivacyAggregationType?
        /// The upper bound of the aggregation expression.
        public var maxColumnValue: Swift.Float?
        /// The lower bound of the aggregation expression.
        public var minColumnValue: Swift.Float?
        /// The maximum number of rows contributed by a user in a SQL query.
        /// This member is required.
        public var userContributionLimit: Swift.Int?

        public init(
            aggregationExpression: Swift.String? = nil,
            aggregationType: CleanRoomsClientTypes.DifferentialPrivacyAggregationType? = nil,
            maxColumnValue: Swift.Float? = nil,
            minColumnValue: Swift.Float? = nil,
            userContributionLimit: Swift.Int? = nil
        )
        {
            self.aggregationExpression = aggregationExpression
            self.aggregationType = aggregationType
            self.maxColumnValue = maxColumnValue
            self.minColumnValue = minColumnValue
            self.userContributionLimit = userContributionLimit
        }
    }
}

extension CleanRoomsClientTypes {

    /// An array that contains the sensitivity parameters.
    public struct DifferentialPrivacyParameters: Swift.Sendable {
        /// Provides the sensitivity parameters that you can use to better understand the total amount of noise in query results.
        /// This member is required.
        public var sensitivityParameters: [CleanRoomsClientTypes.DifferentialPrivacySensitivityParameters]?

        public init(
            sensitivityParameters: [CleanRoomsClientTypes.DifferentialPrivacySensitivityParameters]? = nil
        )
        {
            self.sensitivityParameters = sensitivityParameters
        }
    }
}

extension CleanRoomsClientTypes {

    /// Details of errors thrown by the protected query.
    public struct ProtectedQueryError: Swift.Sendable {
        /// An error code for the error.
        /// This member is required.
        public var code: Swift.String?
        /// A description of why the query failed.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: Swift.String? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }
}

extension CleanRoomsClientTypes {

    /// Details about the member who received the query result.
    public struct ProtectedQuerySingleMemberOutput: Swift.Sendable {
        /// The Amazon Web Services account ID of the member in the collaboration who can receive results for the query.
        /// This member is required.
        public var accountId: Swift.String?

        public init(
            accountId: Swift.String? = nil
        )
        {
            self.accountId = accountId
        }
    }
}

extension CleanRoomsClientTypes {

    /// Contains output information for protected queries with an S3 output type.
    public struct ProtectedQueryS3Output: Swift.Sendable {
        /// The S3 location of the result.
        /// This member is required.
        public var location: Swift.String?

        public init(
            location: Swift.String? = nil
        )
        {
            self.location = location
        }
    }
}

extension CleanRoomsClientTypes {

    /// Contains details about the protected query output.
    public enum ProtectedQueryOutput: Swift.Sendable {
        /// If present, the output for a protected query with an `S3` output type.
        case s3(CleanRoomsClientTypes.ProtectedQueryS3Output)
        /// The list of member Amazon Web Services account(s) that received the results of the query.
        case memberlist([CleanRoomsClientTypes.ProtectedQuerySingleMemberOutput])
        case sdkUnknown(Swift.String)
    }
}

extension CleanRoomsClientTypes {

    /// Details about the query results.
    public struct ProtectedQueryResult: Swift.Sendable {
        /// The output of the protected query.
        /// This member is required.
        public var output: CleanRoomsClientTypes.ProtectedQueryOutput?

        public init(
            output: CleanRoomsClientTypes.ProtectedQueryOutput? = nil
        )
        {
            self.output = output
        }
    }
}

extension CleanRoomsClientTypes {

    /// Contains configuration details for the protected query member output.
    public struct ProtectedQueryMemberOutputConfiguration: Swift.Sendable {
        /// The unique identifier for the account.
        /// This member is required.
        public var accountId: Swift.String?

        public init(
            accountId: Swift.String? = nil
        )
        {
            self.accountId = accountId
        }
    }
}

extension CleanRoomsClientTypes {

    /// Contains configuration details for protected query output.
    public enum ProtectedQueryOutputConfiguration: Swift.Sendable {
        /// Required configuration for a protected query with an s3 output type.
        case s3(CleanRoomsClientTypes.ProtectedQueryS3OutputConfiguration)
        /// Required configuration for a protected query with a member output type.
        case member(CleanRoomsClientTypes.ProtectedQueryMemberOutputConfiguration)
        case sdkUnknown(Swift.String)
    }
}

extension CleanRoomsClientTypes {

    /// Contains configurations for protected query results.
    public struct ProtectedQueryResultConfiguration: Swift.Sendable {
        /// Configuration for protected query results.
        /// This member is required.
        public var outputConfiguration: CleanRoomsClientTypes.ProtectedQueryOutputConfiguration?

        public init(
            outputConfiguration: CleanRoomsClientTypes.ProtectedQueryOutputConfiguration? = nil
        )
        {
            self.outputConfiguration = outputConfiguration
        }
    }
}

extension CleanRoomsClientTypes {

    /// The parameters for the SQL type Protected Query.
    public struct ProtectedQuerySQLParameters: Swift.Sendable {
        /// The Amazon Resource Name (ARN) associated with the analysis template within a collaboration.
        public var analysisTemplateArn: Swift.String?
        /// The protected query SQL parameters.
        public var parameters: [Swift.String: Swift.String]?
        /// The query string to be submitted.
        public var queryString: Swift.String?

        public init(
            analysisTemplateArn: Swift.String? = nil,
            parameters: [Swift.String: Swift.String]? = nil,
            queryString: Swift.String? = nil
        )
        {
            self.analysisTemplateArn = analysisTemplateArn
            self.parameters = parameters
            self.queryString = queryString
        }
    }
}

extension CleanRoomsClientTypes.ProtectedQuerySQLParameters: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension CleanRoomsClientTypes {

    /// Information related to the utilization of resources that have been billed or charged for in a given context, such as a protected query.
    public struct BilledResourceUtilization: Swift.Sendable {
        /// The number of Clean Rooms Processing Unit (CRPU) hours that have been billed.
        /// This member is required.
        public var units: Swift.Double?

        public init(
            units: Swift.Double? = nil
        )
        {
            self.units = units
        }
    }
}

extension CleanRoomsClientTypes {

    /// Contains statistics about the execution of the protected query.
    public struct ProtectedQueryStatistics: Swift.Sendable {
        /// The billed resource utilization.
        public var billedResourceUtilization: CleanRoomsClientTypes.BilledResourceUtilization?
        /// The duration of the protected query, from creation until query completion.
        public var totalDurationInMillis: Swift.Int?

        public init(
            billedResourceUtilization: CleanRoomsClientTypes.BilledResourceUtilization? = nil,
            totalDurationInMillis: Swift.Int? = nil
        )
        {
            self.billedResourceUtilization = billedResourceUtilization
            self.totalDurationInMillis = totalDurationInMillis
        }
    }
}

extension CleanRoomsClientTypes {

    public enum ProtectedQueryStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case cancelling
        case failed
        case started
        case submitted
        case success
        case timedOut
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtectedQueryStatus] {
            return [
                .cancelled,
                .cancelling,
                .failed,
                .started,
                .submitted,
                .success,
                .timedOut
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .cancelling: return "CANCELLING"
            case .failed: return "FAILED"
            case .started: return "STARTED"
            case .submitted: return "SUBMITTED"
            case .success: return "SUCCESS"
            case .timedOut: return "TIMED_OUT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension CleanRoomsClientTypes {

    /// The parameters for an Clean Rooms protected query.
    public struct ProtectedQuery: Swift.Sendable {
        /// The compute configuration for the protected query.
        public var computeConfiguration: CleanRoomsClientTypes.ComputeConfiguration?
        /// The time at which the protected query was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The sensitivity parameters of the differential privacy results of the protected query.
        public var differentialPrivacy: CleanRoomsClientTypes.DifferentialPrivacyParameters?
        /// An error thrown by the protected query.
        public var error: CleanRoomsClientTypes.ProtectedQueryError?
        /// The identifier for a protected query instance.
        /// This member is required.
        public var id: Swift.String?
        /// The ARN of the membership.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The identifier for the membership.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The result of the protected query.
        public var result: CleanRoomsClientTypes.ProtectedQueryResult?
        /// Contains any details needed to write the query results.
        public var resultConfiguration: CleanRoomsClientTypes.ProtectedQueryResultConfiguration?
        /// The protected query SQL parameters.
        public var sqlParameters: CleanRoomsClientTypes.ProtectedQuerySQLParameters?
        /// Statistics about protected query execution.
        public var statistics: CleanRoomsClientTypes.ProtectedQueryStatistics?
        /// The status of the query.
        /// This member is required.
        public var status: CleanRoomsClientTypes.ProtectedQueryStatus?

        public init(
            computeConfiguration: CleanRoomsClientTypes.ComputeConfiguration? = nil,
            createTime: Foundation.Date? = nil,
            differentialPrivacy: CleanRoomsClientTypes.DifferentialPrivacyParameters? = nil,
            error: CleanRoomsClientTypes.ProtectedQueryError? = nil,
            id: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            result: CleanRoomsClientTypes.ProtectedQueryResult? = nil,
            resultConfiguration: CleanRoomsClientTypes.ProtectedQueryResultConfiguration? = nil,
            sqlParameters: CleanRoomsClientTypes.ProtectedQuerySQLParameters? = nil,
            statistics: CleanRoomsClientTypes.ProtectedQueryStatistics? = nil,
            status: CleanRoomsClientTypes.ProtectedQueryStatus? = nil
        )
        {
            self.computeConfiguration = computeConfiguration
            self.createTime = createTime
            self.differentialPrivacy = differentialPrivacy
            self.error = error
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.result = result
            self.resultConfiguration = resultConfiguration
            self.sqlParameters = sqlParameters
            self.statistics = statistics
            self.status = status
        }
    }
}

extension CleanRoomsClientTypes.ProtectedQuery: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ProtectedQuery(computeConfiguration: \(Swift.String(describing: computeConfiguration)), createTime: \(Swift.String(describing: createTime)), differentialPrivacy: \(Swift.String(describing: differentialPrivacy)), error: \(Swift.String(describing: error)), id: \(Swift.String(describing: id)), membershipArn: \(Swift.String(describing: membershipArn)), membershipId: \(Swift.String(describing: membershipId)), result: \(Swift.String(describing: result)), resultConfiguration: \(Swift.String(describing: resultConfiguration)), statistics: \(Swift.String(describing: statistics)), status: \(Swift.String(describing: status)), sqlParameters: \"CONTENT_REDACTED\")"}
}

public struct GetProtectedQueryOutput: Swift.Sendable {
    /// The query processing metadata.
    /// This member is required.
    public var protectedQuery: CleanRoomsClientTypes.ProtectedQuery?

    public init(
        protectedQuery: CleanRoomsClientTypes.ProtectedQuery? = nil
    )
    {
        self.protectedQuery = protectedQuery
    }
}

public struct ListMembershipsInput: Swift.Sendable {
    /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the `maxResults` value has not been met.
    public var maxResults: Swift.Int?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// A filter which will return only memberships in the specified status.
    public var status: CleanRoomsClientTypes.MembershipStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        status: CleanRoomsClientTypes.MembershipStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.status = status
    }
}

extension CleanRoomsClientTypes {

    /// The membership object listed by the request.
    public struct MembershipSummary: Swift.Sendable {
        /// The unique ARN for the membership.
        /// This member is required.
        public var arn: Swift.String?
        /// The unique ARN for the membership's associated collaboration.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The identifier of the Amazon Web Services principal that created the collaboration. Currently only supports Amazon Web Services account ID.
        /// This member is required.
        public var collaborationCreatorAccountId: Swift.String?
        /// The display name of the collaboration creator.
        /// This member is required.
        public var collaborationCreatorDisplayName: Swift.String?
        /// The unique ID for the membership's collaboration.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The name for the membership's collaboration.
        /// This member is required.
        public var collaborationName: Swift.String?
        /// The time when the membership was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The unique ID for the membership's collaboration.
        /// This member is required.
        public var id: Swift.String?
        /// The abilities granted to the collaboration member.
        /// This member is required.
        public var memberAbilities: [CleanRoomsClientTypes.MemberAbility]?
        /// The payment responsibilities accepted by the collaboration member.
        /// This member is required.
        public var paymentConfiguration: CleanRoomsClientTypes.MembershipPaymentConfiguration?
        /// The status of the membership.
        /// This member is required.
        public var status: CleanRoomsClientTypes.MembershipStatus?
        /// The time the membership metadata was last updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationCreatorAccountId: Swift.String? = nil,
            collaborationCreatorDisplayName: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            collaborationName: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            memberAbilities: [CleanRoomsClientTypes.MemberAbility]? = nil,
            paymentConfiguration: CleanRoomsClientTypes.MembershipPaymentConfiguration? = nil,
            status: CleanRoomsClientTypes.MembershipStatus? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationCreatorAccountId = collaborationCreatorAccountId
            self.collaborationCreatorDisplayName = collaborationCreatorDisplayName
            self.collaborationId = collaborationId
            self.collaborationName = collaborationName
            self.createTime = createTime
            self.id = id
            self.memberAbilities = memberAbilities
            self.paymentConfiguration = paymentConfiguration
            self.status = status
            self.updateTime = updateTime
        }
    }
}

public struct ListMembershipsOutput: Swift.Sendable {
    /// The list of memberships returned from the ListMemberships operation.
    /// This member is required.
    public var membershipSummaries: [CleanRoomsClientTypes.MembershipSummary]?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        membershipSummaries: [CleanRoomsClientTypes.MembershipSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.membershipSummaries = membershipSummaries
        self.nextToken = nextToken
    }
}

public struct ListPrivacyBudgetsInput: Swift.Sendable {
    /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the `maxResults` value has not been met.
    public var maxResults: Swift.Int?
    /// A unique identifier for one of your memberships for a collaboration. The privacy budget is retrieved from the collaboration that this membership belongs to. Accepts a membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// The privacy budget type.
    /// This member is required.
    public var privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType?

    public init(
        maxResults: Swift.Int? = nil,
        membershipIdentifier: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType? = nil
    )
    {
        self.maxResults = maxResults
        self.membershipIdentifier = membershipIdentifier
        self.nextToken = nextToken
        self.privacyBudgetType = privacyBudgetType
    }
}

extension CleanRoomsClientTypes {

    /// An array that summaries the specified privacy budget. This summary includes collaboration information, creation information, membership information, and privacy budget information.
    public struct PrivacyBudgetSummary: Swift.Sendable {
        /// The provided privacy budget.
        /// This member is required.
        public var budget: CleanRoomsClientTypes.PrivacyBudget?
        /// The ARN of the collaboration that contains this privacy budget.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique identifier of the collaboration that contains this privacy budget.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time at which the privacy budget was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The unique identifier of the privacy budget.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the member who created the privacy budget summary.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The identifier for a membership resource.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The ARN of the privacy budget template.
        /// This member is required.
        public var privacyBudgetTemplateArn: Swift.String?
        /// The unique identifier of the privacy budget template.
        /// This member is required.
        public var privacyBudgetTemplateId: Swift.String?
        /// Specifies the type of the privacy budget.
        /// This member is required.
        public var type: CleanRoomsClientTypes.PrivacyBudgetType?
        /// The most recent time at which the privacy budget was updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            budget: CleanRoomsClientTypes.PrivacyBudget? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            privacyBudgetTemplateArn: Swift.String? = nil,
            privacyBudgetTemplateId: Swift.String? = nil,
            type: CleanRoomsClientTypes.PrivacyBudgetType? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.budget = budget
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.privacyBudgetTemplateArn = privacyBudgetTemplateArn
            self.privacyBudgetTemplateId = privacyBudgetTemplateId
            self.type = type
            self.updateTime = updateTime
        }
    }
}

public struct ListPrivacyBudgetsOutput: Swift.Sendable {
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// An array that summarizes the privacy budgets. The summary includes collaboration information, membership information, privacy budget template information, and privacy budget details.
    /// This member is required.
    public var privacyBudgetSummaries: [CleanRoomsClientTypes.PrivacyBudgetSummary]?

    public init(
        nextToken: Swift.String? = nil,
        privacyBudgetSummaries: [CleanRoomsClientTypes.PrivacyBudgetSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.privacyBudgetSummaries = privacyBudgetSummaries
    }
}

public struct ListProtectedQueriesInput: Swift.Sendable {
    /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the `maxResults` value has not been met.
    public var maxResults: Swift.Int?
    /// The identifier for the membership in the collaboration.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// A filter on the status of the protected query.
    public var status: CleanRoomsClientTypes.ProtectedQueryStatus?

    public init(
        maxResults: Swift.Int? = nil,
        membershipIdentifier: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        status: CleanRoomsClientTypes.ProtectedQueryStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.membershipIdentifier = membershipIdentifier
        self.nextToken = nextToken
        self.status = status
    }
}

extension CleanRoomsClientTypes {

    /// The direct analysis configuration details.
    public struct DirectAnalysisConfigurationDetails: Swift.Sendable {
        /// The account IDs for the member who received the results of a protected query.
        public var receiverAccountIds: [Swift.String]?

        public init(
            receiverAccountIds: [Swift.String]? = nil
        )
        {
            self.receiverAccountIds = receiverAccountIds
        }
    }
}

extension CleanRoomsClientTypes {

    /// The configuration details.
    public enum ConfigurationDetails: Swift.Sendable {
        /// The direct analysis configuration details.
        case directanalysisconfigurationdetails(CleanRoomsClientTypes.DirectAnalysisConfigurationDetails)
        case sdkUnknown(Swift.String)
    }
}

extension CleanRoomsClientTypes {

    /// The receiver configuration for a protected query.
    public struct ReceiverConfiguration: Swift.Sendable {
        /// The type of analysis for the protected query. The results of the query can be analyzed directly (DIRECT_ANALYSIS) or used as input into additional analyses (ADDITIONAL_ANALYSIS), such as a query that is a seed for a lookalike ML model.
        /// This member is required.
        public var analysisType: CleanRoomsClientTypes.AnalysisType?
        /// The configuration details of the receiver configuration.
        public var configurationDetails: CleanRoomsClientTypes.ConfigurationDetails?

        public init(
            analysisType: CleanRoomsClientTypes.AnalysisType? = nil,
            configurationDetails: CleanRoomsClientTypes.ConfigurationDetails? = nil
        )
        {
            self.analysisType = analysisType
            self.configurationDetails = configurationDetails
        }
    }
}

extension CleanRoomsClientTypes {

    /// The protected query summary for the objects listed by the request.
    public struct ProtectedQuerySummary: Swift.Sendable {
        /// The time the protected query was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The unique ID of the protected query.
        /// This member is required.
        public var id: Swift.String?
        /// The unique ARN for the membership that initiated the protected query.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The unique ID for the membership that initiated the protected query.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The receiver configuration.
        /// This member is required.
        public var receiverConfigurations: [CleanRoomsClientTypes.ReceiverConfiguration]?
        /// The status of the protected query.
        /// This member is required.
        public var status: CleanRoomsClientTypes.ProtectedQueryStatus?

        public init(
            createTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            receiverConfigurations: [CleanRoomsClientTypes.ReceiverConfiguration]? = [],
            status: CleanRoomsClientTypes.ProtectedQueryStatus? = nil
        )
        {
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.receiverConfigurations = receiverConfigurations
            self.status = status
        }
    }
}

public struct ListProtectedQueriesOutput: Swift.Sendable {
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// A list of protected queries.
    /// This member is required.
    public var protectedQueries: [CleanRoomsClientTypes.ProtectedQuerySummary]?

    public init(
        nextToken: Swift.String? = nil,
        protectedQueries: [CleanRoomsClientTypes.ProtectedQuerySummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.protectedQueries = protectedQueries
    }
}

extension CleanRoomsClientTypes {

    /// The epsilon and noise parameters that you want to preview.
    public struct DifferentialPrivacyPreviewParametersInput: Swift.Sendable {
        /// The epsilon value that you want to preview.
        /// This member is required.
        public var epsilon: Swift.Int?
        /// Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        /// This member is required.
        public var usersNoisePerQuery: Swift.Int?

        public init(
            epsilon: Swift.Int? = nil,
            usersNoisePerQuery: Swift.Int? = nil
        )
        {
            self.epsilon = epsilon
            self.usersNoisePerQuery = usersNoisePerQuery
        }
    }
}

extension CleanRoomsClientTypes {

    /// Specifies the updated epsilon and noise parameters to preview. The preview allows you to see how the maximum number of each type of aggregation function would change with the new parameters.
    public enum PreviewPrivacyImpactParametersInput: Swift.Sendable {
        /// An array that specifies the epsilon and noise parameters.
        case differentialprivacy(CleanRoomsClientTypes.DifferentialPrivacyPreviewParametersInput)
        case sdkUnknown(Swift.String)
    }
}

public struct PreviewPrivacyImpactInput: Swift.Sendable {
    /// A unique identifier for one of your memberships for a collaboration. Accepts a membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// Specifies the desired epsilon and noise parameters to preview.
    /// This member is required.
    public var parameters: CleanRoomsClientTypes.PreviewPrivacyImpactParametersInput?

    public init(
        membershipIdentifier: Swift.String? = nil,
        parameters: CleanRoomsClientTypes.PreviewPrivacyImpactParametersInput? = nil
    )
    {
        self.membershipIdentifier = membershipIdentifier
        self.parameters = parameters
    }
}

extension CleanRoomsClientTypes {

    /// Provides an estimate of the number of aggregation functions that the member who can query can run given the epsilon and noise parameters.
    public struct DifferentialPrivacyPreviewAggregation: Swift.Sendable {
        /// The maximum number of aggregations that the member who can query can run given the epsilon and noise parameters.
        /// This member is required.
        public var maxCount: Swift.Int?
        /// The type of aggregation function.
        /// This member is required.
        public var type: CleanRoomsClientTypes.DifferentialPrivacyAggregationType?

        public init(
            maxCount: Swift.Int? = nil,
            type: CleanRoomsClientTypes.DifferentialPrivacyAggregationType? = nil
        )
        {
            self.maxCount = maxCount
            self.type = type
        }
    }
}

extension CleanRoomsClientTypes {

    /// Information about the number of aggregation functions that the member who can query can run given the epsilon and noise parameters.
    public struct DifferentialPrivacyPrivacyImpact: Swift.Sendable {
        /// The number of aggregation functions that you can perform.
        /// This member is required.
        public var aggregations: [CleanRoomsClientTypes.DifferentialPrivacyPreviewAggregation]?

        public init(
            aggregations: [CleanRoomsClientTypes.DifferentialPrivacyPreviewAggregation]? = nil
        )
        {
            self.aggregations = aggregations
        }
    }
}

extension CleanRoomsClientTypes {

    /// Provides an estimate of the number of aggregation functions that the member who can query can run given the epsilon and noise parameters.
    public enum PrivacyImpact: Swift.Sendable {
        /// An object that lists the number and type of aggregation functions you can perform.
        case differentialprivacy(CleanRoomsClientTypes.DifferentialPrivacyPrivacyImpact)
        case sdkUnknown(Swift.String)
    }
}

public struct PreviewPrivacyImpactOutput: Swift.Sendable {
    /// An estimate of the number of aggregation functions that the member who can query can run given the epsilon and noise parameters. This does not change the privacy budget.
    /// This member is required.
    public var privacyImpact: CleanRoomsClientTypes.PrivacyImpact?

    public init(
        privacyImpact: CleanRoomsClientTypes.PrivacyImpact? = nil
    )
    {
        self.privacyImpact = privacyImpact
    }
}

extension CleanRoomsClientTypes {

    public enum ProtectedQueryType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case sql
        case sdkUnknown(Swift.String)

        public static var allCases: [ProtectedQueryType] {
            return [
                .sql
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .sql: return "SQL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StartProtectedQueryInput: Swift.Sendable {
    /// The compute configuration for the protected query.
    public var computeConfiguration: CleanRoomsClientTypes.ComputeConfiguration?
    /// A unique identifier for the membership to run this query against. Currently accepts a membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The details needed to write the query results.
    public var resultConfiguration: CleanRoomsClientTypes.ProtectedQueryResultConfiguration?
    /// The protected SQL query parameters.
    /// This member is required.
    public var sqlParameters: CleanRoomsClientTypes.ProtectedQuerySQLParameters?
    /// The type of the protected query to be started.
    /// This member is required.
    public var type: CleanRoomsClientTypes.ProtectedQueryType?

    public init(
        computeConfiguration: CleanRoomsClientTypes.ComputeConfiguration? = nil,
        membershipIdentifier: Swift.String? = nil,
        resultConfiguration: CleanRoomsClientTypes.ProtectedQueryResultConfiguration? = nil,
        sqlParameters: CleanRoomsClientTypes.ProtectedQuerySQLParameters? = nil,
        type: CleanRoomsClientTypes.ProtectedQueryType? = nil
    )
    {
        self.computeConfiguration = computeConfiguration
        self.membershipIdentifier = membershipIdentifier
        self.resultConfiguration = resultConfiguration
        self.sqlParameters = sqlParameters
        self.type = type
    }
}

extension StartProtectedQueryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartProtectedQueryInput(computeConfiguration: \(Swift.String(describing: computeConfiguration)), membershipIdentifier: \(Swift.String(describing: membershipIdentifier)), resultConfiguration: \(Swift.String(describing: resultConfiguration)), type: \(Swift.String(describing: type)), sqlParameters: \"CONTENT_REDACTED\")"}
}

public struct StartProtectedQueryOutput: Swift.Sendable {
    /// The protected query.
    /// This member is required.
    public var protectedQuery: CleanRoomsClientTypes.ProtectedQuery?

    public init(
        protectedQuery: CleanRoomsClientTypes.ProtectedQuery? = nil
    )
    {
        self.protectedQuery = protectedQuery
    }
}

public struct UpdateMembershipInput: Swift.Sendable {
    /// The default protected query result configuration as specified by the member who can receive results.
    public var defaultResultConfiguration: CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration?
    /// The unique identifier of the membership.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// An indicator as to whether query logging has been enabled or disabled for the membership.
    public var queryLogStatus: CleanRoomsClientTypes.MembershipQueryLogStatus?

    public init(
        defaultResultConfiguration: CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration? = nil,
        membershipIdentifier: Swift.String? = nil,
        queryLogStatus: CleanRoomsClientTypes.MembershipQueryLogStatus? = nil
    )
    {
        self.defaultResultConfiguration = defaultResultConfiguration
        self.membershipIdentifier = membershipIdentifier
        self.queryLogStatus = queryLogStatus
    }
}

public struct UpdateMembershipOutput: Swift.Sendable {
    /// The membership object.
    /// This member is required.
    public var membership: CleanRoomsClientTypes.Membership?

    public init(
        membership: CleanRoomsClientTypes.Membership? = nil
    )
    {
        self.membership = membership
    }
}

extension CleanRoomsClientTypes {

    public enum TargetProtectedQueryStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetProtectedQueryStatus] {
            return [
                .cancelled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct UpdateProtectedQueryInput: Swift.Sendable {
    /// The identifier for a member of a protected query instance.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The identifier for a protected query instance.
    /// This member is required.
    public var protectedQueryIdentifier: Swift.String?
    /// The target status of a query. Used to update the execution status of a currently running query.
    /// This member is required.
    public var targetStatus: CleanRoomsClientTypes.TargetProtectedQueryStatus?

    public init(
        membershipIdentifier: Swift.String? = nil,
        protectedQueryIdentifier: Swift.String? = nil,
        targetStatus: CleanRoomsClientTypes.TargetProtectedQueryStatus? = nil
    )
    {
        self.membershipIdentifier = membershipIdentifier
        self.protectedQueryIdentifier = protectedQueryIdentifier
        self.targetStatus = targetStatus
    }
}

public struct UpdateProtectedQueryOutput: Swift.Sendable {
    /// The protected query output.
    /// This member is required.
    public var protectedQuery: CleanRoomsClientTypes.ProtectedQuery?

    public init(
        protectedQuery: CleanRoomsClientTypes.ProtectedQuery? = nil
    )
    {
        self.protectedQuery = protectedQuery
    }
}

extension CleanRoomsClientTypes {

    /// The epsilon and noise parameter values that you want to use for the differential privacy template.
    public struct DifferentialPrivacyTemplateParametersInput: Swift.Sendable {
        /// The epsilon value that you want to use.
        /// This member is required.
        public var epsilon: Swift.Int?
        /// Noise added per query is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        /// This member is required.
        public var usersNoisePerQuery: Swift.Int?

        public init(
            epsilon: Swift.Int? = nil,
            usersNoisePerQuery: Swift.Int? = nil
        )
        {
            self.epsilon = epsilon
            self.usersNoisePerQuery = usersNoisePerQuery
        }
    }
}

extension CleanRoomsClientTypes {

    /// The epsilon and noise parameters that you want to use for the privacy budget template.
    public enum PrivacyBudgetTemplateParametersInput: Swift.Sendable {
        /// An object that specifies the epsilon and noise parameters.
        case differentialprivacy(CleanRoomsClientTypes.DifferentialPrivacyTemplateParametersInput)
        case sdkUnknown(Swift.String)
    }
}

public struct CreatePrivacyBudgetTemplateInput: Swift.Sendable {
    /// How often the privacy budget refreshes. If you plan to regularly bring new data into the collaboration, you can use CALENDAR_MONTH to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queries across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.
    /// This member is required.
    public var autoRefresh: CleanRoomsClientTypes.PrivacyBudgetTemplateAutoRefresh?
    /// A unique identifier for one of your memberships for a collaboration. The privacy budget template is created in the collaboration that this membership belongs to. Accepts a membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// Specifies your parameters for the privacy budget template.
    /// This member is required.
    public var parameters: CleanRoomsClientTypes.PrivacyBudgetTemplateParametersInput?
    /// Specifies the type of the privacy budget template.
    /// This member is required.
    public var privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType?
    /// An optional label that you can assign to a resource when you create it. Each tag consists of a key and an optional value, both of which you define. When you use tagging, you can also use tag-based access control in IAM policies to control access to this resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        autoRefresh: CleanRoomsClientTypes.PrivacyBudgetTemplateAutoRefresh? = nil,
        membershipIdentifier: Swift.String? = nil,
        parameters: CleanRoomsClientTypes.PrivacyBudgetTemplateParametersInput? = nil,
        privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.autoRefresh = autoRefresh
        self.membershipIdentifier = membershipIdentifier
        self.parameters = parameters
        self.privacyBudgetType = privacyBudgetType
        self.tags = tags
    }
}

extension CleanRoomsClientTypes {

    /// An object that defines the privacy budget template.
    public struct PrivacyBudgetTemplate: Swift.Sendable {
        /// The ARN of the privacy budget template.
        /// This member is required.
        public var arn: Swift.String?
        /// How often the privacy budget refreshes. If you plan to regularly bring new data into the collaboration, use CALENDAR_MONTH to automatically get a new privacy budget for the collaboration every calendar month. Choosing this option allows arbitrary amounts of information to be revealed about rows of the data when repeatedly queried across refreshes. Avoid choosing this if the same rows will be repeatedly queried between privacy budget refreshes.
        /// This member is required.
        public var autoRefresh: CleanRoomsClientTypes.PrivacyBudgetTemplateAutoRefresh?
        /// The ARN of the collaboration that contains this privacy budget template.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique ID of the collaboration that contains this privacy budget template.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time at which the privacy budget template was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The unique identifier of the privacy budget template.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the member who created the privacy budget template.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The identifier for a membership resource.
        /// This member is required.
        public var membershipId: Swift.String?
        /// Specifies the epsilon and noise parameters for the privacy budget template.
        /// This member is required.
        public var parameters: CleanRoomsClientTypes.PrivacyBudgetTemplateParametersOutput?
        /// Specifies the type of the privacy budget template.
        /// This member is required.
        public var privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType?
        /// The most recent time at which the privacy budget template was updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            autoRefresh: CleanRoomsClientTypes.PrivacyBudgetTemplateAutoRefresh? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            parameters: CleanRoomsClientTypes.PrivacyBudgetTemplateParametersOutput? = nil,
            privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.autoRefresh = autoRefresh
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.parameters = parameters
            self.privacyBudgetType = privacyBudgetType
            self.updateTime = updateTime
        }
    }
}

public struct CreatePrivacyBudgetTemplateOutput: Swift.Sendable {
    /// A summary of the elements in the privacy budget template.
    /// This member is required.
    public var privacyBudgetTemplate: CleanRoomsClientTypes.PrivacyBudgetTemplate?

    public init(
        privacyBudgetTemplate: CleanRoomsClientTypes.PrivacyBudgetTemplate? = nil
    )
    {
        self.privacyBudgetTemplate = privacyBudgetTemplate
    }
}

public struct DeletePrivacyBudgetTemplateInput: Swift.Sendable {
    /// A unique identifier for one of your memberships for a collaboration. The privacy budget template is deleted from the collaboration that this membership belongs to. Accepts a membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// A unique identifier for your privacy budget template.
    /// This member is required.
    public var privacyBudgetTemplateIdentifier: Swift.String?

    public init(
        membershipIdentifier: Swift.String? = nil,
        privacyBudgetTemplateIdentifier: Swift.String? = nil
    )
    {
        self.membershipIdentifier = membershipIdentifier
        self.privacyBudgetTemplateIdentifier = privacyBudgetTemplateIdentifier
    }
}

public struct DeletePrivacyBudgetTemplateOutput: Swift.Sendable {

    public init() { }
}

public struct GetPrivacyBudgetTemplateInput: Swift.Sendable {
    /// A unique identifier for one of your memberships for a collaboration. The privacy budget template is retrieved from the collaboration that this membership belongs to. Accepts a membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// A unique identifier for your privacy budget template.
    /// This member is required.
    public var privacyBudgetTemplateIdentifier: Swift.String?

    public init(
        membershipIdentifier: Swift.String? = nil,
        privacyBudgetTemplateIdentifier: Swift.String? = nil
    )
    {
        self.membershipIdentifier = membershipIdentifier
        self.privacyBudgetTemplateIdentifier = privacyBudgetTemplateIdentifier
    }
}

public struct GetPrivacyBudgetTemplateOutput: Swift.Sendable {
    /// Returns the details of the privacy budget template that you requested.
    /// This member is required.
    public var privacyBudgetTemplate: CleanRoomsClientTypes.PrivacyBudgetTemplate?

    public init(
        privacyBudgetTemplate: CleanRoomsClientTypes.PrivacyBudgetTemplate? = nil
    )
    {
        self.privacyBudgetTemplate = privacyBudgetTemplate
    }
}

public struct ListPrivacyBudgetTemplatesInput: Swift.Sendable {
    /// The maximum number of results that are returned for an API request call. The service chooses a default number if you don't set one. The service might return a `nextToken` even if the `maxResults` value has not been met.
    public var maxResults: Swift.Int?
    /// A unique identifier for one of your memberships for a collaboration. The privacy budget templates are retrieved from the collaboration that this membership belongs to. Accepts a membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        membershipIdentifier: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.membershipIdentifier = membershipIdentifier
        self.nextToken = nextToken
    }
}

extension CleanRoomsClientTypes {

    /// A summary of the privacy budget template. The summary includes membership information, collaboration information, and creation information.
    public struct PrivacyBudgetTemplateSummary: Swift.Sendable {
        /// The ARN of the privacy budget template.
        /// This member is required.
        public var arn: Swift.String?
        /// The ARN of the collaboration that contains this privacy budget template.
        /// This member is required.
        public var collaborationArn: Swift.String?
        /// The unique ID of the collaboration that contains this privacy budget template.
        /// This member is required.
        public var collaborationId: Swift.String?
        /// The time at which the privacy budget template was created.
        /// This member is required.
        public var createTime: Foundation.Date?
        /// The unique identifier of the privacy budget template.
        /// This member is required.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the member who created the privacy budget template.
        /// This member is required.
        public var membershipArn: Swift.String?
        /// The identifier for a membership resource.
        /// This member is required.
        public var membershipId: Swift.String?
        /// The type of the privacy budget template.
        /// This member is required.
        public var privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType?
        /// The most recent time at which the privacy budget template was updated.
        /// This member is required.
        public var updateTime: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            collaborationArn: Swift.String? = nil,
            collaborationId: Swift.String? = nil,
            createTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            membershipArn: Swift.String? = nil,
            membershipId: Swift.String? = nil,
            privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType? = nil,
            updateTime: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.collaborationArn = collaborationArn
            self.collaborationId = collaborationId
            self.createTime = createTime
            self.id = id
            self.membershipArn = membershipArn
            self.membershipId = membershipId
            self.privacyBudgetType = privacyBudgetType
            self.updateTime = updateTime
        }
    }
}

public struct ListPrivacyBudgetTemplatesOutput: Swift.Sendable {
    /// The pagination token that's used to fetch the next set of results.
    public var nextToken: Swift.String?
    /// An array that summarizes the privacy budget templates. The summary includes collaboration information, creation information, and privacy budget type.
    /// This member is required.
    public var privacyBudgetTemplateSummaries: [CleanRoomsClientTypes.PrivacyBudgetTemplateSummary]?

    public init(
        nextToken: Swift.String? = nil,
        privacyBudgetTemplateSummaries: [CleanRoomsClientTypes.PrivacyBudgetTemplateSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.privacyBudgetTemplateSummaries = privacyBudgetTemplateSummaries
    }
}

extension CleanRoomsClientTypes {

    /// The epsilon and noise parameter values that you want to update in the differential privacy template.
    public struct DifferentialPrivacyTemplateUpdateParameters: Swift.Sendable {
        /// The updated epsilon value that you want to use.
        public var epsilon: Swift.Int?
        /// The updated value of noise added per query. It is measured in terms of the number of users whose contributions you want to obscure. This value governs the rate at which the privacy budget is depleted.
        public var usersNoisePerQuery: Swift.Int?

        public init(
            epsilon: Swift.Int? = nil,
            usersNoisePerQuery: Swift.Int? = nil
        )
        {
            self.epsilon = epsilon
            self.usersNoisePerQuery = usersNoisePerQuery
        }
    }
}

extension CleanRoomsClientTypes {

    /// The epsilon and noise parameters that you want to update in the privacy budget template.
    public enum PrivacyBudgetTemplateUpdateParameters: Swift.Sendable {
        /// An object that specifies the new values for the epsilon and noise parameters.
        case differentialprivacy(CleanRoomsClientTypes.DifferentialPrivacyTemplateUpdateParameters)
        case sdkUnknown(Swift.String)
    }
}

public struct UpdatePrivacyBudgetTemplateInput: Swift.Sendable {
    /// A unique identifier for one of your memberships for a collaboration. The privacy budget template is updated in the collaboration that this membership belongs to. Accepts a membership ID.
    /// This member is required.
    public var membershipIdentifier: Swift.String?
    /// Specifies the epsilon and noise parameters for the privacy budget template.
    public var parameters: CleanRoomsClientTypes.PrivacyBudgetTemplateUpdateParameters?
    /// A unique identifier for your privacy budget template that you want to update.
    /// This member is required.
    public var privacyBudgetTemplateIdentifier: Swift.String?
    /// Specifies the type of the privacy budget template.
    /// This member is required.
    public var privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType?

    public init(
        membershipIdentifier: Swift.String? = nil,
        parameters: CleanRoomsClientTypes.PrivacyBudgetTemplateUpdateParameters? = nil,
        privacyBudgetTemplateIdentifier: Swift.String? = nil,
        privacyBudgetType: CleanRoomsClientTypes.PrivacyBudgetType? = nil
    )
    {
        self.membershipIdentifier = membershipIdentifier
        self.parameters = parameters
        self.privacyBudgetTemplateIdentifier = privacyBudgetTemplateIdentifier
        self.privacyBudgetType = privacyBudgetType
    }
}

public struct UpdatePrivacyBudgetTemplateOutput: Swift.Sendable {
    /// Summary of the privacy budget template.
    /// This member is required.
    public var privacyBudgetTemplate: CleanRoomsClientTypes.PrivacyBudgetTemplate?

    public init(
        privacyBudgetTemplate: CleanRoomsClientTypes.PrivacyBudgetTemplate? = nil
    )
    {
        self.privacyBudgetTemplate = privacyBudgetTemplate
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) associated with the resource you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map of objects specifying each key name and value.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) associated with the resource you want to remove the tag from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of key names of tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension BatchGetCollaborationAnalysisTemplateInput {

    static func urlPathProvider(_ value: BatchGetCollaborationAnalysisTemplateInput) -> Swift.String? {
        guard let collaborationIdentifier = value.collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/batch-analysistemplates"
    }
}

extension BatchGetSchemaInput {

    static func urlPathProvider(_ value: BatchGetSchemaInput) -> Swift.String? {
        guard let collaborationIdentifier = value.collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/batch-schema"
    }
}

extension BatchGetSchemaAnalysisRuleInput {

    static func urlPathProvider(_ value: BatchGetSchemaAnalysisRuleInput) -> Swift.String? {
        guard let collaborationIdentifier = value.collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/batch-schema-analysis-rule"
    }
}

extension CreateAnalysisTemplateInput {

    static func urlPathProvider(_ value: CreateAnalysisTemplateInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/analysistemplates"
    }
}

extension CreateCollaborationInput {

    static func urlPathProvider(_ value: CreateCollaborationInput) -> Swift.String? {
        return "/collaborations"
    }
}

extension CreateConfiguredAudienceModelAssociationInput {

    static func urlPathProvider(_ value: CreateConfiguredAudienceModelAssociationInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredaudiencemodelassociations"
    }
}

extension CreateConfiguredTableInput {

    static func urlPathProvider(_ value: CreateConfiguredTableInput) -> Swift.String? {
        return "/configuredTables"
    }
}

extension CreateConfiguredTableAnalysisRuleInput {

    static func urlPathProvider(_ value: CreateConfiguredTableAnalysisRuleInput) -> Swift.String? {
        guard let configuredTableIdentifier = value.configuredTableIdentifier else {
            return nil
        }
        return "/configuredTables/\(configuredTableIdentifier.urlPercentEncoding())/analysisRule"
    }
}

extension CreateConfiguredTableAssociationInput {

    static func urlPathProvider(_ value: CreateConfiguredTableAssociationInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredTableAssociations"
    }
}

extension CreateConfiguredTableAssociationAnalysisRuleInput {

    static func urlPathProvider(_ value: CreateConfiguredTableAssociationAnalysisRuleInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let configuredTableAssociationIdentifier = value.configuredTableAssociationIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredTableAssociations/\(configuredTableAssociationIdentifier.urlPercentEncoding())/analysisRule"
    }
}

extension CreateIdMappingTableInput {

    static func urlPathProvider(_ value: CreateIdMappingTableInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/idmappingtables"
    }
}

extension CreateIdNamespaceAssociationInput {

    static func urlPathProvider(_ value: CreateIdNamespaceAssociationInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/idnamespaceassociations"
    }
}

extension CreateMembershipInput {

    static func urlPathProvider(_ value: CreateMembershipInput) -> Swift.String? {
        return "/memberships"
    }
}

extension CreatePrivacyBudgetTemplateInput {

    static func urlPathProvider(_ value: CreatePrivacyBudgetTemplateInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/privacybudgettemplates"
    }
}

extension DeleteAnalysisTemplateInput {

    static func urlPathProvider(_ value: DeleteAnalysisTemplateInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let analysisTemplateIdentifier = value.analysisTemplateIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/analysistemplates/\(analysisTemplateIdentifier.urlPercentEncoding())"
    }
}

extension DeleteCollaborationInput {

    static func urlPathProvider(_ value: DeleteCollaborationInput) -> Swift.String? {
        guard let collaborationIdentifier = value.collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())"
    }
}

extension DeleteConfiguredAudienceModelAssociationInput {

    static func urlPathProvider(_ value: DeleteConfiguredAudienceModelAssociationInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let configuredAudienceModelAssociationIdentifier = value.configuredAudienceModelAssociationIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredaudiencemodelassociations/\(configuredAudienceModelAssociationIdentifier.urlPercentEncoding())"
    }
}

extension DeleteConfiguredTableInput {

    static func urlPathProvider(_ value: DeleteConfiguredTableInput) -> Swift.String? {
        guard let configuredTableIdentifier = value.configuredTableIdentifier else {
            return nil
        }
        return "/configuredTables/\(configuredTableIdentifier.urlPercentEncoding())"
    }
}

extension DeleteConfiguredTableAnalysisRuleInput {

    static func urlPathProvider(_ value: DeleteConfiguredTableAnalysisRuleInput) -> Swift.String? {
        guard let configuredTableIdentifier = value.configuredTableIdentifier else {
            return nil
        }
        guard let analysisRuleType = value.analysisRuleType else {
            return nil
        }
        return "/configuredTables/\(configuredTableIdentifier.urlPercentEncoding())/analysisRule/\(analysisRuleType.rawValue.urlPercentEncoding())"
    }
}

extension DeleteConfiguredTableAssociationInput {

    static func urlPathProvider(_ value: DeleteConfiguredTableAssociationInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let configuredTableAssociationIdentifier = value.configuredTableAssociationIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredTableAssociations/\(configuredTableAssociationIdentifier.urlPercentEncoding())"
    }
}

extension DeleteConfiguredTableAssociationAnalysisRuleInput {

    static func urlPathProvider(_ value: DeleteConfiguredTableAssociationAnalysisRuleInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let configuredTableAssociationIdentifier = value.configuredTableAssociationIdentifier else {
            return nil
        }
        guard let analysisRuleType = value.analysisRuleType else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredTableAssociations/\(configuredTableAssociationIdentifier.urlPercentEncoding())/analysisRule/\(analysisRuleType.rawValue.urlPercentEncoding())"
    }
}

extension DeleteIdMappingTableInput {

    static func urlPathProvider(_ value: DeleteIdMappingTableInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let idMappingTableIdentifier = value.idMappingTableIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/idmappingtables/\(idMappingTableIdentifier.urlPercentEncoding())"
    }
}

extension DeleteIdNamespaceAssociationInput {

    static func urlPathProvider(_ value: DeleteIdNamespaceAssociationInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let idNamespaceAssociationIdentifier = value.idNamespaceAssociationIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/idnamespaceassociations/\(idNamespaceAssociationIdentifier.urlPercentEncoding())"
    }
}

extension DeleteMemberInput {

    static func urlPathProvider(_ value: DeleteMemberInput) -> Swift.String? {
        guard let collaborationIdentifier = value.collaborationIdentifier else {
            return nil
        }
        guard let accountId = value.accountId else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/member/\(accountId.urlPercentEncoding())"
    }
}

extension DeleteMembershipInput {

    static func urlPathProvider(_ value: DeleteMembershipInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())"
    }
}

extension DeletePrivacyBudgetTemplateInput {

    static func urlPathProvider(_ value: DeletePrivacyBudgetTemplateInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let privacyBudgetTemplateIdentifier = value.privacyBudgetTemplateIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/privacybudgettemplates/\(privacyBudgetTemplateIdentifier.urlPercentEncoding())"
    }
}

extension GetAnalysisTemplateInput {

    static func urlPathProvider(_ value: GetAnalysisTemplateInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let analysisTemplateIdentifier = value.analysisTemplateIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/analysistemplates/\(analysisTemplateIdentifier.urlPercentEncoding())"
    }
}

extension GetCollaborationInput {

    static func urlPathProvider(_ value: GetCollaborationInput) -> Swift.String? {
        guard let collaborationIdentifier = value.collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())"
    }
}

extension GetCollaborationAnalysisTemplateInput {

    static func urlPathProvider(_ value: GetCollaborationAnalysisTemplateInput) -> Swift.String? {
        guard let collaborationIdentifier = value.collaborationIdentifier else {
            return nil
        }
        guard let analysisTemplateArn = value.analysisTemplateArn else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/analysistemplates/\(analysisTemplateArn.urlPercentEncoding())"
    }
}

extension GetCollaborationConfiguredAudienceModelAssociationInput {

    static func urlPathProvider(_ value: GetCollaborationConfiguredAudienceModelAssociationInput) -> Swift.String? {
        guard let collaborationIdentifier = value.collaborationIdentifier else {
            return nil
        }
        guard let configuredAudienceModelAssociationIdentifier = value.configuredAudienceModelAssociationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/configuredaudiencemodelassociations/\(configuredAudienceModelAssociationIdentifier.urlPercentEncoding())"
    }
}

extension GetCollaborationIdNamespaceAssociationInput {

    static func urlPathProvider(_ value: GetCollaborationIdNamespaceAssociationInput) -> Swift.String? {
        guard let collaborationIdentifier = value.collaborationIdentifier else {
            return nil
        }
        guard let idNamespaceAssociationIdentifier = value.idNamespaceAssociationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/idnamespaceassociations/\(idNamespaceAssociationIdentifier.urlPercentEncoding())"
    }
}

extension GetCollaborationPrivacyBudgetTemplateInput {

    static func urlPathProvider(_ value: GetCollaborationPrivacyBudgetTemplateInput) -> Swift.String? {
        guard let collaborationIdentifier = value.collaborationIdentifier else {
            return nil
        }
        guard let privacyBudgetTemplateIdentifier = value.privacyBudgetTemplateIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/privacybudgettemplates/\(privacyBudgetTemplateIdentifier.urlPercentEncoding())"
    }
}

extension GetConfiguredAudienceModelAssociationInput {

    static func urlPathProvider(_ value: GetConfiguredAudienceModelAssociationInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let configuredAudienceModelAssociationIdentifier = value.configuredAudienceModelAssociationIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredaudiencemodelassociations/\(configuredAudienceModelAssociationIdentifier.urlPercentEncoding())"
    }
}

extension GetConfiguredTableInput {

    static func urlPathProvider(_ value: GetConfiguredTableInput) -> Swift.String? {
        guard let configuredTableIdentifier = value.configuredTableIdentifier else {
            return nil
        }
        return "/configuredTables/\(configuredTableIdentifier.urlPercentEncoding())"
    }
}

extension GetConfiguredTableAnalysisRuleInput {

    static func urlPathProvider(_ value: GetConfiguredTableAnalysisRuleInput) -> Swift.String? {
        guard let configuredTableIdentifier = value.configuredTableIdentifier else {
            return nil
        }
        guard let analysisRuleType = value.analysisRuleType else {
            return nil
        }
        return "/configuredTables/\(configuredTableIdentifier.urlPercentEncoding())/analysisRule/\(analysisRuleType.rawValue.urlPercentEncoding())"
    }
}

extension GetConfiguredTableAssociationInput {

    static func urlPathProvider(_ value: GetConfiguredTableAssociationInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let configuredTableAssociationIdentifier = value.configuredTableAssociationIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredTableAssociations/\(configuredTableAssociationIdentifier.urlPercentEncoding())"
    }
}

extension GetConfiguredTableAssociationAnalysisRuleInput {

    static func urlPathProvider(_ value: GetConfiguredTableAssociationAnalysisRuleInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let configuredTableAssociationIdentifier = value.configuredTableAssociationIdentifier else {
            return nil
        }
        guard let analysisRuleType = value.analysisRuleType else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredTableAssociations/\(configuredTableAssociationIdentifier.urlPercentEncoding())/analysisRule/\(analysisRuleType.rawValue.urlPercentEncoding())"
    }
}

extension GetIdMappingTableInput {

    static func urlPathProvider(_ value: GetIdMappingTableInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let idMappingTableIdentifier = value.idMappingTableIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/idmappingtables/\(idMappingTableIdentifier.urlPercentEncoding())"
    }
}

extension GetIdNamespaceAssociationInput {

    static func urlPathProvider(_ value: GetIdNamespaceAssociationInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let idNamespaceAssociationIdentifier = value.idNamespaceAssociationIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/idnamespaceassociations/\(idNamespaceAssociationIdentifier.urlPercentEncoding())"
    }
}

extension GetMembershipInput {

    static func urlPathProvider(_ value: GetMembershipInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())"
    }
}

extension GetPrivacyBudgetTemplateInput {

    static func urlPathProvider(_ value: GetPrivacyBudgetTemplateInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let privacyBudgetTemplateIdentifier = value.privacyBudgetTemplateIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/privacybudgettemplates/\(privacyBudgetTemplateIdentifier.urlPercentEncoding())"
    }
}

extension GetProtectedQueryInput {

    static func urlPathProvider(_ value: GetProtectedQueryInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let protectedQueryIdentifier = value.protectedQueryIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/protectedQueries/\(protectedQueryIdentifier.urlPercentEncoding())"
    }
}

extension GetSchemaInput {

    static func urlPathProvider(_ value: GetSchemaInput) -> Swift.String? {
        guard let collaborationIdentifier = value.collaborationIdentifier else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/schemas/\(name.urlPercentEncoding())"
    }
}

extension GetSchemaAnalysisRuleInput {

    static func urlPathProvider(_ value: GetSchemaAnalysisRuleInput) -> Swift.String? {
        guard let collaborationIdentifier = value.collaborationIdentifier else {
            return nil
        }
        guard let name = value.name else {
            return nil
        }
        guard let type = value.type else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/schemas/\(name.urlPercentEncoding())/analysisRule/\(type.rawValue.urlPercentEncoding())"
    }
}

extension ListAnalysisTemplatesInput {

    static func urlPathProvider(_ value: ListAnalysisTemplatesInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/analysistemplates"
    }
}

extension ListAnalysisTemplatesInput {

    static func queryItemProvider(_ value: ListAnalysisTemplatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCollaborationAnalysisTemplatesInput {

    static func urlPathProvider(_ value: ListCollaborationAnalysisTemplatesInput) -> Swift.String? {
        guard let collaborationIdentifier = value.collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/analysistemplates"
    }
}

extension ListCollaborationAnalysisTemplatesInput {

    static func queryItemProvider(_ value: ListCollaborationAnalysisTemplatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCollaborationConfiguredAudienceModelAssociationsInput {

    static func urlPathProvider(_ value: ListCollaborationConfiguredAudienceModelAssociationsInput) -> Swift.String? {
        guard let collaborationIdentifier = value.collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/configuredaudiencemodelassociations"
    }
}

extension ListCollaborationConfiguredAudienceModelAssociationsInput {

    static func queryItemProvider(_ value: ListCollaborationConfiguredAudienceModelAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCollaborationIdNamespaceAssociationsInput {

    static func urlPathProvider(_ value: ListCollaborationIdNamespaceAssociationsInput) -> Swift.String? {
        guard let collaborationIdentifier = value.collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/idnamespaceassociations"
    }
}

extension ListCollaborationIdNamespaceAssociationsInput {

    static func queryItemProvider(_ value: ListCollaborationIdNamespaceAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCollaborationPrivacyBudgetsInput {

    static func urlPathProvider(_ value: ListCollaborationPrivacyBudgetsInput) -> Swift.String? {
        guard let collaborationIdentifier = value.collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/privacybudgets"
    }
}

extension ListCollaborationPrivacyBudgetsInput {

    static func queryItemProvider(_ value: ListCollaborationPrivacyBudgetsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let privacyBudgetType = value.privacyBudgetType else {
            let message = "Creating a URL Query Item failed. privacyBudgetType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let privacyBudgetTypeQueryItem = Smithy.URIQueryItem(name: "privacyBudgetType".urlPercentEncoding(), value: Swift.String(privacyBudgetType.rawValue).urlPercentEncoding())
        items.append(privacyBudgetTypeQueryItem)
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListCollaborationPrivacyBudgetTemplatesInput {

    static func urlPathProvider(_ value: ListCollaborationPrivacyBudgetTemplatesInput) -> Swift.String? {
        guard let collaborationIdentifier = value.collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/privacybudgettemplates"
    }
}

extension ListCollaborationPrivacyBudgetTemplatesInput {

    static func queryItemProvider(_ value: ListCollaborationPrivacyBudgetTemplatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCollaborationsInput {

    static func urlPathProvider(_ value: ListCollaborationsInput) -> Swift.String? {
        return "/collaborations"
    }
}

extension ListCollaborationsInput {

    static func queryItemProvider(_ value: ListCollaborationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let memberStatus = value.memberStatus {
            let memberStatusQueryItem = Smithy.URIQueryItem(name: "memberStatus".urlPercentEncoding(), value: Swift.String(memberStatus.rawValue).urlPercentEncoding())
            items.append(memberStatusQueryItem)
        }
        return items
    }
}

extension ListConfiguredAudienceModelAssociationsInput {

    static func urlPathProvider(_ value: ListConfiguredAudienceModelAssociationsInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredaudiencemodelassociations"
    }
}

extension ListConfiguredAudienceModelAssociationsInput {

    static func queryItemProvider(_ value: ListConfiguredAudienceModelAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListConfiguredTableAssociationsInput {

    static func urlPathProvider(_ value: ListConfiguredTableAssociationsInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredTableAssociations"
    }
}

extension ListConfiguredTableAssociationsInput {

    static func queryItemProvider(_ value: ListConfiguredTableAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListConfiguredTablesInput {

    static func urlPathProvider(_ value: ListConfiguredTablesInput) -> Swift.String? {
        return "/configuredTables"
    }
}

extension ListConfiguredTablesInput {

    static func queryItemProvider(_ value: ListConfiguredTablesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIdMappingTablesInput {

    static func urlPathProvider(_ value: ListIdMappingTablesInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/idmappingtables"
    }
}

extension ListIdMappingTablesInput {

    static func queryItemProvider(_ value: ListIdMappingTablesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListIdNamespaceAssociationsInput {

    static func urlPathProvider(_ value: ListIdNamespaceAssociationsInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/idnamespaceassociations"
    }
}

extension ListIdNamespaceAssociationsInput {

    static func queryItemProvider(_ value: ListIdNamespaceAssociationsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMembersInput {

    static func urlPathProvider(_ value: ListMembersInput) -> Swift.String? {
        guard let collaborationIdentifier = value.collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/members"
    }
}

extension ListMembersInput {

    static func queryItemProvider(_ value: ListMembersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListMembershipsInput {

    static func urlPathProvider(_ value: ListMembershipsInput) -> Swift.String? {
        return "/memberships"
    }
}

extension ListMembershipsInput {

    static func queryItemProvider(_ value: ListMembershipsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListPrivacyBudgetsInput {

    static func urlPathProvider(_ value: ListPrivacyBudgetsInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/privacybudgets"
    }
}

extension ListPrivacyBudgetsInput {

    static func queryItemProvider(_ value: ListPrivacyBudgetsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let privacyBudgetType = value.privacyBudgetType else {
            let message = "Creating a URL Query Item failed. privacyBudgetType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let privacyBudgetTypeQueryItem = Smithy.URIQueryItem(name: "privacyBudgetType".urlPercentEncoding(), value: Swift.String(privacyBudgetType.rawValue).urlPercentEncoding())
        items.append(privacyBudgetTypeQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPrivacyBudgetTemplatesInput {

    static func urlPathProvider(_ value: ListPrivacyBudgetTemplatesInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/privacybudgettemplates"
    }
}

extension ListPrivacyBudgetTemplatesInput {

    static func queryItemProvider(_ value: ListPrivacyBudgetTemplatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProtectedQueriesInput {

    static func urlPathProvider(_ value: ListProtectedQueriesInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/protectedQueries"
    }
}

extension ListProtectedQueriesInput {

    static func queryItemProvider(_ value: ListProtectedQueriesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = Smithy.URIQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListSchemasInput {

    static func urlPathProvider(_ value: ListSchemasInput) -> Swift.String? {
        guard let collaborationIdentifier = value.collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())/schemas"
    }
}

extension ListSchemasInput {

    static func queryItemProvider(_ value: ListSchemasInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let schemaType = value.schemaType {
            let schemaTypeQueryItem = Smithy.URIQueryItem(name: "schemaType".urlPercentEncoding(), value: Swift.String(schemaType.rawValue).urlPercentEncoding())
            items.append(schemaTypeQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension PopulateIdMappingTableInput {

    static func urlPathProvider(_ value: PopulateIdMappingTableInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let idMappingTableIdentifier = value.idMappingTableIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/idmappingtables/\(idMappingTableIdentifier.urlPercentEncoding())/populate"
    }
}

extension PreviewPrivacyImpactInput {

    static func urlPathProvider(_ value: PreviewPrivacyImpactInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/previewprivacyimpact"
    }
}

extension StartProtectedQueryInput {

    static func urlPathProvider(_ value: StartProtectedQueryInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/protectedQueries"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateAnalysisTemplateInput {

    static func urlPathProvider(_ value: UpdateAnalysisTemplateInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let analysisTemplateIdentifier = value.analysisTemplateIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/analysistemplates/\(analysisTemplateIdentifier.urlPercentEncoding())"
    }
}

extension UpdateCollaborationInput {

    static func urlPathProvider(_ value: UpdateCollaborationInput) -> Swift.String? {
        guard let collaborationIdentifier = value.collaborationIdentifier else {
            return nil
        }
        return "/collaborations/\(collaborationIdentifier.urlPercentEncoding())"
    }
}

extension UpdateConfiguredAudienceModelAssociationInput {

    static func urlPathProvider(_ value: UpdateConfiguredAudienceModelAssociationInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let configuredAudienceModelAssociationIdentifier = value.configuredAudienceModelAssociationIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredaudiencemodelassociations/\(configuredAudienceModelAssociationIdentifier.urlPercentEncoding())"
    }
}

extension UpdateConfiguredTableInput {

    static func urlPathProvider(_ value: UpdateConfiguredTableInput) -> Swift.String? {
        guard let configuredTableIdentifier = value.configuredTableIdentifier else {
            return nil
        }
        return "/configuredTables/\(configuredTableIdentifier.urlPercentEncoding())"
    }
}

extension UpdateConfiguredTableAnalysisRuleInput {

    static func urlPathProvider(_ value: UpdateConfiguredTableAnalysisRuleInput) -> Swift.String? {
        guard let configuredTableIdentifier = value.configuredTableIdentifier else {
            return nil
        }
        guard let analysisRuleType = value.analysisRuleType else {
            return nil
        }
        return "/configuredTables/\(configuredTableIdentifier.urlPercentEncoding())/analysisRule/\(analysisRuleType.rawValue.urlPercentEncoding())"
    }
}

extension UpdateConfiguredTableAssociationInput {

    static func urlPathProvider(_ value: UpdateConfiguredTableAssociationInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let configuredTableAssociationIdentifier = value.configuredTableAssociationIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredTableAssociations/\(configuredTableAssociationIdentifier.urlPercentEncoding())"
    }
}

extension UpdateConfiguredTableAssociationAnalysisRuleInput {

    static func urlPathProvider(_ value: UpdateConfiguredTableAssociationAnalysisRuleInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let configuredTableAssociationIdentifier = value.configuredTableAssociationIdentifier else {
            return nil
        }
        guard let analysisRuleType = value.analysisRuleType else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/configuredTableAssociations/\(configuredTableAssociationIdentifier.urlPercentEncoding())/analysisRule/\(analysisRuleType.rawValue.urlPercentEncoding())"
    }
}

extension UpdateIdMappingTableInput {

    static func urlPathProvider(_ value: UpdateIdMappingTableInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let idMappingTableIdentifier = value.idMappingTableIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/idmappingtables/\(idMappingTableIdentifier.urlPercentEncoding())"
    }
}

extension UpdateIdNamespaceAssociationInput {

    static func urlPathProvider(_ value: UpdateIdNamespaceAssociationInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let idNamespaceAssociationIdentifier = value.idNamespaceAssociationIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/idnamespaceassociations/\(idNamespaceAssociationIdentifier.urlPercentEncoding())"
    }
}

extension UpdateMembershipInput {

    static func urlPathProvider(_ value: UpdateMembershipInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())"
    }
}

extension UpdatePrivacyBudgetTemplateInput {

    static func urlPathProvider(_ value: UpdatePrivacyBudgetTemplateInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let privacyBudgetTemplateIdentifier = value.privacyBudgetTemplateIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/privacybudgettemplates/\(privacyBudgetTemplateIdentifier.urlPercentEncoding())"
    }
}

extension UpdateProtectedQueryInput {

    static func urlPathProvider(_ value: UpdateProtectedQueryInput) -> Swift.String? {
        guard let membershipIdentifier = value.membershipIdentifier else {
            return nil
        }
        guard let protectedQueryIdentifier = value.protectedQueryIdentifier else {
            return nil
        }
        return "/memberships/\(membershipIdentifier.urlPercentEncoding())/protectedQueries/\(protectedQueryIdentifier.urlPercentEncoding())"
    }
}

extension BatchGetCollaborationAnalysisTemplateInput {

    static func write(value: BatchGetCollaborationAnalysisTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["analysisTemplateArns"].writeList(value.analysisTemplateArns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetSchemaInput {

    static func write(value: BatchGetSchemaInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["names"].writeList(value.names, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension BatchGetSchemaAnalysisRuleInput {

    static func write(value: BatchGetSchemaAnalysisRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["schemaAnalysisRuleRequests"].writeList(value.schemaAnalysisRuleRequests, memberWritingClosure: CleanRoomsClientTypes.SchemaAnalysisRuleRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAnalysisTemplateInput {

    static func write(value: CreateAnalysisTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["analysisParameters"].writeList(value.analysisParameters, memberWritingClosure: CleanRoomsClientTypes.AnalysisParameter.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["format"].write(value.format)
        try writer["name"].write(value.name)
        try writer["source"].write(value.source, with: CleanRoomsClientTypes.AnalysisSource.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateCollaborationInput {

    static func write(value: CreateCollaborationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["analyticsEngine"].write(value.analyticsEngine)
        try writer["creatorDisplayName"].write(value.creatorDisplayName)
        try writer["creatorMemberAbilities"].writeList(value.creatorMemberAbilities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<CleanRoomsClientTypes.MemberAbility>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["creatorPaymentConfiguration"].write(value.creatorPaymentConfiguration, with: CleanRoomsClientTypes.PaymentConfiguration.write(value:to:))
        try writer["dataEncryptionMetadata"].write(value.dataEncryptionMetadata, with: CleanRoomsClientTypes.DataEncryptionMetadata.write(value:to:))
        try writer["description"].write(value.description)
        try writer["members"].writeList(value.members, memberWritingClosure: CleanRoomsClientTypes.MemberSpecification.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["queryLogStatus"].write(value.queryLogStatus)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateConfiguredAudienceModelAssociationInput {

    static func write(value: CreateConfiguredAudienceModelAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuredAudienceModelArn"].write(value.configuredAudienceModelArn)
        try writer["configuredAudienceModelAssociationName"].write(value.configuredAudienceModelAssociationName)
        try writer["description"].write(value.description)
        try writer["manageResourcePolicies"].write(value.manageResourcePolicies)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateConfiguredTableInput {

    static func write(value: CreateConfiguredTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowedColumns"].writeList(value.allowedColumns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["analysisMethod"].write(value.analysisMethod)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["tableReference"].write(value.tableReference, with: CleanRoomsClientTypes.TableReference.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateConfiguredTableAnalysisRuleInput {

    static func write(value: CreateConfiguredTableAnalysisRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["analysisRulePolicy"].write(value.analysisRulePolicy, with: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy.write(value:to:))
        try writer["analysisRuleType"].write(value.analysisRuleType)
    }
}

extension CreateConfiguredTableAssociationInput {

    static func write(value: CreateConfiguredTableAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configuredTableIdentifier"].write(value.configuredTableIdentifier)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateConfiguredTableAssociationAnalysisRuleInput {

    static func write(value: CreateConfiguredTableAssociationAnalysisRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["analysisRulePolicy"].write(value.analysisRulePolicy, with: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRulePolicy.write(value:to:))
        try writer["analysisRuleType"].write(value.analysisRuleType)
    }
}

extension CreateIdMappingTableInput {

    static func write(value: CreateIdMappingTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["inputReferenceConfig"].write(value.inputReferenceConfig, with: CleanRoomsClientTypes.IdMappingTableInputReferenceConfig.write(value:to:))
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateIdNamespaceAssociationInput {

    static func write(value: CreateIdNamespaceAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["idMappingConfig"].write(value.idMappingConfig, with: CleanRoomsClientTypes.IdMappingConfig.write(value:to:))
        try writer["inputReferenceConfig"].write(value.inputReferenceConfig, with: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceConfig.write(value:to:))
        try writer["name"].write(value.name)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateMembershipInput {

    static func write(value: CreateMembershipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["collaborationIdentifier"].write(value.collaborationIdentifier)
        try writer["defaultResultConfiguration"].write(value.defaultResultConfiguration, with: CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration.write(value:to:))
        try writer["paymentConfiguration"].write(value.paymentConfiguration, with: CleanRoomsClientTypes.MembershipPaymentConfiguration.write(value:to:))
        try writer["queryLogStatus"].write(value.queryLogStatus)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreatePrivacyBudgetTemplateInput {

    static func write(value: CreatePrivacyBudgetTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["autoRefresh"].write(value.autoRefresh)
        try writer["parameters"].write(value.parameters, with: CleanRoomsClientTypes.PrivacyBudgetTemplateParametersInput.write(value:to:))
        try writer["privacyBudgetType"].write(value.privacyBudgetType)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension PreviewPrivacyImpactInput {

    static func write(value: PreviewPrivacyImpactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["parameters"].write(value.parameters, with: CleanRoomsClientTypes.PreviewPrivacyImpactParametersInput.write(value:to:))
    }
}

extension StartProtectedQueryInput {

    static func write(value: StartProtectedQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["computeConfiguration"].write(value.computeConfiguration, with: CleanRoomsClientTypes.ComputeConfiguration.write(value:to:))
        try writer["resultConfiguration"].write(value.resultConfiguration, with: CleanRoomsClientTypes.ProtectedQueryResultConfiguration.write(value:to:))
        try writer["sqlParameters"].write(value.sqlParameters, with: CleanRoomsClientTypes.ProtectedQuerySQLParameters.write(value:to:))
        try writer["type"].write(value.type)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateAnalysisTemplateInput {

    static func write(value: UpdateAnalysisTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
    }
}

extension UpdateCollaborationInput {

    static func write(value: UpdateCollaborationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
    }
}

extension UpdateConfiguredAudienceModelAssociationInput {

    static func write(value: UpdateConfiguredAudienceModelAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
    }
}

extension UpdateConfiguredTableInput {

    static func write(value: UpdateConfiguredTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
    }
}

extension UpdateConfiguredTableAnalysisRuleInput {

    static func write(value: UpdateConfiguredTableAnalysisRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["analysisRulePolicy"].write(value.analysisRulePolicy, with: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy.write(value:to:))
    }
}

extension UpdateConfiguredTableAssociationInput {

    static func write(value: UpdateConfiguredTableAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["roleArn"].write(value.roleArn)
    }
}

extension UpdateConfiguredTableAssociationAnalysisRuleInput {

    static func write(value: UpdateConfiguredTableAssociationAnalysisRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["analysisRulePolicy"].write(value.analysisRulePolicy, with: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRulePolicy.write(value:to:))
    }
}

extension UpdateIdMappingTableInput {

    static func write(value: UpdateIdMappingTableInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
    }
}

extension UpdateIdNamespaceAssociationInput {

    static func write(value: UpdateIdNamespaceAssociationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["idMappingConfig"].write(value.idMappingConfig, with: CleanRoomsClientTypes.IdMappingConfig.write(value:to:))
        try writer["name"].write(value.name)
    }
}

extension UpdateMembershipInput {

    static func write(value: UpdateMembershipInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["defaultResultConfiguration"].write(value.defaultResultConfiguration, with: CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration.write(value:to:))
        try writer["queryLogStatus"].write(value.queryLogStatus)
    }
}

extension UpdatePrivacyBudgetTemplateInput {

    static func write(value: UpdatePrivacyBudgetTemplateInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["parameters"].write(value.parameters, with: CleanRoomsClientTypes.PrivacyBudgetTemplateUpdateParameters.write(value:to:))
        try writer["privacyBudgetType"].write(value.privacyBudgetType)
    }
}

extension UpdateProtectedQueryInput {

    static func write(value: UpdateProtectedQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetStatus"].write(value.targetStatus)
    }
}

extension BatchGetCollaborationAnalysisTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetCollaborationAnalysisTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetCollaborationAnalysisTemplateOutput()
        value.collaborationAnalysisTemplates = try reader["collaborationAnalysisTemplates"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.CollaborationAnalysisTemplate.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.BatchGetCollaborationAnalysisTemplateError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BatchGetSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetSchemaOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.BatchGetSchemaError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.schemas = try reader["schemas"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.Schema.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BatchGetSchemaAnalysisRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetSchemaAnalysisRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetSchemaAnalysisRuleOutput()
        value.analysisRules = try reader["analysisRules"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.AnalysisRule.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.BatchGetSchemaAnalysisRuleError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CreateAnalysisTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAnalysisTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAnalysisTemplateOutput()
        value.analysisTemplate = try reader["analysisTemplate"].readIfPresent(with: CleanRoomsClientTypes.AnalysisTemplate.read(from:))
        return value
    }
}

extension CreateCollaborationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateCollaborationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateCollaborationOutput()
        value.collaboration = try reader["collaboration"].readIfPresent(with: CleanRoomsClientTypes.Collaboration.read(from:))
        return value
    }
}

extension CreateConfiguredAudienceModelAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConfiguredAudienceModelAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConfiguredAudienceModelAssociationOutput()
        value.configuredAudienceModelAssociation = try reader["configuredAudienceModelAssociation"].readIfPresent(with: CleanRoomsClientTypes.ConfiguredAudienceModelAssociation.read(from:))
        return value
    }
}

extension CreateConfiguredTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConfiguredTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConfiguredTableOutput()
        value.configuredTable = try reader["configuredTable"].readIfPresent(with: CleanRoomsClientTypes.ConfiguredTable.read(from:))
        return value
    }
}

extension CreateConfiguredTableAnalysisRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConfiguredTableAnalysisRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConfiguredTableAnalysisRuleOutput()
        value.analysisRule = try reader["analysisRule"].readIfPresent(with: CleanRoomsClientTypes.ConfiguredTableAnalysisRule.read(from:))
        return value
    }
}

extension CreateConfiguredTableAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConfiguredTableAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConfiguredTableAssociationOutput()
        value.configuredTableAssociation = try reader["configuredTableAssociation"].readIfPresent(with: CleanRoomsClientTypes.ConfiguredTableAssociation.read(from:))
        return value
    }
}

extension CreateConfiguredTableAssociationAnalysisRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConfiguredTableAssociationAnalysisRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConfiguredTableAssociationAnalysisRuleOutput()
        value.analysisRule = try reader["analysisRule"].readIfPresent(with: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRule.read(from:))
        return value
    }
}

extension CreateIdMappingTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIdMappingTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIdMappingTableOutput()
        value.idMappingTable = try reader["idMappingTable"].readIfPresent(with: CleanRoomsClientTypes.IdMappingTable.read(from:))
        return value
    }
}

extension CreateIdNamespaceAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateIdNamespaceAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateIdNamespaceAssociationOutput()
        value.idNamespaceAssociation = try reader["idNamespaceAssociation"].readIfPresent(with: CleanRoomsClientTypes.IdNamespaceAssociation.read(from:))
        return value
    }
}

extension CreateMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateMembershipOutput()
        value.membership = try reader["membership"].readIfPresent(with: CleanRoomsClientTypes.Membership.read(from:))
        return value
    }
}

extension CreatePrivacyBudgetTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePrivacyBudgetTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePrivacyBudgetTemplateOutput()
        value.privacyBudgetTemplate = try reader["privacyBudgetTemplate"].readIfPresent(with: CleanRoomsClientTypes.PrivacyBudgetTemplate.read(from:))
        return value
    }
}

extension DeleteAnalysisTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAnalysisTemplateOutput {
        return DeleteAnalysisTemplateOutput()
    }
}

extension DeleteCollaborationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteCollaborationOutput {
        return DeleteCollaborationOutput()
    }
}

extension DeleteConfiguredAudienceModelAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConfiguredAudienceModelAssociationOutput {
        return DeleteConfiguredAudienceModelAssociationOutput()
    }
}

extension DeleteConfiguredTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConfiguredTableOutput {
        return DeleteConfiguredTableOutput()
    }
}

extension DeleteConfiguredTableAnalysisRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConfiguredTableAnalysisRuleOutput {
        return DeleteConfiguredTableAnalysisRuleOutput()
    }
}

extension DeleteConfiguredTableAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConfiguredTableAssociationOutput {
        return DeleteConfiguredTableAssociationOutput()
    }
}

extension DeleteConfiguredTableAssociationAnalysisRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteConfiguredTableAssociationAnalysisRuleOutput {
        return DeleteConfiguredTableAssociationAnalysisRuleOutput()
    }
}

extension DeleteIdMappingTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIdMappingTableOutput {
        return DeleteIdMappingTableOutput()
    }
}

extension DeleteIdNamespaceAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteIdNamespaceAssociationOutput {
        return DeleteIdNamespaceAssociationOutput()
    }
}

extension DeleteMemberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMemberOutput {
        return DeleteMemberOutput()
    }
}

extension DeleteMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteMembershipOutput {
        return DeleteMembershipOutput()
    }
}

extension DeletePrivacyBudgetTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePrivacyBudgetTemplateOutput {
        return DeletePrivacyBudgetTemplateOutput()
    }
}

extension GetAnalysisTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAnalysisTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAnalysisTemplateOutput()
        value.analysisTemplate = try reader["analysisTemplate"].readIfPresent(with: CleanRoomsClientTypes.AnalysisTemplate.read(from:))
        return value
    }
}

extension GetCollaborationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCollaborationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCollaborationOutput()
        value.collaboration = try reader["collaboration"].readIfPresent(with: CleanRoomsClientTypes.Collaboration.read(from:))
        return value
    }
}

extension GetCollaborationAnalysisTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCollaborationAnalysisTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCollaborationAnalysisTemplateOutput()
        value.collaborationAnalysisTemplate = try reader["collaborationAnalysisTemplate"].readIfPresent(with: CleanRoomsClientTypes.CollaborationAnalysisTemplate.read(from:))
        return value
    }
}

extension GetCollaborationConfiguredAudienceModelAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCollaborationConfiguredAudienceModelAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCollaborationConfiguredAudienceModelAssociationOutput()
        value.collaborationConfiguredAudienceModelAssociation = try reader["collaborationConfiguredAudienceModelAssociation"].readIfPresent(with: CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociation.read(from:))
        return value
    }
}

extension GetCollaborationIdNamespaceAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCollaborationIdNamespaceAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCollaborationIdNamespaceAssociationOutput()
        value.collaborationIdNamespaceAssociation = try reader["collaborationIdNamespaceAssociation"].readIfPresent(with: CleanRoomsClientTypes.CollaborationIdNamespaceAssociation.read(from:))
        return value
    }
}

extension GetCollaborationPrivacyBudgetTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetCollaborationPrivacyBudgetTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetCollaborationPrivacyBudgetTemplateOutput()
        value.collaborationPrivacyBudgetTemplate = try reader["collaborationPrivacyBudgetTemplate"].readIfPresent(with: CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplate.read(from:))
        return value
    }
}

extension GetConfiguredAudienceModelAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConfiguredAudienceModelAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConfiguredAudienceModelAssociationOutput()
        value.configuredAudienceModelAssociation = try reader["configuredAudienceModelAssociation"].readIfPresent(with: CleanRoomsClientTypes.ConfiguredAudienceModelAssociation.read(from:))
        return value
    }
}

extension GetConfiguredTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConfiguredTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConfiguredTableOutput()
        value.configuredTable = try reader["configuredTable"].readIfPresent(with: CleanRoomsClientTypes.ConfiguredTable.read(from:))
        return value
    }
}

extension GetConfiguredTableAnalysisRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConfiguredTableAnalysisRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConfiguredTableAnalysisRuleOutput()
        value.analysisRule = try reader["analysisRule"].readIfPresent(with: CleanRoomsClientTypes.ConfiguredTableAnalysisRule.read(from:))
        return value
    }
}

extension GetConfiguredTableAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConfiguredTableAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConfiguredTableAssociationOutput()
        value.configuredTableAssociation = try reader["configuredTableAssociation"].readIfPresent(with: CleanRoomsClientTypes.ConfiguredTableAssociation.read(from:))
        return value
    }
}

extension GetConfiguredTableAssociationAnalysisRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConfiguredTableAssociationAnalysisRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConfiguredTableAssociationAnalysisRuleOutput()
        value.analysisRule = try reader["analysisRule"].readIfPresent(with: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRule.read(from:))
        return value
    }
}

extension GetIdMappingTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIdMappingTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIdMappingTableOutput()
        value.idMappingTable = try reader["idMappingTable"].readIfPresent(with: CleanRoomsClientTypes.IdMappingTable.read(from:))
        return value
    }
}

extension GetIdNamespaceAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetIdNamespaceAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetIdNamespaceAssociationOutput()
        value.idNamespaceAssociation = try reader["idNamespaceAssociation"].readIfPresent(with: CleanRoomsClientTypes.IdNamespaceAssociation.read(from:))
        return value
    }
}

extension GetMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetMembershipOutput()
        value.membership = try reader["membership"].readIfPresent(with: CleanRoomsClientTypes.Membership.read(from:))
        return value
    }
}

extension GetPrivacyBudgetTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPrivacyBudgetTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPrivacyBudgetTemplateOutput()
        value.privacyBudgetTemplate = try reader["privacyBudgetTemplate"].readIfPresent(with: CleanRoomsClientTypes.PrivacyBudgetTemplate.read(from:))
        return value
    }
}

extension GetProtectedQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProtectedQueryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProtectedQueryOutput()
        value.protectedQuery = try reader["protectedQuery"].readIfPresent(with: CleanRoomsClientTypes.ProtectedQuery.read(from:))
        return value
    }
}

extension GetSchemaOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSchemaOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSchemaOutput()
        value.schema = try reader["schema"].readIfPresent(with: CleanRoomsClientTypes.Schema.read(from:))
        return value
    }
}

extension GetSchemaAnalysisRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSchemaAnalysisRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSchemaAnalysisRuleOutput()
        value.analysisRule = try reader["analysisRule"].readIfPresent(with: CleanRoomsClientTypes.AnalysisRule.read(from:))
        return value
    }
}

extension ListAnalysisTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAnalysisTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAnalysisTemplatesOutput()
        value.analysisTemplateSummaries = try reader["analysisTemplateSummaries"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.AnalysisTemplateSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCollaborationAnalysisTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCollaborationAnalysisTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCollaborationAnalysisTemplatesOutput()
        value.collaborationAnalysisTemplateSummaries = try reader["collaborationAnalysisTemplateSummaries"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.CollaborationAnalysisTemplateSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCollaborationConfiguredAudienceModelAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCollaborationConfiguredAudienceModelAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCollaborationConfiguredAudienceModelAssociationsOutput()
        value.collaborationConfiguredAudienceModelAssociationSummaries = try reader["collaborationConfiguredAudienceModelAssociationSummaries"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCollaborationIdNamespaceAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCollaborationIdNamespaceAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCollaborationIdNamespaceAssociationsOutput()
        value.collaborationIdNamespaceAssociationSummaries = try reader["collaborationIdNamespaceAssociationSummaries"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.CollaborationIdNamespaceAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCollaborationPrivacyBudgetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCollaborationPrivacyBudgetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCollaborationPrivacyBudgetsOutput()
        value.collaborationPrivacyBudgetSummaries = try reader["collaborationPrivacyBudgetSummaries"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.CollaborationPrivacyBudgetSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCollaborationPrivacyBudgetTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCollaborationPrivacyBudgetTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCollaborationPrivacyBudgetTemplatesOutput()
        value.collaborationPrivacyBudgetTemplateSummaries = try reader["collaborationPrivacyBudgetTemplateSummaries"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplateSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCollaborationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCollaborationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCollaborationsOutput()
        value.collaborationList = try reader["collaborationList"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.CollaborationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListConfiguredAudienceModelAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConfiguredAudienceModelAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConfiguredAudienceModelAssociationsOutput()
        value.configuredAudienceModelAssociationSummaries = try reader["configuredAudienceModelAssociationSummaries"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.ConfiguredAudienceModelAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListConfiguredTableAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConfiguredTableAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConfiguredTableAssociationsOutput()
        value.configuredTableAssociationSummaries = try reader["configuredTableAssociationSummaries"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.ConfiguredTableAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListConfiguredTablesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConfiguredTablesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConfiguredTablesOutput()
        value.configuredTableSummaries = try reader["configuredTableSummaries"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.ConfiguredTableSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListIdMappingTablesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIdMappingTablesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIdMappingTablesOutput()
        value.idMappingTableSummaries = try reader["idMappingTableSummaries"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.IdMappingTableSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListIdNamespaceAssociationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListIdNamespaceAssociationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListIdNamespaceAssociationsOutput()
        value.idNamespaceAssociationSummaries = try reader["idNamespaceAssociationSummaries"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.IdNamespaceAssociationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMembersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMembersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMembersOutput()
        value.memberSummaries = try reader["memberSummaries"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.MemberSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListMembershipsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListMembershipsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListMembershipsOutput()
        value.membershipSummaries = try reader["membershipSummaries"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.MembershipSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListPrivacyBudgetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPrivacyBudgetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPrivacyBudgetsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.privacyBudgetSummaries = try reader["privacyBudgetSummaries"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.PrivacyBudgetSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListPrivacyBudgetTemplatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPrivacyBudgetTemplatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPrivacyBudgetTemplatesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.privacyBudgetTemplateSummaries = try reader["privacyBudgetTemplateSummaries"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.PrivacyBudgetTemplateSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListProtectedQueriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProtectedQueriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProtectedQueriesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.protectedQueries = try reader["protectedQueries"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.ProtectedQuerySummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListSchemasOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSchemasOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSchemasOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.schemaSummaries = try reader["schemaSummaries"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.SchemaSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension PopulateIdMappingTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PopulateIdMappingTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PopulateIdMappingTableOutput()
        value.idMappingJobId = try reader["idMappingJobId"].readIfPresent() ?? ""
        return value
    }
}

extension PreviewPrivacyImpactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PreviewPrivacyImpactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PreviewPrivacyImpactOutput()
        value.privacyImpact = try reader["privacyImpact"].readIfPresent(with: CleanRoomsClientTypes.PrivacyImpact.read(from:))
        return value
    }
}

extension StartProtectedQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartProtectedQueryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartProtectedQueryOutput()
        value.protectedQuery = try reader["protectedQuery"].readIfPresent(with: CleanRoomsClientTypes.ProtectedQuery.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAnalysisTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAnalysisTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAnalysisTemplateOutput()
        value.analysisTemplate = try reader["analysisTemplate"].readIfPresent(with: CleanRoomsClientTypes.AnalysisTemplate.read(from:))
        return value
    }
}

extension UpdateCollaborationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateCollaborationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateCollaborationOutput()
        value.collaboration = try reader["collaboration"].readIfPresent(with: CleanRoomsClientTypes.Collaboration.read(from:))
        return value
    }
}

extension UpdateConfiguredAudienceModelAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConfiguredAudienceModelAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConfiguredAudienceModelAssociationOutput()
        value.configuredAudienceModelAssociation = try reader["configuredAudienceModelAssociation"].readIfPresent(with: CleanRoomsClientTypes.ConfiguredAudienceModelAssociation.read(from:))
        return value
    }
}

extension UpdateConfiguredTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConfiguredTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConfiguredTableOutput()
        value.configuredTable = try reader["configuredTable"].readIfPresent(with: CleanRoomsClientTypes.ConfiguredTable.read(from:))
        return value
    }
}

extension UpdateConfiguredTableAnalysisRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConfiguredTableAnalysisRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConfiguredTableAnalysisRuleOutput()
        value.analysisRule = try reader["analysisRule"].readIfPresent(with: CleanRoomsClientTypes.ConfiguredTableAnalysisRule.read(from:))
        return value
    }
}

extension UpdateConfiguredTableAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConfiguredTableAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConfiguredTableAssociationOutput()
        value.configuredTableAssociation = try reader["configuredTableAssociation"].readIfPresent(with: CleanRoomsClientTypes.ConfiguredTableAssociation.read(from:))
        return value
    }
}

extension UpdateConfiguredTableAssociationAnalysisRuleOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConfiguredTableAssociationAnalysisRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConfiguredTableAssociationAnalysisRuleOutput()
        value.analysisRule = try reader["analysisRule"].readIfPresent(with: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRule.read(from:))
        return value
    }
}

extension UpdateIdMappingTableOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIdMappingTableOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIdMappingTableOutput()
        value.idMappingTable = try reader["idMappingTable"].readIfPresent(with: CleanRoomsClientTypes.IdMappingTable.read(from:))
        return value
    }
}

extension UpdateIdNamespaceAssociationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateIdNamespaceAssociationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateIdNamespaceAssociationOutput()
        value.idNamespaceAssociation = try reader["idNamespaceAssociation"].readIfPresent(with: CleanRoomsClientTypes.IdNamespaceAssociation.read(from:))
        return value
    }
}

extension UpdateMembershipOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateMembershipOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateMembershipOutput()
        value.membership = try reader["membership"].readIfPresent(with: CleanRoomsClientTypes.Membership.read(from:))
        return value
    }
}

extension UpdatePrivacyBudgetTemplateOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePrivacyBudgetTemplateOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePrivacyBudgetTemplateOutput()
        value.privacyBudgetTemplate = try reader["privacyBudgetTemplate"].readIfPresent(with: CleanRoomsClientTypes.PrivacyBudgetTemplate.read(from:))
        return value
    }
}

extension UpdateProtectedQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProtectedQueryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateProtectedQueryOutput()
        value.protectedQuery = try reader["protectedQuery"].readIfPresent(with: CleanRoomsClientTypes.ProtectedQuery.read(from:))
        return value
    }
}

enum BatchGetCollaborationAnalysisTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetSchemaAnalysisRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAnalysisTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateCollaborationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConfiguredAudienceModelAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConfiguredTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConfiguredTableAnalysisRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConfiguredTableAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConfiguredTableAssociationAnalysisRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIdMappingTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateIdNamespaceAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePrivacyBudgetTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAnalysisTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteCollaborationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConfiguredAudienceModelAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConfiguredTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConfiguredTableAnalysisRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConfiguredTableAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteConfiguredTableAssociationAnalysisRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIdMappingTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteIdNamespaceAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMemberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePrivacyBudgetTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAnalysisTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCollaborationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCollaborationAnalysisTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCollaborationConfiguredAudienceModelAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCollaborationIdNamespaceAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetCollaborationPrivacyBudgetTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConfiguredAudienceModelAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConfiguredTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConfiguredTableAnalysisRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConfiguredTableAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConfiguredTableAssociationAnalysisRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIdMappingTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetIdNamespaceAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPrivacyBudgetTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProtectedQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSchemaOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSchemaAnalysisRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAnalysisTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCollaborationAnalysisTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCollaborationConfiguredAudienceModelAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCollaborationIdNamespaceAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCollaborationPrivacyBudgetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCollaborationPrivacyBudgetTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCollaborationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConfiguredAudienceModelAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConfiguredTableAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConfiguredTablesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIdMappingTablesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListIdNamespaceAssociationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMembersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListMembershipsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPrivacyBudgetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPrivacyBudgetTemplatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProtectedQueriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSchemasOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PopulateIdMappingTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PreviewPrivacyImpactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartProtectedQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAnalysisTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateCollaborationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConfiguredAudienceModelAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConfiguredTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConfiguredTableAnalysisRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConfiguredTableAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConfiguredTableAssociationAnalysisRuleOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIdMappingTableOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateIdNamespaceAssociationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateMembershipOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePrivacyBudgetTemplateOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProtectedQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaName = try reader["quotaName"].readIfPresent() ?? ""
        value.properties.quotaValue = try reader["quotaValue"].readIfPresent() ?? 0.0
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CleanRoomsClientTypes.CollaborationAnalysisTemplate {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.CollaborationAnalysisTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.CollaborationAnalysisTemplate()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.creatorAccountId = try reader["creatorAccountId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.schema = try reader["schema"].readIfPresent(with: CleanRoomsClientTypes.AnalysisSchema.read(from:))
        value.format = try reader["format"].readIfPresent() ?? .sdkUnknown("")
        value.source = try reader["source"].readIfPresent(with: CleanRoomsClientTypes.AnalysisSource.read(from:))
        value.analysisParameters = try reader["analysisParameters"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.AnalysisParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.validations = try reader["validations"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.AnalysisTemplateValidationStatusDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CleanRoomsClientTypes.AnalysisTemplateValidationStatusDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.AnalysisTemplateValidationStatusDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.AnalysisTemplateValidationStatusDetail()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.reasons = try reader["reasons"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.AnalysisTemplateValidationStatusReason.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CleanRoomsClientTypes.AnalysisTemplateValidationStatusReason {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.AnalysisTemplateValidationStatusReason {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.AnalysisTemplateValidationStatusReason()
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension CleanRoomsClientTypes.AnalysisParameter {

    static func write(value: CleanRoomsClientTypes.AnalysisParameter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["defaultValue"].write(value.defaultValue)
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.AnalysisParameter {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.AnalysisParameter()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.defaultValue = try reader["defaultValue"].readIfPresent()
        return value
    }
}

extension CleanRoomsClientTypes.AnalysisSource {

    static func write(value: CleanRoomsClientTypes.AnalysisSource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .text(text):
                try writer["text"].write(text)
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.AnalysisSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "text":
                return .text(try reader["text"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CleanRoomsClientTypes.AnalysisSchema {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.AnalysisSchema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.AnalysisSchema()
        value.referencedTables = try reader["referencedTables"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CleanRoomsClientTypes.BatchGetCollaborationAnalysisTemplateError {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.BatchGetCollaborationAnalysisTemplateError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.BatchGetCollaborationAnalysisTemplateError()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.code = try reader["code"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension CleanRoomsClientTypes.Schema {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.Schema {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.Schema()
        value.columns = try reader["columns"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.Column.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.partitionKeys = try reader["partitionKeys"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.Column.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.analysisRuleTypes = try reader["analysisRuleTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CleanRoomsClientTypes.AnalysisRuleType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.analysisMethod = try reader["analysisMethod"].readIfPresent()
        value.creatorAccountId = try reader["creatorAccountId"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.schemaStatusDetails = try reader["schemaStatusDetails"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.SchemaStatusDetail.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.schemaTypeProperties = try reader["schemaTypeProperties"].readIfPresent(with: CleanRoomsClientTypes.SchemaTypeProperties.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.SchemaTypeProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.SchemaTypeProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "idMappingTable":
                return .idmappingtable(try reader["idMappingTable"].read(with: CleanRoomsClientTypes.IdMappingTableSchemaTypeProperties.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CleanRoomsClientTypes.IdMappingTableSchemaTypeProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.IdMappingTableSchemaTypeProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.IdMappingTableSchemaTypeProperties()
        value.idMappingTableInputSource = try reader["idMappingTableInputSource"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.IdMappingTableInputSource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CleanRoomsClientTypes.IdMappingTableInputSource {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.IdMappingTableInputSource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.IdMappingTableInputSource()
        value.idNamespaceAssociationId = try reader["idNamespaceAssociationId"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CleanRoomsClientTypes.SchemaStatusDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.SchemaStatusDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.SchemaStatusDetail()
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.reasons = try reader["reasons"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.SchemaStatusReason.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.analysisRuleType = try reader["analysisRuleType"].readIfPresent()
        value.configurations = try reader["configurations"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CleanRoomsClientTypes.SchemaConfiguration>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.analysisType = try reader["analysisType"].readIfPresent()
        return value
    }
}

extension CleanRoomsClientTypes.SchemaStatusReason {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.SchemaStatusReason {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.SchemaStatusReason()
        value.code = try reader["code"].readIfPresent() ?? .sdkUnknown("")
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension CleanRoomsClientTypes.Column {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.Column {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.Column()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? ""
        return value
    }
}

extension CleanRoomsClientTypes.BatchGetSchemaError {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.BatchGetSchemaError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.BatchGetSchemaError()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.code = try reader["code"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension CleanRoomsClientTypes.AnalysisRule {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.AnalysisRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.AnalysisRule()
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.policy = try reader["policy"].readIfPresent(with: CleanRoomsClientTypes.AnalysisRulePolicy.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.AnalysisRulePolicy {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.AnalysisRulePolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "v1":
                return .v1(try reader["v1"].read(with: CleanRoomsClientTypes.AnalysisRulePolicyV1.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CleanRoomsClientTypes.AnalysisRulePolicyV1 {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.AnalysisRulePolicyV1 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "list":
                return .list(try reader["list"].read(with: CleanRoomsClientTypes.AnalysisRuleList.read(from:)))
            case "aggregation":
                return .aggregation(try reader["aggregation"].read(with: CleanRoomsClientTypes.AnalysisRuleAggregation.read(from:)))
            case "custom":
                return .custom(try reader["custom"].read(with: CleanRoomsClientTypes.AnalysisRuleCustom.read(from:)))
            case "idMappingTable":
                return .idmappingtable(try reader["idMappingTable"].read(with: CleanRoomsClientTypes.AnalysisRuleIdMappingTable.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CleanRoomsClientTypes.AnalysisRuleIdMappingTable {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.AnalysisRuleIdMappingTable {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.AnalysisRuleIdMappingTable()
        value.joinColumns = try reader["joinColumns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.queryConstraints = try reader["queryConstraints"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.QueryConstraint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.dimensionColumns = try reader["dimensionColumns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CleanRoomsClientTypes.QueryConstraint {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.QueryConstraint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "requireOverlap":
                return .requireoverlap(try reader["requireOverlap"].read(with: CleanRoomsClientTypes.QueryConstraintRequireOverlap.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CleanRoomsClientTypes.QueryConstraintRequireOverlap {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.QueryConstraintRequireOverlap {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.QueryConstraintRequireOverlap()
        value.columns = try reader["columns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CleanRoomsClientTypes.AnalysisRuleCustom {

    static func write(value: CleanRoomsClientTypes.AnalysisRuleCustom?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalAnalyses"].write(value.additionalAnalyses)
        try writer["allowedAnalyses"].writeList(value.allowedAnalyses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["allowedAnalysisProviders"].writeList(value.allowedAnalysisProviders, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["differentialPrivacy"].write(value.differentialPrivacy, with: CleanRoomsClientTypes.DifferentialPrivacyConfiguration.write(value:to:))
        try writer["disallowedOutputColumns"].writeList(value.disallowedOutputColumns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.AnalysisRuleCustom {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.AnalysisRuleCustom()
        value.allowedAnalyses = try reader["allowedAnalyses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.allowedAnalysisProviders = try reader["allowedAnalysisProviders"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.additionalAnalyses = try reader["additionalAnalyses"].readIfPresent()
        value.disallowedOutputColumns = try reader["disallowedOutputColumns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.differentialPrivacy = try reader["differentialPrivacy"].readIfPresent(with: CleanRoomsClientTypes.DifferentialPrivacyConfiguration.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.DifferentialPrivacyConfiguration {

    static func write(value: CleanRoomsClientTypes.DifferentialPrivacyConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["columns"].writeList(value.columns, memberWritingClosure: CleanRoomsClientTypes.DifferentialPrivacyColumn.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.DifferentialPrivacyConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.DifferentialPrivacyConfiguration()
        value.columns = try reader["columns"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.DifferentialPrivacyColumn.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CleanRoomsClientTypes.DifferentialPrivacyColumn {

    static func write(value: CleanRoomsClientTypes.DifferentialPrivacyColumn?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.DifferentialPrivacyColumn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.DifferentialPrivacyColumn()
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension CleanRoomsClientTypes.AnalysisRuleAggregation {

    static func write(value: CleanRoomsClientTypes.AnalysisRuleAggregation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalAnalyses"].write(value.additionalAnalyses)
        try writer["aggregateColumns"].writeList(value.aggregateColumns, memberWritingClosure: CleanRoomsClientTypes.AggregateColumn.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["allowedJoinOperators"].writeList(value.allowedJoinOperators, memberWritingClosure: SmithyReadWrite.WritingClosureBox<CleanRoomsClientTypes.JoinOperator>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["dimensionColumns"].writeList(value.dimensionColumns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["joinColumns"].writeList(value.joinColumns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["joinRequired"].write(value.joinRequired)
        try writer["outputConstraints"].writeList(value.outputConstraints, memberWritingClosure: CleanRoomsClientTypes.AggregationConstraint.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["scalarFunctions"].writeList(value.scalarFunctions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<CleanRoomsClientTypes.ScalarFunctions>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.AnalysisRuleAggregation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.AnalysisRuleAggregation()
        value.aggregateColumns = try reader["aggregateColumns"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.AggregateColumn.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.joinColumns = try reader["joinColumns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.joinRequired = try reader["joinRequired"].readIfPresent()
        value.allowedJoinOperators = try reader["allowedJoinOperators"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CleanRoomsClientTypes.JoinOperator>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dimensionColumns = try reader["dimensionColumns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.scalarFunctions = try reader["scalarFunctions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CleanRoomsClientTypes.ScalarFunctions>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.outputConstraints = try reader["outputConstraints"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.AggregationConstraint.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.additionalAnalyses = try reader["additionalAnalyses"].readIfPresent()
        return value
    }
}

extension CleanRoomsClientTypes.AggregationConstraint {

    static func write(value: CleanRoomsClientTypes.AggregationConstraint?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["columnName"].write(value.columnName)
        try writer["minimum"].write(value.minimum)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.AggregationConstraint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.AggregationConstraint()
        value.columnName = try reader["columnName"].readIfPresent() ?? ""
        value.minimum = try reader["minimum"].readIfPresent() ?? 0
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CleanRoomsClientTypes.AggregateColumn {

    static func write(value: CleanRoomsClientTypes.AggregateColumn?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["columnNames"].writeList(value.columnNames, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["function"].write(value.function)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.AggregateColumn {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.AggregateColumn()
        value.columnNames = try reader["columnNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.function = try reader["function"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CleanRoomsClientTypes.AnalysisRuleList {

    static func write(value: CleanRoomsClientTypes.AnalysisRuleList?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["additionalAnalyses"].write(value.additionalAnalyses)
        try writer["allowedJoinOperators"].writeList(value.allowedJoinOperators, memberWritingClosure: SmithyReadWrite.WritingClosureBox<CleanRoomsClientTypes.JoinOperator>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["joinColumns"].writeList(value.joinColumns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["listColumns"].writeList(value.listColumns, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.AnalysisRuleList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.AnalysisRuleList()
        value.joinColumns = try reader["joinColumns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.allowedJoinOperators = try reader["allowedJoinOperators"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CleanRoomsClientTypes.JoinOperator>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.listColumns = try reader["listColumns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.additionalAnalyses = try reader["additionalAnalyses"].readIfPresent()
        return value
    }
}

extension CleanRoomsClientTypes.BatchGetSchemaAnalysisRuleError {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.BatchGetSchemaAnalysisRuleError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.BatchGetSchemaAnalysisRuleError()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.code = try reader["code"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension CleanRoomsClientTypes.AnalysisTemplate {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.AnalysisTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.AnalysisTemplate()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.membershipId = try reader["membershipId"].readIfPresent() ?? ""
        value.membershipArn = try reader["membershipArn"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.schema = try reader["schema"].readIfPresent(with: CleanRoomsClientTypes.AnalysisSchema.read(from:))
        value.format = try reader["format"].readIfPresent() ?? .sdkUnknown("")
        value.source = try reader["source"].readIfPresent(with: CleanRoomsClientTypes.AnalysisSource.read(from:))
        value.analysisParameters = try reader["analysisParameters"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.AnalysisParameter.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.validations = try reader["validations"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.AnalysisTemplateValidationStatusDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CleanRoomsClientTypes.Collaboration {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.Collaboration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.Collaboration()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.creatorAccountId = try reader["creatorAccountId"].readIfPresent() ?? ""
        value.creatorDisplayName = try reader["creatorDisplayName"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.memberStatus = try reader["memberStatus"].readIfPresent() ?? .sdkUnknown("")
        value.membershipId = try reader["membershipId"].readIfPresent()
        value.membershipArn = try reader["membershipArn"].readIfPresent()
        value.dataEncryptionMetadata = try reader["dataEncryptionMetadata"].readIfPresent(with: CleanRoomsClientTypes.DataEncryptionMetadata.read(from:))
        value.queryLogStatus = try reader["queryLogStatus"].readIfPresent() ?? .sdkUnknown("")
        value.analyticsEngine = try reader["analyticsEngine"].readIfPresent()
        return value
    }
}

extension CleanRoomsClientTypes.DataEncryptionMetadata {

    static func write(value: CleanRoomsClientTypes.DataEncryptionMetadata?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowCleartext"].write(value.allowCleartext)
        try writer["allowDuplicates"].write(value.allowDuplicates)
        try writer["allowJoinsOnColumnsWithDifferentNames"].write(value.allowJoinsOnColumnsWithDifferentNames)
        try writer["preserveNulls"].write(value.preserveNulls)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.DataEncryptionMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.DataEncryptionMetadata()
        value.allowCleartext = try reader["allowCleartext"].readIfPresent() ?? false
        value.allowDuplicates = try reader["allowDuplicates"].readIfPresent() ?? false
        value.allowJoinsOnColumnsWithDifferentNames = try reader["allowJoinsOnColumnsWithDifferentNames"].readIfPresent() ?? false
        value.preserveNulls = try reader["preserveNulls"].readIfPresent() ?? false
        return value
    }
}

extension CleanRoomsClientTypes.ConfiguredAudienceModelAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ConfiguredAudienceModelAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ConfiguredAudienceModelAssociation()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.configuredAudienceModelArn = try reader["configuredAudienceModelArn"].readIfPresent() ?? ""
        value.membershipId = try reader["membershipId"].readIfPresent() ?? ""
        value.membershipArn = try reader["membershipArn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.manageResourcePolicies = try reader["manageResourcePolicies"].readIfPresent() ?? false
        value.description = try reader["description"].readIfPresent()
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CleanRoomsClientTypes.ConfiguredTable {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ConfiguredTable {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ConfiguredTable()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.tableReference = try reader["tableReference"].readIfPresent(with: CleanRoomsClientTypes.TableReference.read(from:))
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.analysisRuleTypes = try reader["analysisRuleTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.analysisMethod = try reader["analysisMethod"].readIfPresent() ?? .sdkUnknown("")
        value.allowedColumns = try reader["allowedColumns"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CleanRoomsClientTypes.TableReference {

    static func write(value: CleanRoomsClientTypes.TableReference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .glue(glue):
                try writer["glue"].write(glue, with: CleanRoomsClientTypes.GlueTableReference.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.TableReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "glue":
                return .glue(try reader["glue"].read(with: CleanRoomsClientTypes.GlueTableReference.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CleanRoomsClientTypes.GlueTableReference {

    static func write(value: CleanRoomsClientTypes.GlueTableReference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["databaseName"].write(value.databaseName)
        try writer["tableName"].write(value.tableName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.GlueTableReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.GlueTableReference()
        value.tableName = try reader["tableName"].readIfPresent() ?? ""
        value.databaseName = try reader["databaseName"].readIfPresent() ?? ""
        return value
    }
}

extension CleanRoomsClientTypes.ConfiguredTableAnalysisRule {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ConfiguredTableAnalysisRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ConfiguredTableAnalysisRule()
        value.configuredTableId = try reader["configuredTableId"].readIfPresent() ?? ""
        value.configuredTableArn = try reader["configuredTableArn"].readIfPresent() ?? ""
        value.policy = try reader["policy"].readIfPresent(with: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy.read(from:))
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy {

    static func write(value: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .v1(v1):
                try writer["v1"].write(v1, with: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicyV1.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "v1":
                return .v1(try reader["v1"].read(with: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicyV1.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicyV1 {

    static func write(value: CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicyV1?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .aggregation(aggregation):
                try writer["aggregation"].write(aggregation, with: CleanRoomsClientTypes.AnalysisRuleAggregation.write(value:to:))
            case let .custom(custom):
                try writer["custom"].write(custom, with: CleanRoomsClientTypes.AnalysisRuleCustom.write(value:to:))
            case let .list(list):
                try writer["list"].write(list, with: CleanRoomsClientTypes.AnalysisRuleList.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ConfiguredTableAnalysisRulePolicyV1 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "list":
                return .list(try reader["list"].read(with: CleanRoomsClientTypes.AnalysisRuleList.read(from:)))
            case "aggregation":
                return .aggregation(try reader["aggregation"].read(with: CleanRoomsClientTypes.AnalysisRuleAggregation.read(from:)))
            case "custom":
                return .custom(try reader["custom"].read(with: CleanRoomsClientTypes.AnalysisRuleCustom.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CleanRoomsClientTypes.ConfiguredTableAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ConfiguredTableAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ConfiguredTableAssociation()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.id = try reader["id"].readIfPresent() ?? ""
        value.configuredTableId = try reader["configuredTableId"].readIfPresent() ?? ""
        value.configuredTableArn = try reader["configuredTableArn"].readIfPresent() ?? ""
        value.membershipId = try reader["membershipId"].readIfPresent() ?? ""
        value.membershipArn = try reader["membershipArn"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.analysisRuleTypes = try reader["analysisRuleTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleType>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRule {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRule()
        value.membershipIdentifier = try reader["membershipIdentifier"].readIfPresent() ?? ""
        value.configuredTableAssociationId = try reader["configuredTableAssociationId"].readIfPresent() ?? ""
        value.configuredTableAssociationArn = try reader["configuredTableAssociationArn"].readIfPresent() ?? ""
        value.policy = try reader["policy"].readIfPresent(with: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRulePolicy.read(from:))
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRulePolicy {

    static func write(value: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRulePolicy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .v1(v1):
                try writer["v1"].write(v1, with: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRulePolicyV1.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRulePolicy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "v1":
                return .v1(try reader["v1"].read(with: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRulePolicyV1.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRulePolicyV1 {

    static func write(value: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRulePolicyV1?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .aggregation(aggregation):
                try writer["aggregation"].write(aggregation, with: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleAggregation.write(value:to:))
            case let .custom(custom):
                try writer["custom"].write(custom, with: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleCustom.write(value:to:))
            case let .list(list):
                try writer["list"].write(list, with: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleList.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRulePolicyV1 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "list":
                return .list(try reader["list"].read(with: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleList.read(from:)))
            case "aggregation":
                return .aggregation(try reader["aggregation"].read(with: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleAggregation.read(from:)))
            case "custom":
                return .custom(try reader["custom"].read(with: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleCustom.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleCustom {

    static func write(value: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleCustom?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowedAdditionalAnalyses"].writeList(value.allowedAdditionalAnalyses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["allowedResultReceivers"].writeList(value.allowedResultReceivers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleCustom {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleCustom()
        value.allowedResultReceivers = try reader["allowedResultReceivers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowedAdditionalAnalyses = try reader["allowedAdditionalAnalyses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleAggregation {

    static func write(value: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleAggregation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowedAdditionalAnalyses"].writeList(value.allowedAdditionalAnalyses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["allowedResultReceivers"].writeList(value.allowedResultReceivers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleAggregation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleAggregation()
        value.allowedResultReceivers = try reader["allowedResultReceivers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowedAdditionalAnalyses = try reader["allowedAdditionalAnalyses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleList {

    static func write(value: CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleList?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowedAdditionalAnalyses"].writeList(value.allowedAdditionalAnalyses, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["allowedResultReceivers"].writeList(value.allowedResultReceivers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleList {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ConfiguredTableAssociationAnalysisRuleList()
        value.allowedResultReceivers = try reader["allowedResultReceivers"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.allowedAdditionalAnalyses = try reader["allowedAdditionalAnalyses"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CleanRoomsClientTypes.IdMappingTable {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.IdMappingTable {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.IdMappingTable()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.inputReferenceConfig = try reader["inputReferenceConfig"].readIfPresent(with: CleanRoomsClientTypes.IdMappingTableInputReferenceConfig.read(from:))
        value.membershipId = try reader["membershipId"].readIfPresent() ?? ""
        value.membershipArn = try reader["membershipArn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.inputReferenceProperties = try reader["inputReferenceProperties"].readIfPresent(with: CleanRoomsClientTypes.IdMappingTableInputReferenceProperties.read(from:))
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        return value
    }
}

extension CleanRoomsClientTypes.IdMappingTableInputReferenceProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.IdMappingTableInputReferenceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.IdMappingTableInputReferenceProperties()
        value.idMappingTableInputSource = try reader["idMappingTableInputSource"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.IdMappingTableInputSource.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CleanRoomsClientTypes.IdMappingTableInputReferenceConfig {

    static func write(value: CleanRoomsClientTypes.IdMappingTableInputReferenceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputReferenceArn"].write(value.inputReferenceArn)
        try writer["manageResourcePolicies"].write(value.manageResourcePolicies)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.IdMappingTableInputReferenceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.IdMappingTableInputReferenceConfig()
        value.inputReferenceArn = try reader["inputReferenceArn"].readIfPresent() ?? ""
        value.manageResourcePolicies = try reader["manageResourcePolicies"].readIfPresent() ?? false
        return value
    }
}

extension CleanRoomsClientTypes.IdNamespaceAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.IdNamespaceAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.IdNamespaceAssociation()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.membershipId = try reader["membershipId"].readIfPresent() ?? ""
        value.membershipArn = try reader["membershipArn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.inputReferenceConfig = try reader["inputReferenceConfig"].readIfPresent(with: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceConfig.read(from:))
        value.inputReferenceProperties = try reader["inputReferenceProperties"].readIfPresent(with: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceProperties.read(from:))
        value.idMappingConfig = try reader["idMappingConfig"].readIfPresent(with: CleanRoomsClientTypes.IdMappingConfig.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.IdMappingConfig {

    static func write(value: CleanRoomsClientTypes.IdMappingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allowUseAsDimensionColumn"].write(value.allowUseAsDimensionColumn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.IdMappingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.IdMappingConfig()
        value.allowUseAsDimensionColumn = try reader["allowUseAsDimensionColumn"].readIfPresent() ?? false
        return value
    }
}

extension CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceProperties {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceProperties {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceProperties()
        value.idNamespaceType = try reader["idNamespaceType"].readIfPresent() ?? .sdkUnknown("")
        value.idMappingWorkflowsSupported = try reader["idMappingWorkflowsSupported"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readDocument(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceConfig {

    static func write(value: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["inputReferenceArn"].write(value.inputReferenceArn)
        try writer["manageResourcePolicies"].write(value.manageResourcePolicies)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceConfig()
        value.inputReferenceArn = try reader["inputReferenceArn"].readIfPresent() ?? ""
        value.manageResourcePolicies = try reader["manageResourcePolicies"].readIfPresent() ?? false
        return value
    }
}

extension CleanRoomsClientTypes.Membership {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.Membership {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.Membership()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.collaborationCreatorAccountId = try reader["collaborationCreatorAccountId"].readIfPresent() ?? ""
        value.collaborationCreatorDisplayName = try reader["collaborationCreatorDisplayName"].readIfPresent() ?? ""
        value.collaborationName = try reader["collaborationName"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.memberAbilities = try reader["memberAbilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CleanRoomsClientTypes.MemberAbility>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.queryLogStatus = try reader["queryLogStatus"].readIfPresent() ?? .sdkUnknown("")
        value.defaultResultConfiguration = try reader["defaultResultConfiguration"].readIfPresent(with: CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration.read(from:))
        value.paymentConfiguration = try reader["paymentConfiguration"].readIfPresent(with: CleanRoomsClientTypes.MembershipPaymentConfiguration.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.MembershipPaymentConfiguration {

    static func write(value: CleanRoomsClientTypes.MembershipPaymentConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["queryCompute"].write(value.queryCompute, with: CleanRoomsClientTypes.MembershipQueryComputePaymentConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.MembershipPaymentConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.MembershipPaymentConfiguration()
        value.queryCompute = try reader["queryCompute"].readIfPresent(with: CleanRoomsClientTypes.MembershipQueryComputePaymentConfig.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.MembershipQueryComputePaymentConfig {

    static func write(value: CleanRoomsClientTypes.MembershipQueryComputePaymentConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["isResponsible"].write(value.isResponsible)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.MembershipQueryComputePaymentConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.MembershipQueryComputePaymentConfig()
        value.isResponsible = try reader["isResponsible"].readIfPresent() ?? false
        return value
    }
}

extension CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration {

    static func write(value: CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["outputConfiguration"].write(value.outputConfiguration, with: CleanRoomsClientTypes.MembershipProtectedQueryOutputConfiguration.write(value:to:))
        try writer["roleArn"].write(value.roleArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.MembershipProtectedQueryResultConfiguration()
        value.outputConfiguration = try reader["outputConfiguration"].readIfPresent(with: CleanRoomsClientTypes.MembershipProtectedQueryOutputConfiguration.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent()
        return value
    }
}

extension CleanRoomsClientTypes.MembershipProtectedQueryOutputConfiguration {

    static func write(value: CleanRoomsClientTypes.MembershipProtectedQueryOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .s3(s3):
                try writer["s3"].write(s3, with: CleanRoomsClientTypes.ProtectedQueryS3OutputConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.MembershipProtectedQueryOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3":
                return .s3(try reader["s3"].read(with: CleanRoomsClientTypes.ProtectedQueryS3OutputConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CleanRoomsClientTypes.ProtectedQueryS3OutputConfiguration {

    static func write(value: CleanRoomsClientTypes.ProtectedQueryS3OutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucket"].write(value.bucket)
        try writer["keyPrefix"].write(value.keyPrefix)
        try writer["resultFormat"].write(value.resultFormat)
        try writer["singleFileOutput"].write(value.singleFileOutput)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ProtectedQueryS3OutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ProtectedQueryS3OutputConfiguration()
        value.resultFormat = try reader["resultFormat"].readIfPresent() ?? .sdkUnknown("")
        value.bucket = try reader["bucket"].readIfPresent() ?? ""
        value.keyPrefix = try reader["keyPrefix"].readIfPresent()
        value.singleFileOutput = try reader["singleFileOutput"].readIfPresent()
        return value
    }
}

extension CleanRoomsClientTypes.PrivacyBudgetTemplate {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.PrivacyBudgetTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.PrivacyBudgetTemplate()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.membershipId = try reader["membershipId"].readIfPresent() ?? ""
        value.membershipArn = try reader["membershipArn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.privacyBudgetType = try reader["privacyBudgetType"].readIfPresent() ?? .sdkUnknown("")
        value.autoRefresh = try reader["autoRefresh"].readIfPresent() ?? .sdkUnknown("")
        value.parameters = try reader["parameters"].readIfPresent(with: CleanRoomsClientTypes.PrivacyBudgetTemplateParametersOutput.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.PrivacyBudgetTemplateParametersOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.PrivacyBudgetTemplateParametersOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "differentialPrivacy":
                return .differentialprivacy(try reader["differentialPrivacy"].read(with: CleanRoomsClientTypes.DifferentialPrivacyTemplateParametersOutput.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CleanRoomsClientTypes.DifferentialPrivacyTemplateParametersOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.DifferentialPrivacyTemplateParametersOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.DifferentialPrivacyTemplateParametersOutput()
        value.epsilon = try reader["epsilon"].readIfPresent() ?? 0
        value.usersNoisePerQuery = try reader["usersNoisePerQuery"].readIfPresent() ?? 0
        return value
    }
}

extension CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociation()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.configuredAudienceModelArn = try reader["configuredAudienceModelArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.creatorAccountId = try reader["creatorAccountId"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CleanRoomsClientTypes.CollaborationIdNamespaceAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.CollaborationIdNamespaceAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.CollaborationIdNamespaceAssociation()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.creatorAccountId = try reader["creatorAccountId"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.inputReferenceConfig = try reader["inputReferenceConfig"].readIfPresent(with: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceConfig.read(from:))
        value.inputReferenceProperties = try reader["inputReferenceProperties"].readIfPresent(with: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceProperties.read(from:))
        value.idMappingConfig = try reader["idMappingConfig"].readIfPresent(with: CleanRoomsClientTypes.IdMappingConfig.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplate {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplate {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplate()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.creatorAccountId = try reader["creatorAccountId"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.privacyBudgetType = try reader["privacyBudgetType"].readIfPresent() ?? .sdkUnknown("")
        value.autoRefresh = try reader["autoRefresh"].readIfPresent() ?? .sdkUnknown("")
        value.parameters = try reader["parameters"].readIfPresent(with: CleanRoomsClientTypes.PrivacyBudgetTemplateParametersOutput.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.ProtectedQuery {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ProtectedQuery {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ProtectedQuery()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.membershipId = try reader["membershipId"].readIfPresent() ?? ""
        value.membershipArn = try reader["membershipArn"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.sqlParameters = try reader["sqlParameters"].readIfPresent(with: CleanRoomsClientTypes.ProtectedQuerySQLParameters.read(from:))
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.resultConfiguration = try reader["resultConfiguration"].readIfPresent(with: CleanRoomsClientTypes.ProtectedQueryResultConfiguration.read(from:))
        value.statistics = try reader["statistics"].readIfPresent(with: CleanRoomsClientTypes.ProtectedQueryStatistics.read(from:))
        value.result = try reader["result"].readIfPresent(with: CleanRoomsClientTypes.ProtectedQueryResult.read(from:))
        value.error = try reader["error"].readIfPresent(with: CleanRoomsClientTypes.ProtectedQueryError.read(from:))
        value.differentialPrivacy = try reader["differentialPrivacy"].readIfPresent(with: CleanRoomsClientTypes.DifferentialPrivacyParameters.read(from:))
        value.computeConfiguration = try reader["computeConfiguration"].readIfPresent(with: CleanRoomsClientTypes.ComputeConfiguration.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.ComputeConfiguration {

    static func write(value: CleanRoomsClientTypes.ComputeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .worker(worker):
                try writer["worker"].write(worker, with: CleanRoomsClientTypes.WorkerComputeConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ComputeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "worker":
                return .worker(try reader["worker"].read(with: CleanRoomsClientTypes.WorkerComputeConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CleanRoomsClientTypes.WorkerComputeConfiguration {

    static func write(value: CleanRoomsClientTypes.WorkerComputeConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["number"].write(value.number)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.WorkerComputeConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.WorkerComputeConfiguration()
        value.type = try reader["type"].readIfPresent()
        value.number = try reader["number"].readIfPresent()
        return value
    }
}

extension CleanRoomsClientTypes.DifferentialPrivacyParameters {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.DifferentialPrivacyParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.DifferentialPrivacyParameters()
        value.sensitivityParameters = try reader["sensitivityParameters"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.DifferentialPrivacySensitivityParameters.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CleanRoomsClientTypes.DifferentialPrivacySensitivityParameters {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.DifferentialPrivacySensitivityParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.DifferentialPrivacySensitivityParameters()
        value.aggregationType = try reader["aggregationType"].readIfPresent() ?? .sdkUnknown("")
        value.aggregationExpression = try reader["aggregationExpression"].readIfPresent() ?? ""
        value.userContributionLimit = try reader["userContributionLimit"].readIfPresent() ?? 0
        value.minColumnValue = try reader["minColumnValue"].readIfPresent()
        value.maxColumnValue = try reader["maxColumnValue"].readIfPresent()
        return value
    }
}

extension CleanRoomsClientTypes.ProtectedQueryError {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ProtectedQueryError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ProtectedQueryError()
        value.message = try reader["message"].readIfPresent() ?? ""
        value.code = try reader["code"].readIfPresent() ?? ""
        return value
    }
}

extension CleanRoomsClientTypes.ProtectedQueryResult {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ProtectedQueryResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ProtectedQueryResult()
        value.output = try reader["output"].readIfPresent(with: CleanRoomsClientTypes.ProtectedQueryOutput.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.ProtectedQueryOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ProtectedQueryOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3":
                return .s3(try reader["s3"].read(with: CleanRoomsClientTypes.ProtectedQueryS3Output.read(from:)))
            case "memberList":
                return .memberlist(try reader["memberList"].readList(memberReadingClosure: CleanRoomsClientTypes.ProtectedQuerySingleMemberOutput.read(from:), memberNodeInfo: "member", isFlattened: false))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CleanRoomsClientTypes.ProtectedQuerySingleMemberOutput {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ProtectedQuerySingleMemberOutput {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ProtectedQuerySingleMemberOutput()
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        return value
    }
}

extension CleanRoomsClientTypes.ProtectedQueryS3Output {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ProtectedQueryS3Output {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ProtectedQueryS3Output()
        value.location = try reader["location"].readIfPresent() ?? ""
        return value
    }
}

extension CleanRoomsClientTypes.ProtectedQueryStatistics {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ProtectedQueryStatistics {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ProtectedQueryStatistics()
        value.totalDurationInMillis = try reader["totalDurationInMillis"].readIfPresent()
        value.billedResourceUtilization = try reader["billedResourceUtilization"].readIfPresent(with: CleanRoomsClientTypes.BilledResourceUtilization.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.BilledResourceUtilization {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.BilledResourceUtilization {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.BilledResourceUtilization()
        value.units = try reader["units"].readIfPresent() ?? 0.0
        return value
    }
}

extension CleanRoomsClientTypes.ProtectedQueryResultConfiguration {

    static func write(value: CleanRoomsClientTypes.ProtectedQueryResultConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["outputConfiguration"].write(value.outputConfiguration, with: CleanRoomsClientTypes.ProtectedQueryOutputConfiguration.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ProtectedQueryResultConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ProtectedQueryResultConfiguration()
        value.outputConfiguration = try reader["outputConfiguration"].readIfPresent(with: CleanRoomsClientTypes.ProtectedQueryOutputConfiguration.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.ProtectedQueryOutputConfiguration {

    static func write(value: CleanRoomsClientTypes.ProtectedQueryOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .member(member):
                try writer["member"].write(member, with: CleanRoomsClientTypes.ProtectedQueryMemberOutputConfiguration.write(value:to:))
            case let .s3(s3):
                try writer["s3"].write(s3, with: CleanRoomsClientTypes.ProtectedQueryS3OutputConfiguration.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ProtectedQueryOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "s3":
                return .s3(try reader["s3"].read(with: CleanRoomsClientTypes.ProtectedQueryS3OutputConfiguration.read(from:)))
            case "member":
                return .member(try reader["member"].read(with: CleanRoomsClientTypes.ProtectedQueryMemberOutputConfiguration.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CleanRoomsClientTypes.ProtectedQueryMemberOutputConfiguration {

    static func write(value: CleanRoomsClientTypes.ProtectedQueryMemberOutputConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountId"].write(value.accountId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ProtectedQueryMemberOutputConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ProtectedQueryMemberOutputConfiguration()
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        return value
    }
}

extension CleanRoomsClientTypes.ProtectedQuerySQLParameters {

    static func write(value: CleanRoomsClientTypes.ProtectedQuerySQLParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["analysisTemplateArn"].write(value.analysisTemplateArn)
        try writer["parameters"].writeMap(value.parameters, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["queryString"].write(value.queryString)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ProtectedQuerySQLParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ProtectedQuerySQLParameters()
        value.queryString = try reader["queryString"].readIfPresent()
        value.analysisTemplateArn = try reader["analysisTemplateArn"].readIfPresent()
        value.parameters = try reader["parameters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension CleanRoomsClientTypes.AnalysisTemplateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.AnalysisTemplateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.AnalysisTemplateSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.membershipArn = try reader["membershipArn"].readIfPresent() ?? ""
        value.membershipId = try reader["membershipId"].readIfPresent() ?? ""
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension CleanRoomsClientTypes.CollaborationAnalysisTemplateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.CollaborationAnalysisTemplateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.CollaborationAnalysisTemplateSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.creatorAccountId = try reader["creatorAccountId"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.CollaborationConfiguredAudienceModelAssociationSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.creatorAccountId = try reader["creatorAccountId"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension CleanRoomsClientTypes.CollaborationIdNamespaceAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.CollaborationIdNamespaceAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.CollaborationIdNamespaceAssociationSummary()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.id = try reader["id"].readIfPresent() ?? ""
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.creatorAccountId = try reader["creatorAccountId"].readIfPresent() ?? ""
        value.inputReferenceConfig = try reader["inputReferenceConfig"].readIfPresent(with: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceConfig.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.inputReferenceProperties = try reader["inputReferenceProperties"].readIfPresent(with: CleanRoomsClientTypes.IdNamespaceAssociationInputReferencePropertiesSummary.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.IdNamespaceAssociationInputReferencePropertiesSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.IdNamespaceAssociationInputReferencePropertiesSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.IdNamespaceAssociationInputReferencePropertiesSummary()
        value.idNamespaceType = try reader["idNamespaceType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CleanRoomsClientTypes.CollaborationPrivacyBudgetSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.CollaborationPrivacyBudgetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.CollaborationPrivacyBudgetSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.privacyBudgetTemplateId = try reader["privacyBudgetTemplateId"].readIfPresent() ?? ""
        value.privacyBudgetTemplateArn = try reader["privacyBudgetTemplateArn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.creatorAccountId = try reader["creatorAccountId"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.budget = try reader["budget"].readIfPresent(with: CleanRoomsClientTypes.PrivacyBudget.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.PrivacyBudget {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.PrivacyBudget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "differentialPrivacy":
                return .differentialprivacy(try reader["differentialPrivacy"].read(with: CleanRoomsClientTypes.DifferentialPrivacyPrivacyBudget.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CleanRoomsClientTypes.DifferentialPrivacyPrivacyBudget {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.DifferentialPrivacyPrivacyBudget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.DifferentialPrivacyPrivacyBudget()
        value.aggregations = try reader["aggregations"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.DifferentialPrivacyPrivacyBudgetAggregation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.epsilon = try reader["epsilon"].readIfPresent() ?? 0
        return value
    }
}

extension CleanRoomsClientTypes.DifferentialPrivacyPrivacyBudgetAggregation {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.DifferentialPrivacyPrivacyBudgetAggregation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.DifferentialPrivacyPrivacyBudgetAggregation()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.maxCount = try reader["maxCount"].readIfPresent() ?? 0
        value.remainingCount = try reader["remainingCount"].readIfPresent() ?? 0
        return value
    }
}

extension CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.CollaborationPrivacyBudgetTemplateSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.creatorAccountId = try reader["creatorAccountId"].readIfPresent() ?? ""
        value.privacyBudgetType = try reader["privacyBudgetType"].readIfPresent() ?? .sdkUnknown("")
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CleanRoomsClientTypes.CollaborationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.CollaborationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.CollaborationSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.creatorAccountId = try reader["creatorAccountId"].readIfPresent() ?? ""
        value.creatorDisplayName = try reader["creatorDisplayName"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.memberStatus = try reader["memberStatus"].readIfPresent() ?? .sdkUnknown("")
        value.membershipId = try reader["membershipId"].readIfPresent()
        value.membershipArn = try reader["membershipArn"].readIfPresent()
        value.analyticsEngine = try reader["analyticsEngine"].readIfPresent()
        return value
    }
}

extension CleanRoomsClientTypes.ConfiguredAudienceModelAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ConfiguredAudienceModelAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ConfiguredAudienceModelAssociationSummary()
        value.membershipId = try reader["membershipId"].readIfPresent() ?? ""
        value.membershipArn = try reader["membershipArn"].readIfPresent() ?? ""
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.configuredAudienceModelArn = try reader["configuredAudienceModelArn"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        return value
    }
}

extension CleanRoomsClientTypes.ConfiguredTableAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ConfiguredTableAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ConfiguredTableAssociationSummary()
        value.configuredTableId = try reader["configuredTableId"].readIfPresent() ?? ""
        value.membershipId = try reader["membershipId"].readIfPresent() ?? ""
        value.membershipArn = try reader["membershipArn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension CleanRoomsClientTypes.ConfiguredTableSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ConfiguredTableSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ConfiguredTableSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.analysisRuleTypes = try reader["analysisRuleTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CleanRoomsClientTypes.ConfiguredTableAnalysisRuleType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.analysisMethod = try reader["analysisMethod"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CleanRoomsClientTypes.IdMappingTableSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.IdMappingTableSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.IdMappingTableSummary()
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.membershipId = try reader["membershipId"].readIfPresent() ?? ""
        value.membershipArn = try reader["membershipArn"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.inputReferenceConfig = try reader["inputReferenceConfig"].readIfPresent(with: CleanRoomsClientTypes.IdMappingTableInputReferenceConfig.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        return value
    }
}

extension CleanRoomsClientTypes.IdNamespaceAssociationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.IdNamespaceAssociationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.IdNamespaceAssociationSummary()
        value.membershipId = try reader["membershipId"].readIfPresent() ?? ""
        value.membershipArn = try reader["membershipArn"].readIfPresent() ?? ""
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.inputReferenceConfig = try reader["inputReferenceConfig"].readIfPresent(with: CleanRoomsClientTypes.IdNamespaceAssociationInputReferenceConfig.read(from:))
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.inputReferenceProperties = try reader["inputReferenceProperties"].readIfPresent(with: CleanRoomsClientTypes.IdNamespaceAssociationInputReferencePropertiesSummary.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.MemberSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.MemberSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.MemberSummary()
        value.accountId = try reader["accountId"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.displayName = try reader["displayName"].readIfPresent() ?? ""
        value.abilities = try reader["abilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CleanRoomsClientTypes.MemberAbility>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.membershipId = try reader["membershipId"].readIfPresent()
        value.membershipArn = try reader["membershipArn"].readIfPresent()
        value.paymentConfiguration = try reader["paymentConfiguration"].readIfPresent(with: CleanRoomsClientTypes.PaymentConfiguration.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.PaymentConfiguration {

    static func write(value: CleanRoomsClientTypes.PaymentConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["queryCompute"].write(value.queryCompute, with: CleanRoomsClientTypes.QueryComputePaymentConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.PaymentConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.PaymentConfiguration()
        value.queryCompute = try reader["queryCompute"].readIfPresent(with: CleanRoomsClientTypes.QueryComputePaymentConfig.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.QueryComputePaymentConfig {

    static func write(value: CleanRoomsClientTypes.QueryComputePaymentConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["isResponsible"].write(value.isResponsible)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.QueryComputePaymentConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.QueryComputePaymentConfig()
        value.isResponsible = try reader["isResponsible"].readIfPresent() ?? false
        return value
    }
}

extension CleanRoomsClientTypes.MembershipSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.MembershipSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.MembershipSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.collaborationCreatorAccountId = try reader["collaborationCreatorAccountId"].readIfPresent() ?? ""
        value.collaborationCreatorDisplayName = try reader["collaborationCreatorDisplayName"].readIfPresent() ?? ""
        value.collaborationName = try reader["collaborationName"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.memberAbilities = try reader["memberAbilities"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CleanRoomsClientTypes.MemberAbility>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.paymentConfiguration = try reader["paymentConfiguration"].readIfPresent(with: CleanRoomsClientTypes.MembershipPaymentConfiguration.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.PrivacyBudgetSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.PrivacyBudgetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.PrivacyBudgetSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.privacyBudgetTemplateId = try reader["privacyBudgetTemplateId"].readIfPresent() ?? ""
        value.privacyBudgetTemplateArn = try reader["privacyBudgetTemplateArn"].readIfPresent() ?? ""
        value.membershipId = try reader["membershipId"].readIfPresent() ?? ""
        value.membershipArn = try reader["membershipArn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.budget = try reader["budget"].readIfPresent(with: CleanRoomsClientTypes.PrivacyBudget.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.PrivacyBudgetTemplateSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.PrivacyBudgetTemplateSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.PrivacyBudgetTemplateSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.membershipId = try reader["membershipId"].readIfPresent() ?? ""
        value.membershipArn = try reader["membershipArn"].readIfPresent() ?? ""
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.privacyBudgetType = try reader["privacyBudgetType"].readIfPresent() ?? .sdkUnknown("")
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CleanRoomsClientTypes.ProtectedQuerySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ProtectedQuerySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ProtectedQuerySummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.membershipId = try reader["membershipId"].readIfPresent() ?? ""
        value.membershipArn = try reader["membershipArn"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        value.receiverConfigurations = try reader["receiverConfigurations"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.ReceiverConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CleanRoomsClientTypes.ReceiverConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ReceiverConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ReceiverConfiguration()
        value.analysisType = try reader["analysisType"].readIfPresent() ?? .sdkUnknown("")
        value.configurationDetails = try reader["configurationDetails"].readIfPresent(with: CleanRoomsClientTypes.ConfigurationDetails.read(from:))
        return value
    }
}

extension CleanRoomsClientTypes.ConfigurationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "directAnalysisConfigurationDetails":
                return .directanalysisconfigurationdetails(try reader["directAnalysisConfigurationDetails"].read(with: CleanRoomsClientTypes.DirectAnalysisConfigurationDetails.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CleanRoomsClientTypes.DirectAnalysisConfigurationDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.DirectAnalysisConfigurationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.DirectAnalysisConfigurationDetails()
        value.receiverAccountIds = try reader["receiverAccountIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension CleanRoomsClientTypes.SchemaSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.SchemaSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.SchemaSummary()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.creatorAccountId = try reader["creatorAccountId"].readIfPresent() ?? ""
        value.createTime = try reader["createTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updateTime = try reader["updateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.collaborationId = try reader["collaborationId"].readIfPresent() ?? ""
        value.collaborationArn = try reader["collaborationArn"].readIfPresent() ?? ""
        value.analysisRuleTypes = try reader["analysisRuleTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<CleanRoomsClientTypes.AnalysisRuleType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.analysisMethod = try reader["analysisMethod"].readIfPresent()
        return value
    }
}

extension CleanRoomsClientTypes.PrivacyImpact {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.PrivacyImpact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "differentialPrivacy":
                return .differentialprivacy(try reader["differentialPrivacy"].read(with: CleanRoomsClientTypes.DifferentialPrivacyPrivacyImpact.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension CleanRoomsClientTypes.DifferentialPrivacyPrivacyImpact {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.DifferentialPrivacyPrivacyImpact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.DifferentialPrivacyPrivacyImpact()
        value.aggregations = try reader["aggregations"].readListIfPresent(memberReadingClosure: CleanRoomsClientTypes.DifferentialPrivacyPreviewAggregation.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CleanRoomsClientTypes.DifferentialPrivacyPreviewAggregation {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.DifferentialPrivacyPreviewAggregation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.DifferentialPrivacyPreviewAggregation()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.maxCount = try reader["maxCount"].readIfPresent() ?? 0
        return value
    }
}

extension CleanRoomsClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> CleanRoomsClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = CleanRoomsClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension CleanRoomsClientTypes.SchemaAnalysisRuleRequest {

    static func write(value: CleanRoomsClientTypes.SchemaAnalysisRuleRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["type"].write(value.type)
    }
}

extension CleanRoomsClientTypes.MemberSpecification {

    static func write(value: CleanRoomsClientTypes.MemberSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accountId"].write(value.accountId)
        try writer["displayName"].write(value.displayName)
        try writer["memberAbilities"].writeList(value.memberAbilities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<CleanRoomsClientTypes.MemberAbility>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["paymentConfiguration"].write(value.paymentConfiguration, with: CleanRoomsClientTypes.PaymentConfiguration.write(value:to:))
    }
}

extension CleanRoomsClientTypes.PrivacyBudgetTemplateParametersInput {

    static func write(value: CleanRoomsClientTypes.PrivacyBudgetTemplateParametersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .differentialprivacy(differentialprivacy):
                try writer["differentialPrivacy"].write(differentialprivacy, with: CleanRoomsClientTypes.DifferentialPrivacyTemplateParametersInput.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension CleanRoomsClientTypes.DifferentialPrivacyTemplateParametersInput {

    static func write(value: CleanRoomsClientTypes.DifferentialPrivacyTemplateParametersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["epsilon"].write(value.epsilon)
        try writer["usersNoisePerQuery"].write(value.usersNoisePerQuery)
    }
}

extension CleanRoomsClientTypes.PreviewPrivacyImpactParametersInput {

    static func write(value: CleanRoomsClientTypes.PreviewPrivacyImpactParametersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .differentialprivacy(differentialprivacy):
                try writer["differentialPrivacy"].write(differentialprivacy, with: CleanRoomsClientTypes.DifferentialPrivacyPreviewParametersInput.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension CleanRoomsClientTypes.DifferentialPrivacyPreviewParametersInput {

    static func write(value: CleanRoomsClientTypes.DifferentialPrivacyPreviewParametersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["epsilon"].write(value.epsilon)
        try writer["usersNoisePerQuery"].write(value.usersNoisePerQuery)
    }
}

extension CleanRoomsClientTypes.PrivacyBudgetTemplateUpdateParameters {

    static func write(value: CleanRoomsClientTypes.PrivacyBudgetTemplateUpdateParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .differentialprivacy(differentialprivacy):
                try writer["differentialPrivacy"].write(differentialprivacy, with: CleanRoomsClientTypes.DifferentialPrivacyTemplateUpdateParameters.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension CleanRoomsClientTypes.DifferentialPrivacyTemplateUpdateParameters {

    static func write(value: CleanRoomsClientTypes.DifferentialPrivacyTemplateUpdateParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["epsilon"].write(value.epsilon)
        try writer["usersNoisePerQuery"].write(value.usersNoisePerQuery)
    }
}

public enum CleanRoomsClientTypes {}
