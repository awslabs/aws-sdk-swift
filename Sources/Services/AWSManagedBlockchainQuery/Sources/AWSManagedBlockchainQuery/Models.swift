//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// The Amazon Web Services account doesnâ€™t have access to this resource.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The container for the exception message.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// This is the container for the unique public address on the blockchain.
    public struct AddressIdentifierFilter {
        /// The container for the recipient address of the transaction.
        /// This member is required.
        public var transactionEventToAddress: [Swift.String]?

        public init(
            transactionEventToAddress: [Swift.String]? = nil
        )
        {
            self.transactionEventToAddress = transactionEventToAddress
        }
    }

}

extension ManagedBlockchainQueryClientTypes {

    public enum QueryNetwork: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Bitcoin main network
        case bitcoinMainnet
        /// Bitcoin test network
        case bitcoinTestnet
        /// Ethereum main network
        case ethereumMainnet
        /// SEPOLIA network (ethereum testnet)
        case ethereumSepoliaTestnet
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryNetwork] {
            return [
                .bitcoinMainnet,
                .bitcoinTestnet,
                .ethereumMainnet,
                .ethereumSepoliaTestnet
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bitcoinMainnet: return "BITCOIN_MAINNET"
            case .bitcoinTestnet: return "BITCOIN_TESTNET"
            case .ethereumMainnet: return "ETHEREUM_MAINNET"
            case .ethereumSepoliaTestnet: return "ETHEREUM_SEPOLIA_TESTNET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// Container for the blockchain address and network information about a contract.
    public struct ContractIdentifier {
        /// Container for the blockchain address about a contract.
        /// This member is required.
        public var contractAddress: Swift.String?
        /// The blockchain network of the contract.
        /// This member is required.
        public var network: ManagedBlockchainQueryClientTypes.QueryNetwork?

        public init(
            contractAddress: Swift.String? = nil,
            network: ManagedBlockchainQueryClientTypes.QueryNetwork? = nil
        )
        {
            self.contractAddress = contractAddress
            self.network = network
        }
    }

}

extension ManagedBlockchainQueryClientTypes {

    public enum QueryTokenStandard: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case erc1155
        case erc20
        case erc721
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryTokenStandard] {
            return [
                .erc1155,
                .erc20,
                .erc721
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .erc1155: return "ERC1155"
            case .erc20: return "ERC20"
            case .erc721: return "ERC721"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// This container contains information about an contract.
    public struct AssetContract {
        /// The container for the contract identifier containing its blockchain network and address.
        /// This member is required.
        public var contractIdentifier: ManagedBlockchainQueryClientTypes.ContractIdentifier?
        /// The address of the contract deployer.
        /// This member is required.
        public var deployerAddress: Swift.String?
        /// The token standard of the contract.
        /// This member is required.
        public var tokenStandard: ManagedBlockchainQueryClientTypes.QueryTokenStandard?

        public init(
            contractIdentifier: ManagedBlockchainQueryClientTypes.ContractIdentifier? = nil,
            deployerAddress: Swift.String? = nil,
            tokenStandard: ManagedBlockchainQueryClientTypes.QueryTokenStandard? = nil
        )
        {
            self.contractIdentifier = contractIdentifier
            self.deployerAddress = deployerAddress
            self.tokenStandard = tokenStandard
        }
    }

}

/// The request processing has failed because of an internal error in the service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The container for the exception message.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Specifies the retryAfterSeconds value.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

extension ManagedBlockchainQueryClientTypes {

    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case collection
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .collection
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .collection: return "collection"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The container for the exception message.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resourceId of the resource that caused the exception.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resourceType of the resource that caused the exception.
        /// This member is required.
        public internal(set) var resourceType: ManagedBlockchainQueryClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: ManagedBlockchainQueryClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The service quota has been exceeded for this resource.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The container for the exception message.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The container for the quotaCode.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The resourceId of the resource that caused the exception.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resourceType of the resource that caused the exception.
        /// This member is required.
        public internal(set) var resourceType: ManagedBlockchainQueryClientTypes.ResourceType? = nil
        /// The container for the serviceCode.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: ManagedBlockchainQueryClientTypes.ResourceType? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

/// The request or operation couldn't be performed because a service is throttling requests. The most common source of throttling errors is when you create resources that exceed your service limit for this resource type. Request a limit increase or delete unused resources, if possible.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The container for the exception message.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The container for the quotaCode.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The container of the retryAfterSeconds value.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The container for the serviceCode.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// The resource passed is invalid.
    public struct ValidationExceptionField {
        /// The ValidationException message.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that triggered the ValidationException.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension ManagedBlockchainQueryClientTypes {

    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The resource passed is invalid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The container for the fieldList of the exception.
        public internal(set) var fieldList: [ManagedBlockchainQueryClientTypes.ValidationExceptionField]? = nil
        /// The container for the exception message.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The container for the reason for the exception
        /// This member is required.
        public internal(set) var reason: ManagedBlockchainQueryClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [ManagedBlockchainQueryClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: ManagedBlockchainQueryClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// The container for time.
    public struct BlockchainInstant {
        /// The container of the Timestamp of the blockchain instant. This timestamp will only be recorded up to the second.
        public var time: Foundation.Date?

        public init(
            time: Foundation.Date? = nil
        )
        {
            self.time = time
        }
    }

}

extension ManagedBlockchainQueryClientTypes {
    /// The container for the owner identifier.
    public struct OwnerIdentifier {
        /// The contract or wallet address for the owner.
        /// This member is required.
        public var address: Swift.String?

        public init(
            address: Swift.String? = nil
        )
        {
            self.address = address
        }
    }

}

extension ManagedBlockchainQueryClientTypes {
    /// The container for the identifier for the token including the unique token ID and its blockchain network. Only the native tokens BTC and ETH, and the ERC-20, ERC-721, and ERC 1155 token standards are supported.
    public struct TokenIdentifier {
        /// This is the token's contract address.
        public var contractAddress: Swift.String?
        /// The blockchain network of the token.
        /// This member is required.
        public var network: ManagedBlockchainQueryClientTypes.QueryNetwork?
        /// The unique identifier of the token. For native tokens, use the 3 character abbreviation that best matches your token. For example, btc for Bitcoin, eth for Ether, etc. For all other token types you must specify the tokenId in the 64 character hexadecimal tokenid format.
        public var tokenId: Swift.String?

        public init(
            contractAddress: Swift.String? = nil,
            network: ManagedBlockchainQueryClientTypes.QueryNetwork? = nil,
            tokenId: Swift.String? = nil
        )
        {
            self.contractAddress = contractAddress
            self.network = network
            self.tokenId = tokenId
        }
    }

}

extension ManagedBlockchainQueryClientTypes {
    /// The container for the input for getting a token balance.
    public struct BatchGetTokenBalanceInputItem {
        /// The container for time.
        public var atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?
        /// The container for the owner identifier.
        /// This member is required.
        public var ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier?
        /// The container for the identifier for the token including the unique token ID and its blockchain network. Only the native tokens BTC and ETH, and the ERC-20, ERC-721, and ERC 1155 token standards are supported.
        /// This member is required.
        public var tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier?

        public init(
            atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
            ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier? = nil,
            tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier? = nil
        )
        {
            self.atBlockchainInstant = atBlockchainInstant
            self.ownerIdentifier = ownerIdentifier
            self.tokenIdentifier = tokenIdentifier
        }
    }

}

public struct BatchGetTokenBalanceInput {
    /// An array of BatchGetTokenBalanceInputItem objects whose balance is being requested.
    public var getTokenBalanceInputs: [ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceInputItem]?

    public init(
        getTokenBalanceInputs: [ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceInputItem]? = nil
    )
    {
        self.getTokenBalanceInputs = getTokenBalanceInputs
    }
}

extension ManagedBlockchainQueryClientTypes {

    public enum ErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// An API request retrieving an item that can't be found
        case resourceNotFoundException
        /// An API request validation exception
        case validationException
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorType] {
            return [
                .resourceNotFoundException,
                .validationException
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .resourceNotFoundException: return "RESOURCE_NOT_FOUND_EXCEPTION"
            case .validationException: return "VALIDATION_EXCEPTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// Error generated from a failed BatchGetTokenBalance request.
    public struct BatchGetTokenBalanceErrorItem {
        /// The container for time.
        public var atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?
        /// The error code associated with the error.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The message associated with the error.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The type of error.
        /// This member is required.
        public var errorType: ManagedBlockchainQueryClientTypes.ErrorType?
        /// The container for the owner identifier.
        public var ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier?
        /// The container for the identifier for the token including the unique token ID and its blockchain network. Only the native tokens BTC and ETH, and the ERC-20, ERC-721, and ERC 1155 token standards are supported.
        public var tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier?

        public init(
            atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            errorType: ManagedBlockchainQueryClientTypes.ErrorType? = nil,
            ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier? = nil,
            tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier? = nil
        )
        {
            self.atBlockchainInstant = atBlockchainInstant
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.errorType = errorType
            self.ownerIdentifier = ownerIdentifier
            self.tokenIdentifier = tokenIdentifier
        }
    }

}

extension ManagedBlockchainQueryClientTypes {
    /// The container for the properties of a token balance output.
    public struct BatchGetTokenBalanceOutputItem {
        /// The container for time.
        /// This member is required.
        public var atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?
        /// The container for the token balance.
        /// This member is required.
        public var balance: Swift.String?
        /// The container for time.
        public var lastUpdatedTime: ManagedBlockchainQueryClientTypes.BlockchainInstant?
        /// The container for the owner identifier.
        public var ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier?
        /// The container for the identifier for the token including the unique token ID and its blockchain network. Only the native tokens BTC and ETH, and the ERC-20, ERC-721, and ERC 1155 token standards are supported.
        public var tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier?

        public init(
            atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
            balance: Swift.String? = nil,
            lastUpdatedTime: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
            ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier? = nil,
            tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier? = nil
        )
        {
            self.atBlockchainInstant = atBlockchainInstant
            self.balance = balance
            self.lastUpdatedTime = lastUpdatedTime
            self.ownerIdentifier = ownerIdentifier
            self.tokenIdentifier = tokenIdentifier
        }
    }

}

public struct BatchGetTokenBalanceOutput {
    /// An array of BatchGetTokenBalanceErrorItem objects returned from the request.
    /// This member is required.
    public var errors: [ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceErrorItem]?
    /// An array of BatchGetTokenBalanceOutputItem objects returned by the response.
    /// This member is required.
    public var tokenBalances: [ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceOutputItem]?

    public init(
        errors: [ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceErrorItem]? = nil,
        tokenBalances: [ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceOutputItem]? = nil
    )
    {
        self.errors = errors
        self.tokenBalances = tokenBalances
    }
}

extension ManagedBlockchainQueryClientTypes {

    public enum ConfirmationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `final`
        case nonfinal
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfirmationStatus] {
            return [
                .final,
                .nonfinal
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .final: return "FINAL"
            case .nonfinal: return "NONFINAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// The container for the ConfirmationStatusFilter that filters for the [ finality ](https://docs.aws.amazon.com/managed-blockchain/latest/ambq-dg/key-concepts.html#finality) of the results.
    public struct ConfirmationStatusFilter {
        /// The container to determine whether to list results that have only reached [ finality ](https://docs.aws.amazon.com/managed-blockchain/latest/ambq-dg/key-concepts.html#finality). Transactions that have reached finality are always part of the response.
        /// This member is required.
        public var include: [ManagedBlockchainQueryClientTypes.ConfirmationStatus]?

        public init(
            include: [ManagedBlockchainQueryClientTypes.ConfirmationStatus]? = nil
        )
        {
            self.include = include
        }
    }

}

extension ManagedBlockchainQueryClientTypes {
    /// The contract or wallet address by which to filter the request.
    public struct ContractFilter {
        /// The network address of the deployer.
        /// This member is required.
        public var deployerAddress: Swift.String?
        /// The blockchain network of the contract.
        /// This member is required.
        public var network: ManagedBlockchainQueryClientTypes.QueryNetwork?
        /// The container for the token standard.
        /// This member is required.
        public var tokenStandard: ManagedBlockchainQueryClientTypes.QueryTokenStandard?

        public init(
            deployerAddress: Swift.String? = nil,
            network: ManagedBlockchainQueryClientTypes.QueryNetwork? = nil,
            tokenStandard: ManagedBlockchainQueryClientTypes.QueryTokenStandard? = nil
        )
        {
            self.deployerAddress = deployerAddress
            self.network = network
            self.tokenStandard = tokenStandard
        }
    }

}

extension ManagedBlockchainQueryClientTypes {
    /// The metadata of the contract.
    public struct ContractMetadata {
        /// The decimals used by the token contract.
        public var decimals: Swift.Int?
        /// The name of the token contract.
        public var name: Swift.String?
        /// The symbol of the token contract.
        public var symbol: Swift.String?

        public init(
            decimals: Swift.Int? = nil,
            name: Swift.String? = nil,
            symbol: Swift.String? = nil
        )
        {
            self.decimals = decimals
            self.name = name
            self.symbol = symbol
        }
    }

}

extension ManagedBlockchainQueryClientTypes {

    public enum ExecutionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionStatus] {
            return [
                .failed,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetAssetContractInput {
    /// Contains the blockchain address and network information about the contract.
    /// This member is required.
    public var contractIdentifier: ManagedBlockchainQueryClientTypes.ContractIdentifier?

    public init(
        contractIdentifier: ManagedBlockchainQueryClientTypes.ContractIdentifier? = nil
    )
    {
        self.contractIdentifier = contractIdentifier
    }
}

public struct GetAssetContractOutput {
    /// Contains the blockchain address and network information about the contract.
    /// This member is required.
    public var contractIdentifier: ManagedBlockchainQueryClientTypes.ContractIdentifier?
    /// The address of the deployer of contract.
    /// This member is required.
    public var deployerAddress: Swift.String?
    /// The metadata of the contract.
    public var metadata: ManagedBlockchainQueryClientTypes.ContractMetadata?
    /// The token standard of the contract requested.
    /// This member is required.
    public var tokenStandard: ManagedBlockchainQueryClientTypes.QueryTokenStandard?

    public init(
        contractIdentifier: ManagedBlockchainQueryClientTypes.ContractIdentifier? = nil,
        deployerAddress: Swift.String? = nil,
        metadata: ManagedBlockchainQueryClientTypes.ContractMetadata? = nil,
        tokenStandard: ManagedBlockchainQueryClientTypes.QueryTokenStandard? = nil
    )
    {
        self.contractIdentifier = contractIdentifier
        self.deployerAddress = deployerAddress
        self.metadata = metadata
        self.tokenStandard = tokenStandard
    }
}

public struct GetTokenBalanceInput {
    /// The time for when the TokenBalance is requested or the current time if a time is not provided in the request. This time will only be recorded up to the second.
    public var atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?
    /// The container for the identifier for the owner.
    /// This member is required.
    public var ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier?
    /// The container for the identifier for the token, including the unique token ID and its blockchain network.
    /// This member is required.
    public var tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier?

    public init(
        atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
        ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier? = nil,
        tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier? = nil
    )
    {
        self.atBlockchainInstant = atBlockchainInstant
        self.ownerIdentifier = ownerIdentifier
        self.tokenIdentifier = tokenIdentifier
    }
}

public struct GetTokenBalanceOutput {
    /// The container for time.
    /// This member is required.
    public var atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?
    /// The container for the token balance.
    /// This member is required.
    public var balance: Swift.String?
    /// The container for time.
    public var lastUpdatedTime: ManagedBlockchainQueryClientTypes.BlockchainInstant?
    /// The container for the owner identifier.
    public var ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier?
    /// The container for the identifier for the token including the unique token ID and its blockchain network. Only the native tokens BTC and ETH, and the ERC-20, ERC-721, and ERC 1155 token standards are supported.
    public var tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier?

    public init(
        atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
        balance: Swift.String? = nil,
        lastUpdatedTime: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
        ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier? = nil,
        tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier? = nil
    )
    {
        self.atBlockchainInstant = atBlockchainInstant
        self.balance = balance
        self.lastUpdatedTime = lastUpdatedTime
        self.ownerIdentifier = ownerIdentifier
        self.tokenIdentifier = tokenIdentifier
    }
}

public struct GetTransactionInput {
    /// The blockchain network where the transaction occurred.
    /// This member is required.
    public var network: ManagedBlockchainQueryClientTypes.QueryNetwork?
    /// The hash of a transaction. It is generated when a transaction is created.
    public var transactionHash: Swift.String?
    /// The identifier of a Bitcoin transaction. It is generated when a transaction is created. transactionId is only supported on the Bitcoin networks.
    public var transactionId: Swift.String?

    public init(
        network: ManagedBlockchainQueryClientTypes.QueryNetwork? = nil,
        transactionHash: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.network = network
        self.transactionHash = transactionHash
        self.transactionId = transactionId
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// There are two possible types of transactions used for this data type:
    ///
    /// * A Bitcoin transaction is a movement of BTC from one address to another.
    ///
    /// * An Ethereum transaction refers to an action initiated by an externally owned account, which is an account managed by a human, not a contract. For example, if Bob sends Alice 1 ETH, Bob's account must be debited and Alice's must be credited. This state-changing action occurs within a transaction.
    public struct Transaction {
        /// The block hash is a unique identifier for a block. It is a fixed-size string that is calculated by using the information in the block. The block hash is used to verify the integrity of the data in the block.
        public var blockHash: Swift.String?
        /// The block number in which the transaction is recorded.
        public var blockNumber: Swift.String?
        /// Specifies whether the transaction has reached Finality.
        public var confirmationStatus: ManagedBlockchainQueryClientTypes.ConfirmationStatus?
        /// The blockchain address for the contract.
        public var contractAddress: Swift.String?
        /// The amount of gas used up to the specified point in the block.
        public var cumulativeGasUsed: Swift.String?
        /// The effective gas price.
        public var effectiveGasPrice: Swift.String?
        /// Identifies whether the transaction has succeeded or failed.
        public var executionStatus: ManagedBlockchainQueryClientTypes.ExecutionStatus?
        /// The initiator of the transaction. It is either in the form a public key or a contract address.
        public var from: Swift.String?
        /// The amount of gas used for the transaction.
        public var gasUsed: Swift.String?
        /// The blockchain network where the transaction occurred.
        /// This member is required.
        public var network: ManagedBlockchainQueryClientTypes.QueryNetwork?
        /// The number of transactions in the block.
        /// This member is required.
        public var numberOfTransactions: Swift.Int?
        /// The signature of the transaction. The X coordinate of a point R.
        public var signaturer: Swift.String?
        /// The signature of the transaction. The Y coordinate of a point S.
        public var signatures: Swift.String?
        /// The signature of the transaction. The Z coordinate of a point V.
        public var signaturev: Swift.Int?
        /// The identifier of the transaction. It is generated whenever a transaction is verified and added to the blockchain.
        /// This member is required.
        public var to: Swift.String?
        /// The transaction fee.
        public var transactionFee: Swift.String?
        /// The hash of a transaction. It is generated when a transaction is created.
        /// This member is required.
        public var transactionHash: Swift.String?
        /// The identifier of a Bitcoin transaction. It is generated when a transaction is created.
        public var transactionId: Swift.String?
        /// The index of the transaction within a blockchain.
        /// This member is required.
        public var transactionIndex: Swift.Int?
        /// The Timestamp of the transaction.
        /// This member is required.
        public var transactionTimestamp: Foundation.Date?

        public init(
            blockHash: Swift.String? = nil,
            blockNumber: Swift.String? = nil,
            confirmationStatus: ManagedBlockchainQueryClientTypes.ConfirmationStatus? = nil,
            contractAddress: Swift.String? = nil,
            cumulativeGasUsed: Swift.String? = nil,
            effectiveGasPrice: Swift.String? = nil,
            executionStatus: ManagedBlockchainQueryClientTypes.ExecutionStatus? = nil,
            from: Swift.String? = nil,
            gasUsed: Swift.String? = nil,
            network: ManagedBlockchainQueryClientTypes.QueryNetwork? = nil,
            numberOfTransactions: Swift.Int? = nil,
            signaturer: Swift.String? = nil,
            signatures: Swift.String? = nil,
            signaturev: Swift.Int? = nil,
            to: Swift.String? = nil,
            transactionFee: Swift.String? = nil,
            transactionHash: Swift.String? = nil,
            transactionId: Swift.String? = nil,
            transactionIndex: Swift.Int? = nil,
            transactionTimestamp: Foundation.Date? = nil
        )
        {
            self.blockHash = blockHash
            self.blockNumber = blockNumber
            self.confirmationStatus = confirmationStatus
            self.contractAddress = contractAddress
            self.cumulativeGasUsed = cumulativeGasUsed
            self.effectiveGasPrice = effectiveGasPrice
            self.executionStatus = executionStatus
            self.from = from
            self.gasUsed = gasUsed
            self.network = network
            self.numberOfTransactions = numberOfTransactions
            self.signaturer = signaturer
            self.signatures = signatures
            self.signaturev = signaturev
            self.to = to
            self.transactionFee = transactionFee
            self.transactionHash = transactionHash
            self.transactionId = transactionId
            self.transactionIndex = transactionIndex
            self.transactionTimestamp = transactionTimestamp
        }
    }

}

public struct GetTransactionOutput {
    /// Contains the details of the transaction.
    /// This member is required.
    public var transaction: ManagedBlockchainQueryClientTypes.Transaction?

    public init(
        transaction: ManagedBlockchainQueryClientTypes.Transaction? = nil
    )
    {
        self.transaction = transaction
    }
}

public struct ListAssetContractsInput {
    /// Contains the filter parameter for the request.
    /// This member is required.
    public var contractFilter: ManagedBlockchainQueryClientTypes.ContractFilter?
    /// The maximum number of contracts to list. Default: 100 Even if additional results can be retrieved, the request can return less results than maxResults or an empty array of results. To retrieve the next set of results, make another request with the returned nextToken value. The value of nextToken is null when there are no more results to return
    public var maxResults: Swift.Int?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?

    public init(
        contractFilter: ManagedBlockchainQueryClientTypes.ContractFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contractFilter = contractFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAssetContractsOutput {
    /// An array of contract objects that contain the properties for each contract.
    /// This member is required.
    public var contracts: [ManagedBlockchainQueryClientTypes.AssetContract]?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?

    public init(
        contracts: [ManagedBlockchainQueryClientTypes.AssetContract]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.contracts = contracts
        self.nextToken = nextToken
    }
}

extension ManagedBlockchainQueryClientTypes {

    public enum ListFilteredTransactionEventsSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Timestamp of a transaction
        case blockchaininstant
        case sdkUnknown(Swift.String)

        public static var allCases: [ListFilteredTransactionEventsSortBy] {
            return [
                .blockchaininstant
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .blockchaininstant: return "blockchainInstant"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ManagedBlockchainQueryClientTypes {

    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Result sorted in ascending order
        case ascending
        /// Result sorted in descending order
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// Lists all the transaction events for an address on the blockchain. This operation is only supported on the Bitcoin blockchain networks.
    public struct ListFilteredTransactionEventsSort {
        /// Container on how the results will be sorted by?
        public var sortBy: ManagedBlockchainQueryClientTypes.ListFilteredTransactionEventsSortBy?
        /// The container for the sort order for ListFilteredTransactionEvents. The SortOrder field only accepts the values ASCENDING and DESCENDING. Not providing SortOrder will default to ASCENDING.
        public var sortOrder: ManagedBlockchainQueryClientTypes.SortOrder?

        public init(
            sortBy: ManagedBlockchainQueryClientTypes.ListFilteredTransactionEventsSortBy? = nil,
            sortOrder: ManagedBlockchainQueryClientTypes.SortOrder? = nil
        )
        {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension ManagedBlockchainQueryClientTypes {
    /// This container is used to specify a time frame.
    public struct TimeFilter {
        /// The container for time.
        public var from: ManagedBlockchainQueryClientTypes.BlockchainInstant?
        /// The container for time.
        public var to: ManagedBlockchainQueryClientTypes.BlockchainInstant?

        public init(
            from: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
            to: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil
        )
        {
            self.from = from
            self.to = to
        }
    }

}

extension ManagedBlockchainQueryClientTypes {
    /// This container specifies filtering attributes related to BITCOIN_VOUT event types
    public struct VoutFilter {
        /// Specifies if the transaction output is spent or unspent.
        /// This member is required.
        public var voutSpent: Swift.Bool?

        public init(
            voutSpent: Swift.Bool? = nil
        )
        {
            self.voutSpent = voutSpent
        }
    }

}

public struct ListFilteredTransactionEventsInput {
    /// This is the unique public address on the blockchain for which the transaction events are being requested.
    /// This member is required.
    public var addressIdentifierFilter: ManagedBlockchainQueryClientTypes.AddressIdentifierFilter?
    /// The container for the ConfirmationStatusFilter that filters for the [ finality ](https://docs.aws.amazon.com/managed-blockchain/latest/ambq-dg/key-concepts.html#finality) of the results.
    public var confirmationStatusFilter: ManagedBlockchainQueryClientTypes.ConfirmationStatusFilter?
    /// The maximum number of transaction events to list. Default: 100 Even if additional results can be retrieved, the request can return less results than maxResults or an empty array of results. To retrieve the next set of results, make another request with the returned nextToken value. The value of nextToken is null when there are no more results to return
    public var maxResults: Swift.Int?
    /// The blockchain network where the transaction occurred. Valid Values: BITCOIN_MAINNET | BITCOIN_TESTNET
    /// This member is required.
    public var network: Swift.String?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?
    /// The order by which the results will be sorted.
    public var sort: ManagedBlockchainQueryClientTypes.ListFilteredTransactionEventsSort?
    /// This container specifies the time frame for the transaction events returned in the response.
    public var timeFilter: ManagedBlockchainQueryClientTypes.TimeFilter?
    /// This container specifies filtering attributes related to BITCOIN_VOUT event types
    public var voutFilter: ManagedBlockchainQueryClientTypes.VoutFilter?

    public init(
        addressIdentifierFilter: ManagedBlockchainQueryClientTypes.AddressIdentifierFilter? = nil,
        confirmationStatusFilter: ManagedBlockchainQueryClientTypes.ConfirmationStatusFilter? = nil,
        maxResults: Swift.Int? = nil,
        network: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        sort: ManagedBlockchainQueryClientTypes.ListFilteredTransactionEventsSort? = nil,
        timeFilter: ManagedBlockchainQueryClientTypes.TimeFilter? = nil,
        voutFilter: ManagedBlockchainQueryClientTypes.VoutFilter? = nil
    )
    {
        self.addressIdentifierFilter = addressIdentifierFilter
        self.confirmationStatusFilter = confirmationStatusFilter
        self.maxResults = maxResults
        self.network = network
        self.nextToken = nextToken
        self.sort = sort
        self.timeFilter = timeFilter
        self.voutFilter = voutFilter
    }
}

extension ManagedBlockchainQueryClientTypes {

    public enum QueryTransactionEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// A Bitcoin Vin transfer type
        case bitcoinVin
        /// A Bitcoin Vout transfer type
        case bitcoinVout
        /// An ERC1155 transfer type
        case erc1155Transfer
        /// An ERC20_BURN transfer type
        case erc20Burn
        /// An ERC20_DEPOSIT transfer type
        case erc20Deposit
        /// An ERC20_MINT transfer type
        case erc20Mint
        /// An ERC20 transfer type
        case erc20Transfer
        /// An ERC20_WITHDRAWAL transfer type
        case erc20Withdrawal
        /// An ERC721 transfer type
        case erc721Transfer
        /// An ETH transfer type
        case ethTransfer
        /// An internal ETH transfer type
        case internalEthTransfer
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryTransactionEventType] {
            return [
                .bitcoinVin,
                .bitcoinVout,
                .erc1155Transfer,
                .erc20Burn,
                .erc20Deposit,
                .erc20Mint,
                .erc20Transfer,
                .erc20Withdrawal,
                .erc721Transfer,
                .ethTransfer,
                .internalEthTransfer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bitcoinVin: return "BITCOIN_VIN"
            case .bitcoinVout: return "BITCOIN_VOUT"
            case .erc1155Transfer: return "ERC1155_TRANSFER"
            case .erc20Burn: return "ERC20_BURN"
            case .erc20Deposit: return "ERC20_DEPOSIT"
            case .erc20Mint: return "ERC20_MINT"
            case .erc20Transfer: return "ERC20_TRANSFER"
            case .erc20Withdrawal: return "ERC20_WITHDRAWAL"
            case .erc721Transfer: return "ERC721_TRANSFER"
            case .ethTransfer: return "ETH_TRANSFER"
            case .internalEthTransfer: return "INTERNAL_ETH_TRANSFER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// The container for the properties of a transaction event.
    public struct TransactionEvent {
        /// The container for time.
        public var blockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?
        /// This container specifies whether the transaction has reached Finality.
        public var confirmationStatus: ManagedBlockchainQueryClientTypes.ConfirmationStatus?
        /// The blockchain address for the contract
        public var contractAddress: Swift.String?
        /// The type of transaction event.
        /// This member is required.
        public var eventType: ManagedBlockchainQueryClientTypes.QueryTransactionEventType?
        /// The wallet address initiating the transaction. It can either be a public key or a contract.
        public var from: Swift.String?
        /// The blockchain network where the transaction occurred.
        /// This member is required.
        public var network: ManagedBlockchainQueryClientTypes.QueryNetwork?
        /// The position of the spent transaction output in the output list of the creating transaction. This is only returned for BITCOIN_VIN event types.
        public var spentVoutIndex: Swift.Int?
        /// The transactionHash that created the spent transaction output. This is only returned for BITCOIN_VIN event types.
        public var spentVoutTransactionHash: Swift.String?
        /// The transactionId that created the spent transaction output. This is only returned for BITCOIN_VIN event types.
        public var spentVoutTransactionId: Swift.String?
        /// The wallet address receiving the transaction. It can either be a public key or a contract.
        public var to: Swift.String?
        /// The unique identifier for the token involved in the transaction.
        public var tokenId: Swift.String?
        /// The hash of a transaction. It is generated when a transaction is created.
        /// This member is required.
        public var transactionHash: Swift.String?
        /// The identifier of a Bitcoin transaction. It is generated when a transaction is created.
        public var transactionId: Swift.String?
        /// The value that was transacted.
        public var value: Swift.String?
        /// The position of the transaction output in the transaction output list.
        public var voutIndex: Swift.Int?
        /// Specifies if the transaction output is spent or unspent. This is only returned for BITCOIN_VOUT event types. This is only returned for BITCOIN_VOUT event types.
        public var voutSpent: Swift.Bool?

        public init(
            blockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
            confirmationStatus: ManagedBlockchainQueryClientTypes.ConfirmationStatus? = nil,
            contractAddress: Swift.String? = nil,
            eventType: ManagedBlockchainQueryClientTypes.QueryTransactionEventType? = nil,
            from: Swift.String? = nil,
            network: ManagedBlockchainQueryClientTypes.QueryNetwork? = nil,
            spentVoutIndex: Swift.Int? = nil,
            spentVoutTransactionHash: Swift.String? = nil,
            spentVoutTransactionId: Swift.String? = nil,
            to: Swift.String? = nil,
            tokenId: Swift.String? = nil,
            transactionHash: Swift.String? = nil,
            transactionId: Swift.String? = nil,
            value: Swift.String? = nil,
            voutIndex: Swift.Int? = nil,
            voutSpent: Swift.Bool? = nil
        )
        {
            self.blockchainInstant = blockchainInstant
            self.confirmationStatus = confirmationStatus
            self.contractAddress = contractAddress
            self.eventType = eventType
            self.from = from
            self.network = network
            self.spentVoutIndex = spentVoutIndex
            self.spentVoutTransactionHash = spentVoutTransactionHash
            self.spentVoutTransactionId = spentVoutTransactionId
            self.to = to
            self.tokenId = tokenId
            self.transactionHash = transactionHash
            self.transactionId = transactionId
            self.value = value
            self.voutIndex = voutIndex
            self.voutSpent = voutSpent
        }
    }

}

public struct ListFilteredTransactionEventsOutput {
    /// The transaction events returned by the request.
    /// This member is required.
    public var events: [ManagedBlockchainQueryClientTypes.TransactionEvent]?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?

    public init(
        events: [ManagedBlockchainQueryClientTypes.TransactionEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// The container for the owner information to filter by.
    public struct OwnerFilter {
        /// The contract or wallet address.
        /// This member is required.
        public var address: Swift.String?

        public init(
            address: Swift.String? = nil
        )
        {
            self.address = address
        }
    }

}

extension ManagedBlockchainQueryClientTypes {
    /// The container of the token filter like the contract address on a given blockchain network or a unique token identifier on a given blockchain network. You must always specify the network property of this container when using this operation.
    public struct TokenFilter {
        /// This is the address of the contract.
        public var contractAddress: Swift.String?
        /// The blockchain network of the token.
        /// This member is required.
        public var network: ManagedBlockchainQueryClientTypes.QueryNetwork?
        /// The unique identifier of the token.
        public var tokenId: Swift.String?

        public init(
            contractAddress: Swift.String? = nil,
            network: ManagedBlockchainQueryClientTypes.QueryNetwork? = nil,
            tokenId: Swift.String? = nil
        )
        {
            self.contractAddress = contractAddress
            self.network = network
            self.tokenId = tokenId
        }
    }

}

public struct ListTokenBalancesInput {
    /// The maximum number of token balances to return. Default: 100 Even if additional results can be retrieved, the request can return less results than maxResults or an empty array of results. To retrieve the next set of results, make another request with the returned nextToken value. The value of nextToken is null when there are no more results to return
    public var maxResults: Swift.Int?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?
    /// The contract or wallet address on the blockchain network by which to filter the request. You must specify the address property of the ownerFilter when listing balances of tokens owned by the address.
    public var ownerFilter: ManagedBlockchainQueryClientTypes.OwnerFilter?
    /// The contract address or a token identifier on the blockchain network by which to filter the request. You must specify the contractAddress property of this container when listing tokens minted by a contract. You must always specify the network property of this container when using this operation.
    /// This member is required.
    public var tokenFilter: ManagedBlockchainQueryClientTypes.TokenFilter?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        ownerFilter: ManagedBlockchainQueryClientTypes.OwnerFilter? = nil,
        tokenFilter: ManagedBlockchainQueryClientTypes.TokenFilter? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ownerFilter = ownerFilter
        self.tokenFilter = tokenFilter
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// The balance of the token.
    public struct TokenBalance {
        /// The time for when the TokenBalance is requested or the current time if a time is not provided in the request. This time will only be recorded up to the second.
        /// This member is required.
        public var atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?
        /// The container of the token balance.
        /// This member is required.
        public var balance: Swift.String?
        /// The Timestamp of the last transaction at which the balance for the token in the wallet was updated.
        public var lastUpdatedTime: ManagedBlockchainQueryClientTypes.BlockchainInstant?
        /// The container for the identifier of the owner.
        public var ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier?
        /// The identifier for the token, including the unique token ID and its blockchain network.
        public var tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier?

        public init(
            atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
            balance: Swift.String? = nil,
            lastUpdatedTime: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
            ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier? = nil,
            tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier? = nil
        )
        {
            self.atBlockchainInstant = atBlockchainInstant
            self.balance = balance
            self.lastUpdatedTime = lastUpdatedTime
            self.ownerIdentifier = ownerIdentifier
            self.tokenIdentifier = tokenIdentifier
        }
    }

}

public struct ListTokenBalancesOutput {
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?
    /// An array of TokenBalance objects. Each object contains details about the token balance.
    /// This member is required.
    public var tokenBalances: [ManagedBlockchainQueryClientTypes.TokenBalance]?

    public init(
        nextToken: Swift.String? = nil,
        tokenBalances: [ManagedBlockchainQueryClientTypes.TokenBalance]? = nil
    )
    {
        self.nextToken = nextToken
        self.tokenBalances = tokenBalances
    }
}

public struct ListTransactionEventsInput {
    /// The maximum number of transaction events to list. Default: 100 Even if additional results can be retrieved, the request can return less results than maxResults or an empty array of results. To retrieve the next set of results, make another request with the returned nextToken value. The value of nextToken is null when there are no more results to return
    public var maxResults: Swift.Int?
    /// The blockchain network where the transaction events occurred.
    /// This member is required.
    public var network: ManagedBlockchainQueryClientTypes.QueryNetwork?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?
    /// The hash of a transaction. It is generated when a transaction is created.
    public var transactionHash: Swift.String?
    /// The identifier of a Bitcoin transaction. It is generated when a transaction is created. transactionId is only supported on the Bitcoin networks.
    public var transactionId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        network: ManagedBlockchainQueryClientTypes.QueryNetwork? = nil,
        nextToken: Swift.String? = nil,
        transactionHash: Swift.String? = nil,
        transactionId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.network = network
        self.nextToken = nextToken
        self.transactionHash = transactionHash
        self.transactionId = transactionId
    }
}

public struct ListTransactionEventsOutput {
    /// An array of TransactionEvent objects. Each object contains details about the transaction events.
    /// This member is required.
    public var events: [ManagedBlockchainQueryClientTypes.TransactionEvent]?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?

    public init(
        events: [ManagedBlockchainQueryClientTypes.TransactionEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

extension ManagedBlockchainQueryClientTypes {

    public enum ListTransactionsSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        /// Timestamp of a transaction
        case transactionTimestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [ListTransactionsSortBy] {
            return [
                .transactionTimestamp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .transactionTimestamp: return "TRANSACTION_TIMESTAMP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// The container for determining how the list transaction result will be sorted.
    public struct ListTransactionsSort {
        /// Defaults to the value TRANSACTION_TIMESTAMP.
        public var sortBy: ManagedBlockchainQueryClientTypes.ListTransactionsSortBy?
        /// The container for the sort order for ListTransactions. The SortOrder field only accepts the values ASCENDING and DESCENDING. Not providing SortOrder will default to ASCENDING.
        public var sortOrder: ManagedBlockchainQueryClientTypes.SortOrder?

        public init(
            sortBy: ManagedBlockchainQueryClientTypes.ListTransactionsSortBy? = nil,
            sortOrder: ManagedBlockchainQueryClientTypes.SortOrder? = nil
        )
        {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

public struct ListTransactionsInput {
    /// The address (either a contract or wallet), whose transactions are being requested.
    /// This member is required.
    public var address: Swift.String?
    /// This filter is used to include transactions in the response that haven't reached [ finality ](https://docs.aws.amazon.com/managed-blockchain/latest/ambq-dg/key-concepts.html#finality). Transactions that have reached finality are always part of the response.
    public var confirmationStatusFilter: ManagedBlockchainQueryClientTypes.ConfirmationStatusFilter?
    /// The container for time.
    public var fromBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?
    /// The maximum number of transactions to list. Default: 100 Even if additional results can be retrieved, the request can return less results than maxResults or an empty array of results. To retrieve the next set of results, make another request with the returned nextToken value. The value of nextToken is null when there are no more results to return
    public var maxResults: Swift.Int?
    /// The blockchain network where the transactions occurred.
    /// This member is required.
    public var network: ManagedBlockchainQueryClientTypes.QueryNetwork?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?
    /// The order by which the results will be sorted.
    public var sort: ManagedBlockchainQueryClientTypes.ListTransactionsSort?
    /// The container for time.
    public var toBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?

    public init(
        address: Swift.String? = nil,
        confirmationStatusFilter: ManagedBlockchainQueryClientTypes.ConfirmationStatusFilter? = nil,
        fromBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
        maxResults: Swift.Int? = nil,
        network: ManagedBlockchainQueryClientTypes.QueryNetwork? = nil,
        nextToken: Swift.String? = nil,
        sort: ManagedBlockchainQueryClientTypes.ListTransactionsSort? = nil,
        toBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil
    )
    {
        self.address = address
        self.confirmationStatusFilter = confirmationStatusFilter
        self.fromBlockchainInstant = fromBlockchainInstant
        self.maxResults = maxResults
        self.network = network
        self.nextToken = nextToken
        self.sort = sort
        self.toBlockchainInstant = toBlockchainInstant
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// The container of the transaction output.
    public struct TransactionOutputItem {
        /// Specifies whether to list transactions that have not reached Finality.
        public var confirmationStatus: ManagedBlockchainQueryClientTypes.ConfirmationStatus?
        /// The blockchain network where the transaction occurred.
        /// This member is required.
        public var network: ManagedBlockchainQueryClientTypes.QueryNetwork?
        /// The hash of a transaction. It is generated when a transaction is created.
        /// This member is required.
        public var transactionHash: Swift.String?
        /// The identifier of a Bitcoin transaction. It is generated when a transaction is created.
        public var transactionId: Swift.String?
        /// The time when the transaction occurred.
        /// This member is required.
        public var transactionTimestamp: Foundation.Date?

        public init(
            confirmationStatus: ManagedBlockchainQueryClientTypes.ConfirmationStatus? = nil,
            network: ManagedBlockchainQueryClientTypes.QueryNetwork? = nil,
            transactionHash: Swift.String? = nil,
            transactionId: Swift.String? = nil,
            transactionTimestamp: Foundation.Date? = nil
        )
        {
            self.confirmationStatus = confirmationStatus
            self.network = network
            self.transactionHash = transactionHash
            self.transactionId = transactionId
            self.transactionTimestamp = transactionTimestamp
        }
    }

}

public struct ListTransactionsOutput {
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?
    /// The array of transactions returned by the request.
    /// This member is required.
    public var transactions: [ManagedBlockchainQueryClientTypes.TransactionOutputItem]?

    public init(
        nextToken: Swift.String? = nil,
        transactions: [ManagedBlockchainQueryClientTypes.TransactionOutputItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.transactions = transactions
    }
}

extension BatchGetTokenBalanceInput {

    static func urlPathProvider(_ value: BatchGetTokenBalanceInput) -> Swift.String? {
        return "/batch-get-token-balance"
    }
}

extension GetAssetContractInput {

    static func urlPathProvider(_ value: GetAssetContractInput) -> Swift.String? {
        return "/get-asset-contract"
    }
}

extension GetTokenBalanceInput {

    static func urlPathProvider(_ value: GetTokenBalanceInput) -> Swift.String? {
        return "/get-token-balance"
    }
}

extension GetTransactionInput {

    static func urlPathProvider(_ value: GetTransactionInput) -> Swift.String? {
        return "/get-transaction"
    }
}

extension ListAssetContractsInput {

    static func urlPathProvider(_ value: ListAssetContractsInput) -> Swift.String? {
        return "/list-asset-contracts"
    }
}

extension ListFilteredTransactionEventsInput {

    static func urlPathProvider(_ value: ListFilteredTransactionEventsInput) -> Swift.String? {
        return "/list-filtered-transaction-events"
    }
}

extension ListTokenBalancesInput {

    static func urlPathProvider(_ value: ListTokenBalancesInput) -> Swift.String? {
        return "/list-token-balances"
    }
}

extension ListTransactionEventsInput {

    static func urlPathProvider(_ value: ListTransactionEventsInput) -> Swift.String? {
        return "/list-transaction-events"
    }
}

extension ListTransactionsInput {

    static func urlPathProvider(_ value: ListTransactionsInput) -> Swift.String? {
        return "/list-transactions"
    }
}

extension BatchGetTokenBalanceInput {

    static func write(value: BatchGetTokenBalanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["getTokenBalanceInputs"].writeList(value.getTokenBalanceInputs, memberWritingClosure: ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceInputItem.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension GetAssetContractInput {

    static func write(value: GetAssetContractInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contractIdentifier"].write(value.contractIdentifier, with: ManagedBlockchainQueryClientTypes.ContractIdentifier.write(value:to:))
    }
}

extension GetTokenBalanceInput {

    static func write(value: GetTokenBalanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["atBlockchainInstant"].write(value.atBlockchainInstant, with: ManagedBlockchainQueryClientTypes.BlockchainInstant.write(value:to:))
        try writer["ownerIdentifier"].write(value.ownerIdentifier, with: ManagedBlockchainQueryClientTypes.OwnerIdentifier.write(value:to:))
        try writer["tokenIdentifier"].write(value.tokenIdentifier, with: ManagedBlockchainQueryClientTypes.TokenIdentifier.write(value:to:))
    }
}

extension GetTransactionInput {

    static func write(value: GetTransactionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["network"].write(value.network)
        try writer["transactionHash"].write(value.transactionHash)
        try writer["transactionId"].write(value.transactionId)
    }
}

extension ListAssetContractsInput {

    static func write(value: ListAssetContractsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contractFilter"].write(value.contractFilter, with: ManagedBlockchainQueryClientTypes.ContractFilter.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListFilteredTransactionEventsInput {

    static func write(value: ListFilteredTransactionEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["addressIdentifierFilter"].write(value.addressIdentifierFilter, with: ManagedBlockchainQueryClientTypes.AddressIdentifierFilter.write(value:to:))
        try writer["confirmationStatusFilter"].write(value.confirmationStatusFilter, with: ManagedBlockchainQueryClientTypes.ConfirmationStatusFilter.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["network"].write(value.network)
        try writer["nextToken"].write(value.nextToken)
        try writer["sort"].write(value.sort, with: ManagedBlockchainQueryClientTypes.ListFilteredTransactionEventsSort.write(value:to:))
        try writer["timeFilter"].write(value.timeFilter, with: ManagedBlockchainQueryClientTypes.TimeFilter.write(value:to:))
        try writer["voutFilter"].write(value.voutFilter, with: ManagedBlockchainQueryClientTypes.VoutFilter.write(value:to:))
    }
}

extension ListTokenBalancesInput {

    static func write(value: ListTokenBalancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["ownerFilter"].write(value.ownerFilter, with: ManagedBlockchainQueryClientTypes.OwnerFilter.write(value:to:))
        try writer["tokenFilter"].write(value.tokenFilter, with: ManagedBlockchainQueryClientTypes.TokenFilter.write(value:to:))
    }
}

extension ListTransactionEventsInput {

    static func write(value: ListTransactionEventsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["network"].write(value.network)
        try writer["nextToken"].write(value.nextToken)
        try writer["transactionHash"].write(value.transactionHash)
        try writer["transactionId"].write(value.transactionId)
    }
}

extension ListTransactionsInput {

    static func write(value: ListTransactionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["address"].write(value.address)
        try writer["confirmationStatusFilter"].write(value.confirmationStatusFilter, with: ManagedBlockchainQueryClientTypes.ConfirmationStatusFilter.write(value:to:))
        try writer["fromBlockchainInstant"].write(value.fromBlockchainInstant, with: ManagedBlockchainQueryClientTypes.BlockchainInstant.write(value:to:))
        try writer["maxResults"].write(value.maxResults)
        try writer["network"].write(value.network)
        try writer["nextToken"].write(value.nextToken)
        try writer["sort"].write(value.sort, with: ManagedBlockchainQueryClientTypes.ListTransactionsSort.write(value:to:))
        try writer["toBlockchainInstant"].write(value.toBlockchainInstant, with: ManagedBlockchainQueryClientTypes.BlockchainInstant.write(value:to:))
    }
}

extension BatchGetTokenBalanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetTokenBalanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetTokenBalanceOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceErrorItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.tokenBalances = try reader["tokenBalances"].readListIfPresent(memberReadingClosure: ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceOutputItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetAssetContractOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAssetContractOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssetContractOutput()
        value.contractIdentifier = try reader["contractIdentifier"].readIfPresent(with: ManagedBlockchainQueryClientTypes.ContractIdentifier.read(from:))
        value.deployerAddress = try reader["deployerAddress"].readIfPresent() ?? ""
        value.metadata = try reader["metadata"].readIfPresent(with: ManagedBlockchainQueryClientTypes.ContractMetadata.read(from:))
        value.tokenStandard = try reader["tokenStandard"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetTokenBalanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTokenBalanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTokenBalanceOutput()
        value.atBlockchainInstant = try reader["atBlockchainInstant"].readIfPresent(with: ManagedBlockchainQueryClientTypes.BlockchainInstant.read(from:))
        value.balance = try reader["balance"].readIfPresent() ?? ""
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readIfPresent(with: ManagedBlockchainQueryClientTypes.BlockchainInstant.read(from:))
        value.ownerIdentifier = try reader["ownerIdentifier"].readIfPresent(with: ManagedBlockchainQueryClientTypes.OwnerIdentifier.read(from:))
        value.tokenIdentifier = try reader["tokenIdentifier"].readIfPresent(with: ManagedBlockchainQueryClientTypes.TokenIdentifier.read(from:))
        return value
    }
}

extension GetTransactionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetTransactionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetTransactionOutput()
        value.transaction = try reader["transaction"].readIfPresent(with: ManagedBlockchainQueryClientTypes.Transaction.read(from:))
        return value
    }
}

extension ListAssetContractsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssetContractsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssetContractsOutput()
        value.contracts = try reader["contracts"].readListIfPresent(memberReadingClosure: ManagedBlockchainQueryClientTypes.AssetContract.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListFilteredTransactionEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListFilteredTransactionEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListFilteredTransactionEventsOutput()
        value.events = try reader["events"].readListIfPresent(memberReadingClosure: ManagedBlockchainQueryClientTypes.TransactionEvent.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTokenBalancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTokenBalancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTokenBalancesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.tokenBalances = try reader["tokenBalances"].readListIfPresent(memberReadingClosure: ManagedBlockchainQueryClientTypes.TokenBalance.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTransactionEventsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTransactionEventsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTransactionEventsOutput()
        value.events = try reader["events"].readListIfPresent(memberReadingClosure: ManagedBlockchainQueryClientTypes.TransactionEvent.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTransactionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTransactionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTransactionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.transactions = try reader["transactions"].readListIfPresent(memberReadingClosure: ManagedBlockchainQueryClientTypes.TransactionOutputItem.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

enum BatchGetTokenBalanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAssetContractOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTokenBalanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetTransactionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssetContractsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListFilteredTransactionEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTokenBalancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTransactionEventsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTransactionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: ManagedBlockchainQueryClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? .sdkUnknown("")
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceOutputItem {

    static func read(from reader: SmithyJSON.Reader) throws -> ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceOutputItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceOutputItem()
        value.ownerIdentifier = try reader["ownerIdentifier"].readIfPresent(with: ManagedBlockchainQueryClientTypes.OwnerIdentifier.read(from:))
        value.tokenIdentifier = try reader["tokenIdentifier"].readIfPresent(with: ManagedBlockchainQueryClientTypes.TokenIdentifier.read(from:))
        value.balance = try reader["balance"].readIfPresent() ?? ""
        value.atBlockchainInstant = try reader["atBlockchainInstant"].readIfPresent(with: ManagedBlockchainQueryClientTypes.BlockchainInstant.read(from:))
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readIfPresent(with: ManagedBlockchainQueryClientTypes.BlockchainInstant.read(from:))
        return value
    }
}

extension ManagedBlockchainQueryClientTypes.BlockchainInstant {

    static func write(value: ManagedBlockchainQueryClientTypes.BlockchainInstant?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["time"].writeTimestamp(value.time, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ManagedBlockchainQueryClientTypes.BlockchainInstant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ManagedBlockchainQueryClientTypes.BlockchainInstant()
        value.time = try reader["time"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension ManagedBlockchainQueryClientTypes.TokenIdentifier {

    static func write(value: ManagedBlockchainQueryClientTypes.TokenIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contractAddress"].write(value.contractAddress)
        try writer["network"].write(value.network)
        try writer["tokenId"].write(value.tokenId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ManagedBlockchainQueryClientTypes.TokenIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ManagedBlockchainQueryClientTypes.TokenIdentifier()
        value.network = try reader["network"].readIfPresent() ?? .sdkUnknown("")
        value.contractAddress = try reader["contractAddress"].readIfPresent()
        value.tokenId = try reader["tokenId"].readIfPresent()
        return value
    }
}

extension ManagedBlockchainQueryClientTypes.OwnerIdentifier {

    static func write(value: ManagedBlockchainQueryClientTypes.OwnerIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["address"].write(value.address)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ManagedBlockchainQueryClientTypes.OwnerIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ManagedBlockchainQueryClientTypes.OwnerIdentifier()
        value.address = try reader["address"].readIfPresent() ?? ""
        return value
    }
}

extension ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceErrorItem {

    static func read(from reader: SmithyJSON.Reader) throws -> ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceErrorItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceErrorItem()
        value.tokenIdentifier = try reader["tokenIdentifier"].readIfPresent(with: ManagedBlockchainQueryClientTypes.TokenIdentifier.read(from:))
        value.ownerIdentifier = try reader["ownerIdentifier"].readIfPresent(with: ManagedBlockchainQueryClientTypes.OwnerIdentifier.read(from:))
        value.atBlockchainInstant = try reader["atBlockchainInstant"].readIfPresent(with: ManagedBlockchainQueryClientTypes.BlockchainInstant.read(from:))
        value.errorCode = try reader["errorCode"].readIfPresent() ?? ""
        value.errorMessage = try reader["errorMessage"].readIfPresent() ?? ""
        value.errorType = try reader["errorType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ManagedBlockchainQueryClientTypes.ContractIdentifier {

    static func write(value: ManagedBlockchainQueryClientTypes.ContractIdentifier?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contractAddress"].write(value.contractAddress)
        try writer["network"].write(value.network)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> ManagedBlockchainQueryClientTypes.ContractIdentifier {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ManagedBlockchainQueryClientTypes.ContractIdentifier()
        value.network = try reader["network"].readIfPresent() ?? .sdkUnknown("")
        value.contractAddress = try reader["contractAddress"].readIfPresent() ?? ""
        return value
    }
}

extension ManagedBlockchainQueryClientTypes.ContractMetadata {

    static func read(from reader: SmithyJSON.Reader) throws -> ManagedBlockchainQueryClientTypes.ContractMetadata {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ManagedBlockchainQueryClientTypes.ContractMetadata()
        value.name = try reader["name"].readIfPresent()
        value.symbol = try reader["symbol"].readIfPresent()
        value.decimals = try reader["decimals"].readIfPresent()
        return value
    }
}

extension ManagedBlockchainQueryClientTypes.Transaction {

    static func read(from reader: SmithyJSON.Reader) throws -> ManagedBlockchainQueryClientTypes.Transaction {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ManagedBlockchainQueryClientTypes.Transaction()
        value.network = try reader["network"].readIfPresent() ?? .sdkUnknown("")
        value.blockHash = try reader["blockHash"].readIfPresent()
        value.transactionHash = try reader["transactionHash"].readIfPresent() ?? ""
        value.blockNumber = try reader["blockNumber"].readIfPresent()
        value.transactionTimestamp = try reader["transactionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.transactionIndex = try reader["transactionIndex"].readIfPresent() ?? 0
        value.numberOfTransactions = try reader["numberOfTransactions"].readIfPresent() ?? 0
        value.to = try reader["to"].readIfPresent() ?? ""
        value.from = try reader["from"].readIfPresent()
        value.contractAddress = try reader["contractAddress"].readIfPresent()
        value.gasUsed = try reader["gasUsed"].readIfPresent()
        value.cumulativeGasUsed = try reader["cumulativeGasUsed"].readIfPresent()
        value.effectiveGasPrice = try reader["effectiveGasPrice"].readIfPresent()
        value.signaturev = try reader["signatureV"].readIfPresent()
        value.signaturer = try reader["signatureR"].readIfPresent()
        value.signatures = try reader["signatureS"].readIfPresent()
        value.transactionFee = try reader["transactionFee"].readIfPresent()
        value.transactionId = try reader["transactionId"].readIfPresent()
        value.confirmationStatus = try reader["confirmationStatus"].readIfPresent()
        value.executionStatus = try reader["executionStatus"].readIfPresent()
        return value
    }
}

extension ManagedBlockchainQueryClientTypes.AssetContract {

    static func read(from reader: SmithyJSON.Reader) throws -> ManagedBlockchainQueryClientTypes.AssetContract {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ManagedBlockchainQueryClientTypes.AssetContract()
        value.contractIdentifier = try reader["contractIdentifier"].readIfPresent(with: ManagedBlockchainQueryClientTypes.ContractIdentifier.read(from:))
        value.tokenStandard = try reader["tokenStandard"].readIfPresent() ?? .sdkUnknown("")
        value.deployerAddress = try reader["deployerAddress"].readIfPresent() ?? ""
        return value
    }
}

extension ManagedBlockchainQueryClientTypes.TransactionEvent {

    static func read(from reader: SmithyJSON.Reader) throws -> ManagedBlockchainQueryClientTypes.TransactionEvent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ManagedBlockchainQueryClientTypes.TransactionEvent()
        value.network = try reader["network"].readIfPresent() ?? .sdkUnknown("")
        value.transactionHash = try reader["transactionHash"].readIfPresent() ?? ""
        value.eventType = try reader["eventType"].readIfPresent() ?? .sdkUnknown("")
        value.from = try reader["from"].readIfPresent()
        value.to = try reader["to"].readIfPresent()
        value.value = try reader["value"].readIfPresent()
        value.contractAddress = try reader["contractAddress"].readIfPresent()
        value.tokenId = try reader["tokenId"].readIfPresent()
        value.transactionId = try reader["transactionId"].readIfPresent()
        value.voutIndex = try reader["voutIndex"].readIfPresent()
        value.voutSpent = try reader["voutSpent"].readIfPresent()
        value.spentVoutTransactionId = try reader["spentVoutTransactionId"].readIfPresent()
        value.spentVoutTransactionHash = try reader["spentVoutTransactionHash"].readIfPresent()
        value.spentVoutIndex = try reader["spentVoutIndex"].readIfPresent()
        value.blockchainInstant = try reader["blockchainInstant"].readIfPresent(with: ManagedBlockchainQueryClientTypes.BlockchainInstant.read(from:))
        value.confirmationStatus = try reader["confirmationStatus"].readIfPresent()
        return value
    }
}

extension ManagedBlockchainQueryClientTypes.TokenBalance {

    static func read(from reader: SmithyJSON.Reader) throws -> ManagedBlockchainQueryClientTypes.TokenBalance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ManagedBlockchainQueryClientTypes.TokenBalance()
        value.ownerIdentifier = try reader["ownerIdentifier"].readIfPresent(with: ManagedBlockchainQueryClientTypes.OwnerIdentifier.read(from:))
        value.tokenIdentifier = try reader["tokenIdentifier"].readIfPresent(with: ManagedBlockchainQueryClientTypes.TokenIdentifier.read(from:))
        value.balance = try reader["balance"].readIfPresent() ?? ""
        value.atBlockchainInstant = try reader["atBlockchainInstant"].readIfPresent(with: ManagedBlockchainQueryClientTypes.BlockchainInstant.read(from:))
        value.lastUpdatedTime = try reader["lastUpdatedTime"].readIfPresent(with: ManagedBlockchainQueryClientTypes.BlockchainInstant.read(from:))
        return value
    }
}

extension ManagedBlockchainQueryClientTypes.TransactionOutputItem {

    static func read(from reader: SmithyJSON.Reader) throws -> ManagedBlockchainQueryClientTypes.TransactionOutputItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ManagedBlockchainQueryClientTypes.TransactionOutputItem()
        value.transactionHash = try reader["transactionHash"].readIfPresent() ?? ""
        value.transactionId = try reader["transactionId"].readIfPresent()
        value.network = try reader["network"].readIfPresent() ?? .sdkUnknown("")
        value.transactionTimestamp = try reader["transactionTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.confirmationStatus = try reader["confirmationStatus"].readIfPresent()
        return value
    }
}

extension ManagedBlockchainQueryClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> ManagedBlockchainQueryClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = ManagedBlockchainQueryClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceInputItem {

    static func write(value: ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceInputItem?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["atBlockchainInstant"].write(value.atBlockchainInstant, with: ManagedBlockchainQueryClientTypes.BlockchainInstant.write(value:to:))
        try writer["ownerIdentifier"].write(value.ownerIdentifier, with: ManagedBlockchainQueryClientTypes.OwnerIdentifier.write(value:to:))
        try writer["tokenIdentifier"].write(value.tokenIdentifier, with: ManagedBlockchainQueryClientTypes.TokenIdentifier.write(value:to:))
    }
}

extension ManagedBlockchainQueryClientTypes.ContractFilter {

    static func write(value: ManagedBlockchainQueryClientTypes.ContractFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["deployerAddress"].write(value.deployerAddress)
        try writer["network"].write(value.network)
        try writer["tokenStandard"].write(value.tokenStandard)
    }
}

extension ManagedBlockchainQueryClientTypes.AddressIdentifierFilter {

    static func write(value: ManagedBlockchainQueryClientTypes.AddressIdentifierFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["transactionEventToAddress"].writeList(value.transactionEventToAddress, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ManagedBlockchainQueryClientTypes.TimeFilter {

    static func write(value: ManagedBlockchainQueryClientTypes.TimeFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["from"].write(value.from, with: ManagedBlockchainQueryClientTypes.BlockchainInstant.write(value:to:))
        try writer["to"].write(value.to, with: ManagedBlockchainQueryClientTypes.BlockchainInstant.write(value:to:))
    }
}

extension ManagedBlockchainQueryClientTypes.VoutFilter {

    static func write(value: ManagedBlockchainQueryClientTypes.VoutFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["voutSpent"].write(value.voutSpent)
    }
}

extension ManagedBlockchainQueryClientTypes.ConfirmationStatusFilter {

    static func write(value: ManagedBlockchainQueryClientTypes.ConfirmationStatusFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["include"].writeList(value.include, memberWritingClosure: SmithyReadWrite.WritingClosureBox<ManagedBlockchainQueryClientTypes.ConfirmationStatus>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ManagedBlockchainQueryClientTypes.ListFilteredTransactionEventsSort {

    static func write(value: ManagedBlockchainQueryClientTypes.ListFilteredTransactionEventsSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

extension ManagedBlockchainQueryClientTypes.OwnerFilter {

    static func write(value: ManagedBlockchainQueryClientTypes.OwnerFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["address"].write(value.address)
    }
}

extension ManagedBlockchainQueryClientTypes.TokenFilter {

    static func write(value: ManagedBlockchainQueryClientTypes.TokenFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["contractAddress"].write(value.contractAddress)
        try writer["network"].write(value.network)
        try writer["tokenId"].write(value.tokenId)
    }
}

extension ManagedBlockchainQueryClientTypes.ListTransactionsSort {

    static func write(value: ManagedBlockchainQueryClientTypes.ListTransactionsSort?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["sortBy"].write(value.sortBy)
        try writer["sortOrder"].write(value.sortOrder)
    }
}

public enum ManagedBlockchainQueryClientTypes {}
