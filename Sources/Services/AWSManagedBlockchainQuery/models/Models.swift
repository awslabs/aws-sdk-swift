// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The Amazon Web Services account doesnâ€™t have access to this resource.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The container for the exception message.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceErrorItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case atBlockchainInstant
        case errorCode
        case errorMessage
        case errorType
        case ownerIdentifier
        case tokenIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let atBlockchainInstant = self.atBlockchainInstant {
            try encodeContainer.encode(atBlockchainInstant, forKey: .atBlockchainInstant)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorType = self.errorType {
            try encodeContainer.encode(errorType.rawValue, forKey: .errorType)
        }
        if let ownerIdentifier = self.ownerIdentifier {
            try encodeContainer.encode(ownerIdentifier, forKey: .ownerIdentifier)
        }
        if let tokenIdentifier = self.tokenIdentifier {
            try encodeContainer.encode(tokenIdentifier, forKey: .tokenIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenIdentifierDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.TokenIdentifier.self, forKey: .tokenIdentifier)
        tokenIdentifier = tokenIdentifierDecoded
        let ownerIdentifierDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.OwnerIdentifier.self, forKey: .ownerIdentifier)
        ownerIdentifier = ownerIdentifierDecoded
        let atBlockchainInstantDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.BlockchainInstant.self, forKey: .atBlockchainInstant)
        atBlockchainInstant = atBlockchainInstantDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorTypeDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.ErrorType.self, forKey: .errorType)
        errorType = errorTypeDecoded
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// Error generated from a failed BatchGetTokenBalance request.
    public struct BatchGetTokenBalanceErrorItem: Swift.Equatable {
        /// The container for time.
        public var atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?
        /// The error code associated with the error.
        /// This member is required.
        public var errorCode: Swift.String?
        /// The message associated with the error.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The type of error.
        /// This member is required.
        public var errorType: ManagedBlockchainQueryClientTypes.ErrorType?
        /// The container for the identifier of the owner.
        public var ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier?
        /// The container for the identifier for the token including the unique token ID and its blockchain network. Only the native tokens BTC,ETH, and the ERC-20, ERC-721, and ERC 1155 token standards are supported.
        public var tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier?

        public init(
            atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            errorType: ManagedBlockchainQueryClientTypes.ErrorType? = nil,
            ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier? = nil,
            tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier? = nil
        )
        {
            self.atBlockchainInstant = atBlockchainInstant
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.errorType = errorType
            self.ownerIdentifier = ownerIdentifier
            self.tokenIdentifier = tokenIdentifier
        }
    }

}

extension BatchGetTokenBalanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case getTokenBalanceInputs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let getTokenBalanceInputs = getTokenBalanceInputs {
            var getTokenBalanceInputsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .getTokenBalanceInputs)
            for batchgettokenbalanceinputitem0 in getTokenBalanceInputs {
                try getTokenBalanceInputsContainer.encode(batchgettokenbalanceinputitem0)
            }
        }
    }
}

extension BatchGetTokenBalanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/batch-get-token-balance"
    }
}

public struct BatchGetTokenBalanceInput: Swift.Equatable {
    /// An array of GetTokenBalanceInput objects whose balance is being requested.
    public var getTokenBalanceInputs: [ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceInputItem]?

    public init(
        getTokenBalanceInputs: [ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceInputItem]? = nil
    )
    {
        self.getTokenBalanceInputs = getTokenBalanceInputs
    }
}

struct BatchGetTokenBalanceInputBody: Swift.Equatable {
    let getTokenBalanceInputs: [ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceInputItem]?
}

extension BatchGetTokenBalanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case getTokenBalanceInputs
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let getTokenBalanceInputsContainer = try containerValues.decodeIfPresent([ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceInputItem?].self, forKey: .getTokenBalanceInputs)
        var getTokenBalanceInputsDecoded0:[ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceInputItem]? = nil
        if let getTokenBalanceInputsContainer = getTokenBalanceInputsContainer {
            getTokenBalanceInputsDecoded0 = [ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceInputItem]()
            for structure0 in getTokenBalanceInputsContainer {
                if let structure0 = structure0 {
                    getTokenBalanceInputsDecoded0?.append(structure0)
                }
            }
        }
        getTokenBalanceInputs = getTokenBalanceInputsDecoded0
    }
}

extension ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceInputItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case atBlockchainInstant
        case ownerIdentifier
        case tokenIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let atBlockchainInstant = self.atBlockchainInstant {
            try encodeContainer.encode(atBlockchainInstant, forKey: .atBlockchainInstant)
        }
        if let ownerIdentifier = self.ownerIdentifier {
            try encodeContainer.encode(ownerIdentifier, forKey: .ownerIdentifier)
        }
        if let tokenIdentifier = self.tokenIdentifier {
            try encodeContainer.encode(tokenIdentifier, forKey: .tokenIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenIdentifierDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.TokenIdentifier.self, forKey: .tokenIdentifier)
        tokenIdentifier = tokenIdentifierDecoded
        let ownerIdentifierDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.OwnerIdentifier.self, forKey: .ownerIdentifier)
        ownerIdentifier = ownerIdentifierDecoded
        let atBlockchainInstantDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.BlockchainInstant.self, forKey: .atBlockchainInstant)
        atBlockchainInstant = atBlockchainInstantDecoded
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// The container for the input for getting a token balance.
    public struct BatchGetTokenBalanceInputItem: Swift.Equatable {
        /// The container for time.
        public var atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?
        /// The container for the identifier of the owner.
        /// This member is required.
        public var ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier?
        /// The container for the identifier for the token including the unique token ID and its blockchain network. Only the native tokens BTC,ETH, and the ERC-20, ERC-721, and ERC 1155 token standards are supported.
        /// This member is required.
        public var tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier?

        public init(
            atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
            ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier? = nil,
            tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier? = nil
        )
        {
            self.atBlockchainInstant = atBlockchainInstant
            self.ownerIdentifier = ownerIdentifier
            self.tokenIdentifier = tokenIdentifier
        }
    }

}

public enum BatchGetTokenBalanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceOutputItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case atBlockchainInstant
        case balance
        case lastUpdatedTime
        case ownerIdentifier
        case tokenIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let atBlockchainInstant = self.atBlockchainInstant {
            try encodeContainer.encode(atBlockchainInstant, forKey: .atBlockchainInstant)
        }
        if let balance = self.balance {
            try encodeContainer.encode(balance, forKey: .balance)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let ownerIdentifier = self.ownerIdentifier {
            try encodeContainer.encode(ownerIdentifier, forKey: .ownerIdentifier)
        }
        if let tokenIdentifier = self.tokenIdentifier {
            try encodeContainer.encode(tokenIdentifier, forKey: .tokenIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdentifierDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.OwnerIdentifier.self, forKey: .ownerIdentifier)
        ownerIdentifier = ownerIdentifierDecoded
        let tokenIdentifierDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.TokenIdentifier.self, forKey: .tokenIdentifier)
        tokenIdentifier = tokenIdentifierDecoded
        let balanceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .balance)
        balance = balanceDecoded
        let atBlockchainInstantDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.BlockchainInstant.self, forKey: .atBlockchainInstant)
        atBlockchainInstant = atBlockchainInstantDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.BlockchainInstant.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// The container for the properties of a token balance output.
    public struct BatchGetTokenBalanceOutputItem: Swift.Equatable {
        /// The container for time.
        /// This member is required.
        public var atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?
        /// The container for the token balance.
        /// This member is required.
        public var balance: Swift.String?
        /// The container for time.
        public var lastUpdatedTime: ManagedBlockchainQueryClientTypes.BlockchainInstant?
        /// The container for the identifier of the owner.
        public var ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier?
        /// The container for the identifier for the token including the unique token ID and its blockchain network. Only the native tokens BTC,ETH, and the ERC-20, ERC-721, and ERC 1155 token standards are supported.
        public var tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier?

        public init(
            atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
            balance: Swift.String? = nil,
            lastUpdatedTime: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
            ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier? = nil,
            tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier? = nil
        )
        {
            self.atBlockchainInstant = atBlockchainInstant
            self.balance = balance
            self.lastUpdatedTime = lastUpdatedTime
            self.ownerIdentifier = ownerIdentifier
            self.tokenIdentifier = tokenIdentifier
        }
    }

}

extension BatchGetTokenBalanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetTokenBalanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
            self.tokenBalances = output.tokenBalances
        } else {
            self.errors = nil
            self.tokenBalances = nil
        }
    }
}

public struct BatchGetTokenBalanceOutputResponse: Swift.Equatable {
    /// An array of BatchGetTokenBalanceErrorItem objects returned from the request.
    /// This member is required.
    public var errors: [ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceErrorItem]?
    /// An array of BatchGetTokenBalanceOutputItem objects returned by the response.
    /// This member is required.
    public var tokenBalances: [ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceOutputItem]?

    public init(
        errors: [ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceErrorItem]? = nil,
        tokenBalances: [ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceOutputItem]? = nil
    )
    {
        self.errors = errors
        self.tokenBalances = tokenBalances
    }
}

struct BatchGetTokenBalanceOutputResponseBody: Swift.Equatable {
    let tokenBalances: [ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceOutputItem]?
    let errors: [ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceErrorItem]?
}

extension BatchGetTokenBalanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
        case tokenBalances
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenBalancesContainer = try containerValues.decodeIfPresent([ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceOutputItem?].self, forKey: .tokenBalances)
        var tokenBalancesDecoded0:[ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceOutputItem]? = nil
        if let tokenBalancesContainer = tokenBalancesContainer {
            tokenBalancesDecoded0 = [ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceOutputItem]()
            for structure0 in tokenBalancesContainer {
                if let structure0 = structure0 {
                    tokenBalancesDecoded0?.append(structure0)
                }
            }
        }
        tokenBalances = tokenBalancesDecoded0
        let errorsContainer = try containerValues.decodeIfPresent([ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceErrorItem?].self, forKey: .errors)
        var errorsDecoded0:[ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceErrorItem]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [ManagedBlockchainQueryClientTypes.BatchGetTokenBalanceErrorItem]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension ManagedBlockchainQueryClientTypes.BlockchainInstant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case time
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let time = self.time {
            try encodeContainer.encodeTimestamp(time, format: .epochSeconds, forKey: .time)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .time)
        time = timeDecoded
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// The container for time.
    public struct BlockchainInstant: Swift.Equatable {
        /// The container of the Timestamp of the blockchain instant. This timestamp will only be recorded up to the second.
        public var time: ClientRuntime.Date?

        public init(
            time: ClientRuntime.Date? = nil
        )
        {
            self.time = time
        }
    }

}

extension ManagedBlockchainQueryClientTypes {
    public enum ErrorType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// An API request retrieving an item that can't be found
        case resourceNotFoundException
        /// An API request validation exception
        case validationException
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorType] {
            return [
                .resourceNotFoundException,
                .validationException,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .resourceNotFoundException: return "RESOURCE_NOT_FOUND_EXCEPTION"
            case .validationException: return "VALIDATION_EXCEPTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorType(rawValue: rawValue) ?? ErrorType.sdkUnknown(rawValue)
        }
    }
}

extension GetTokenBalanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case atBlockchainInstant
        case ownerIdentifier
        case tokenIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let atBlockchainInstant = self.atBlockchainInstant {
            try encodeContainer.encode(atBlockchainInstant, forKey: .atBlockchainInstant)
        }
        if let ownerIdentifier = self.ownerIdentifier {
            try encodeContainer.encode(ownerIdentifier, forKey: .ownerIdentifier)
        }
        if let tokenIdentifier = self.tokenIdentifier {
            try encodeContainer.encode(tokenIdentifier, forKey: .tokenIdentifier)
        }
    }
}

extension GetTokenBalanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/get-token-balance"
    }
}

public struct GetTokenBalanceInput: Swift.Equatable {
    /// The time for when the TokenBalance is requested or the current time if a time is not provided in the request. This time will only be recorded up to the second.
    public var atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?
    /// The container for the identifier for the owner.
    /// This member is required.
    public var ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier?
    /// The container for the identifier for the token, including the unique token ID and its blockchain network.
    /// This member is required.
    public var tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier?

    public init(
        atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
        ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier? = nil,
        tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier? = nil
    )
    {
        self.atBlockchainInstant = atBlockchainInstant
        self.ownerIdentifier = ownerIdentifier
        self.tokenIdentifier = tokenIdentifier
    }
}

struct GetTokenBalanceInputBody: Swift.Equatable {
    let tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier?
    let ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier?
    let atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?
}

extension GetTokenBalanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case atBlockchainInstant
        case ownerIdentifier
        case tokenIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenIdentifierDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.TokenIdentifier.self, forKey: .tokenIdentifier)
        tokenIdentifier = tokenIdentifierDecoded
        let ownerIdentifierDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.OwnerIdentifier.self, forKey: .ownerIdentifier)
        ownerIdentifier = ownerIdentifierDecoded
        let atBlockchainInstantDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.BlockchainInstant.self, forKey: .atBlockchainInstant)
        atBlockchainInstant = atBlockchainInstantDecoded
    }
}

public enum GetTokenBalanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTokenBalanceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTokenBalanceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.atBlockchainInstant = output.atBlockchainInstant
            self.balance = output.balance
            self.lastUpdatedTime = output.lastUpdatedTime
            self.ownerIdentifier = output.ownerIdentifier
            self.tokenIdentifier = output.tokenIdentifier
        } else {
            self.atBlockchainInstant = nil
            self.balance = nil
            self.lastUpdatedTime = nil
            self.ownerIdentifier = nil
            self.tokenIdentifier = nil
        }
    }
}

public struct GetTokenBalanceOutputResponse: Swift.Equatable {
    /// The container for time.
    /// This member is required.
    public var atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?
    /// The container for the token balance.
    /// This member is required.
    public var balance: Swift.String?
    /// The container for time.
    public var lastUpdatedTime: ManagedBlockchainQueryClientTypes.BlockchainInstant?
    /// The container for the identifier of the owner.
    public var ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier?
    /// The container for the identifier for the token including the unique token ID and its blockchain network. Only the native tokens BTC,ETH, and the ERC-20, ERC-721, and ERC 1155 token standards are supported.
    public var tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier?

    public init(
        atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
        balance: Swift.String? = nil,
        lastUpdatedTime: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
        ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier? = nil,
        tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier? = nil
    )
    {
        self.atBlockchainInstant = atBlockchainInstant
        self.balance = balance
        self.lastUpdatedTime = lastUpdatedTime
        self.ownerIdentifier = ownerIdentifier
        self.tokenIdentifier = tokenIdentifier
    }
}

struct GetTokenBalanceOutputResponseBody: Swift.Equatable {
    let ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier?
    let tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier?
    let balance: Swift.String?
    let atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?
    let lastUpdatedTime: ManagedBlockchainQueryClientTypes.BlockchainInstant?
}

extension GetTokenBalanceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case atBlockchainInstant
        case balance
        case lastUpdatedTime
        case ownerIdentifier
        case tokenIdentifier
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdentifierDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.OwnerIdentifier.self, forKey: .ownerIdentifier)
        ownerIdentifier = ownerIdentifierDecoded
        let tokenIdentifierDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.TokenIdentifier.self, forKey: .tokenIdentifier)
        tokenIdentifier = tokenIdentifierDecoded
        let balanceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .balance)
        balance = balanceDecoded
        let atBlockchainInstantDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.BlockchainInstant.self, forKey: .atBlockchainInstant)
        atBlockchainInstant = atBlockchainInstantDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.BlockchainInstant.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension GetTransactionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case network
        case transactionHash
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let network = self.network {
            try encodeContainer.encode(network.rawValue, forKey: .network)
        }
        if let transactionHash = self.transactionHash {
            try encodeContainer.encode(transactionHash, forKey: .transactionHash)
        }
    }
}

extension GetTransactionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/get-transaction"
    }
}

public struct GetTransactionInput: Swift.Equatable {
    /// The blockchain network where the transaction occurred.
    /// This member is required.
    public var network: ManagedBlockchainQueryClientTypes.QueryNetwork?
    /// The hash of the transaction. It is generated whenever a transaction is verified and added to the blockchain.
    /// This member is required.
    public var transactionHash: Swift.String?

    public init(
        network: ManagedBlockchainQueryClientTypes.QueryNetwork? = nil,
        transactionHash: Swift.String? = nil
    )
    {
        self.network = network
        self.transactionHash = transactionHash
    }
}

struct GetTransactionInputBody: Swift.Equatable {
    let transactionHash: Swift.String?
    let network: ManagedBlockchainQueryClientTypes.QueryNetwork?
}

extension GetTransactionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case network
        case transactionHash
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionHash)
        transactionHash = transactionHashDecoded
        let networkDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.QueryNetwork.self, forKey: .network)
        network = networkDecoded
    }
}

public enum GetTransactionOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTransactionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTransactionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.transaction = output.transaction
        } else {
            self.transaction = nil
        }
    }
}

public struct GetTransactionOutputResponse: Swift.Equatable {
    /// Contains the details of the transaction.
    /// This member is required.
    public var transaction: ManagedBlockchainQueryClientTypes.Transaction?

    public init(
        transaction: ManagedBlockchainQueryClientTypes.Transaction? = nil
    )
    {
        self.transaction = transaction
    }
}

struct GetTransactionOutputResponseBody: Swift.Equatable {
    let transaction: ManagedBlockchainQueryClientTypes.Transaction?
}

extension GetTransactionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case transaction
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.Transaction.self, forKey: .transaction)
        transaction = transactionDecoded
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request processing has failed because of an internal error in the service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The container for the exception message.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The container of the retryAfterSeconds value.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListTokenBalancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case ownerFilter
        case tokenFilter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let ownerFilter = self.ownerFilter {
            try encodeContainer.encode(ownerFilter, forKey: .ownerFilter)
        }
        if let tokenFilter = self.tokenFilter {
            try encodeContainer.encode(tokenFilter, forKey: .tokenFilter)
        }
    }
}

extension ListTokenBalancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-token-balances"
    }
}

public struct ListTokenBalancesInput: Swift.Equatable {
    /// The maximum number of token balances to return.
    public var maxResults: Swift.Int?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?
    /// The contract or wallet address on the blockchain network by which to filter the request. You must specify the address property of the ownerFilter when listing balances of tokens owned by the address.
    public var ownerFilter: ManagedBlockchainQueryClientTypes.OwnerFilter?
    /// The contract address or a token identifier on the blockchain network by which to filter the request. You must specify the contractAddress property of this container when listing tokens minted by a contract. You must always specify the network property of this container when using this operation.
    /// This member is required.
    public var tokenFilter: ManagedBlockchainQueryClientTypes.TokenFilter?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        ownerFilter: ManagedBlockchainQueryClientTypes.OwnerFilter? = nil,
        tokenFilter: ManagedBlockchainQueryClientTypes.TokenFilter? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.ownerFilter = ownerFilter
        self.tokenFilter = tokenFilter
    }
}

struct ListTokenBalancesInputBody: Swift.Equatable {
    let ownerFilter: ManagedBlockchainQueryClientTypes.OwnerFilter?
    let tokenFilter: ManagedBlockchainQueryClientTypes.TokenFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTokenBalancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case ownerFilter
        case tokenFilter
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerFilterDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.OwnerFilter.self, forKey: .ownerFilter)
        ownerFilter = ownerFilterDecoded
        let tokenFilterDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.TokenFilter.self, forKey: .tokenFilter)
        tokenFilter = tokenFilterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

public enum ListTokenBalancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTokenBalancesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTokenBalancesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tokenBalances = output.tokenBalances
        } else {
            self.nextToken = nil
            self.tokenBalances = nil
        }
    }
}

public struct ListTokenBalancesOutputResponse: Swift.Equatable {
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?
    /// An array of TokenBalance objects. Each object contains details about the token balance.
    /// This member is required.
    public var tokenBalances: [ManagedBlockchainQueryClientTypes.TokenBalance]?

    public init(
        nextToken: Swift.String? = nil,
        tokenBalances: [ManagedBlockchainQueryClientTypes.TokenBalance]? = nil
    )
    {
        self.nextToken = nextToken
        self.tokenBalances = tokenBalances
    }
}

struct ListTokenBalancesOutputResponseBody: Swift.Equatable {
    let tokenBalances: [ManagedBlockchainQueryClientTypes.TokenBalance]?
    let nextToken: Swift.String?
}

extension ListTokenBalancesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tokenBalances
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tokenBalancesContainer = try containerValues.decodeIfPresent([ManagedBlockchainQueryClientTypes.TokenBalance?].self, forKey: .tokenBalances)
        var tokenBalancesDecoded0:[ManagedBlockchainQueryClientTypes.TokenBalance]? = nil
        if let tokenBalancesContainer = tokenBalancesContainer {
            tokenBalancesDecoded0 = [ManagedBlockchainQueryClientTypes.TokenBalance]()
            for structure0 in tokenBalancesContainer {
                if let structure0 = structure0 {
                    tokenBalancesDecoded0?.append(structure0)
                }
            }
        }
        tokenBalances = tokenBalancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTransactionEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case network
        case nextToken
        case transactionHash
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let network = self.network {
            try encodeContainer.encode(network.rawValue, forKey: .network)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let transactionHash = self.transactionHash {
            try encodeContainer.encode(transactionHash, forKey: .transactionHash)
        }
    }
}

extension ListTransactionEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-transaction-events"
    }
}

public struct ListTransactionEventsInput: Swift.Equatable {
    /// The maximum number of transaction events to list. Even if additional results can be retrieved, the request can return less results than maxResults or an empty array of results. To retrieve the next set of results, make another request with the returned nextToken value. The value of nextToken is null when there are no more results to return
    public var maxResults: Swift.Int?
    /// The blockchain network where the transaction events occurred.
    /// This member is required.
    public var network: ManagedBlockchainQueryClientTypes.QueryNetwork?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?
    /// The hash of the transaction. It is generated whenever a transaction is verified and added to the blockchain.
    /// This member is required.
    public var transactionHash: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        network: ManagedBlockchainQueryClientTypes.QueryNetwork? = nil,
        nextToken: Swift.String? = nil,
        transactionHash: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.network = network
        self.nextToken = nextToken
        self.transactionHash = transactionHash
    }
}

struct ListTransactionEventsInputBody: Swift.Equatable {
    let transactionHash: Swift.String?
    let network: ManagedBlockchainQueryClientTypes.QueryNetwork?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTransactionEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case network
        case nextToken
        case transactionHash
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionHash)
        transactionHash = transactionHashDecoded
        let networkDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.QueryNetwork.self, forKey: .network)
        network = networkDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

public enum ListTransactionEventsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTransactionEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTransactionEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct ListTransactionEventsOutputResponse: Swift.Equatable {
    /// An array of TransactionEvent objects. Each object contains details about the transaction events.
    /// This member is required.
    public var events: [ManagedBlockchainQueryClientTypes.TransactionEvent]?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?

    public init(
        events: [ManagedBlockchainQueryClientTypes.TransactionEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct ListTransactionEventsOutputResponseBody: Swift.Equatable {
    let events: [ManagedBlockchainQueryClientTypes.TransactionEvent]?
    let nextToken: Swift.String?
}

extension ListTransactionEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([ManagedBlockchainQueryClientTypes.TransactionEvent?].self, forKey: .events)
        var eventsDecoded0:[ManagedBlockchainQueryClientTypes.TransactionEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [ManagedBlockchainQueryClientTypes.TransactionEvent]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTransactionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address
        case fromBlockchainInstant
        case maxResults
        case network
        case nextToken
        case sort
        case toBlockchainInstant
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let fromBlockchainInstant = self.fromBlockchainInstant {
            try encodeContainer.encode(fromBlockchainInstant, forKey: .fromBlockchainInstant)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let network = self.network {
            try encodeContainer.encode(network.rawValue, forKey: .network)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sort = self.sort {
            try encodeContainer.encode(sort, forKey: .sort)
        }
        if let toBlockchainInstant = self.toBlockchainInstant {
            try encodeContainer.encode(toBlockchainInstant, forKey: .toBlockchainInstant)
        }
    }
}

extension ListTransactionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-transactions"
    }
}

public struct ListTransactionsInput: Swift.Equatable {
    /// The address (either a contract or wallet), whose transactions are being requested.
    /// This member is required.
    public var address: Swift.String?
    /// The container for time.
    public var fromBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?
    /// The maximum number of transactions to list. Even if additional results can be retrieved, the request can return less results than maxResults or an empty array of results. To retrieve the next set of results, make another request with the returned nextToken value. The value of nextToken is null when there are no more results to return
    public var maxResults: Swift.Int?
    /// The blockchain network where the transactions occurred.
    /// This member is required.
    public var network: ManagedBlockchainQueryClientTypes.QueryNetwork?
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?
    /// Sorts items in an ascending order if the first page starts at fromTime. Sorts items in a descending order if the first page starts at toTime.
    public var sort: ManagedBlockchainQueryClientTypes.ListTransactionsSort?
    /// The container for time.
    public var toBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?

    public init(
        address: Swift.String? = nil,
        fromBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
        maxResults: Swift.Int? = nil,
        network: ManagedBlockchainQueryClientTypes.QueryNetwork? = nil,
        nextToken: Swift.String? = nil,
        sort: ManagedBlockchainQueryClientTypes.ListTransactionsSort? = nil,
        toBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil
    )
    {
        self.address = address
        self.fromBlockchainInstant = fromBlockchainInstant
        self.maxResults = maxResults
        self.network = network
        self.nextToken = nextToken
        self.sort = sort
        self.toBlockchainInstant = toBlockchainInstant
    }
}

struct ListTransactionsInputBody: Swift.Equatable {
    let address: Swift.String?
    let network: ManagedBlockchainQueryClientTypes.QueryNetwork?
    let fromBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?
    let toBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?
    let sort: ManagedBlockchainQueryClientTypes.ListTransactionsSort?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListTransactionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address
        case fromBlockchainInstant
        case maxResults
        case network
        case nextToken
        case sort
        case toBlockchainInstant
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
        let networkDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.QueryNetwork.self, forKey: .network)
        network = networkDecoded
        let fromBlockchainInstantDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.BlockchainInstant.self, forKey: .fromBlockchainInstant)
        fromBlockchainInstant = fromBlockchainInstantDecoded
        let toBlockchainInstantDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.BlockchainInstant.self, forKey: .toBlockchainInstant)
        toBlockchainInstant = toBlockchainInstantDecoded
        let sortDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.ListTransactionsSort.self, forKey: .sort)
        sort = sortDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

public enum ListTransactionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    public static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTransactionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTransactionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.transactions = output.transactions
        } else {
            self.nextToken = nil
            self.transactions = nil
        }
    }
}

public struct ListTransactionsOutputResponse: Swift.Equatable {
    /// The pagination token that indicates the next set of results to retrieve.
    public var nextToken: Swift.String?
    /// The array of transactions returned by the request.
    /// This member is required.
    public var transactions: [ManagedBlockchainQueryClientTypes.TransactionOutputItem]?

    public init(
        nextToken: Swift.String? = nil,
        transactions: [ManagedBlockchainQueryClientTypes.TransactionOutputItem]? = nil
    )
    {
        self.nextToken = nextToken
        self.transactions = transactions
    }
}

struct ListTransactionsOutputResponseBody: Swift.Equatable {
    let transactions: [ManagedBlockchainQueryClientTypes.TransactionOutputItem]?
    let nextToken: Swift.String?
}

extension ListTransactionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case transactions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionsContainer = try containerValues.decodeIfPresent([ManagedBlockchainQueryClientTypes.TransactionOutputItem?].self, forKey: .transactions)
        var transactionsDecoded0:[ManagedBlockchainQueryClientTypes.TransactionOutputItem]? = nil
        if let transactionsContainer = transactionsContainer {
            transactionsDecoded0 = [ManagedBlockchainQueryClientTypes.TransactionOutputItem]()
            for structure0 in transactionsContainer {
                if let structure0 = structure0 {
                    transactionsDecoded0?.append(structure0)
                }
            }
        }
        transactions = transactionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ManagedBlockchainQueryClientTypes.ListTransactionsSort: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sortBy
        case sortOrder
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sortBy = self.sortBy {
            try encodeContainer.encode(sortBy.rawValue, forKey: .sortBy)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sortByDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.ListTransactionsSortBy.self, forKey: .sortBy)
        sortBy = sortByDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.SortOrder.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// The container for determining how the list transaction result will be sorted.
    public struct ListTransactionsSort: Swift.Equatable {
        /// Defaults to the value TRANSACTION_TIMESTAMP.
        public var sortBy: ManagedBlockchainQueryClientTypes.ListTransactionsSortBy?
        /// The container for the sort order for ListTransactions. The SortOrder field only accepts the values ASCENDING and DESCENDING. Not providing SortOrder will default to ASCENDING.
        public var sortOrder: ManagedBlockchainQueryClientTypes.SortOrder?

        public init(
            sortBy: ManagedBlockchainQueryClientTypes.ListTransactionsSortBy? = nil,
            sortOrder: ManagedBlockchainQueryClientTypes.SortOrder? = nil
        )
        {
            self.sortBy = sortBy
            self.sortOrder = sortOrder
        }
    }

}

extension ManagedBlockchainQueryClientTypes {
    public enum ListTransactionsSortBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Timestamp of a transaction
        case transactionTimestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [ListTransactionsSortBy] {
            return [
                .transactionTimestamp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .transactionTimestamp: return "TRANSACTION_TIMESTAMP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListTransactionsSortBy(rawValue: rawValue) ?? ListTransactionsSortBy.sdkUnknown(rawValue)
        }
    }
}

extension ManagedBlockchainQueryClientTypes.OwnerFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// The container for the owner information to filter by.
    public struct OwnerFilter: Swift.Equatable {
        /// The contract or wallet address.
        /// This member is required.
        public var address: Swift.String?

        public init(
            address: Swift.String? = nil
        )
        {
            self.address = address
        }
    }

}

extension ManagedBlockchainQueryClientTypes.OwnerIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// The container for the identifier of the owner.
    public struct OwnerIdentifier: Swift.Equatable {
        /// The contract or wallet address for the owner.
        /// This member is required.
        public var address: Swift.String?

        public init(
            address: Swift.String? = nil
        )
        {
            self.address = address
        }
    }

}

extension ManagedBlockchainQueryClientTypes {
    public enum QueryNetwork: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Bitcoin main network
        case bitcoinMainnet
        /// Ethereum main network
        case ethereumMainnet
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryNetwork] {
            return [
                .bitcoinMainnet,
                .ethereumMainnet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bitcoinMainnet: return "BITCOIN_MAINNET"
            case .ethereumMainnet: return "ETHEREUM_MAINNET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueryNetwork(rawValue: rawValue) ?? QueryNetwork.sdkUnknown(rawValue)
        }
    }
}

extension ManagedBlockchainQueryClientTypes {
    public enum QueryTransactionEventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// A Bitcoin Vin transfer type
        case bitcoinVin
        /// A Bitcoin Vout transfer type
        case bitcoinVout
        /// An ERC1155 transfer type
        case erc1155Transfer
        /// An ERC20_BURN transfer type
        case erc20Burn
        /// An ERC20_DEPOSIT transfer type
        case erc20Deposit
        /// An ERC20_MINT transfer type
        case erc20Mint
        /// An ERC20 transfer type
        case erc20Transfer
        /// An ERC20_WITHDRAWAL transfer type
        case erc20Withdrawal
        /// An ERC721 transfer type
        case erc721Transfer
        /// An ETH transfer type
        case ethTransfer
        /// An internal ETH transfer type
        case internalEthTransfer
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryTransactionEventType] {
            return [
                .bitcoinVin,
                .bitcoinVout,
                .erc1155Transfer,
                .erc20Burn,
                .erc20Deposit,
                .erc20Mint,
                .erc20Transfer,
                .erc20Withdrawal,
                .erc721Transfer,
                .ethTransfer,
                .internalEthTransfer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bitcoinVin: return "BITCOIN_VIN"
            case .bitcoinVout: return "BITCOIN_VOUT"
            case .erc1155Transfer: return "ERC1155_TRANSFER"
            case .erc20Burn: return "ERC20_BURN"
            case .erc20Deposit: return "ERC20_DEPOSIT"
            case .erc20Mint: return "ERC20_MINT"
            case .erc20Transfer: return "ERC20_TRANSFER"
            case .erc20Withdrawal: return "ERC20_WITHDRAWAL"
            case .erc721Transfer: return "ERC721_TRANSFER"
            case .ethTransfer: return "ETH_TRANSFER"
            case .internalEthTransfer: return "INTERNAL_ETH_TRANSFER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueryTransactionEventType(rawValue: rawValue) ?? QueryTransactionEventType.sdkUnknown(rawValue)
        }
    }
}

extension ManagedBlockchainQueryClientTypes {
    public enum QueryTransactionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// The transaction completed on the blockchain, but failed
        case failed
        /// The transaction has been confirmed and is final in the blockchain
        case `final`
        case sdkUnknown(Swift.String)

        public static var allCases: [QueryTransactionStatus] {
            return [
                .failed,
                .final,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .final: return "FINAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = QueryTransactionStatus(rawValue: rawValue) ?? QueryTransactionStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The container for the exception message.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The resourceId of the resource that caused the exception.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resourceType of the resource that caused the exception.
        /// This member is required.
        public internal(set) var resourceType: ManagedBlockchainQueryClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: ManagedBlockchainQueryClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: ManagedBlockchainQueryClientTypes.ResourceType?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ManagedBlockchainQueryClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case collection
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .collection,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .collection: return "collection"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service quota has been exceeded for this resource.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The container for the exception message.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The container for the quotaCode.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The resourceId of the resource that caused the exception.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The resourceType of the resource that caused the exception.
        /// This member is required.
        public internal(set) var resourceType: ManagedBlockchainQueryClientTypes.ResourceType? = nil
        /// The container for the serviceCode.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: ManagedBlockchainQueryClientTypes.ResourceType? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: ManagedBlockchainQueryClientTypes.ResourceType?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension ManagedBlockchainQueryClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        /// Result sorted in ascending order
        case ascending
        /// Result sorted in descending order
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request or operation couldn't be performed because a service is throttling requests. The most common source of throttling errors is when you create resources that exceed your service limit for this resource type. Request a limit increase or delete unused resources, if possible.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The container for the exception message.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The container for the quotaCode.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The container of the retryAfterSeconds value.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The container for the serviceCode.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension ManagedBlockchainQueryClientTypes.TokenBalance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case atBlockchainInstant
        case balance
        case lastUpdatedTime
        case ownerIdentifier
        case tokenIdentifier
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let atBlockchainInstant = self.atBlockchainInstant {
            try encodeContainer.encode(atBlockchainInstant, forKey: .atBlockchainInstant)
        }
        if let balance = self.balance {
            try encodeContainer.encode(balance, forKey: .balance)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let ownerIdentifier = self.ownerIdentifier {
            try encodeContainer.encode(ownerIdentifier, forKey: .ownerIdentifier)
        }
        if let tokenIdentifier = self.tokenIdentifier {
            try encodeContainer.encode(tokenIdentifier, forKey: .tokenIdentifier)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ownerIdentifierDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.OwnerIdentifier.self, forKey: .ownerIdentifier)
        ownerIdentifier = ownerIdentifierDecoded
        let tokenIdentifierDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.TokenIdentifier.self, forKey: .tokenIdentifier)
        tokenIdentifier = tokenIdentifierDecoded
        let balanceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .balance)
        balance = balanceDecoded
        let atBlockchainInstantDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.BlockchainInstant.self, forKey: .atBlockchainInstant)
        atBlockchainInstant = atBlockchainInstantDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.BlockchainInstant.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// The balance of the token.
    public struct TokenBalance: Swift.Equatable {
        /// The time for when the TokenBalance is requested or the current time if a time is not provided in the request. This time will only be recorded up to the second.
        /// This member is required.
        public var atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant?
        /// The container of the token balance.
        /// This member is required.
        public var balance: Swift.String?
        /// The timestamp of the last transaction at which the balance for the token in the wallet was updated.
        public var lastUpdatedTime: ManagedBlockchainQueryClientTypes.BlockchainInstant?
        /// The container for the identifier of the owner.
        public var ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier?
        /// The identifier for the token, including the unique token ID and its blockchain network.
        public var tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier?

        public init(
            atBlockchainInstant: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
            balance: Swift.String? = nil,
            lastUpdatedTime: ManagedBlockchainQueryClientTypes.BlockchainInstant? = nil,
            ownerIdentifier: ManagedBlockchainQueryClientTypes.OwnerIdentifier? = nil,
            tokenIdentifier: ManagedBlockchainQueryClientTypes.TokenIdentifier? = nil
        )
        {
            self.atBlockchainInstant = atBlockchainInstant
            self.balance = balance
            self.lastUpdatedTime = lastUpdatedTime
            self.ownerIdentifier = ownerIdentifier
            self.tokenIdentifier = tokenIdentifier
        }
    }

}

extension ManagedBlockchainQueryClientTypes.TokenFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contractAddress
        case network
        case tokenId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contractAddress = self.contractAddress {
            try encodeContainer.encode(contractAddress, forKey: .contractAddress)
        }
        if let network = self.network {
            try encodeContainer.encode(network.rawValue, forKey: .network)
        }
        if let tokenId = self.tokenId {
            try encodeContainer.encode(tokenId, forKey: .tokenId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.QueryNetwork.self, forKey: .network)
        network = networkDecoded
        let contractAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contractAddress)
        contractAddress = contractAddressDecoded
        let tokenIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenId)
        tokenId = tokenIdDecoded
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// The container of the token filter like the contract address on a given blockchain network or a unique token identifier on a given blockchain network. You must always specify the network property of this container when using this operation.
    public struct TokenFilter: Swift.Equatable {
        /// This is the address of the contract.
        public var contractAddress: Swift.String?
        /// The blockchain network of the token.
        /// This member is required.
        public var network: ManagedBlockchainQueryClientTypes.QueryNetwork?
        /// The unique identifier of the token.
        public var tokenId: Swift.String?

        public init(
            contractAddress: Swift.String? = nil,
            network: ManagedBlockchainQueryClientTypes.QueryNetwork? = nil,
            tokenId: Swift.String? = nil
        )
        {
            self.contractAddress = contractAddress
            self.network = network
            self.tokenId = tokenId
        }
    }

}

extension ManagedBlockchainQueryClientTypes.TokenIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contractAddress
        case network
        case tokenId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contractAddress = self.contractAddress {
            try encodeContainer.encode(contractAddress, forKey: .contractAddress)
        }
        if let network = self.network {
            try encodeContainer.encode(network.rawValue, forKey: .network)
        }
        if let tokenId = self.tokenId {
            try encodeContainer.encode(tokenId, forKey: .tokenId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.QueryNetwork.self, forKey: .network)
        network = networkDecoded
        let contractAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contractAddress)
        contractAddress = contractAddressDecoded
        let tokenIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenId)
        tokenId = tokenIdDecoded
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// The container for the identifier for the token including the unique token ID and its blockchain network. Only the native tokens BTC,ETH, and the ERC-20, ERC-721, and ERC 1155 token standards are supported.
    public struct TokenIdentifier: Swift.Equatable {
        /// This is the token's contract address.
        public var contractAddress: Swift.String?
        /// The blockchain network of the token.
        /// This member is required.
        public var network: ManagedBlockchainQueryClientTypes.QueryNetwork?
        /// The unique identifier of the token.
        public var tokenId: Swift.String?

        public init(
            contractAddress: Swift.String? = nil,
            network: ManagedBlockchainQueryClientTypes.QueryNetwork? = nil,
            tokenId: Swift.String? = nil
        )
        {
            self.contractAddress = contractAddress
            self.network = network
            self.tokenId = tokenId
        }
    }

}

extension ManagedBlockchainQueryClientTypes.Transaction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockHash
        case blockNumber
        case contractAddress
        case cumulativeGasUsed
        case effectiveGasPrice
        case from
        case gasUsed
        case network
        case numberOfTransactions
        case signaturer = "signatureR"
        case signatures = "signatureS"
        case signaturev = "signatureV"
        case status
        case to
        case transactionFee
        case transactionHash
        case transactionId
        case transactionIndex
        case transactionTimestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockHash = self.blockHash {
            try encodeContainer.encode(blockHash, forKey: .blockHash)
        }
        if let blockNumber = self.blockNumber {
            try encodeContainer.encode(blockNumber, forKey: .blockNumber)
        }
        if let contractAddress = self.contractAddress {
            try encodeContainer.encode(contractAddress, forKey: .contractAddress)
        }
        if let cumulativeGasUsed = self.cumulativeGasUsed {
            try encodeContainer.encode(cumulativeGasUsed, forKey: .cumulativeGasUsed)
        }
        if let effectiveGasPrice = self.effectiveGasPrice {
            try encodeContainer.encode(effectiveGasPrice, forKey: .effectiveGasPrice)
        }
        if let from = self.from {
            try encodeContainer.encode(from, forKey: .from)
        }
        if let gasUsed = self.gasUsed {
            try encodeContainer.encode(gasUsed, forKey: .gasUsed)
        }
        if let network = self.network {
            try encodeContainer.encode(network.rawValue, forKey: .network)
        }
        if let numberOfTransactions = self.numberOfTransactions {
            try encodeContainer.encode(numberOfTransactions, forKey: .numberOfTransactions)
        }
        if let signaturer = self.signaturer {
            try encodeContainer.encode(signaturer, forKey: .signaturer)
        }
        if let signatures = self.signatures {
            try encodeContainer.encode(signatures, forKey: .signatures)
        }
        if let signaturev = self.signaturev {
            try encodeContainer.encode(signaturev, forKey: .signaturev)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let to = self.to {
            try encodeContainer.encode(to, forKey: .to)
        }
        if let transactionFee = self.transactionFee {
            try encodeContainer.encode(transactionFee, forKey: .transactionFee)
        }
        if let transactionHash = self.transactionHash {
            try encodeContainer.encode(transactionHash, forKey: .transactionHash)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
        if let transactionIndex = self.transactionIndex {
            try encodeContainer.encode(transactionIndex, forKey: .transactionIndex)
        }
        if let transactionTimestamp = self.transactionTimestamp {
            try encodeContainer.encodeTimestamp(transactionTimestamp, format: .epochSeconds, forKey: .transactionTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.QueryNetwork.self, forKey: .network)
        network = networkDecoded
        let blockHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blockHash)
        blockHash = blockHashDecoded
        let transactionHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionHash)
        transactionHash = transactionHashDecoded
        let blockNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .blockNumber)
        blockNumber = blockNumberDecoded
        let transactionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .transactionTimestamp)
        transactionTimestamp = transactionTimestampDecoded
        let transactionIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .transactionIndex)
        transactionIndex = transactionIndexDecoded
        let numberOfTransactionsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfTransactions)
        numberOfTransactions = numberOfTransactionsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.QueryTransactionStatus.self, forKey: .status)
        status = statusDecoded
        let toDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .to)
        to = toDecoded
        let fromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .from)
        from = fromDecoded
        let contractAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contractAddress)
        contractAddress = contractAddressDecoded
        let gasUsedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gasUsed)
        gasUsed = gasUsedDecoded
        let cumulativeGasUsedDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cumulativeGasUsed)
        cumulativeGasUsed = cumulativeGasUsedDecoded
        let effectiveGasPriceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectiveGasPrice)
        effectiveGasPrice = effectiveGasPriceDecoded
        let signaturevDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .signaturev)
        signaturev = signaturevDecoded
        let signaturerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signaturer)
        signaturer = signaturerDecoded
        let signaturesDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .signatures)
        signatures = signaturesDecoded
        let transactionFeeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionFee)
        transactionFee = transactionFeeDecoded
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// There are two possible types of transactions used for this data type:
    ///
    /// * A Bitcoin transaction is a movement of BTC from one address to another.
    ///
    /// * An Ethereum transaction refers to an action initiated by an externally owned account, which is an account managed by a human, not a contract. For example, if Bob sends Alice 1 ETH, Bob's account must be debited and Alice's must be credited. This state-changing action occurs within a transaction.
    public struct Transaction: Swift.Equatable {
        /// The block hash is a unique identifier for a block. It is a fixed-size string that is calculated by using the information in the block. The block hash is used to verify the integrity of the data in the block.
        public var blockHash: Swift.String?
        /// The block number in which the transaction is recorded.
        public var blockNumber: Swift.String?
        /// The blockchain address for the contract.
        public var contractAddress: Swift.String?
        /// The amount of gas used up to the specified point in the block.
        public var cumulativeGasUsed: Swift.String?
        /// The effective gas price.
        public var effectiveGasPrice: Swift.String?
        /// The initiator of the transaction. It is either in the form a public key or a contract address.
        public var from: Swift.String?
        /// The amount of gas used for the transaction.
        public var gasUsed: Swift.String?
        /// The blockchain network where the transaction occured.
        /// This member is required.
        public var network: ManagedBlockchainQueryClientTypes.QueryNetwork?
        /// The number of transactions in the block.
        /// This member is required.
        public var numberOfTransactions: Swift.Int?
        /// The signature of the transaction. The X coordinate of a point R.
        public var signaturer: Swift.String?
        /// The signature of the transaction. The Y coordinate of a point S.
        public var signatures: Swift.String?
        /// The signature of the transaction. The Z coordinate of a point V.
        public var signaturev: Swift.Int?
        /// The status of the transaction.
        /// This member is required.
        public var status: ManagedBlockchainQueryClientTypes.QueryTransactionStatus?
        /// The identifier of the transaction. It is generated whenever a transaction is verified and added to the blockchain.
        /// This member is required.
        public var to: Swift.String?
        /// The transaction fee.
        public var transactionFee: Swift.String?
        /// The hash of the transaction. It is generated whenever a transaction is verified and added to the blockchain.
        /// This member is required.
        public var transactionHash: Swift.String?
        /// The unique identifier of the transaction. It is generated whenever a transaction is verified and added to the blockchain.
        public var transactionId: Swift.String?
        /// The index of the transaction within a blockchain.
        /// This member is required.
        public var transactionIndex: Swift.Int?
        /// The Timestamp of the transaction.
        /// This member is required.
        public var transactionTimestamp: ClientRuntime.Date?

        public init(
            blockHash: Swift.String? = nil,
            blockNumber: Swift.String? = nil,
            contractAddress: Swift.String? = nil,
            cumulativeGasUsed: Swift.String? = nil,
            effectiveGasPrice: Swift.String? = nil,
            from: Swift.String? = nil,
            gasUsed: Swift.String? = nil,
            network: ManagedBlockchainQueryClientTypes.QueryNetwork? = nil,
            numberOfTransactions: Swift.Int? = nil,
            signaturer: Swift.String? = nil,
            signatures: Swift.String? = nil,
            signaturev: Swift.Int? = nil,
            status: ManagedBlockchainQueryClientTypes.QueryTransactionStatus? = nil,
            to: Swift.String? = nil,
            transactionFee: Swift.String? = nil,
            transactionHash: Swift.String? = nil,
            transactionId: Swift.String? = nil,
            transactionIndex: Swift.Int? = nil,
            transactionTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.blockHash = blockHash
            self.blockNumber = blockNumber
            self.contractAddress = contractAddress
            self.cumulativeGasUsed = cumulativeGasUsed
            self.effectiveGasPrice = effectiveGasPrice
            self.from = from
            self.gasUsed = gasUsed
            self.network = network
            self.numberOfTransactions = numberOfTransactions
            self.signaturer = signaturer
            self.signatures = signatures
            self.signaturev = signaturev
            self.status = status
            self.to = to
            self.transactionFee = transactionFee
            self.transactionHash = transactionHash
            self.transactionId = transactionId
            self.transactionIndex = transactionIndex
            self.transactionTimestamp = transactionTimestamp
        }
    }

}

extension ManagedBlockchainQueryClientTypes.TransactionEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contractAddress
        case eventType
        case from
        case network
        case to
        case tokenId
        case transactionHash
        case transactionId
        case value
        case voutIndex
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contractAddress = self.contractAddress {
            try encodeContainer.encode(contractAddress, forKey: .contractAddress)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let from = self.from {
            try encodeContainer.encode(from, forKey: .from)
        }
        if let network = self.network {
            try encodeContainer.encode(network.rawValue, forKey: .network)
        }
        if let to = self.to {
            try encodeContainer.encode(to, forKey: .to)
        }
        if let tokenId = self.tokenId {
            try encodeContainer.encode(tokenId, forKey: .tokenId)
        }
        if let transactionHash = self.transactionHash {
            try encodeContainer.encode(transactionHash, forKey: .transactionHash)
        }
        if let transactionId = self.transactionId {
            try encodeContainer.encode(transactionId, forKey: .transactionId)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
        if let voutIndex = self.voutIndex {
            try encodeContainer.encode(voutIndex, forKey: .voutIndex)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let networkDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.QueryNetwork.self, forKey: .network)
        network = networkDecoded
        let transactionHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionHash)
        transactionHash = transactionHashDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.QueryTransactionEventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let fromDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .from)
        from = fromDecoded
        let toDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .to)
        to = toDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let contractAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contractAddress)
        contractAddress = contractAddressDecoded
        let tokenIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tokenId)
        tokenId = tokenIdDecoded
        let transactionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionId)
        transactionId = transactionIdDecoded
        let voutIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .voutIndex)
        voutIndex = voutIndexDecoded
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// The container for the properties of a transaction event.
    public struct TransactionEvent: Swift.Equatable {
        /// The blockchain address. for the contract
        public var contractAddress: Swift.String?
        /// The type of transaction event.
        /// This member is required.
        public var eventType: ManagedBlockchainQueryClientTypes.QueryTransactionEventType?
        /// The wallet address initiating the transaction. It can either be a public key or a contract.
        public var from: Swift.String?
        /// The blockchain network where the transaction occurred.
        /// This member is required.
        public var network: ManagedBlockchainQueryClientTypes.QueryNetwork?
        /// The wallet address receiving the transaction. It can either be a public key or a contract.
        public var to: Swift.String?
        /// The unique identifier for the token involved in the transaction.
        public var tokenId: Swift.String?
        /// The hash of the transaction. It is generated whenever a transaction is verified and added to the blockchain.
        /// This member is required.
        public var transactionHash: Swift.String?
        /// The unique identifier of the transaction. It is generated whenever a transaction is verified and added to the blockchain.
        public var transactionId: Swift.String?
        /// The value that was transacted.
        public var value: Swift.String?
        /// The position of the vout in the transaction output list.
        public var voutIndex: Swift.Int?

        public init(
            contractAddress: Swift.String? = nil,
            eventType: ManagedBlockchainQueryClientTypes.QueryTransactionEventType? = nil,
            from: Swift.String? = nil,
            network: ManagedBlockchainQueryClientTypes.QueryNetwork? = nil,
            to: Swift.String? = nil,
            tokenId: Swift.String? = nil,
            transactionHash: Swift.String? = nil,
            transactionId: Swift.String? = nil,
            value: Swift.String? = nil,
            voutIndex: Swift.Int? = nil
        )
        {
            self.contractAddress = contractAddress
            self.eventType = eventType
            self.from = from
            self.network = network
            self.to = to
            self.tokenId = tokenId
            self.transactionHash = transactionHash
            self.transactionId = transactionId
            self.value = value
            self.voutIndex = voutIndex
        }
    }

}

extension ManagedBlockchainQueryClientTypes.TransactionOutputItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case network
        case transactionHash
        case transactionTimestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let network = self.network {
            try encodeContainer.encode(network.rawValue, forKey: .network)
        }
        if let transactionHash = self.transactionHash {
            try encodeContainer.encode(transactionHash, forKey: .transactionHash)
        }
        if let transactionTimestamp = self.transactionTimestamp {
            try encodeContainer.encodeTimestamp(transactionTimestamp, format: .epochSeconds, forKey: .transactionTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transactionHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .transactionHash)
        transactionHash = transactionHashDecoded
        let networkDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.QueryNetwork.self, forKey: .network)
        network = networkDecoded
        let transactionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .transactionTimestamp)
        transactionTimestamp = transactionTimestampDecoded
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// The container of the transaction output.
    public struct TransactionOutputItem: Swift.Equatable {
        /// The blockchain network where the transaction occurred.
        /// This member is required.
        public var network: ManagedBlockchainQueryClientTypes.QueryNetwork?
        /// The hash of the transaction. It is generated whenever a transaction is verified and added to the blockchain.
        /// This member is required.
        public var transactionHash: Swift.String?
        /// The time when the transaction occurred.
        /// This member is required.
        public var transactionTimestamp: ClientRuntime.Date?

        public init(
            network: ManagedBlockchainQueryClientTypes.QueryNetwork? = nil,
            transactionHash: Swift.String? = nil,
            transactionTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.network = network
            self.transactionHash = transactionHash
            self.transactionTimestamp = transactionTimestamp
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource passed is invalid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The container for the fieldList of the exception.
        public internal(set) var fieldList: [ManagedBlockchainQueryClientTypes.ValidationExceptionField]? = nil
        /// The container for the exception message.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The container for the reason for the exception
        /// This member is required.
        public internal(set) var reason: ManagedBlockchainQueryClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [ManagedBlockchainQueryClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: ManagedBlockchainQueryClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: ManagedBlockchainQueryClientTypes.ValidationExceptionReason?
    let fieldList: [ManagedBlockchainQueryClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(ManagedBlockchainQueryClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([ManagedBlockchainQueryClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[ManagedBlockchainQueryClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [ManagedBlockchainQueryClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension ManagedBlockchainQueryClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ManagedBlockchainQueryClientTypes {
    /// The resource passed is invalid.
    public struct ValidationExceptionField: Swift.Equatable {
        /// The ValidationException message.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that triggered the ValidationException.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension ManagedBlockchainQueryClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
